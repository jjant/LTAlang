{"version":3,"sources":["../../src/utils/generator.js"],"names":["base62","t","serializeBody","generator","context","statements","serializeGenerator","blockStatement","Generator","realm","useAbstractInterpretation","realmPreludeGenerator","preludeGenerator","parent","_entries","id","nextGeneratorId","key","canBeIdentifier","index","Number","parseInt","toString","numericLiteral","keyIsAscii","test","isValidIdentifier","identifier","stringLiteral","length","value","declaredGlobals","add","emitGlobalAssignment","strictMode","_addEntry","args","buildNode","valueNode","expressionStatement","assignmentExpression","globalReference","unaryExpression","object","refuseSerialization","propName","getAsPropertyNameExpression","objectNode","memberExpression","isIdentifier","desc","isDescChanged","enumerable","configurable","writable","descValue","emitPropertyAssignment","Object","assign","$Realm","intrinsics","undefined","get","set","_","emitDefinePropertyBody","createCallee","callExpression","values","method","emitCall","map","v","violationConditionFn","appendLastToInvariantFn","omitInvariants","nodes","throwString","last","pop","binaryExpression","condition","throwblock","throwStatement","newExpression","ifStatement","types","kind","derive","buildNode_","Function","o","lh","sourceObject","targetObject","boundName","obj","tgt","src","obj1","tgt1","src1","forInLoopStatement","forInStatement","lazyObjectsRuntime","leadingComments","type","optionalArgs","forceHydrateLazyObjects","nameGenerator","generate","derivedIds","name","options","Constructor","isTypeCompatibleWith","getType","res","isPure","declared","statement","variableDeclaration","variableDeclarator","intrinsicName","skipInvariant","typeofString","emitInvariant","logicalExpression","node","entry","canOmit","boundArg","i","serializeValue","emit","declare","callbacks","canSkip","recordDelayedEntry","recordDeclaration","visitValues","dependencies","dependency","visitGenerator","visitEntry","push","other","leadingComment","empty","block","generator1","generator2","joinCondition","cond","block1","block2","NameGenerator","forbiddenNames","debugNames","uniqueSuffix","prefix","uidCounter","debugSuffix","encode","replace","has","PreludeGenerator","prelude","Map","memoizedRefs","Set","usesThis","str","split","memoizeReference","reduce","prop","globalScope","keyNode","ref","init","includes","thisExpression","lastIndexOf","substr"],"mappings":"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","file":"generator.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport {\n  AbstractObjectValue,\n  AbstractValue,\n  BooleanValue,\n  ConcreteValue,\n  FunctionValue,\n  NullValue,\n  NumberValue,\n  ObjectValue,\n  StringValue,\n  SymbolValue,\n  UndefinedValue,\n  Value,\n} from \"../values/index.js\";\nimport type { AbstractValueBuildNodeFunction } from \"../values/AbstractValue.js\";\nimport type { Descriptor } from \"../types.js\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\nimport * as base62 from \"base62\";\nimport * as t from \"babel-types\";\nimport invariant from \"../invariant.js\";\nimport type {\n  BabelNodeExpression,\n  BabelNodeIdentifier,\n  BabelNodeStatement,\n  BabelNodeMemberExpression,\n  BabelNodeVariableDeclaration,\n  BabelNodeBlockStatement,\n} from \"babel-types\";\nimport { nullExpression } from \"./internalizer.js\";\n\nexport type SerializationContext = {\n  serializeValue: Value => BabelNodeExpression,\n  serializeGenerator: Generator => Array<BabelNodeStatement>,\n  emitDefinePropertyBody: (ObjectValue, string | SymbolValue, Descriptor) => BabelNodeStatement,\n  emit: BabelNodeStatement => void,\n  canOmit: AbstractValue => boolean,\n  declare: AbstractValue => void,\n};\n\nexport type GeneratorBuildNodeFunction = (Array<BabelNodeExpression>, SerializationContext) => BabelNodeStatement;\n\nexport type GeneratorEntry = {\n  declared?: AbstractValue,\n  args: Array<Value>,\n  buildNode: GeneratorBuildNodeFunction,\n  dependencies?: Array<Generator>,\n  isPure?: boolean,\n};\n\nexport type VisitEntryCallbacks = {|\n  visitValues: (Array<Value>) => void,\n  visitGenerator: Generator => void,\n  canSkip: AbstractValue => boolean,\n  recordDeclaration: AbstractValue => void,\n  recordDelayedEntry: GeneratorEntry => void,\n|};\n\nfunction serializeBody(generator: Generator, context: SerializationContext): BabelNodeBlockStatement {\n  let statements = context.serializeGenerator(generator);\n  return t.blockStatement(statements);\n}\n\nexport class Generator {\n  constructor(realm: Realm) {\n    invariant(realm.useAbstractInterpretation);\n    let realmPreludeGenerator = realm.preludeGenerator;\n    invariant(realmPreludeGenerator);\n    this.preludeGenerator = realmPreludeGenerator;\n    this.parent = realm.generator;\n    this.realm = realm;\n    this._entries = [];\n    this.id = realm.nextGeneratorId++;\n  }\n\n  realm: Realm;\n  _entries: Array<GeneratorEntry>;\n  preludeGenerator: PreludeGenerator;\n  parent: void | Generator;\n  id: number;\n\n  getAsPropertyNameExpression(key: string, canBeIdentifier: boolean = true) {\n    // If key is a non-negative numeric string literal, parse it and set it as a numeric index instead.\n    let index = Number.parseInt(key, 10);\n    if (index >= 0 && index.toString() === key) {\n      return t.numericLiteral(index);\n    }\n\n    if (canBeIdentifier) {\n      // TODO #1020: revert this when Unicode identifiers are supported by all targetted JavaScript engines\n      let keyIsAscii = /^[\\u0000-\\u007f]*$/.test(key);\n      if (t.isValidIdentifier(key) && keyIsAscii) return t.identifier(key);\n    }\n\n    return t.stringLiteral(key);\n  }\n\n  getParent(): void | Generator {\n    return this.parent;\n  }\n\n  empty() {\n    return this._entries.length === 0;\n  }\n\n  emitGlobalDeclaration(key: string, value: Value) {\n    this.preludeGenerator.declaredGlobals.add(key);\n    if (!(value instanceof UndefinedValue)) this.emitGlobalAssignment(key, value, true);\n  }\n\n  emitGlobalAssignment(key: string, value: Value, strictMode: boolean) {\n    this._addEntry({\n      args: [value],\n      buildNode: ([valueNode]) =>\n        t.expressionStatement(\n          t.assignmentExpression(\"=\", this.preludeGenerator.globalReference(key, !strictMode), valueNode)\n        ),\n    });\n  }\n\n  emitGlobalDelete(key: string, strictMode: boolean) {\n    this._addEntry({\n      args: [],\n      buildNode: ([]) =>\n        t.expressionStatement(t.unaryExpression(\"delete\", this.preludeGenerator.globalReference(key, !strictMode))),\n    });\n  }\n\n  emitPropertyAssignment(object: ObjectValue, key: string, value: Value) {\n    if (object.refuseSerialization) return;\n    let propName = this.getAsPropertyNameExpression(key);\n    this._addEntry({\n      args: [object, value],\n      buildNode: ([objectNode, valueNode]) =>\n        t.expressionStatement(\n          t.assignmentExpression(\"=\", t.memberExpression(objectNode, propName, !t.isIdentifier(propName)), valueNode)\n        ),\n    });\n  }\n\n  emitDefineProperty(object: ObjectValue, key: string, desc: Descriptor, isDescChanged: boolean = true) {\n    if (object.refuseSerialization) return;\n    if (desc.enumerable && desc.configurable && desc.writable && desc.value && !isDescChanged) {\n      let descValue = desc.value;\n      invariant(descValue instanceof Value);\n      this.emitPropertyAssignment(object, key, descValue);\n    } else {\n      desc = Object.assign({}, desc);\n      let descValue = desc.value || object.$Realm.intrinsics.undefined;\n      invariant(descValue instanceof Value);\n      this._addEntry({\n        args: [\n          object,\n          descValue,\n          desc.get || object.$Realm.intrinsics.undefined,\n          desc.set || object.$Realm.intrinsics.undefined,\n        ],\n        buildNode: (_, context: SerializationContext) => context.emitDefinePropertyBody(object, key, desc),\n      });\n    }\n  }\n\n  emitPropertyDelete(object: ObjectValue, key: string) {\n    if (object.refuseSerialization) return;\n    let propName = this.getAsPropertyNameExpression(key);\n    this._addEntry({\n      args: [object],\n      buildNode: ([objectNode]) =>\n        t.expressionStatement(\n          t.unaryExpression(\"delete\", t.memberExpression(objectNode, propName, !t.isIdentifier(propName)))\n        ),\n    });\n  }\n\n  emitCall(createCallee: () => BabelNodeExpression, args: Array<Value>) {\n    this._addEntry({\n      args,\n      buildNode: values => t.expressionStatement(t.callExpression(createCallee(), [...values])),\n    });\n  }\n\n  emitConsoleLog(method: \"log\" | \"warn\" | \"error\", args: Array<string | ConcreteValue>) {\n    this.emitCall(\n      () => t.memberExpression(t.identifier(\"console\"), t.identifier(method)),\n      args.map(v => (typeof v === \"string\" ? new StringValue(this.realm, v) : v))\n    );\n  }\n\n  emitInvariant(\n    args: Array<Value>,\n    violationConditionFn: (Array<BabelNodeExpression>) => BabelNodeExpression,\n    appendLastToInvariantFn?: BabelNodeExpression => BabelNodeExpression\n  ): void {\n    if (this.realm.omitInvariants) return;\n    this._addEntry({\n      args,\n      buildNode: (nodes: Array<BabelNodeExpression>) => {\n        let throwString = t.stringLiteral(\"Prepack model invariant violation\");\n        if (appendLastToInvariantFn) {\n          let last = nodes.pop();\n          throwString = t.binaryExpression(\n            \"+\",\n            t.stringLiteral(\"Prepack model invariant violation: \"),\n            appendLastToInvariantFn(last)\n          );\n        }\n        let condition = violationConditionFn(nodes);\n        let throwblock = t.blockStatement([t.throwStatement(t.newExpression(t.identifier(\"Error\"), [throwString]))]);\n        return t.ifStatement(condition, throwblock);\n      },\n    });\n  }\n\n  emitCallAndCaptureResult(\n    types: TypesDomain,\n    values: ValuesDomain,\n    createCallee: () => BabelNodeExpression,\n    args: Array<Value>,\n    kind?: string\n  ): AbstractValue {\n    return this.derive(types, values, args, (nodes: any) => t.callExpression(createCallee(), nodes));\n  }\n\n  emitStatement(args: Array<Value>, buildNode_: (Array<BabelNodeExpression>) => BabelNodeStatement) {\n    this._addEntry({\n      args,\n      buildNode: buildNode_,\n    });\n  }\n\n  emitVoidExpression(\n    types: TypesDomain,\n    values: ValuesDomain,\n    args: Array<Value>,\n    buildNode_: AbstractValueBuildNodeFunction | BabelNodeExpression\n  ): UndefinedValue {\n    this._addEntry({\n      args,\n      buildNode: (nodes: Array<BabelNodeExpression>) =>\n        t.expressionStatement(\n          (buildNode_: any) instanceof Function\n            ? ((buildNode_: any): AbstractValueBuildNodeFunction)(nodes)\n            : ((buildNode_: any): BabelNodeExpression)\n        ),\n    });\n    return this.realm.intrinsics.undefined;\n  }\n\n  emitForInStatement(\n    o: ObjectValue | AbstractObjectValue,\n    lh: BabelNodeVariableDeclaration,\n    sourceObject: ObjectValue,\n    targetObject: ObjectValue,\n    boundName: BabelNodeIdentifier\n  ) {\n    this._addEntry({\n      // duplicate args to ensure refcount > 1\n      args: [o, targetObject, sourceObject, targetObject, sourceObject],\n      buildNode: ([obj, tgt, src, obj1, tgt1, src1]) => {\n        const forInLoopStatement = t.forInStatement(\n          lh,\n          obj,\n          t.blockStatement([\n            t.expressionStatement(\n              t.assignmentExpression(\n                \"=\",\n                t.memberExpression(tgt, boundName, true),\n                t.memberExpression(src, boundName, true)\n              )\n            ),\n          ])\n        );\n        if (this.realm.lazyObjectsRuntime) {\n          forInLoopStatement.leadingComments = [({ type: \"BlockComment\", value: \"force hydrate lazy objects\" }: any)];\n        }\n        return forInLoopStatement;\n      },\n    });\n  }\n\n  derive(\n    types: TypesDomain,\n    values: ValuesDomain,\n    args: Array<Value>,\n    buildNode_: AbstractValueBuildNodeFunction | BabelNodeExpression,\n    optionalArgs?: {| kind?: string, isPure?: boolean, skipInvariant?: boolean |},\n    forceHydrateLazyObjects: boolean = false\n  ): AbstractValue {\n    invariant(buildNode_ instanceof Function || args.length === 0);\n    let id = t.identifier(this.preludeGenerator.nameGenerator.generate(\"derived\"));\n    this.preludeGenerator.derivedIds.set(id.name, args);\n    let options = {};\n    if (optionalArgs && optionalArgs.kind) options.kind = optionalArgs.kind;\n    let Constructor = Value.isTypeCompatibleWith(types.getType(), ObjectValue) ? AbstractObjectValue : AbstractValue;\n    let res = new Constructor(this.realm, types, values, 0, [], id, options);\n    this._addEntry({\n      isPure: optionalArgs ? optionalArgs.isPure : undefined,\n      declared: res,\n      args,\n      buildNode: (nodes: Array<BabelNodeExpression>) => {\n        const statement = t.variableDeclaration(\"var\", [\n          t.variableDeclarator(\n            id,\n            (buildNode_: any) instanceof Function\n              ? ((buildNode_: any): AbstractValueBuildNodeFunction)(nodes)\n              : ((buildNode_: any): BabelNodeExpression)\n          ),\n        ]);\n        if (forceHydrateLazyObjects && this.realm.lazyObjectsRuntime) {\n          statement.leadingComments = [({ type: \"BlockComment\", value: \"force hydrate lazy objects\" }: any)];\n        }\n        return statement;\n      },\n    });\n    let type = types.getType();\n    res.intrinsicName = id.name;\n    if (optionalArgs && optionalArgs.skipInvariant) return res;\n    let typeofString;\n    if (type instanceof FunctionValue) typeofString = \"function\";\n    else if (type === UndefinedValue) invariant(false);\n    else if (type === NullValue) invariant(false);\n    else if (type === StringValue) typeofString = \"string\";\n    else if (type === BooleanValue) typeofString = \"boolean\";\n    else if (type === NumberValue) typeofString = \"number\";\n    else if (type === SymbolValue) typeofString = \"symbol\";\n    else if (type === ObjectValue) typeofString = \"object\";\n    if (typeofString !== undefined) {\n      // Verify that the types are as expected, a failure of this invariant\n      // should mean the model is wrong.\n      this.emitInvariant(\n        [res, res],\n        nodes => {\n          invariant(typeofString !== undefined);\n          let condition = t.binaryExpression(\n            \"!==\",\n            t.unaryExpression(\"typeof\", nodes[0]),\n            t.stringLiteral(typeofString)\n          );\n          if (typeofString === \"object\") {\n            condition = t.logicalExpression(\n              \"&&\",\n              condition,\n              t.binaryExpression(\"!==\", t.unaryExpression(\"typeof\", nodes[0]), t.stringLiteral(\"function\"))\n            );\n            condition = t.logicalExpression(\"||\", condition, t.binaryExpression(\"===\", nodes[0], nullExpression));\n          }\n          return condition;\n        },\n        node => node\n      );\n    }\n\n    return res;\n  }\n\n  serialize(context: SerializationContext) {\n    for (let entry of this._entries) {\n      if (!entry.isPure || !entry.declared || !context.canOmit(entry.declared)) {\n        let nodes = entry.args.map((boundArg, i) => context.serializeValue(boundArg));\n        context.emit(entry.buildNode(nodes, context));\n        if (entry.declared !== undefined) context.declare(entry.declared);\n      }\n    }\n  }\n\n  visitEntry(entry: GeneratorEntry, callbacks: VisitEntryCallbacks) {\n    if (entry.isPure && entry.declared && callbacks.canSkip(entry.declared)) {\n      callbacks.recordDelayedEntry(entry);\n    } else {\n      if (entry.declared) callbacks.recordDeclaration(entry.declared);\n      callbacks.visitValues(entry.args);\n      if (entry.dependencies) for (let dependency of entry.dependencies) callbacks.visitGenerator(dependency);\n    }\n  }\n\n  visit(callbacks: VisitEntryCallbacks) {\n    for (let entry of this._entries) this.visitEntry(entry, callbacks);\n  }\n\n  _addEntry(entry: GeneratorEntry) {\n    this._entries.push(entry);\n  }\n\n  appendGenerator(other: Generator, leadingComment: string): void {\n    if (other.empty()) return;\n    this._addEntry({\n      args: [],\n      buildNode: function(args, context: SerializationContext) {\n        let statements = context.serializeGenerator(other);\n        let block = t.blockStatement(statements);\n        if (leadingComment.length > 0) block.leadingComments = [({ type: \"BlockComment\", value: leadingComment }: any)];\n        return block;\n      },\n      dependencies: [other],\n    });\n  }\n\n  composeGenerators(generator1: Generator, generator2: Generator): void {\n    this._addEntry({\n      args: [],\n      buildNode: function([], context) {\n        let statements = [];\n        if (!generator1.empty()) statements.push(serializeBody(generator1, context));\n        if (!generator2.empty()) statements.push(serializeBody(generator2, context));\n        return t.blockStatement(statements);\n      },\n      dependencies: [generator1, generator2],\n    });\n  }\n\n  joinGenerators(joinCondition: AbstractValue, generator1: Generator, generator2: Generator): void {\n    this._addEntry({\n      args: [joinCondition],\n      buildNode: function([cond], context) {\n        let block1 = generator1.empty() ? null : serializeBody(generator1, context);\n        let block2 = generator2.empty() ? null : serializeBody(generator2, context);\n        if (block1) return t.ifStatement(cond, block1, block2);\n        invariant(block2);\n        return t.ifStatement(t.unaryExpression(\"!\", cond), block2);\n      },\n      dependencies: [generator1, generator2],\n    });\n  }\n}\n\nexport class NameGenerator {\n  constructor(forbiddenNames: Set<string>, debugNames: boolean, uniqueSuffix: string, prefix: string) {\n    this.prefix = prefix;\n    this.uidCounter = 0;\n    this.debugNames = debugNames;\n    this.forbiddenNames = forbiddenNames;\n    this.uniqueSuffix = uniqueSuffix;\n  }\n  prefix: string;\n  uidCounter: number;\n  debugNames: boolean;\n  forbiddenNames: Set<string>;\n  uniqueSuffix: string;\n  generate(debugSuffix: ?string): string {\n    let id;\n    do {\n      id = this.prefix + base62.encode(this.uidCounter++);\n      if (this.uniqueSuffix.length > 0) id += this.uniqueSuffix;\n      if (this.debugNames) {\n        if (debugSuffix) id += \"_\" + debugSuffix.replace(/[.,:]/g, \"_\");\n        else id += \"_\";\n      }\n    } while (this.forbiddenNames.has(id));\n    return id;\n  }\n}\n\nexport class PreludeGenerator {\n  constructor(debugNames: ?boolean, uniqueSuffix: ?string) {\n    this.prelude = [];\n    this.derivedIds = new Map();\n    this.memoizedRefs = new Map();\n    this.nameGenerator = new NameGenerator(new Set(), !!debugNames, uniqueSuffix || \"\", \"_$\");\n    this.usesThis = false;\n    this.declaredGlobals = new Set();\n  }\n\n  prelude: Array<BabelNodeStatement>;\n  derivedIds: Map<string, Array<Value>>;\n  memoizedRefs: Map<string, BabelNodeIdentifier>;\n  nameGenerator: NameGenerator;\n  usesThis: boolean;\n  declaredGlobals: Set<string>;\n\n  createNameGenerator(prefix: string): NameGenerator {\n    return new NameGenerator(\n      this.nameGenerator.forbiddenNames,\n      this.nameGenerator.debugNames,\n      this.nameGenerator.uniqueSuffix,\n      prefix\n    );\n  }\n\n  convertStringToMember(str: string): BabelNodeIdentifier | BabelNodeMemberExpression {\n    return str\n      .split(\".\")\n      .map(name => (name === \"global\" ? this.memoizeReference(name) : t.identifier(name)))\n      .reduce((obj, prop) => t.memberExpression(obj, prop));\n  }\n\n  globalReference(key: string, globalScope: boolean = false) {\n    if (globalScope && t.isValidIdentifier(key)) return t.identifier(key);\n    let keyNode = t.isValidIdentifier(key) ? t.identifier(key) : t.stringLiteral(key);\n    return t.memberExpression(this.memoizeReference(\"global\"), keyNode, !t.isIdentifier(keyNode));\n  }\n\n  memoizeReference(key: string): BabelNodeIdentifier {\n    let ref = this.memoizedRefs.get(key);\n    if (ref) return ref;\n\n    let init;\n    if (key.includes(\"(\") || key.includes(\"[\")) {\n      // Horrible but effective hack:\n      // Some internal object have intrinsic names such as\n      //    ([][Symbol.iterator]().__proto__.__proto__)\n      // and\n      //    RegExp.prototype[Symbol.match]\n      // which get turned into a babel node here.\n      // TODO: We should properly parse such a string, and memoize all references in it separately.\n      // Instead, we just turn it into a funky identifier, which Babel seems to accept.\n      init = t.identifier(key);\n    } else if (key === \"global\") {\n      this.usesThis = true;\n      init = t.thisExpression();\n    } else {\n      let i = key.lastIndexOf(\".\");\n      if (i === -1) {\n        init = t.memberExpression(this.memoizeReference(\"global\"), t.identifier(key));\n      } else {\n        init = t.memberExpression(this.memoizeReference(key.substr(0, i)), t.identifier(key.substr(i + 1)));\n      }\n    }\n    ref = t.identifier(this.nameGenerator.generate(key));\n    this.prelude.push(t.variableDeclaration(\"var\", [t.variableDeclarator(ref, init)]));\n    this.memoizedRefs.set(key, ref);\n    return ref;\n  }\n}\n"]}