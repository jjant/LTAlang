"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (realm, code, filename) {
  var sourceType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "script";
  var startLine = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;

  try {
    var plugins = [];
    if (realm.react.enabled) {
      plugins.push("jsx");
      if (realm.react.flowRequired) {
        plugins.push("flow");
      }
    }
    var ast = (0, _babylon.parse)(code, { filename: filename, sourceType: sourceType, startLine: startLine, plugins: plugins });
    (0, _traverseFast2.default)(ast, function (node) {
      (0, _invariant2.default)(node.loc);
      node.loc.source = filename;
      return false;
    });
    return ast;
  } catch (e) {
    if (e instanceof SyntaxError) {
      // Babel reports all errors as syntax errors, even if a ReferenceError should be thrown.
      // What we do here is a totally robust way to address that issue.
      var referenceErrors = ["Invalid left-hand side in postfix operation", "Invalid left-hand side in prefix operation", "Invalid left-hand side in assignment expression"];

      var error = void 0;
      if (referenceErrors.some(function (msg) {
        return e.message.indexOf(msg) >= 0;
      })) {
        error = (0, _construct.Construct)(realm, realm.intrinsics.ReferenceError, [new _index.StringValue(realm, e.message)]);
      } else {
        error = (0, _construct.Construct)(realm, realm.intrinsics.SyntaxError, [new _index.StringValue(realm, e.message)]);
      }
      // These constructors are currently guaranteed to produce an object with
      // built-in error data. Append location information about the syntax error
      // and the source code to it so that we can use it to print nicer errors.
      (0, _invariant2.default)(error.$ErrorData);
      error.$ErrorData.locationData = {
        filename: filename,
        sourceCode: code,
        loc: e.loc,
        stackDecorated: false
      };
      throw new _completions.ThrowCompletion(error, e.loc);
    } else {
      throw e;
    }
  }
};

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _completions = require("../completions.js");

var _index = require("../values/index.js");

var _construct = require("../methods/construct.js");

var _traverseFast = require("../utils/traverse-fast.js");

var _traverseFast2 = _interopRequireDefault(_traverseFast);

var _babylon = require("babylon");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
//# sourceMappingURL=parse.js.map