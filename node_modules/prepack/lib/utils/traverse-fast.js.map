{"version":3,"sources":["../../src/utils/traverse-fast.js"],"names":["traverse","t","node","enter","keys","VISITOR_KEYS","type","stop","key","subNode","Array","isArray","elementNode"],"mappings":";;;;;kBAmBwBA,Q;;AARxB;;IACYC,C;;;;AAEZ;AACA;AACA;AACA;AACA;AAlBA;;;;;;;;;AAmBe,SAASD,QAAT,CAAkBE,IAAlB,EAAmCC,KAAnC,EAAgE;AAC7E,MAAI,CAACD,IAAL,EAAW;;AAEX,MAAIE,OAAOH,EAAEI,YAAF,CAAeH,KAAKI,IAApB,CAAX;AACA,MAAI,CAACF,IAAL,EAAW;;AAEX,MAAIG,OAAOJ,MAAMD,IAAN,CAAX;AACA,MAAIK,IAAJ,EAAU;;AAPmE;AAAA;AAAA;;AAAA;AAS7E,yBAAgBH,IAAhB,8HAAsB;AAAA,UAAbI,GAAa;;AACpB,UAAIC,UAAWP,IAAD,CAAYM,GAAZ,CAAd;;AAEA,UAAIE,MAAMC,OAAN,CAAcF,OAAd,CAAJ,EAA4B;AAAA;AAAA;AAAA;;AAAA;AAC1B,gCAAwBA,OAAxB,mIAAiC;AAAA,gBAAxBG,WAAwB;;AAC/BZ,qBAASY,WAAT,EAAsBT,KAAtB;AACD;AAHyB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAI3B,OAJD,MAIO;AACLH,iBAASS,OAAT,EAAkBN,KAAlB;AACD;AACF;AAnB4E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAoB9E","file":"traverse-fast.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { BabelNode } from \"babel-types\";\nimport * as t from \"babel-types\";\n\n// This is a variation of traverseFast from\n// https://github.com/babel/babel/blob/28ae47a174f67a8ae6f4527e0a66e88896814170/packages/babel-types/src/index.js\n// This version...\n// - takes a callback function that returns a boolean to indicate whether to short-circuit the traversal\n// - doesn't pass around or allocate an optional parameter value to the callback.\nexport default function traverse(node: BabelNode, enter: BabelNode => boolean) {\n  if (!node) return;\n\n  let keys = t.VISITOR_KEYS[node.type];\n  if (!keys) return;\n\n  let stop = enter(node);\n  if (stop) return;\n\n  for (let key of keys) {\n    let subNode = (node: any)[key];\n\n    if (Array.isArray(subNode)) {\n      for (let elementNode of subNode) {\n        traverse(elementNode, enter);\n      }\n    } else {\n      traverse(subNode, enter);\n    }\n  }\n}\n"]}