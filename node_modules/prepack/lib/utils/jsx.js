"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isReactElement = isReactElement;
exports.convertExpressionToJSXIdentifier = convertExpressionToJSXIdentifier;
exports.convertJSXExpressionToIdentifier = convertJSXExpressionToIdentifier;
exports.convertKeyValueToJSXAttribute = convertKeyValueToJSXAttribute;
exports.applyKeysToNestedArray = applyKeysToNestedArray;

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _index = require("../values/index.js");

var _index2 = require("../methods/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

function isReactElement(val) {
  if (val instanceof _index.ObjectValue && val.properties.has("$$typeof")) {
    var realm = val.$Realm;
    var $$typeof = (0, _index2.Get)(realm, val, "$$typeof");
    if ($$typeof instanceof _index.SymbolValue) {
      var symbolFromRegistry = realm.globalSymbolRegistry.find(function (e) {
        return e.$Symbol === $$typeof;
      });
      return symbolFromRegistry !== undefined && symbolFromRegistry.$Key === "react.element";
    }
  }
  return false;
}

function convertExpressionToJSXIdentifier(expr, isRoot) {
  switch (expr.type) {
    case "ThisExpression":
      (0, _invariant2.default)(isRoot === false, "invalid conversion of root expression to JSXIdentifier for ThisExpression");
      return t.jSXIdentifier("this");
    case "Identifier":
      var name = expr.name;
      (0, _invariant2.default)(
      // ensure the 1st character of the string is uppercase
      // for a component unless it is not the root
      isRoot === false || name.length > 0 && name[0] === name[0].toUpperCase(), "invalid JSXIdentifer from Identifier, Identifier name must be uppercase");
      return t.jSXIdentifier(name);
    case "StringLiteral":
      var value = expr.value;
      (0, _invariant2.default)(
      // ensure the 1st character of the string is lowercase
      // otherwise it will appear as a component
      value.length > 0 && value[0] === value[0].toLowerCase(), "invalid JSXIdentifer from string, strings must be lowercase");
      return t.jSXIdentifier(value);
    case "MemberExpression":
      (0, _invariant2.default)(expr.computed === false, "Cannot inline computed expressions in JSX type.");
      return t.jSXMemberExpression(convertExpressionToJSXIdentifier(expr.object, false), convertExpressionToJSXIdentifier(expr.property, false));
    default:
      (0, _invariant2.default)(false, "Invalid JSX type");
  }
}

function convertJSXExpressionToIdentifier(expr) {
  switch (expr.type) {
    case "JSXIdentifier":
      return t.identifier(expr.name);
    case "JSXMemberExpression":
      return t.memberExpression(convertJSXExpressionToIdentifier(expr.object), convertJSXExpressionToIdentifier(expr.property));
    default:
      (0, _invariant2.default)(false, "Invalid JSX type");
  }
}

function convertKeyValueToJSXAttribute(key, expr) {
  return t.jSXAttribute(t.jSXIdentifier(key), expr.type === "StringLiteral" ? expr : t.jSXExpressionContainer(expr));
}

function addKeyToElement(astElement, key) {
  var astAttributes = astElement.openingElement.attributes;
  var existingKey = null;

  for (var i = 0; i < astAttributes.length; i++) {
    var astAttribute = astAttributes[i];

    if (t.isJSXAttribute(astAttribute) && t.isJSXIdentifier(astAttribute.name) && astAttribute.name.name === "key") {
      existingKey = astAttribute.value;
      break;
    }
  }
  if (existingKey === null) {
    astAttributes.push(t.jSXAttribute(t.jSXIdentifier("key"), t.stringLiteral(key)));
  }
}

// we create a unique key for each JSXElement to prevent collisions
// otherwise React will detect a missing/conflicting key at runtime and
// this can break the reconcilation of JSXElements in arrays
function getUniqueJSXElementKey(index, usedReactElementKeys) {
  var key = void 0;
  do {
    key = Math.random().toString(36).replace(/[^a-z]+/g, "").substring(0, 2);
  } while (usedReactElementKeys.has(key));
  usedReactElementKeys.add(key);
  if (index !== undefined) {
    return "" + key + index;
  }
  return key;
}

function applyKeysToNestedArray(expr, isBase, usedReactElementKeys) {
  var astElements = expr.elements;

  if (Array.isArray(astElements)) {
    for (var i = 0; i < astElements.length; i++) {
      var astElement = astElements[i];

      if (astElement != null) {
        if (t.isJSXElement(astElement) && isBase === false) {
          addKeyToElement(astElement, getUniqueJSXElementKey("" + i, usedReactElementKeys));
        } else if (t.isArrayExpression(astElement)) {
          applyKeysToNestedArray(astElement, false, usedReactElementKeys);
        } else if (astElement.type === "ConditionalExpression") {
          var alternate = astElement.alternate;
          // it's common for conditions to be in an array, which means we need to check them for keys too
          if (t.isJSXElement(alternate.type) && isBase === false) {
            addKeyToElement(alternate, getUniqueJSXElementKey("0" + i, usedReactElementKeys));
          } else if (t.isArrayExpression(alternate.type)) {
            applyKeysToNestedArray(alternate, false, usedReactElementKeys);
          }
          var consequent = astElement.consequent;
          if (t.isJSXElement(consequent.type) && isBase === false) {
            addKeyToElement(consequent, getUniqueJSXElementKey("1" + i, usedReactElementKeys));
          } else if (t.isArrayExpression(consequent.type)) {
            applyKeysToNestedArray(consequent, false, usedReactElementKeys);
          }
        }
      }
    }
  }
}
//# sourceMappingURL=jsx.js.map