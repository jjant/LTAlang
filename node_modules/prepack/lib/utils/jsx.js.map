{"version":3,"sources":["../../src/utils/jsx.js"],"names":["isReactElement","convertExpressionToJSXIdentifier","convertJSXExpressionToIdentifier","convertKeyValueToJSXAttribute","applyKeysToNestedArray","t","val","properties","has","realm","$Realm","$$typeof","symbolFromRegistry","globalSymbolRegistry","find","e","$Symbol","undefined","$Key","expr","isRoot","type","jSXIdentifier","name","length","toUpperCase","value","toLowerCase","computed","jSXMemberExpression","object","property","identifier","memberExpression","key","jSXAttribute","jSXExpressionContainer","addKeyToElement","astElement","astAttributes","openingElement","attributes","existingKey","i","astAttribute","isJSXAttribute","isJSXIdentifier","push","stringLiteral","getUniqueJSXElementKey","index","usedReactElementKeys","Math","random","toString","replace","substring","add","isBase","astElements","elements","Array","isArray","isJSXElement","isArrayExpression","alternate","consequent"],"mappings":"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","file":"jsx.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport * as t from \"babel-types\";\nimport type {\n  BabelNodeExpression,\n  BabelNodeArrayExpression,\n  BabelNodeJSXElement,\n  BabelNodeJSXMemberExpression,\n  BabelNodeJSXIdentifier,\n  BabelNodeIdentifier,\n  BabelNodeMemberExpression,\n} from \"babel-types\";\nimport invariant from \"../invariant.js\";\nimport { Value, ObjectValue, SymbolValue } from \"../values/index.js\";\nimport { Get } from \"../methods/index.js\";\n\nexport function isReactElement(val: Value): boolean {\n  if (val instanceof ObjectValue && val.properties.has(\"$$typeof\")) {\n    let realm = val.$Realm;\n    let $$typeof = Get(realm, val, \"$$typeof\");\n    if ($$typeof instanceof SymbolValue) {\n      let symbolFromRegistry = realm.globalSymbolRegistry.find(e => e.$Symbol === $$typeof);\n      return symbolFromRegistry !== undefined && symbolFromRegistry.$Key === \"react.element\";\n    }\n  }\n  return false;\n}\n\nexport function convertExpressionToJSXIdentifier(\n  expr: BabelNodeExpression,\n  isRoot: boolean\n): BabelNodeJSXMemberExpression | BabelNodeJSXIdentifier {\n  switch (expr.type) {\n    case \"ThisExpression\":\n      invariant(isRoot === false, `invalid conversion of root expression to JSXIdentifier for ThisExpression`);\n      return t.jSXIdentifier(\"this\");\n    case \"Identifier\":\n      let name = expr.name;\n      invariant(\n        // ensure the 1st character of the string is uppercase\n        // for a component unless it is not the root\n        isRoot === false || (name.length > 0 && name[0] === name[0].toUpperCase()),\n        \"invalid JSXIdentifer from Identifier, Identifier name must be uppercase\"\n      );\n      return t.jSXIdentifier(name);\n    case \"StringLiteral\":\n      let value = expr.value;\n      invariant(\n        // ensure the 1st character of the string is lowercase\n        // otherwise it will appear as a component\n        value.length > 0 && value[0] === value[0].toLowerCase(),\n        \"invalid JSXIdentifer from string, strings must be lowercase\"\n      );\n      return t.jSXIdentifier(value);\n    case \"MemberExpression\":\n      invariant(expr.computed === false, \"Cannot inline computed expressions in JSX type.\");\n      return t.jSXMemberExpression(\n        convertExpressionToJSXIdentifier(expr.object, false),\n        ((convertExpressionToJSXIdentifier(expr.property, false): any): BabelNodeJSXIdentifier)\n      );\n    default:\n      invariant(false, \"Invalid JSX type\");\n  }\n}\n\nexport function convertJSXExpressionToIdentifier(\n  expr: BabelNodeExpression\n): BabelNodeMemberExpression | BabelNodeIdentifier {\n  switch (expr.type) {\n    case \"JSXIdentifier\":\n      return t.identifier(expr.name);\n    case \"JSXMemberExpression\":\n      return t.memberExpression(\n        convertJSXExpressionToIdentifier(expr.object),\n        (convertJSXExpressionToIdentifier(expr.property): any)\n      );\n    default:\n      invariant(false, \"Invalid JSX type\");\n  }\n}\n\nexport function convertKeyValueToJSXAttribute(key: string, expr: BabelNodeExpression) {\n  return t.jSXAttribute(t.jSXIdentifier(key), expr.type === \"StringLiteral\" ? expr : t.jSXExpressionContainer(expr));\n}\n\nfunction addKeyToElement(astElement: BabelNodeJSXElement, key) {\n  let astAttributes = astElement.openingElement.attributes;\n  let existingKey = null;\n\n  for (let i = 0; i < astAttributes.length; i++) {\n    let astAttribute = astAttributes[i];\n\n    if (t.isJSXAttribute(astAttribute) && t.isJSXIdentifier(astAttribute.name) && astAttribute.name.name === \"key\") {\n      existingKey = astAttribute.value;\n      break;\n    }\n  }\n  if (existingKey === null) {\n    astAttributes.push(t.jSXAttribute(t.jSXIdentifier(\"key\"), t.stringLiteral(key)));\n  }\n}\n\n// we create a unique key for each JSXElement to prevent collisions\n// otherwise React will detect a missing/conflicting key at runtime and\n// this can break the reconcilation of JSXElements in arrays\nfunction getUniqueJSXElementKey(index?: string, usedReactElementKeys: Set<string>) {\n  let key;\n  do {\n    key = Math.random().toString(36).replace(/[^a-z]+/g, \"\").substring(0, 2);\n  } while (usedReactElementKeys.has(key));\n  usedReactElementKeys.add(key);\n  if (index !== undefined) {\n    return `${key}${index}`;\n  }\n  return key;\n}\n\nexport function applyKeysToNestedArray(\n  expr: BabelNodeArrayExpression,\n  isBase: boolean,\n  usedReactElementKeys: Set<string>\n): void {\n  let astElements = expr.elements;\n\n  if (Array.isArray(astElements)) {\n    for (let i = 0; i < astElements.length; i++) {\n      let astElement = astElements[i];\n\n      if (astElement != null) {\n        if (t.isJSXElement(astElement) && isBase === false) {\n          addKeyToElement((astElement: any), getUniqueJSXElementKey(\"\" + i, usedReactElementKeys));\n        } else if (t.isArrayExpression(astElement)) {\n          applyKeysToNestedArray((astElement: any), false, usedReactElementKeys);\n        } else if (astElement.type === \"ConditionalExpression\") {\n          let alternate = (astElement.alternate: any);\n          // it's common for conditions to be in an array, which means we need to check them for keys too\n          if (t.isJSXElement(alternate.type) && isBase === false) {\n            addKeyToElement(alternate, getUniqueJSXElementKey(\"0\" + i, usedReactElementKeys));\n          } else if (t.isArrayExpression(alternate.type)) {\n            applyKeysToNestedArray(alternate, false, usedReactElementKeys);\n          }\n          let consequent = (astElement.consequent: any);\n          if (t.isJSXElement(consequent.type) && isBase === false) {\n            addKeyToElement(consequent, getUniqueJSXElementKey(\"1\" + i, usedReactElementKeys));\n          } else if (t.isArrayExpression(consequent.type)) {\n            applyKeysToNestedArray(consequent, false, usedReactElementKeys);\n          }\n        }\n      }\n    }\n  }\n}\n"]}