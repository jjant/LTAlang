{"version":3,"sources":["../../src/utils/simplifier.js"],"names":["simplifyAndRefineAbstractValue","realm","isCondition","value","savedHandler","errorHandler","savedIsReadOnly","isReadOnly","simplify","e","getType","implies","intrinsics","true","impliesNot","false","loc","expressionLocation","op","kind","args","x0","x","negate","equals","undefined","y0","y","mightNotBeTrue","mightNotBeFalse","createFromLogicalOp","simplifyEquality","c0","c","cs","notc","createFromUnaryOp","createFromBinaryOp","xc","xx","createFromConditionalOp","yc","z","pathConditions","length","abstractValue","concreteValues","remainingConcreteValues","concreteValue","push","createAbstractConcreteUnion","equality","mightNotBeUndefined","mightNotBeNull","cond","xy","mightBeUndefined","makeBoolean","mightBeNull","v","unsimplifiedNegation","computeUnary","mightBeNumber","invertedComparison","left","right","invertedLogicalOp"],"mappings":"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","file":"simplifier.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { BabelNodeSourceLocation } from \"babel-types\";\nimport { FatalError } from \"../errors.js\";\nimport { ValuesDomain } from \"../domains/index.js\";\nimport invariant from \"../invariant.js\";\nimport { ToBoolean } from \"../methods/index.js\";\nimport { Realm } from \"../realm.js\";\nimport { AbstractValue, BooleanValue, ConcreteValue, Value } from \"../values/index.js\";\nimport { Path } from \"../singletons.js\";\n\nexport default function simplifyAndRefineAbstractValue(\n  realm: Realm,\n  isCondition: boolean, // The value is only used after converting it to a Boolean\n  value: AbstractValue\n): Value {\n  let savedHandler = realm.errorHandler;\n  let savedIsReadOnly = realm.isReadOnly;\n  realm.isReadOnly = true;\n  try {\n    realm.errorHandler = () => {\n      throw new FatalError();\n    };\n    return simplify(realm, value, isCondition);\n  } catch (e) {\n    return value;\n  } finally {\n    realm.errorHandler = savedHandler;\n    realm.isReadOnly = savedIsReadOnly;\n  }\n}\n\nfunction simplify(realm, value: Value, isCondition: boolean = false): Value {\n  if (value instanceof ConcreteValue) return value;\n  invariant(value instanceof AbstractValue);\n  if (isCondition || value.getType() === BooleanValue) {\n    if (Path.implies(value)) return realm.intrinsics.true;\n    if (Path.impliesNot(value)) return realm.intrinsics.false;\n  }\n  let loc = value.expressionLocation;\n  let op = value.kind;\n  switch (op) {\n    case \"!\": {\n      let [x0] = value.args;\n      let x = simplify(realm, x0, true);\n      return negate(realm, x, loc, x0.equals(x) ? value : undefined);\n    }\n    case \"||\":\n    case \"&&\": {\n      let [x0, y0] = value.args;\n      let x = simplify(realm, x0);\n      let y = simplify(realm, y0);\n      if (x instanceof AbstractValue && x.equals(y)) return x;\n      // true && y <=> y\n      // true || y <=> true\n      if (!x.mightNotBeTrue()) return op === \"&&\" ? y : x;\n      // (x == false) && y <=> x\n      // false || y <=> y\n      if (!x.mightNotBeFalse()) return op === \"||\" ? y : x;\n      if (isCondition || (x.getType() === BooleanValue && y.getType() === BooleanValue)) {\n        // (x: boolean) && true <=> x\n        // x || true <=> true\n        if (!y.mightNotBeTrue()) return op === \"&&\" ? x : realm.intrinsics.true;\n        // (x: boolean) && false <=> false\n        // (x: boolean) || false <=> x\n        if (!y.mightNotBeFalse()) return op === \"||\" ? x : realm.intrinsics.false;\n      }\n      if (\n        op === \"||\" &&\n        y instanceof AbstractValue &&\n        y.kind === \"||\" &&\n        x.equals(y.args[0]) &&\n        !y.args[1].mightNotBeTrue()\n      )\n        return y;\n      if (x.equals(x0) && y.equals(y0)) return value;\n      return AbstractValue.createFromLogicalOp(realm, (value.kind: any), x, y, loc);\n    }\n    case \"==\":\n    case \"!=\":\n    case \"===\":\n    case \"!==\":\n      return simplifyEquality(realm, value);\n    case \"conditional\": {\n      let [c0, x0, y0] = value.args;\n      let c = simplify(realm, c0, true);\n      let cs = simplify(realm, c0);\n      let x = simplify(realm, x0);\n      let y = simplify(realm, y0);\n      if (!c.mightNotBeTrue()) return x;\n      if (!c.mightNotBeFalse()) return y;\n      invariant(c instanceof AbstractValue);\n      if (Path.implies(c)) return x;\n      let notc = AbstractValue.createFromUnaryOp(realm, \"!\", c);\n      if (!notc.mightNotBeTrue()) return y;\n      if (!notc.mightNotBeFalse()) return x;\n      invariant(notc instanceof AbstractValue);\n      if (Path.implies(notc)) return y;\n      if (Path.implies(AbstractValue.createFromBinaryOp(realm, \"===\", value, x))) return x;\n      if (Path.implies(AbstractValue.createFromBinaryOp(realm, \"!==\", value, x))) return y;\n      if (Path.implies(AbstractValue.createFromBinaryOp(realm, \"!==\", value, y))) return x;\n      if (Path.implies(AbstractValue.createFromBinaryOp(realm, \"===\", value, y))) return y;\n      // c ? x : x <=> x\n      if (x.equals(y)) return x;\n      // x ? x : y <=> x || y\n      if (cs.equals(x)) return AbstractValue.createFromLogicalOp(realm, \"||\", x, y, loc);\n      // y ? x : y <=> y && x\n      if (cs.equals(y)) return AbstractValue.createFromLogicalOp(realm, \"&&\", y, x, loc);\n      // c ? (c ? xx : xy) : y <=> c ? xx : y\n      if (x instanceof AbstractValue && x.kind === \"conditional\") {\n        let [xc, xx] = x.args;\n        if (c.equals(xc)) return AbstractValue.createFromConditionalOp(realm, c, xx, y);\n      }\n      // c ? x : (c ? y : z) : z <=> c ? x : z\n      if (y instanceof AbstractValue && y.kind === \"conditional\") {\n        let [yc, , z] = y.args;\n        if (c.equals(yc)) return AbstractValue.createFromConditionalOp(realm, c, x, z);\n      }\n      if (x.getType() === BooleanValue && y.getType() === BooleanValue) {\n        // c ? true : false <=> c\n        if (!x.mightNotBeTrue() && !y.mightNotBeFalse()) return c;\n        // c ? false : true <=> !c\n        if (!x.mightNotBeFalse() && !y.mightNotBeTrue())\n          return AbstractValue.createFromUnaryOp(realm, \"!\", c, true, loc);\n      }\n      if (c.equals(c0) && x.equals(x0) && y.equals(y0)) return value;\n      return AbstractValue.createFromConditionalOp(realm, c, x, y, value.expressionLocation);\n    }\n    case \"abstractConcreteUnion\": {\n      // The union of an abstract value with one or more concrete values.\n      if (realm.pathConditions.length === 0) return value;\n      let [abstractValue, ...concreteValues] = value.args;\n      invariant(abstractValue instanceof AbstractValue);\n      let remainingConcreteValues = [];\n      for (let concreteValue of concreteValues) {\n        if (Path.implies(AbstractValue.createFromBinaryOp(realm, \"!==\", value, concreteValue))) continue;\n        if (Path.implies(AbstractValue.createFromBinaryOp(realm, \"===\", value, concreteValue))) return concreteValue;\n        remainingConcreteValues.push(concreteValue);\n      }\n      if (remainingConcreteValues.length === 0) return abstractValue;\n      if (remainingConcreteValues.length === concreteValues.length) return value;\n      return AbstractValue.createAbstractConcreteUnion(realm, abstractValue, ...remainingConcreteValues);\n    }\n    default:\n      return value;\n  }\n}\n\nfunction simplifyEquality(realm: Realm, equality: AbstractValue): Value {\n  let loc = equality.expressionLocation;\n  let op = equality.kind;\n  let [x, y] = equality.args;\n  if (x instanceof ConcreteValue) [x, y] = [y, x];\n  if (x instanceof AbstractValue && x.kind === \"conditional\" && (!y.mightNotBeUndefined() || !y.mightNotBeNull())) {\n    // try to simplify \"(cond ? xx : xy) op undefined/null\" to just \"cond\" or \"!cond\"\n    let [cond, xx, xy] = x.args;\n    invariant(cond instanceof AbstractValue); // otherwise the the conditional should not have been created\n    if (op === \"===\" || op === \"!==\") {\n      // if xx === undefined && xy !== undefined then cond <=> x === undefined\n      if (!y.mightNotBeUndefined() && !xx.mightNotBeUndefined() && !xy.mightBeUndefined())\n        return op === \"===\" ? makeBoolean(realm, cond, loc) : negate(realm, cond, loc);\n      // if xx !== undefined && xy === undefined then !cond <=> x === undefined\n      if (!y.mightNotBeUndefined() && !xx.mightBeUndefined() && !xy.mightNotBeUndefined())\n        return op === \"===\" ? negate(realm, cond, loc) : makeBoolean(realm, cond, loc);\n      // if xx === null && xy !== null then cond <=> x === null\n      if (!y.mightNotBeNull() && !xx.mightNotBeNull() && !xy.mightBeNull())\n        return op === \"===\" ? makeBoolean(realm, cond, loc) : negate(realm, cond, loc);\n      // if xx !== null && xy === null then !cond <=> x === null\n      if (!y.mightNotBeNull() && !xx.mightBeNull() && !xy.mightNotBeNull())\n        return op === \"===\" ? negate(realm, cond, loc) : makeBoolean(realm, cond, loc);\n    } else {\n      invariant(op === \"==\" || op === \"!=\");\n      // if xx cannot be undefined/null and xy is undefined/null then !cond <=> x == undefined/null\n      if (!xx.mightBeUndefined() && !xx.mightBeNull() && (!xy.mightNotBeUndefined() || !xy.mightNotBeNull()))\n        return op === \"==\" ? negate(realm, cond, loc) : makeBoolean(realm, cond, loc);\n      // if xx is undefined/null and xy cannot be undefined/null then cond <=> x == undefined/null\n      if ((!xx.mightNotBeUndefined() || !xx.mightNotBeNull()) && !xy.mightBeUndefined() && !xy.mightBeNull())\n        return op === \"==\" ? makeBoolean(realm, cond, loc) : negate(realm, cond, loc);\n    }\n  }\n  return equality;\n}\n\nfunction makeBoolean(realm: Realm, value: Value, loc: ?BabelNodeSourceLocation = undefined): Value {\n  if (value.getType() === BooleanValue) return value;\n  if (value instanceof ConcreteValue) return new BooleanValue(realm, ToBoolean(realm, value));\n  invariant(value instanceof AbstractValue);\n  let v = AbstractValue.createFromUnaryOp(realm, \"!\", value, true, value.expressionLocation);\n  if (v instanceof ConcreteValue) return new BooleanValue(realm, !ToBoolean(realm, v));\n  invariant(v instanceof AbstractValue);\n  return AbstractValue.createFromUnaryOp(realm, \"!\", v, true, loc || value.expressionLocation);\n}\n\nfunction negate(\n  realm: Realm,\n  value: Value,\n  loc: ?BabelNodeSourceLocation = undefined,\n  unsimplifiedNegation: void | Value = undefined\n): Value {\n  if (value instanceof ConcreteValue) return ValuesDomain.computeUnary(realm, \"!\", value);\n  invariant(value instanceof AbstractValue);\n  if (value.kind === \"!\") {\n    let [x] = value.args;\n    if (x.getType() === BooleanValue) return simplify(realm, x, true);\n    if (unsimplifiedNegation !== undefined) return unsimplifiedNegation;\n    return makeBoolean(realm, x, loc);\n  }\n  if (!value.mightNotBeTrue()) return realm.intrinsics.false;\n  if (!value.mightNotBeFalse()) return realm.intrinsics.true;\n  // If NaN is not an issue, invert binary ops\n  if (value.args.length === 2 && !value.args[0].mightBeNumber() && !value.args[1].mightBeNumber()) {\n    let invertedComparison;\n    switch (value.kind) {\n      case \"===\":\n        invertedComparison = \"!==\";\n        break;\n      case \"==\":\n        invertedComparison = \"!=\";\n        break;\n      case \"!==\":\n        invertedComparison = \"===\";\n        break;\n      case \"!=\":\n        invertedComparison = \"==\";\n        break;\n      case \"<\":\n        invertedComparison = \">=\";\n        break;\n      case \"<=\":\n        invertedComparison = \">\";\n        break;\n      case \">\":\n        invertedComparison = \"<=\";\n        break;\n      case \">=\":\n        invertedComparison = \"<\";\n        break;\n      default:\n        break;\n    }\n    if (invertedComparison !== undefined) {\n      let left = simplify(realm, value.args[0]);\n      let right = simplify(realm, value.args[1]);\n      return AbstractValue.createFromBinaryOp(realm, invertedComparison, left, right, loc || value.expressionLocation);\n    }\n    let invertedLogicalOp;\n    switch (value.kind) {\n      case \"&&\":\n        invertedLogicalOp = \"||\";\n        break;\n      case \"||\":\n        invertedLogicalOp = \"&&\";\n        break;\n      default:\n        break;\n    }\n    if (invertedLogicalOp !== undefined) {\n      let left = negate(realm, value.args[0]);\n      let right = negate(realm, value.args[1]);\n      return AbstractValue.createFromLogicalOp(realm, invertedLogicalOp, left, right, loc || value.expressionLocation);\n    }\n  }\n  if (unsimplifiedNegation !== undefined) return unsimplifiedNegation;\n  return AbstractValue.createFromUnaryOp(realm, \"!\", value, true, loc || value.expressionLocation);\n}\n"]}