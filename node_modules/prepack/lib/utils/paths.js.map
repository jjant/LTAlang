{"version":3,"sources":["../../src/utils/paths.js"],"names":["PathImplementation","condition","mightNotBeTrue","path","$Realm","pathConditions","i","length","pathCondition","implies","mightNotBeFalse","impliesNot","evaluate","realm","savedPath","pushPathCondition","pushRefinedConditions","pushInversePathCondition","kind","left","args","right","op","leftNeNull","createFromBinaryOp","intrinsics","null","leftNeUndefined","undefined","push","leftEqNull","leftEqUndefined","inverseCondition","createFromUnaryOp","simplifiedInverseCondition","simplifyAndRefineAbstractCondition","equals","unrefinedConditions","unrefinedCond"],"mappings":"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","file":"paths.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { AbstractValue, ConcreteValue, NullValue, UndefinedValue, Value } from \"../values/index.js\";\nimport invariant from \"../invariant.js\";\n\nexport class PathImplementation {\n  implies(condition: AbstractValue): boolean {\n    if (!condition.mightNotBeTrue()) return true; // any path implies true\n    let path = condition.$Realm.pathConditions;\n    for (let i = path.length - 1; i >= 0; i--) {\n      let pathCondition = path[i];\n      if (pathCondition.implies(condition)) return true;\n    }\n    return false;\n  }\n\n  impliesNot(condition: AbstractValue): boolean {\n    if (!condition.mightNotBeFalse()) return true; // any path implies !false\n    let path = condition.$Realm.pathConditions;\n    for (let i = path.length - 1; i >= 0; i--) {\n      let pathCondition = path[i];\n      if (pathCondition.impliesNot(condition)) return true;\n    }\n    return false;\n  }\n\n  withCondition<T>(condition: AbstractValue, evaluate: () => T): T {\n    let realm = condition.$Realm;\n    let savedPath = realm.pathConditions;\n    realm.pathConditions = [];\n    try {\n      pushPathCondition(condition);\n      pushRefinedConditions(savedPath);\n      return evaluate();\n    } finally {\n      realm.pathConditions = savedPath;\n    }\n  }\n\n  withInverseCondition<T>(condition: AbstractValue, evaluate: () => T): T {\n    let realm = condition.$Realm;\n    let savedPath = realm.pathConditions;\n    realm.pathConditions = [];\n    try {\n      pushInversePathCondition(condition);\n      pushRefinedConditions(savedPath);\n      return evaluate();\n    } finally {\n      realm.pathConditions = savedPath;\n    }\n  }\n}\n\n// A path condition is an abstract value that is known to be true in a particular code path\nfunction pushPathCondition(condition: Value) {\n  invariant(condition.mightNotBeFalse()); // it is mistake to assert that false is true\n  if (condition instanceof ConcreteValue) return;\n  if (!condition.mightNotBeTrue()) return;\n  invariant(condition instanceof AbstractValue);\n  let realm = condition.$Realm;\n  if (condition.kind === \"&&\") {\n    let left = condition.args[0];\n    let right = condition.args[1];\n    invariant(left instanceof AbstractValue); // it is a mistake to create an abstract value when concrete value will do\n    pushPathCondition(left);\n    pushPathCondition(right);\n  } else {\n    if (condition.kind === \"!=\" || condition.kind === \"==\") {\n      let left = condition.args[0];\n      let right = condition.args[1];\n      if (left instanceof ConcreteValue && right instanceof AbstractValue) [left, right] = [right, left];\n      if (left instanceof AbstractValue && (right instanceof UndefinedValue || right instanceof NullValue)) {\n        let op = condition.kind === \"!=\" ? \"!==\" : \"===\";\n        if (op === \"!==\") pushPathCondition(left);\n        else pushInversePathCondition(left);\n        let leftNeNull = AbstractValue.createFromBinaryOp(realm, op, left, realm.intrinsics.null);\n        if (leftNeNull.mightNotBeFalse()) pushPathCondition(leftNeNull);\n        let leftNeUndefined = AbstractValue.createFromBinaryOp(realm, op, left, realm.intrinsics.undefined);\n        if (leftNeUndefined.mightNotBeFalse()) pushPathCondition(leftNeUndefined);\n        return;\n      }\n    }\n    realm.pathConditions.push(condition);\n  }\n}\n\n// An inverse path condition is an abstract value that is known to be false in a particular code path\nfunction pushInversePathCondition(condition: Value) {\n  // it is mistake to assert that true is false.\n  invariant(condition.mightNotBeTrue());\n  if (condition instanceof ConcreteValue) return;\n  invariant(condition instanceof AbstractValue);\n  if (condition.kind === \"||\") {\n    let left = condition.args[0];\n    let right = condition.args[1];\n    invariant(left instanceof AbstractValue); // it is a mistake to create an abstract value when concrete value will do\n    pushInversePathCondition(left);\n    if (right.mightNotBeTrue()) pushInversePathCondition(right);\n  } else {\n    let realm = condition.$Realm;\n    if (condition.kind === \"!=\" || condition.kind === \"==\") {\n      let left = condition.args[0];\n      let right = condition.args[1];\n      if (left instanceof ConcreteValue && right instanceof AbstractValue) [left, right] = [right, left];\n      if (left instanceof AbstractValue && (right instanceof UndefinedValue || right instanceof NullValue)) {\n        let op = condition.kind === \"!=\" ? \"===\" : \"!==\";\n        if (op === \"!==\") pushInversePathCondition(left);\n        else pushPathCondition(left);\n        let leftEqNull = AbstractValue.createFromBinaryOp(realm, op, left, realm.intrinsics.null);\n        if (leftEqNull.mightNotBeFalse()) pushPathCondition(leftEqNull);\n        let leftEqUndefined = AbstractValue.createFromBinaryOp(realm, op, left, realm.intrinsics.undefined);\n        if (leftEqUndefined.mightNotBeFalse()) pushPathCondition(leftEqUndefined);\n        return;\n      }\n    }\n    let inverseCondition = AbstractValue.createFromUnaryOp(realm, \"!\", condition);\n    pushPathCondition(inverseCondition);\n    if (inverseCondition instanceof AbstractValue) {\n      let simplifiedInverseCondition = realm.simplifyAndRefineAbstractCondition(inverseCondition);\n      if (!simplifiedInverseCondition.equals(inverseCondition)) pushPathCondition(simplifiedInverseCondition);\n    }\n  }\n}\n\nfunction pushRefinedConditions(unrefinedConditions: Array<AbstractValue>) {\n  for (let unrefinedCond of unrefinedConditions) {\n    pushPathCondition(unrefinedCond.$Realm.simplifyAndRefineAbstractCondition(unrefinedCond));\n  }\n}\n"]}