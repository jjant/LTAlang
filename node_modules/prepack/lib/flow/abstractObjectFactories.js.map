{"version":3,"sources":["../../src/flow/abstractObjectFactories.js"],"names":["createObject","createArray","createAbstractObject","createAbstractByType","realm","shape","name","obj","intrinsics","ObjectPrototype","shapeThatIsNotNull","Object","keys","forEach","id","value","$Set","intrinsicName","ArrayPrototype","_createAbstractArray","createFromTemplate","template","makePartial","makeSimple","values","Set","rebuildNestedProperties","_createAbstractObject","objectTypes","propTypeObject","objTypes","key","propertyName","typeNameString","type","getTypeFromName","undefined"],"mappings":"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","file":"abstractObjectFactories.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { Realm } from \"../realm.js\";\nimport buildExpressionTemplate from \"../utils/builder.js\";\nimport { ObjectCreate, ArrayCreate } from \"../methods/index.js\";\nimport { ValuesDomain } from \"../domains/index.js\";\nimport { Value, AbstractValue, ObjectValue, ArrayValue, AbstractObjectValue } from \"../values/index.js\";\nimport invariant from \"../invariant.js\";\nimport { type ObjectTypeTemplate } from \"./utils.js\";\n\nexport function createObject(realm: Realm, shape: ObjectTypeTemplate | null, name: string | null): ObjectValue {\n  let obj = ObjectCreate(realm, realm.intrinsics.ObjectPrototype);\n  if (shape != null) {\n    // to get around Flow complaining that shape could be null\n    let shapeThatIsNotNull = shape;\n    Object.keys(shape).forEach((id: string) => {\n      let value = shapeThatIsNotNull[id];\n      invariant(value instanceof Value, \"creation of object failed due to object containing non-value properties\");\n      obj.$Set(id, value, obj);\n      if (name !== null) {\n        value.intrinsicName = `${name}.${id}`;\n      }\n    });\n  }\n  if (name !== null) {\n    obj.intrinsicName = name;\n  }\n  return obj;\n}\n\nexport function createArray(realm: Realm, name: string | null): ArrayValue {\n  let obj = ArrayCreate(realm, 0, realm.intrinsics.ArrayPrototype);\n  if (name !== null) {\n    obj.intrinsicName = name;\n  }\n  return ((obj: any): ArrayValue);\n}\n\nfunction _createAbstractArray(realm: Realm, name: string): AbstractValue {\n  let value = AbstractValue.createFromTemplate(realm, buildExpressionTemplate(name), ArrayValue, [], name);\n  value.intrinsicName = name;\n  let template = createArray(realm, name);\n  template.makePartial();\n  template.makeSimple();\n  value.values = new ValuesDomain(new Set([template]));\n  realm.rebuildNestedProperties(value, name);\n  return value;\n}\n\nfunction _createAbstractObject(\n  realm: Realm,\n  name: string | null,\n  objectTypes: ObjectTypeTemplate | null\n): AbstractObjectValue {\n  if (name === null) {\n    name = \"unknown\";\n  }\n  let value = AbstractValue.createFromTemplate(realm, buildExpressionTemplate(name), ObjectValue, [], name);\n  value.intrinsicName = name;\n  let template = createObject(realm, objectTypes, name);\n  template.makePartial();\n  template.makeSimple();\n  value.values = new ValuesDomain(new Set([template]));\n  realm.rebuildNestedProperties(value, name);\n  invariant(value instanceof AbstractObjectValue);\n  return value;\n}\n\nexport function createAbstractObject(\n  realm: Realm,\n  name: string | null,\n  objectTypes: ObjectTypeTemplate | null | string\n): AbstractObjectValue {\n  if (typeof objectTypes === \"string\") {\n    invariant(\n      objectTypes === \"empty\" || objectTypes === \"object\",\n      `Expected an object or a string of \"empty\" or \"object\" for createAbstractObject() paramater \"objectTypes\"`\n    );\n    return _createAbstractObject(realm, name, null);\n  }\n  if (objectTypes !== null) {\n    let propTypeObject = {};\n    let objTypes = objectTypes;\n    invariant(objTypes);\n    Object.keys(objTypes).forEach(key => {\n      let value = objTypes[key];\n      let propertyName = name !== null ? `${name}.${key}` : key;\n      if (typeof value === \"string\") {\n        if (value === \"array\") {\n          propTypeObject[key] = _createAbstractArray(realm, propertyName);\n        } else if (value === \"object\") {\n          propTypeObject[key] = _createAbstractObject(realm, propertyName, null);\n        } else {\n          propTypeObject[key] = createAbstractByType(realm, value, propertyName);\n        }\n      } else if (typeof value === \"object\" && value !== null) {\n        propTypeObject[key] = createAbstractObject(realm, propertyName, value);\n      } else {\n        invariant(false, `Unknown propType value of \"${value}\" for \"${key}\"`);\n      }\n    });\n\n    return _createAbstractObject(realm, name, propTypeObject);\n  } else {\n    return _createAbstractObject(realm, name, null);\n  }\n}\n\nexport function createAbstractByType(realm: Realm, typeNameString: string, name: string): Value {\n  let type = Value.getTypeFromName(typeNameString);\n  invariant(type !== undefined, \"createAbstractByType() cannot be undefined\");\n  let value = AbstractValue.createFromTemplate(realm, buildExpressionTemplate(name), type, [], name);\n  value.intrinsicName = name;\n  return value;\n}\n"]}