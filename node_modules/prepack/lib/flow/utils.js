"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.flowAnnotationToObjectTypeTemplate = flowAnnotationToObjectTypeTemplate;
exports.stripFlowTypeAnnotations = stripFlowTypeAnnotations;

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _babelTraverse = require("babel-traverse");

var _babelTraverse2 = _interopRequireDefault(_babelTraverse);

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function flowAnnotationToObjectTypeTemplate(annotation) {
  if (annotation.type === "TypeAnnotation") {
    return flowAnnotationToObjectTypeTemplate(annotation.typeAnnotation);
  } else if (annotation.type === "GenericTypeAnnotation") {
    if (annotation.id.type === "Identifier") {
      var identifier = annotation.id.name;

      switch (identifier) {
        case "Function":
          return "function";
        case "Object":
          return "object";
        case "Array":
          return "array";
        case "any":
        case "empty":
          return "empty";
        default:
          // get the Flow type
          (0, _invariant2.default)(false, "Flow types are currently not supported");
      }
    } else {
      (0, _invariant2.default)(false, "unknown generic Flow type annotation node");
    }
  } else if (annotation.type === "EmptyTypeAnnotation") {
    return "empty";
  } else if (annotation.type === "BooleanTypeAnnotation") {
    return "boolean";
  } else if (annotation.type === "StringTypeAnnotation") {
    return "string";
  } else if (annotation.type === "NumberTypeAnnotation") {
    return "number";
  } else if (annotation.type === "FunctionTypeAnnotation") {
    return "function";
  } else if (annotation.type === "ArrayTypeAnnotation") {
    return "array";
  } else if (annotation.type === "ObjectTypeAnnotation") {
    var obj = {};
    annotation.properties.forEach(function (property) {
      if (property.type === "ObjectTypeProperty") {
        if (property.key.type === "Identifier") {
          obj[property.key.name] = flowAnnotationToObjectTypeTemplate(property.value);
        } else {
          (0, _invariant2.default)(false, "only Identifier nodes are supported in ObjectTypeProperty keys");
        }
      } else {
        (0, _invariant2.default)(false, "only ObjectTypeProperty properties are supported in ObjectTypeAnnotation");
      }
    });
    return obj;
  } else if (annotation.type === "AnyTypeAnnotation") {
    return "empty";
  } else {
    (0, _invariant2.default)(false, "unknown Flow type annotation node");
  }
}

// Taken directly from Babel:
// https://github.com/babel/babel/blob/cde005422701a69ff21044c138c29a5ad23b6d0a/packages/babel-plugin-transform-flow-strip-types/src/index.js#L32-L107
// Copyright 2015-present Sebastian McKenzie / Babel project (https://github.com/babel)
// only the lines reflected in the above were used
/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

function stripFlowTypeAnnotations(ast) {
  (0, _babelTraverse2.default)(ast, {
    ImportDeclaration: function ImportDeclaration(path) {
      if (!path.node.specifiers.length) return;
      var typeCount = 0;
      path.node.specifiers.forEach(function (_ref) {
        var importKind = _ref.importKind;

        if (importKind === "type" || importKind === "typeof") {
          typeCount++;
        }
      });
      if (typeCount === path.node.specifiers.length) {
        path.remove();
      }
    },
    Flow: function Flow(path) {
      path.remove();
    },
    ClassProperty: function ClassProperty(path) {
      path.node.variance = null;
      path.node.typeAnnotation = null;
      if (!path.node.value) path.remove();
    },
    Class: function Class(path) {
      path.node.implements = null;
      path.get("body.body").forEach(function (child) {
        if (child.isClassProperty()) {
          child.node.typeAnnotation = null;
          if (!child.node.value) child.remove();
        }
      });
    },
    AssignmentPattern: function AssignmentPattern(_ref2) {
      var node = _ref2.node;

      node.left.optional = false;
    },
    Function: function Function(_ref3) {
      var node = _ref3.node;

      for (var i = 0; i < node.params.length; i++) {
        var param = node.params[i];
        param.optional = false;
        if (param.type === "AssignmentPattern") {
          param.left.optional = false;
        }
      }
      node.predicate = null;
    },
    TypeCastExpression: function TypeCastExpression(path) {
      var node = path.node;

      do {
        node = node.expression;
      } while (t.isTypeCastExpression(node));
      path.replaceWith(node);
    }
  }, undefined, undefined, undefined);
}
//# sourceMappingURL=utils.js.map