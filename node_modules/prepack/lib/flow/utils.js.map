{"version":3,"sources":["../../src/flow/utils.js"],"names":["flowAnnotationToObjectTypeTemplate","stripFlowTypeAnnotations","t","annotation","type","typeAnnotation","id","identifier","name","obj","properties","forEach","property","key","value","ast","ImportDeclaration","path","node","specifiers","length","typeCount","importKind","remove","Flow","ClassProperty","variance","Class","implements","get","child","isClassProperty","AssignmentPattern","left","optional","Function","i","params","param","predicate","TypeCastExpression","expression","isTypeCastExpression","replaceWith","undefined"],"mappings":"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","file":"utils.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { typeAnnotation } from \"babel-types\";\nimport invariant from \"../invariant.js\";\nimport traverse from \"babel-traverse\";\nimport { BabelNode } from \"babel-types\";\nimport * as t from \"babel-types\";\n\nexport type ObjectTypeTemplate = {\n  [key: string]: string | ObjectTypeTemplate,\n};\n\nexport function flowAnnotationToObjectTypeTemplate(annotation: typeAnnotation): string | ObjectTypeTemplate {\n  if (annotation.type === \"TypeAnnotation\") {\n    return flowAnnotationToObjectTypeTemplate(annotation.typeAnnotation);\n  } else if (annotation.type === \"GenericTypeAnnotation\") {\n    if (annotation.id.type === \"Identifier\") {\n      let identifier = annotation.id.name;\n\n      switch (identifier) {\n        case \"Function\":\n          return \"function\";\n        case \"Object\":\n          return \"object\";\n        case \"Array\":\n          return \"array\";\n        case \"any\":\n        case \"empty\":\n          return \"empty\";\n        default:\n          // get the Flow type\n          invariant(false, \"Flow types are currently not supported\");\n      }\n    } else {\n      invariant(false, \"unknown generic Flow type annotation node\");\n    }\n  } else if (annotation.type === \"EmptyTypeAnnotation\") {\n    return \"empty\";\n  } else if (annotation.type === \"BooleanTypeAnnotation\") {\n    return \"boolean\";\n  } else if (annotation.type === \"StringTypeAnnotation\") {\n    return \"string\";\n  } else if (annotation.type === \"NumberTypeAnnotation\") {\n    return \"number\";\n  } else if (annotation.type === \"FunctionTypeAnnotation\") {\n    return \"function\";\n  } else if (annotation.type === \"ArrayTypeAnnotation\") {\n    return \"array\";\n  } else if (annotation.type === \"ObjectTypeAnnotation\") {\n    let obj = {};\n    annotation.properties.forEach(property => {\n      if (property.type === \"ObjectTypeProperty\") {\n        if (property.key.type === \"Identifier\") {\n          obj[property.key.name] = flowAnnotationToObjectTypeTemplate(property.value);\n        } else {\n          invariant(false, \"only Identifier nodes are supported in ObjectTypeProperty keys\");\n        }\n      } else {\n        invariant(false, \"only ObjectTypeProperty properties are supported in ObjectTypeAnnotation\");\n      }\n    });\n    return obj;\n  } else if (annotation.type === \"AnyTypeAnnotation\") {\n    return \"empty\";\n  } else {\n    invariant(false, \"unknown Flow type annotation node\");\n  }\n}\n\n// Taken directly from Babel:\n// https://github.com/babel/babel/blob/cde005422701a69ff21044c138c29a5ad23b6d0a/packages/babel-plugin-transform-flow-strip-types/src/index.js#L32-L107\n// Copyright 2015-present Sebastian McKenzie / Babel project (https://github.com/babel)\n// only the lines reflected in the above were used\nexport function stripFlowTypeAnnotations(ast: BabelNode): void {\n  traverse(\n    ast,\n    {\n      ImportDeclaration(path) {\n        if (!path.node.specifiers.length) return;\n        let typeCount = 0;\n        path.node.specifiers.forEach(({ importKind }) => {\n          if (importKind === \"type\" || importKind === \"typeof\") {\n            typeCount++;\n          }\n        });\n        if (typeCount === path.node.specifiers.length) {\n          path.remove();\n        }\n      },\n      Flow(path) {\n        path.remove();\n      },\n      ClassProperty(path) {\n        path.node.variance = null;\n        path.node.typeAnnotation = null;\n        if (!path.node.value) path.remove();\n      },\n      Class(path) {\n        path.node.implements = null;\n        path.get(\"body.body\").forEach(child => {\n          if (child.isClassProperty()) {\n            child.node.typeAnnotation = null;\n            if (!child.node.value) child.remove();\n          }\n        });\n      },\n      AssignmentPattern({ node }) {\n        node.left.optional = false;\n      },\n      Function({ node }) {\n        for (let i = 0; i < node.params.length; i++) {\n          const param = node.params[i];\n          param.optional = false;\n          if (param.type === \"AssignmentPattern\") {\n            param.left.optional = false;\n          }\n        }\n        node.predicate = null;\n      },\n      TypeCastExpression(path) {\n        let { node } = path;\n        do {\n          node = node.expression;\n        } while (t.isTypeCastExpression(node));\n        path.replaceWith(node);\n      },\n    },\n    undefined,\n    (undefined: any),\n    undefined\n  );\n}\n"]}