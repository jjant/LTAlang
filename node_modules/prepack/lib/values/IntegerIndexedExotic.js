"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _index = require("../values/index.js");

var _to = require("../methods/to.js");

var _is = require("../methods/is.js");

var _get = require("../methods/get.js");

var _has = require("../methods/has.js");

var _typedarray = require("../methods/typedarray.js");

var _singletons = require("../singletons.js");

var _invariant = require("../invariant");

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright (c) 2017-present, Facebook, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * This source code is licensed under the BSD-style license found in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * LICENSE file in the root directory of this source tree. An additional grant
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * of patent rights can be found in the PATENTS file in the same directory.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var IntegerIndexedExotic = function (_ObjectValue) {
  _inherits(IntegerIndexedExotic, _ObjectValue);

  function IntegerIndexedExotic(realm, intrinsicName) {
    _classCallCheck(this, IntegerIndexedExotic);

    return _possibleConstructorReturn(this, (IntegerIndexedExotic.__proto__ || Object.getPrototypeOf(IntegerIndexedExotic)).call(this, realm, realm.intrinsics.ObjectPrototype, intrinsicName));
  }

  // ECMA262 9.4.5.1


  _createClass(IntegerIndexedExotic, [{
    key: "$GetOwnProperty",
    value: function $GetOwnProperty(P) {
      var O = this;

      // 1. Assert: IsPropertyKey(P) is true.
      (0, _invariant2.default)((0, _is.IsPropertyKey)(this.$Realm, P), "IsPropertyKey(P) is true");

      // 2. Assert: O is an Object that has a [[ViewedArrayBuffer]] internal slot.
      (0, _invariant2.default)(O instanceof _index.ObjectValue && O.$ViewedArrayBuffer);

      // 3. If Type(P) is String, then
      if (typeof P === "string" || P instanceof _index.StringValue) {
        // a. Let numericIndex be ! CanonicalNumericIndexString(P).
        var numericIndex = (0, _to.CanonicalNumericIndexString)(this.$Realm, typeof P === "string" ? new _index.StringValue(this.$Realm, P) : P);

        // b. If numericIndex is not undefined, then
        if (numericIndex !== undefined) {
          // i. Let value be ? IntegerIndexedElementGet(O, numericIndex).
          var value = (0, _typedarray.IntegerIndexedElementGet)(this.$Realm, O, numericIndex);

          // ii. If value is undefined, return undefined.
          if (value instanceof _index.UndefinedValue) return undefined;

          // iii. Return a PropertyDescriptor{[[Value]]: value, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: false}.
          return {
            value: value,
            writable: true,
            enumerable: true,
            configurable: false
          };
        }
      }
      // 4. Return OrdinaryGetOwnProperty(O, P).
      return _singletons.Properties.OrdinaryGetOwnProperty(this.$Realm, O, P);
    }

    // ECMA262 9.4.5.2

  }, {
    key: "$HasProperty",
    value: function $HasProperty(P) {
      var O = this;

      // 1. Assert: IsPropertyKey(P) is true.
      (0, _invariant2.default)((0, _is.IsPropertyKey)(this.$Realm, P), "IsPropertyKey(P) is true");

      // 2. Assert: O is an Object that has a [[ViewedArrayBuffer]] internal slot.
      (0, _invariant2.default)(O instanceof _index.ObjectValue && O.$ViewedArrayBuffer);

      // 3. If Type(P) is String, then
      if (typeof P === "string" || P instanceof _index.StringValue) {
        // a. Let numericIndex be ! CanonicalNumericIndexString(P).
        var numericIndex = (0, _to.CanonicalNumericIndexString)(this.$Realm, typeof P === "string" ? new _index.StringValue(this.$Realm, P) : P);

        // b. If numericIndex is not undefined, then
        if (numericIndex !== undefined) {
          // i. Let buffer be O.[[ViewedArrayBuffer]].
          var buffer = O.$ViewedArrayBuffer;
          (0, _invariant2.default)(buffer);

          // ii. If IsDetachedBuffer(buffer) is true, throw a TypeError exception.
          if ((0, _is.IsDetachedBuffer)(this.$Realm, buffer) === true) {
            throw this.$Realm.createErrorThrowCompletion(this.$Realm.intrinsics.TypeError, "IsDetachedBuffer(buffer) is true");
          }

          // iii. If IsInteger(numericIndex) is false, return false.
          if ((0, _is.IsInteger)(this.$Realm, numericIndex) === false) return false;

          // iv. If numericIndex = -0, return false.
          if (Object.is(numericIndex, -0)) return false;

          // v. If numericIndex < 0, return false.
          if (numericIndex < 0) return false;

          // vi. If numericIndex ≥ O.[[ArrayLength]], return false.
          (0, _invariant2.default)(O.$ArrayLength);
          if (numericIndex >= O.$ArrayLength) return false;

          // vii. Return true.
          return true;
        }
      }

      // 4. Return ? OrdinaryHasProperty(O, P).
      return (0, _has.OrdinaryHasProperty)(this.$Realm, O, P);
    }

    // ECMA262 9.4.5.3

  }, {
    key: "$DefineOwnProperty",
    value: function $DefineOwnProperty(P, Desc) {
      var O = this;

      // 1. Assert: IsPropertyKey(P) is true.
      (0, _invariant2.default)((0, _is.IsPropertyKey)(this.$Realm, P), "IsPropertyKey(P) is true");

      // 2. Assert: O is an Object that has a [[ViewedArrayBuffer]] internal slot.
      (0, _invariant2.default)(O instanceof _index.ObjectValue && this.$ViewedArrayBuffer);

      // 3. If Type(P) is String, then
      if (typeof P === "string" || P instanceof _index.StringValue) {
        // a. Let numericIndex be ! CanonicalNumericIndexString(P).
        var numericIndex = (0, _to.CanonicalNumericIndexString)(this.$Realm, typeof P === "string" ? new _index.StringValue(this.$Realm, P) : P);

        // b. If numericIndex is not undefined, then
        if (numericIndex !== undefined) {
          // i. If IsInteger(numericIndex) is false, return false.
          if ((0, _is.IsInteger)(this.$Realm, numericIndex) === false) return false;

          // ii. If numericIndex = -0, return false.
          if (Object.is(numericIndex, -0)) return false;

          // iii. If numericIndex < 0, return false.
          if (numericIndex < 0) return false;

          // iv. Let length be O.[[ArrayLength]].
          var length = this.$ArrayLength;
          (0, _invariant2.default)(typeof length === "number");

          // v. If numericIndex ≥ length, return false.
          if (numericIndex >= length) return false;

          // vi. If IsAccessorDescriptor(Desc) is true, return false.
          if ((0, _is.IsAccessorDescriptor)(this.$Realm, Desc) === true) return false;

          // vii. If Desc has a [[Configurable]] field and if Desc.[[Configurable]] is true, return false.
          if (Desc.configurable === true) return false;

          // viii. If Desc has an [[Enumerable]] field and if Desc.[[Enumerable]] is false, return false.
          if (Desc.enumerable === false) return false;

          // ix. If Desc has a [[Writable]] field and if Desc.[[Writable]] is false, return false.
          if (Desc.writable === false) return false;

          // x. If Desc has a [[Value]] field, then
          if (Desc.value) {
            // 1. Let value be Desc.[[Value]].
            var value = Desc.value;
            (0, _invariant2.default)(value === undefined || value instanceof _index.Value);

            // 2. Return ? IntegerIndexedElementSet(O, numericIndex, value).
            return (0, _typedarray.IntegerIndexedElementSet)(this.$Realm, O, numericIndex, value);
          }

          // xi. Return true.
          return true;
        }
      }

      // 4. Return ! OrdinaryDefineOwnProperty(O, P, Desc).
      return _singletons.Properties.OrdinaryDefineOwnProperty(this.$Realm, O, P, Desc);
    }

    // ECMA262 9.4.5.4

  }, {
    key: "$Get",
    value: function $Get(P, Receiver) {
      var O = this;

      // 1. Assert: IsPropertyKey(P) is true.
      (0, _invariant2.default)((0, _is.IsPropertyKey)(this.$Realm, P), "IsPropertyKey(P) is true");

      // 2. If Type(P) is String, then
      if (typeof P === "string" || P instanceof _index.StringValue) {
        // a. Let numericIndex be ! CanonicalNumericIndexString(P).
        var numericIndex = (0, _to.CanonicalNumericIndexString)(this.$Realm, typeof P === "string" ? new _index.StringValue(this.$Realm, P) : P);

        // b. If numericIndex is not undefined, then
        if (numericIndex !== undefined) {
          // i. Return ? IntegerIndexedElementGet(O, numericIndex).
          return (0, _typedarray.IntegerIndexedElementGet)(this.$Realm, O, numericIndex);
        }
      }

      // 3. Return ? OrdinaryGet(O, P, Receiver).
      return (0, _get.OrdinaryGet)(this.$Realm, O, P, Receiver);
    }

    // ECMA262 9.4.5.5

  }, {
    key: "$Set",
    value: function $Set(P, V, Receiver) {
      var O = this;

      // 1. Assert: IsPropertyKey(P) is true.
      (0, _invariant2.default)((0, _is.IsPropertyKey)(this.$Realm, P), "IsPropertyKey(P) is true");

      // 2. If Type(P) is String, then
      if (typeof P === "string" || P instanceof _index.StringValue) {
        // a. Let numericIndex be ! CanonicalNumericIndexString(P).
        var numericIndex = (0, _to.CanonicalNumericIndexString)(this.$Realm, typeof P === "string" ? new _index.StringValue(this.$Realm, P) : P);

        // b. If numericIndex is not undefined, then
        if (numericIndex !== undefined) {
          // i. Return ? IntegerIndexedElementSet(O, numericIndex, V).
          return (0, _typedarray.IntegerIndexedElementSet)(this.$Realm, O, numericIndex, V);
        }
      }

      // 3. Return ? OrdinarySet(O, P, V, Receiver).
      return _singletons.Properties.OrdinarySet(this.$Realm, O, P, V, Receiver);
    }

    // ECMA262 9.4.5.6

  }, {
    key: "$OwnPropertyKeys",
    value: function $OwnPropertyKeys() {
      var _this2 = this;

      var O = this;

      // 1. Let keys be a new empty List.
      var keys = [];

      // 2. Assert: O is an Object that has [[ViewedArrayBuffer]], [[ArrayLength]], [[ByteOffset]], and [[TypedArrayName]] internal slots.
      (0, _invariant2.default)(O instanceof _index.ObjectValue && O.$ViewedArrayBuffer && O.$ArrayLength !== undefined && O.$ByteOffset !== undefined && O.$TypedArrayName);

      // 3. Let len be O.[[ArrayLength]].
      var len = O.$ArrayLength;
      (0, _invariant2.default)(typeof len === "number");

      // 4. For each integer i starting with 0 such that i < len, in ascending order,
      for (var i = 0; i < len; ++i) {
        // a. Add ! ToString(i) as the last element of keys.
        keys.push(new _index.StringValue(this.$Realm, (0, _to.ToString)(this.$Realm, new _index.NumberValue(this.$Realm, i))));
      }

      // 5. For each own property key P of O such that Type(P) is String and P is not an integer index, in ascending chronological order of property creation
      var properties = O.getOwnPropertyKeysArray();
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = properties.filter(function (x) {
          return !(0, _is.IsArrayIndex)(_this2.$Realm, x);
        })[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var key = _step.value;

          // i. Add P as the last element of keys.
          keys.push(new _index.StringValue(this.$Realm, key));
        }

        // 6. For each own property key P of O such that Type(P) is Symbol, in ascending chronological order of property creation
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = O.symbols.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _key = _step2.value;

          // a. Add P as the last element of keys.
          keys.push(_key);
        }

        // 7. Return keys.
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return keys;
    }
  }]);

  return IntegerIndexedExotic;
}(_index.ObjectValue);

exports.default = IntegerIndexedExotic;
//# sourceMappingURL=IntegerIndexedExotic.js.map