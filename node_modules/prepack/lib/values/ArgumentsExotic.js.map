{"version":3,"sources":["../../src/values/ArgumentsExotic.js"],"names":["ArgumentsExotic","realm","intrinsicName","intrinsics","ObjectPrototype","P","args","desc","OrdinaryGetOwnProperty","$Realm","undefined","ThrowIfMightHaveBeenDeleted","value","map","$ParameterMap","isMapped","Desc","newArgDesc","writable","Object","assign","allowed","OrdinaryDefineOwnProperty","$Delete","setStatus","Set","Receiver","V","OrdinarySet","result","OrdinaryDelete"],"mappings":"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","file":"ArgumentsExotic.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { PropertyKeyValue, Descriptor } from \"../types.js\";\nimport { ObjectValue, Value } from \"../values/index.js\";\nimport { IsDataDescriptor, IsAccessorDescriptor } from \"../methods/is.js\";\nimport { HasOwnProperty } from \"../methods/has.js\";\nimport { SameValuePartial } from \"../methods/abstract.js\";\nimport { Get, OrdinaryGet } from \"../methods/get.js\";\nimport { Properties } from \"../singletons.js\";\nimport invariant from \"../invariant\";\n\nexport default class ArgumentsExotic extends ObjectValue {\n  constructor(realm: Realm, intrinsicName?: string) {\n    super(realm, realm.intrinsics.ObjectPrototype, intrinsicName);\n  }\n\n  $ParameterMap: void | ObjectValue;\n\n  // ECMA262 9.4.4.1\n  $GetOwnProperty(P: PropertyKeyValue): Descriptor | void {\n    // 1. Let args be the arguments object.\n    let args = this;\n\n    // 2. Let desc be OrdinaryGetOwnProperty(args, P).\n    let desc = Properties.OrdinaryGetOwnProperty(this.$Realm, args, P);\n\n    // 3. If desc is undefined, return desc.\n    if (desc === undefined) return undefined;\n    Properties.ThrowIfMightHaveBeenDeleted(desc.value);\n\n    // 4. Let map be args.[[ParameterMap]].\n    let map = args.$ParameterMap;\n    invariant(map);\n\n    // 5. Let isMapped be ! HasOwnProperty(map, P).\n    let isMapped = HasOwnProperty(this.$Realm, map, P);\n\n    // 6. If isMapped is true, then\n    if (isMapped === true) {\n      // a. Set desc.[[Value]] to Get(map, P).\n      desc.value = Get(this.$Realm, map, P);\n    }\n\n    // 7. Return desc.\n    return desc;\n  }\n\n  // ECMA262 9.4.4.2\n  $DefineOwnProperty(P: PropertyKeyValue, Desc: Descriptor) {\n    // 1. Let args be the arguments object.\n    let args = this;\n\n    // 2. Let map be args.[[ParameterMap]].\n    let map = args.$ParameterMap;\n    invariant(map);\n\n    // 3. Let isMapped be HasOwnProperty(map, P).\n    let isMapped = HasOwnProperty(this.$Realm, map, P);\n\n    // 4. Let newArgDesc be Desc.\n    let newArgDesc = Desc;\n\n    // 5. If isMapped is true and IsDataDescriptor(Desc) is true, then\n    if (isMapped === true && IsDataDescriptor(this.$Realm, Desc) === true) {\n      // a. If Desc.[[Value]] is not present and Desc.[[Writable]] is present and its value is false, then\n      if (Desc.value === undefined && Desc.writable === false) {\n        // i. Let newArgDesc be a copy of Desc.\n        newArgDesc = Object.assign({}, Desc);\n\n        // ii. Set newArgDesc.[[Value]] to Get(map, P).\n        newArgDesc.value = Get(this.$Realm, map, P);\n      }\n    }\n\n    // 6. Let allowed be ? OrdinaryDefineOwnProperty(args, P, newArgDesc).\n    let allowed = Properties.OrdinaryDefineOwnProperty(this.$Realm, args, P, newArgDesc);\n\n    // 7. If allowed is false, return false.\n    if (allowed === false) return false;\n\n    // 8. If isMapped is true, then\n    if (isMapped === true) {\n      // a. If IsAccessorDescriptor(Desc) is true, then\n      if (IsAccessorDescriptor(this.$Realm, Desc) === true) {\n        // i. Call map.[[Delete]](P).\n        map.$Delete(P);\n      } else {\n        // b. Else,\n        // i. If Desc.[[Value]] is present, then\n        if (Desc.value !== undefined) {\n          // 1. Let setStatus be Set(map, P, Desc.[[Value]], false).\n          invariant(Desc.value instanceof Value);\n          let setStatus = Properties.Set(this.$Realm, map, P, Desc.value, false);\n\n          // 2. Assert: setStatus is true because formal parameters mapped by argument objects are always writable.\n          invariant(setStatus === true);\n        }\n\n        // ii. If Desc.[[Writable]] is present and its value is false, then\n        if (Desc.writable === false) {\n          // 1. Call map.[[Delete]](P).\n          map.$Delete(P);\n        }\n      }\n    }\n\n    // 9. Return true.\n    return true;\n  }\n\n  // ECMA262 9.4.4.3\n  $Get(P: PropertyKeyValue, Receiver: Value): Value {\n    // 1. Let args be the arguments object.\n    let args = this;\n\n    // 2. Let map be args.[[ParameterMap]].\n    let map = args.$ParameterMap;\n    invariant(map);\n\n    // 3. Let isMapped be ! HasOwnProperty(map, P).\n    let isMapped = HasOwnProperty(this.$Realm, map, P);\n\n    // 4. If isMapped is false, then\n    if (isMapped === false) {\n      // a. Return ? OrdinaryGet(args, P, Receiver).\n      return OrdinaryGet(this.$Realm, args, P, Receiver);\n    } else {\n      // 5. Else map contains a formal parameter mapping for P,\n      // b. Return Get(map, P).\n      return Get(this.$Realm, map, P);\n    }\n  }\n\n  // ECMA262 9.4.4.4\n  $Set(P: PropertyKeyValue, V: Value, Receiver: Value): boolean {\n    // 1. Let args be the arguments object.\n    let args = this;\n\n    let isMapped, map;\n    // 2. If SameValue(args, Receiver) is false, then\n    if (SameValuePartial(this.$Realm, args, Receiver) === false) {\n      // a. Let isMapped be false.\n      isMapped = false;\n    } else {\n      // 3. Else,\n      // a. Let map be args.[[ParameterMap]].\n      map = args.$ParameterMap;\n      invariant(map);\n\n      // b. Let isMapped be ! HasOwnProperty(map, P).\n      isMapped = HasOwnProperty(this.$Realm, map, P);\n    }\n\n    // 4. If isMapped is true, then\n    if (isMapped === true) {\n      invariant(map);\n      // a. Let setStatus be Set(map, P, V, false).\n      let setStatus = Properties.Set(this.$Realm, map, P, V, false);\n\n      // b. Assert: setStatus is true because formal parameters mapped by argument objects are always writable.\n      invariant(setStatus === true);\n    }\n\n    // 5. Return ? OrdinarySet(args, P, V, Receiver).\n    return Properties.OrdinarySet(this.$Realm, args, P, V, Receiver);\n  }\n\n  // ECMA262 9.4.4.5\n  $Delete(P: PropertyKeyValue): boolean {\n    // 1. Let args be the arguments object.\n    let args = this;\n\n    // 2. Let map be args.[[ParameterMap]].\n    let map = args.$ParameterMap;\n    invariant(map);\n\n    // 3. Let isMapped be ! HasOwnProperty(map, P).\n    let isMapped = HasOwnProperty(this.$Realm, map, P);\n\n    // 4. Let result be ? OrdinaryDelete(args, P).\n    let result = Properties.OrdinaryDelete(this.$Realm, args, P);\n\n    // 5. If result is true and isMapped is true, then\n    if (result === true && isMapped === true) {\n      // a. Call map.[[Delete]](P).\n      map.$Delete(P);\n    }\n\n    // 6. Return result.\n    return result;\n  }\n}\n"]}