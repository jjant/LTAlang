"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _realm = require("../realm.js");

var _index = require("./index.js");

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _to = require("../methods/to.js");

var _abstract = require("../methods/abstract.js");

var _get = require("../methods/get.js");

var _create = require("../methods/create.js");

var _is = require("../methods/is.js");

var _singletons = require("../singletons.js");

var _call = require("../methods/call.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright (c) 2017-present, Facebook, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * This source code is licensed under the BSD-style license found in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * LICENSE file in the root directory of this source tree. An additional grant
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * of patent rights can be found in the PATENTS file in the same directory.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

function FindPropertyKey(realm, keys, key) {
  for (var i = 0; i < keys.length; ++i) {
    if ((0, _abstract.SamePropertyKey)(realm, key, keys[i])) {
      return i;
    }
  }
  return -1;
}

var ProxyValue = function (_ObjectValue) {
  _inherits(ProxyValue, _ObjectValue);

  function ProxyValue(realm) {
    _classCallCheck(this, ProxyValue);

    // $FlowFixMe TODO #1022: exotics should not have $Realm
    var _this = _possibleConstructorReturn(this, (ProxyValue.__proto__ || Object.getPrototypeOf(ProxyValue)).call(this, realm));

    _this.$Realm = undefined;
    _this.realm = realm;
    return _this;
  }

  _createClass(ProxyValue, [{
    key: "getTrackedBindings",
    value: function getTrackedBindings() {
      return ProxyValue.trackedPropertyNames;
    }
  }, {
    key: "isSimpleObject",
    value: function isSimpleObject() {
      return false;
    }

    // ECMA262 9.5.1

  }, {
    key: "$GetPrototypeOf",
    value: function $GetPrototypeOf() {
      var realm = this.realm;

      // 1. Let handler be the value of the [[ProxyHandler]] internal slot of O.
      var handler = this.$ProxyHandler;

      // 2. If handler is null, throw a TypeError exception.
      if (handler instanceof _index.NullValue) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
      }

      // 3. Assert: Type(handler) is Object.
      (0, _invariant2.default)(handler instanceof _index.ObjectValue, "expected an object");

      // 4. Let target be the value of the [[ProxyTarget]] internal slot of O.
      var target = this.$ProxyTarget;
      (0, _invariant2.default)(target instanceof _index.ObjectValue);

      // 5. Let trap be ? GetMethod(handler, "getPrototypeOf").
      var trap = (0, _get.GetMethod)(realm, handler, "getPrototypeOf");

      // 6. If trap is undefined, then
      if (trap instanceof _index.UndefinedValue) {
        // a. Return ? target.[[GetPrototypeOf]]().
        return target.$GetPrototypeOf();
      }

      // 7. Let handlerProto be ? Call(trap, handler, « target »).
      var handlerProto = (0, _call.Call)(realm, trap, handler, [target]);

      // 8. If Type(handlerProto) is neither Object nor Null, throw a TypeError exception.
      if (!(handlerProto instanceof _index.ObjectValue) && !(handlerProto instanceof _index.NullValue)) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
      }

      // 9. Let extensibleTarget be ? IsExtensible(target).
      var extensibleTarget = (0, _is.IsExtensible)(realm, target);

      // 10. If extensibleTarget is true, return handlerProto.
      if (extensibleTarget) return handlerProto;

      // 11. Let targetProto be ? target.[[GetPrototypeOf]]().
      var targetProto = target.$GetPrototypeOf();

      // 12. If SameValue(handlerProto, targetProto) is false, throw a TypeError exception.
      if (!(0, _abstract.SameValue)(realm, handlerProto, targetProto)) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
      }

      // 13. Return handlerProto.
      return handlerProto;
    }

    // ECMA262 9.5.2

  }, {
    key: "$SetPrototypeOf",
    value: function $SetPrototypeOf(V) {
      var realm = this.realm;

      // 1. Assert: Either Type(V) is Object or Type(V) is Null.
      (0, _invariant2.default)(V instanceof _index.ObjectValue || V instanceof _index.NullValue, "expected object or null");

      // 2. Let handler be the value of the [[ProxyHandler]] internal slot of O.
      var handler = this.$ProxyHandler;

      // 3. If handler is null, throw a TypeError exception.
      if (handler instanceof _index.NullValue) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
      }

      // 4. Assert: Type(handler) is Object.
      (0, _invariant2.default)(handler instanceof _index.ObjectValue, "expected object");

      // 5. Let target be the value of the [[ProxyTarget]] internal slot of O.
      var target = this.$ProxyTarget;
      (0, _invariant2.default)(target instanceof _index.ObjectValue);

      // 6. Let trap be ? GetMethod(handler, "setPrototypeOf").
      var trap = (0, _get.GetMethod)(realm, handler, "setPrototypeOf");

      // 7. If trap is undefined, then
      if (trap instanceof _index.UndefinedValue) {
        // a. Return ? target.[[SetPrototypeOf]](V).
        return target.$SetPrototypeOf(V);
      }

      // 8. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target, V »)).
      var booleanTrapResult = (0, _to.ToBooleanPartial)(realm, (0, _call.Call)(realm, trap, handler, [target, V]));

      // 9. If booleanTrapResult is false, return false.
      if (!booleanTrapResult) return false;

      // 10. Let extensibleTarget be ? IsExtensible(target).
      var extensibleTarget = (0, _is.IsExtensible)(realm, target);

      // 11. If extensibleTarget is true, return true.
      if (extensibleTarget) return true;

      // 12. Let targetProto be ? target.[[GetPrototypeOf]]().
      var targetProto = target.$GetPrototypeOf();

      // 13. If SameValue(V, targetProto) is false, throw a TypeError exception.
      if (!(0, _abstract.SameValue)(realm, V, targetProto)) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
      }

      // 14. Return true.
      return true;
    }

    // ECMA262 9.5.3

  }, {
    key: "$IsExtensible",
    value: function $IsExtensible() {
      var realm = this.realm;

      // 1. Let handler be the value of the [[ProxyHandler]] internal slot of O.
      var handler = this.$ProxyHandler;

      // 2. If handler is null, throw a TypeError exception.
      if (handler instanceof _index.NullValue) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
      }

      // 3. Assert: Type(handler) is Object.
      (0, _invariant2.default)(handler instanceof _index.ObjectValue, "expected object");

      // 4. Let target be the value of the [[ProxyTarget]] internal slot of O.
      var target = this.$ProxyTarget;

      // 5. Let trap be ? GetMethod(handler, "isExtensible").
      var trap = (0, _get.GetMethod)(realm, handler, "isExtensible");

      // 6. If trap is undefined, then
      if (trap instanceof _index.UndefinedValue) {
        // a. Return ? target.[[IsExtensible]]().
        (0, _invariant2.default)(target instanceof _index.ObjectValue);
        return target.$IsExtensible();
      }

      // 7. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target »)).
      var booleanTrapResult = (0, _to.ToBooleanPartial)(realm, (0, _call.Call)(realm, trap, handler, [target]));

      // 8. Let targetResult be ? target.[[IsExtensible]]().
      (0, _invariant2.default)(target instanceof _index.ObjectValue);
      var targetResult = target.$IsExtensible();

      // 9. If SameValue(booleanTrapResult, targetResult) is false, throw a TypeError exception.
      if (booleanTrapResult !== targetResult) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
      }

      // 10. Return booleanTrapResult.
      return booleanTrapResult;
    }

    // ECMA262 9.5.4

  }, {
    key: "$PreventExtensions",
    value: function $PreventExtensions() {
      var realm = this.realm;

      // 1. Let handler be the value of the [[ProxyHandler]] internal slot of O.
      var handler = this.$ProxyHandler;

      // 2. If handler is null, throw a TypeError exception.
      if (handler instanceof _index.NullValue) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
      }

      // 3. Assert: Type(handler) is Object.
      (0, _invariant2.default)(handler instanceof _index.ObjectValue, "expected object");

      // 4. Let target be the value of the [[ProxyTarget]] internal slot of O.
      var target = this.$ProxyTarget;

      // 5. Let trap be ? GetMethod(handler, "preventExtensions").
      var trap = (0, _get.GetMethod)(realm, handler, "preventExtensions");

      // 6. If trap is undefined, then
      if (trap instanceof _index.UndefinedValue) {
        // a. Return ? target.[[PreventExtensions]]().
        (0, _invariant2.default)(target instanceof _index.ObjectValue);
        return target.$PreventExtensions();
      }

      // 7. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target »)).
      var booleanTrapResult = (0, _to.ToBooleanPartial)(realm, (0, _call.Call)(realm, trap, handler, [target]));

      // 8. If booleanTrapResult is true, then
      if (booleanTrapResult) {
        // a. Let targetIsExtensible be ? target.[[IsExtensible]]().
        (0, _invariant2.default)(target instanceof _index.ObjectValue);
        var targetIsExtensible = target.$IsExtensible();

        // b. If targetIsExtensible is true, throw a TypeError exception.
        if (targetIsExtensible) {
          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
        }
      }

      // 9. Return booleanTrapResult.
      return booleanTrapResult;
    }

    // ECMA262 9.5.5

  }, {
    key: "$GetOwnProperty",
    value: function $GetOwnProperty(P) {
      var realm = this.realm;

      // 1. Assert: IsPropertyKey(P) is true.
      (0, _invariant2.default)((0, _is.IsPropertyKey)(realm, P), "expected property key");

      // 2. Let handler be the value of the [[ProxyHandler]] internal slot of O.
      var handler = this.$ProxyHandler;

      // 3. If handler is null, throw a TypeError exception.
      if (handler instanceof _index.NullValue) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
      }

      // 4. Assert: Type(handler) is Object.
      (0, _invariant2.default)(handler instanceof _index.ObjectValue, "expected object");

      // 5. Let target be the value of the [[ProxyTarget]] internal slot of O.
      var target = this.$ProxyTarget;
      (0, _invariant2.default)(target instanceof _index.ObjectValue);

      // 6. Let trap be ? GetMethod(handler, "getOwnPropertyDescriptor").
      var trap = (0, _get.GetMethod)(realm, handler, "getOwnPropertyDescriptor");

      // 7. If trap is undefined, then
      if (trap instanceof _index.UndefinedValue) {
        // a. Return ? target.[[GetOwnProperty]](P).
        return target.$GetOwnProperty(P);
      }

      // 8. Let trapResultObj be ? Call(trap, handler, « target, P »).
      var trapResultObj = (0, _call.Call)(realm, trap, handler, [target, typeof P === "string" ? new _index.StringValue(realm, P) : P]);

      // 9. If Type(trapResultObj) is neither Object nor Undefined, throw a TypeError exception.
      if (!(trapResultObj instanceof _index.ObjectValue) && !(trapResultObj instanceof _index.UndefinedValue)) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
      }

      // 10. Let targetDesc be ? target.[[GetOwnProperty]](P).
      var targetDesc = target.$GetOwnProperty(P);

      // 11. If trapResultObj is undefined, then
      if (trapResultObj instanceof _index.UndefinedValue) {
        // a. If targetDesc is undefined, return undefined.
        if (!targetDesc) return undefined;
        _singletons.Properties.ThrowIfMightHaveBeenDeleted(targetDesc.value);

        // b. If targetDesc.[[Configurable]] is false, throw a TypeError exception.
        if (!targetDesc.configurable) {
          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
        }

        // c. Let extensibleTarget be ? IsExtensible(target).
        var _extensibleTarget = (0, _is.IsExtensible)(realm, target);

        // d. Assert: Type(extensibleTarget) is Boolean.
        (0, _invariant2.default)(typeof _extensibleTarget === "boolean", "expected boolean");

        // e. If extensibleTarget is false, throw a TypeError exception.
        if (!_extensibleTarget) {
          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
        }

        // f. Return undefined.
        return undefined;
      }

      // 12. Let extensibleTarget be ? IsExtensible(target).
      var extensibleTarget = (0, _is.IsExtensible)(realm, target);

      // 13. Let resultDesc be ? ToPropertyDescriptor(trapResultObj).
      var resultDesc = (0, _to.ToPropertyDescriptor)(realm, trapResultObj);

      // 14. Call CompletePropertyDescriptor(resultDesc).
      _singletons.Properties.CompletePropertyDescriptor(realm, resultDesc);

      // 15. Let valid be IsCompatiblePropertyDescriptor(extensibleTarget, resultDesc, targetDesc).
      var valid = _singletons.Properties.IsCompatiblePropertyDescriptor(realm, extensibleTarget, resultDesc, targetDesc);

      // 16. If valid is false, throw a TypeError exception.
      if (!valid) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
      }

      // 17. If resultDesc.[[Configurable]] is false, then
      if (!resultDesc.configurable) {
        // a. If targetDesc is undefined or targetDesc.[[Configurable]] is true, then
        if (!targetDesc || targetDesc.configurable) {
          // i. Throw a TypeError exception.
          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
        }
      }

      // 18. Return resultDesc.
      return resultDesc;
    }

    // ECMA262 9.5.6

  }, {
    key: "$DefineOwnProperty",
    value: function $DefineOwnProperty(P, Desc) {
      var realm = this.realm;

      // 1. Assert: IsPropertyKey(P) is true.
      (0, _invariant2.default)((0, _is.IsPropertyKey)(realm, P), "expected property key");

      // 2. Let handler be the value of the [[ProxyHandler]] internal slot of O.
      var handler = this.$ProxyHandler;

      // 3. If handler is null, throw a TypeError exception.
      if (handler instanceof _index.NullValue) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
      }

      // 4. Assert: Type(handler) is Object.
      (0, _invariant2.default)(handler instanceof _index.ObjectValue, "expected object");

      // 5. Let target be the value of the [[ProxyTarget]] internal slot of O.
      var target = this.$ProxyTarget;
      (0, _invariant2.default)(target instanceof _index.ObjectValue);

      // 6. Let trap be ? GetMethod(handler, "defineProperty").
      var trap = (0, _get.GetMethod)(realm, handler, "defineProperty");

      // 7. If trap is undefined, then
      if (trap instanceof _index.UndefinedValue) {
        // a. Return ? target.[[DefineOwnProperty]](P, Desc).
        return target.$DefineOwnProperty(P, Desc);
      }

      // 8. Let descObj be FromPropertyDescriptor(Desc).
      var descObj = _singletons.Properties.FromPropertyDescriptor(realm, Desc);

      // 9. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target, P, descObj »)).
      var booleanTrapResult = (0, _to.ToBooleanPartial)(realm, (0, _call.Call)(realm, trap, handler, [target, typeof P === "string" ? new _index.StringValue(realm, P) : P, descObj]));

      // 10. If booleanTrapResult is false, return false.
      if (!booleanTrapResult) return false;

      // 11. Let targetDesc be ? target.[[GetOwnProperty]](P).
      var targetDesc = target.$GetOwnProperty(P);

      // 12. Let extensibleTarget be ? IsExtensible(target).
      var extensibleTarget = (0, _is.IsExtensible)(realm, target);

      // 13. If Desc has a [[Configurable]] field and if Desc.[[Configurable]] is false, then
      var settingConfigFalse = void 0;
      if ("configurable" in Desc && !Desc.configurable) {
        // a. Let settingConfigFalse be true.
        settingConfigFalse = true;
      } else {
        // 14. Else let settingConfigFalse be false.
        settingConfigFalse = false;
      }

      // 15. If targetDesc is undefined, then
      if (!targetDesc) {
        // a. If extensibleTarget is false, throw a TypeError exception.
        if (!extensibleTarget) {
          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
        }

        // b. If settingConfigFalse is true, throw a TypeError exception.
        if (settingConfigFalse) {
          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
        }
      } else {
        // 16. Else targetDesc is not undefined,
        _singletons.Properties.ThrowIfMightHaveBeenDeleted(targetDesc.value);

        // a. If IsCompatiblePropertyDescriptor(extensibleTarget, Desc, targetDesc) is false, throw a TypeError exception.
        if (!_singletons.Properties.IsCompatiblePropertyDescriptor(realm, extensibleTarget, Desc, targetDesc)) {
          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
        }

        // b. If settingConfigFalse is true and targetDesc.[[Configurable]] is true, throw a TypeError exception.
        if (settingConfigFalse && targetDesc.configurable) {
          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
        }
      }

      // 17. Return true.
      return true;
    }

    // ECMA262 9.5.7

  }, {
    key: "$HasProperty",
    value: function $HasProperty(P) {
      var realm = this.realm;

      // 1. Assert: IsPropertyKey(P) is true.
      (0, _invariant2.default)((0, _is.IsPropertyKey)(realm, P), "expected property key");

      // 2. Let handler be the value of the [[ProxyHandler]] internal slot of O.
      var handler = this.$ProxyHandler;

      // 3. If handler is null, throw a TypeError exception.
      if (handler instanceof _index.NullValue) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
      }

      // 4. Assert: Type(handler) is Object.
      (0, _invariant2.default)(handler instanceof _index.ObjectValue, "expected object");

      // 5. Let target be the value of the [[ProxyTarget]] internal slot of O.
      var target = this.$ProxyTarget;
      (0, _invariant2.default)(target instanceof _index.ObjectValue);

      // 6. Let trap be ? GetMethod(handler, "has").
      var trap = (0, _get.GetMethod)(realm, handler, "has");

      // 7. If trap is undefined, then
      if (trap instanceof _index.UndefinedValue) {
        // a. Return ? target.[[HasProperty]](P).
        return target.$HasProperty(P);
      }

      // 8. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target, P »)).
      var booleanTrapResult = (0, _to.ToBooleanPartial)(realm, (0, _call.Call)(realm, trap, handler, [target, typeof P === "string" ? new _index.StringValue(realm, P) : P]));

      // 9. If booleanTrapResult is false, then
      if (!booleanTrapResult) {
        // a. Let targetDesc be ? target.[[GetOwnProperty]](P).
        var targetDesc = target.$GetOwnProperty(P);

        // b. If targetDesc is not undefined, then
        if (targetDesc) {
          _singletons.Properties.ThrowIfMightHaveBeenDeleted(targetDesc.value);

          // i. If targetDesc.[[Configurable]] is false, throw a TypeError exception.
          if (!targetDesc.configurable) {
            throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
          }

          // ii. Let extensibleTarget be ? IsExtensible(target).
          var extensibleTarget = (0, _is.IsExtensible)(realm, target);

          // iii. If extensibleTarget is false, throw a TypeError exception.
          if (!extensibleTarget) {
            throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
          }
        }
      }

      // 10. Return booleanTrapResult.
      return booleanTrapResult;
    }

    // ECMA262 9.5.8

  }, {
    key: "$Get",
    value: function $Get(P, Receiver) {
      var realm = this.realm;

      // 1. Assert: IsPropertyKey(P) is true.
      (0, _invariant2.default)((0, _is.IsPropertyKey)(realm, P), "expected property key");

      // 2. Let handler be the value of the [[ProxyHandler]] internal slot of O.
      var handler = this.$ProxyHandler;

      // 3. If handler is null, throw a TypeError exception.
      if (handler instanceof _index.NullValue) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
      }

      // 4. Assert: Type(handler) is Object.
      (0, _invariant2.default)(handler instanceof _index.ObjectValue, "expected object");

      // 5. Let target be the value of the [[ProxyTarget]] internal slot of O.
      var target = this.$ProxyTarget;
      (0, _invariant2.default)(target instanceof _index.ObjectValue);

      // 6. Let trap be ? GetMethod(handler, "get").
      var trap = (0, _get.GetMethod)(realm, handler, "get");

      // 7. If trap is undefined, then
      if (trap instanceof _index.UndefinedValue) {
        // a. Return ? target.[[Get]](P, Receiver).
        return target.$Get(P, Receiver);
      }

      // 8. Let trapResult be ? Call(trap, handler, « target, P, Receiver »).
      var trapResult = (0, _call.Call)(realm, trap, handler, [target, typeof P === "string" ? new _index.StringValue(realm, P) : P, Receiver]);

      // 9. Let targetDesc be ? target.[[GetOwnProperty]](P).
      var targetDesc = target.$GetOwnProperty(P);

      // 10. If targetDesc is not undefined, then
      if (targetDesc) {
        _singletons.Properties.ThrowIfMightHaveBeenDeleted(targetDesc.value);

        // a. If IsDataDescriptor(targetDesc) is true and targetDesc.[[Configurable]] is false and targetDesc.[[Writable]] is false, then
        if ((0, _is.IsDataDescriptor)(realm, targetDesc) && targetDesc.configurable === false && targetDesc.writable === false) {
          // i. If SameValue(trapResult, targetDesc.[[Value]]) is false, throw a TypeError exception.
          var targetValue = targetDesc.value || realm.intrinsics.undefined;
          (0, _invariant2.default)(targetValue instanceof _index.Value);
          if (!(0, _abstract.SameValuePartial)(realm, trapResult, targetValue)) {
            throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
          }
        }

        // b. If IsAccessorDescriptor(targetDesc) is true and targetDesc.[[Configurable]] is false and targetDesc.[[Get]] is undefined, then
        if ((0, _is.IsAccessorDescriptor)(realm, targetDesc) && targetDesc.configurable === false && (!targetDesc.get || targetDesc.get instanceof _index.UndefinedValue)) {
          // i. If trapResult is not undefined, throw a TypeError exception.
          if (!(trapResult instanceof _index.UndefinedValue)) {
            throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
          }
        }
      }

      // 11. Return trapResult.
      return trapResult;
    }

    // ECMA262 9.5.9

  }, {
    key: "$Set",
    value: function $Set(P, V, Receiver) {
      var realm = this.realm;

      // 1. Assert: IsPropertyKey(P) is true.
      (0, _invariant2.default)((0, _is.IsPropertyKey)(realm, P), "expected property key");

      // 2. Let handler be the value of the [[ProxyHandler]] internal slot of O.
      var handler = this.$ProxyHandler;

      // 3. If handler is null, throw a TypeError exception.
      if (handler instanceof _index.NullValue) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
      }

      // 4. Assert: Type(handler) is Object.
      (0, _invariant2.default)(handler instanceof _index.ObjectValue, "expected object");

      // 5. Let target be the value of the [[ProxyTarget]] internal slot of O.
      var target = this.$ProxyTarget;

      // 6. Let trap be ? GetMethod(handler, "set").
      var trap = (0, _get.GetMethod)(realm, handler, "set");

      // 7. If trap is undefined, then
      if (trap instanceof _index.UndefinedValue) {
        // a. Return ? target.[[Set]](P, V, Receiver).
        (0, _invariant2.default)(target instanceof _index.ObjectValue);
        return target.$Set(P, V, Receiver);
      }

      // 8. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target, P, V, Receiver »)).
      var booleanTrapResult = (0, _to.ToBooleanPartial)(realm, (0, _call.Call)(realm, trap, handler, [target, typeof P === "string" ? new _index.StringValue(realm, P) : P, V, Receiver]));

      // 9. If booleanTrapResult is false, return false.
      if (!booleanTrapResult) return false;

      // 10. Let targetDesc be ? target.[[GetOwnProperty]](P).
      (0, _invariant2.default)(target instanceof _index.ObjectValue);
      var targetDesc = target.$GetOwnProperty(P);

      // 11. If targetDesc is not undefined, then
      if (targetDesc) {
        _singletons.Properties.ThrowIfMightHaveBeenDeleted(targetDesc.value);

        // a. If IsDataDescriptor(targetDesc) is true and targetDesc.[[Configurable]] is false and targetDesc.[[Writable]] is false, then
        if ((0, _is.IsDataDescriptor)(realm, targetDesc) && !targetDesc.configurable && !targetDesc.writable) {
          // i. If SameValue(V, targetDesc.[[Value]]) is false, throw a TypeError exception.
          var targetValue = targetDesc.value || realm.intrinsics.undefined;
          (0, _invariant2.default)(targetValue instanceof _index.Value);
          if (!(0, _abstract.SameValuePartial)(realm, V, targetValue)) {
            throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
          }
        }

        // b. If IsAccessorDescriptor(targetDesc) is true and targetDesc.[[Configurable]] is false, then
        if ((0, _is.IsAccessorDescriptor)(realm, targetDesc) && !targetDesc.configurable) {
          // i. If targetDesc.[[Set]] is undefined, throw a TypeError exception.
          if (!targetDesc.set || targetDesc.set instanceof _index.UndefinedValue) {
            throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
          }
        }
      }

      // 12. Return true.
      return true;
    }

    // ECMA262 9.5.10

  }, {
    key: "$Delete",
    value: function $Delete(P) {
      var realm = this.realm;

      // 1. Assert: IsPropertyKey(P) is true.
      (0, _invariant2.default)((0, _is.IsPropertyKey)(realm, P), "expected property key");

      // 2. Let handler be the value of the [[ProxyHandler]] internal slot of O.
      var handler = this.$ProxyHandler;

      // 3. If handler is null, throw a TypeError exception.
      if (handler instanceof _index.NullValue) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
      }

      // 4. Assert: Type(handler) is Object.
      (0, _invariant2.default)(handler instanceof _index.ObjectValue, "expected object");

      // 5. Let target be the value of the [[ProxyTarget]] internal slot of O.
      var target = this.$ProxyTarget;

      // 6. Let trap be ? GetMethod(handler, "deleteProperty").
      var trap = (0, _get.GetMethod)(realm, handler, "deleteProperty");

      // 7. If trap is undefined, then
      if (trap instanceof _index.UndefinedValue) {
        // a. Return ? target.[[Delete]](P).
        (0, _invariant2.default)(target instanceof _index.ObjectValue);
        return target.$Delete(P);
      }

      // 8. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target, P »)).
      var booleanTrapResult = (0, _to.ToBooleanPartial)(realm, (0, _call.Call)(realm, trap, handler, [target, typeof P === "string" ? new _index.StringValue(realm, P) : P]));

      // 9. If booleanTrapResult is false, return false.
      if (!booleanTrapResult) return false;

      // 10. Let targetDesc be ? target.[[GetOwnProperty]](P).
      (0, _invariant2.default)(target instanceof _index.ObjectValue);
      var targetDesc = target.$GetOwnProperty(P);

      // 11. If targetDesc is undefined, return true.
      if (!targetDesc) return true;
      _singletons.Properties.ThrowIfMightHaveBeenDeleted(targetDesc.value);

      // 12. If targetDesc.[[Configurable]] is false, throw a TypeError exception.
      if (!targetDesc.configurable) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
      }

      // 13. Return true.
      return true;
    }

    // ECMA262 9.5.11

  }, {
    key: "$OwnPropertyKeys",
    value: function $OwnPropertyKeys() {
      var realm = this.realm;

      // 1. Let handler be the value of the [[ProxyHandler]] internal slot of O.
      var handler = this.$ProxyHandler;

      // 2. If handler is null, throw a TypeError exception.
      if (handler instanceof _index.NullValue) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
      }

      // 3. Assert: Type(handler) is Object.
      (0, _invariant2.default)(handler instanceof _index.ObjectValue, "expected object");

      // 4. Let target be the value of the [[ProxyTarget]] internal slot of O.
      var target = this.$ProxyTarget;
      (0, _invariant2.default)(target instanceof _index.ObjectValue);

      // 5. Let trap be ? GetMethod(handler, "ownKeys").
      var trap = (0, _get.GetMethod)(realm, handler, "ownKeys");

      // 6. If trap is undefined, then
      if (trap instanceof _index.UndefinedValue) {
        // a. Return ? target.[[OwnPropertyKeys]]().
        return target.$OwnPropertyKeys();
      }

      // 7. Let trapResultArray be ? Call(trap, handler, « target »).
      var trapResultArray = (0, _call.Call)(realm, trap, handler, [target]);

      // 8. Let trapResult be ? CreateListFromArrayLike(trapResultArray, « String, Symbol »).
      var trapResult = (0, _create.CreateListFromArrayLike)(realm, trapResultArray, ["String", "Symbol"]);

      // 9. Let extensibleTarget be ? IsExtensible(target).
      var extensibleTarget = (0, _is.IsExtensible)(realm, target);

      // 10. Let targetKeys be ? target.[[OwnPropertyKeys]]().
      var targetKeys = target.$OwnPropertyKeys();

      // 11. Assert: targetKeys is a List containing only String and Symbol values.
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = targetKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var key = _step.value;

          (0, _invariant2.default)(key instanceof _index.SymbolValue || key instanceof _index.StringValue, "expected string or symbol");
        }

        // 12. Let targetConfigurableKeys be a new empty List.
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var targetConfigurableKeys = [];

      // 13. Let targetNonconfigurableKeys be a new empty List.
      var targetNonconfigurableKeys = [];

      // 14. Repeat, for each element key of targetKeys,
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = targetKeys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _key = _step2.value;

          // a. Let desc be ? target.[[GetOwnProperty]](key).
          var desc = target.$GetOwnProperty(_key);
          if (desc) _singletons.Properties.ThrowIfMightHaveBeenDeleted(desc.value);

          // b. If desc is not undefined and desc.[[Configurable]] is false, then
          if (desc && desc.configurable === false) {
            // i. Append key as an element of targetNonconfigurableKeys.
            targetNonconfigurableKeys.push(_key);
          } else {
            // c. Else,
            // i. Append key as an element of targetConfigurableKeys.
            targetConfigurableKeys.push(_key);
          }
        }

        // 15. If extensibleTarget is true and targetNonconfigurableKeys is empty, then
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      if (extensibleTarget && !targetNonconfigurableKeys.length) {
        // a. Return trapResult.
        return trapResult;
      }

      // 16. Let uncheckedResultKeys be a new List which is a copy of trapResult.
      var uncheckedResultKeys = trapResult.slice();

      // 17. Repeat, for each key that is an element of targetNonconfigurableKeys,
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = targetNonconfigurableKeys[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var _key2 = _step3.value;

          // a. If key is not an element of uncheckedResultKeys, throw a TypeError exception.
          var index = FindPropertyKey(realm, uncheckedResultKeys, _key2);
          if (index < 0) {
            throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "key is not an element of uncheckedResultKeys");
          }

          // b. Remove key from uncheckedResultKeys.
          uncheckedResultKeys.splice(index, 1);
        }

        // 18. If extensibleTarget is true, return trapResult.
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      if (extensibleTarget) return trapResult;

      // 19. Repeat, for each key that is an element of targetConfigurableKeys,
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = targetConfigurableKeys[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var _key3 = _step4.value;

          // a. If key is not an element of uncheckedResultKeys, throw a TypeError exception.
          var index = FindPropertyKey(realm, uncheckedResultKeys, _key3);
          if (index < 0) {
            throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "key is not an element of uncheckedResultKeys");
          }

          // b. Remove key from uncheckedResultKeys.
          uncheckedResultKeys.splice(index, 1);
        }

        // 20. If uncheckedResultKeys is not empty, throw a TypeError exception.
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      if (uncheckedResultKeys.length) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
      }

      // 21. Return trapResult.
      return trapResult;
    }
  }]);

  return ProxyValue;
}(_index.ObjectValue);

ProxyValue.trackedPropertyNames = _index.ObjectValue.trackedPropertyNames.concat(["$ProxyTarget", "$ProxyHandler"]);
exports.default = ProxyValue;
//# sourceMappingURL=ProxyValue.js.map