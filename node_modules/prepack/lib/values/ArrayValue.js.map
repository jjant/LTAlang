{"version":3,"sources":["../../src/values/ArrayValue.js"],"names":["ArrayValue","realm","intrinsicName","intrinsics","ArrayPrototype","$TypedArrayName","undefined","P","Desc","A","$Realm","value","ArraySetLength","oldLenDesc","OrdinaryGetOwnProperty","ThrowIfMightHaveBeenDeleted","oldLen","throwIfNotConcrete","index","writable","succeeded","OrdinaryDefineOwnProperty"],"mappings":";;;;;;;;AAaA;;AACA;;AACA;;AACA;;AACA;;;;;;;;;;+eAjBA;;;;;;;;;IAmBqBA,U;;;AACnB,sBAAYC,KAAZ,EAA0BC,aAA1B,EAAkD;AAAA;;AAAA,mHAC1CD,KAD0C,EACnCA,MAAME,UAAN,CAAiBC,cADkB,EACFF,aADE;AAEjD;;;;8BAEqB;AACpB,aAAO,OAAP;AACD;;;qCAEyB;AACxB,aAAO,KAAKG,eAAL,KAAyBC,SAAhC;AACD;;AAED;;;;uCACmBC,C,EAAqBC,I,EAA2B;AACjE,UAAIC,IAAI,IAAR;;AAEA;AACA,+BAAU,uBAAc,KAAKC,MAAnB,EAA2BH,CAA3B,CAAV,EAAyC,yBAAzC;;AAEA;AACA,UAAIA,MAAM,QAAN,IAAmBA,mCAA4BA,EAAEI,KAAF,KAAY,QAA/D,EAA0E;AACxE;AACA,eAAO,uBAAWC,cAAX,CAA0B,KAAKF,MAA/B,EAAuCD,CAAvC,EAA0CD,IAA1C,CAAP;AACD,OAHD,MAGO,IAAI,sBAAa,KAAKE,MAAlB,EAA0BH,CAA1B,CAAJ,EAAkC;AACvC;;AAEA;AACA,YAAIM,aAAa,uBAAWC,sBAAX,CAAkC,KAAKJ,MAAvC,EAA+CD,CAA/C,EAAkD,QAAlD,CAAjB;;AAEA;AACA;AACA,iCACEI,eAAeP,SAAf,IAA4B,CAAC,8BAAqB,KAAKI,MAA1B,EAAkCG,UAAlC,CAD/B,EAEE,+CAFF;AAIA,+BAAWE,2BAAX,CAAuCF,WAAWF,KAAlD;;AAEA;AACA,YAAIK,SAASH,WAAWF,KAAxB;AACA,iCAAUK,8BAAV;AACAA,iBAASA,OAAOC,kBAAP,EAAT;AACA,iCAAUD,oCAAV,EAAyC,uBAAzC;AACAA,iBAASA,OAAOL,KAAhB;;AAEA;AACA,YAAIO,QAAQ,kBAAS,KAAKR,MAAd,EAAsB,OAAOH,CAAP,KAAa,QAAb,GAAwB,uBAAgB,KAAKG,MAArB,EAA6BH,CAA7B,CAAxB,GAA0DA,CAAhF,CAAZ;;AAEA;AACA,YAAIW,SAASF,MAAT,IAAmBH,WAAWM,QAAX,KAAwB,KAA/C,EAAsD,OAAO,KAAP;;AAEtD;AACA,YAAIC,YAAY,uBAAWC,yBAAX,CAAqC,KAAKX,MAA1C,EAAkDD,CAAlD,EAAqDF,CAArD,EAAwDC,IAAxD,CAAhB;;AAEA;AACA,YAAIY,cAAc,KAAlB,EAAyB,OAAO,KAAP;;AAEzB;AACA,YAAIF,SAASF,MAAb,EAAqB;AACnB;AACAH,qBAAWF,KAAX,GAAmB,uBAAgB,KAAKD,MAArB,EAA6BQ,QAAQ,CAArC,CAAnB;;AAEA;AACAE,sBAAY,uBAAWC,yBAAX,CAAqC,KAAKX,MAA1C,EAAkDD,CAAlD,EAAqD,QAArD,EAA+DI,UAA/D,CAAZ;;AAEA;AACA,mCAAUO,SAAV,EAAqB,uCAArB;AACD;;AAED;AACA,eAAO,IAAP;AACD;;AAED;AACA,aAAO,uBAAWC,yBAAX,CAAqC,KAAKX,MAA1C,EAAkDD,CAAlD,EAAqDF,CAArD,EAAwDC,IAAxD,CAAP;AACD;;;;;;kBA3EkBR,U","file":"ArrayValue.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { PropertyKeyValue, Descriptor, ObjectKind } from \"../types.js\";\nimport { ObjectValue, StringValue, NumberValue, Value } from \"./index.js\";\nimport { IsAccessorDescriptor, IsPropertyKey, IsArrayIndex } from \"../methods/is.js\";\nimport { ToUint32 } from \"../methods/to.js\";\nimport { Properties } from \"../singletons.js\";\nimport invariant from \"../invariant.js\";\n\nexport default class ArrayValue extends ObjectValue {\n  constructor(realm: Realm, intrinsicName?: string) {\n    super(realm, realm.intrinsics.ArrayPrototype, intrinsicName);\n  }\n\n  getKind(): ObjectKind {\n    return \"Array\";\n  }\n\n  isSimpleObject(): boolean {\n    return this.$TypedArrayName === undefined;\n  }\n\n  // ECMA262 9.4.2.1\n  $DefineOwnProperty(P: PropertyKeyValue, Desc: Descriptor): boolean {\n    let A = this;\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(this.$Realm, P), \"expected a property key\");\n\n    // 2. If P is \"length\", then\n    if (P === \"length\" || (P instanceof StringValue && P.value === \"length\")) {\n      // a. Return ? ArraySetLength(A, Desc).\n      return Properties.ArraySetLength(this.$Realm, A, Desc);\n    } else if (IsArrayIndex(this.$Realm, P)) {\n      // 3. Else if P is an array index, then\n\n      // a. Let oldLenDesc be OrdinaryGetOwnProperty(A, \"length\").\n      let oldLenDesc = Properties.OrdinaryGetOwnProperty(this.$Realm, A, \"length\");\n\n      // b. Assert: oldLenDesc will never be undefined or an accessor descriptor because Array objects are\n      //    created with a length data property that cannot be deleted or reconfigured.\n      invariant(\n        oldLenDesc !== undefined && !IsAccessorDescriptor(this.$Realm, oldLenDesc),\n        \"cannot be undefined or an accessor descriptor\"\n      );\n      Properties.ThrowIfMightHaveBeenDeleted(oldLenDesc.value);\n\n      // c. Let oldLen be oldLenDesc.[[Value]].\n      let oldLen = oldLenDesc.value;\n      invariant(oldLen instanceof Value);\n      oldLen = oldLen.throwIfNotConcrete();\n      invariant(oldLen instanceof NumberValue, \"expected number value\");\n      oldLen = oldLen.value;\n\n      // d. Let index be ! ToUint32(P).\n      let index = ToUint32(this.$Realm, typeof P === \"string\" ? new StringValue(this.$Realm, P) : P);\n\n      // e. If index ≥ oldLen and oldLenDesc.[[Writable]] is false, return false.\n      if (index >= oldLen && oldLenDesc.writable === false) return false;\n\n      // f. Let succeeded be ! OrdinaryDefineOwnProperty(A, P, Desc).\n      let succeeded = Properties.OrdinaryDefineOwnProperty(this.$Realm, A, P, Desc);\n\n      // g. If succeeded is false, return false.\n      if (succeeded === false) return false;\n\n      // h. If index ≥ oldLen, then\n      if (index >= oldLen) {\n        // i. Set oldLenDesc.[[Value]] to index + 1.\n        oldLenDesc.value = new NumberValue(this.$Realm, index + 1);\n\n        // ii. Let succeeded be OrdinaryDefineOwnProperty(A, \"length\", oldLenDesc).\n        succeeded = Properties.OrdinaryDefineOwnProperty(this.$Realm, A, \"length\", oldLenDesc);\n\n        // iii. Assert: succeeded is true.\n        invariant(succeeded, \"expected length definition to succeed\");\n      }\n\n      // i. Return true.\n      return true;\n    }\n\n    // 1. Return OrdinaryDefineOwnProperty(A, P, Desc).\n    return Properties.OrdinaryDefineOwnProperty(this.$Realm, A, P, Desc);\n  }\n}\n"]}