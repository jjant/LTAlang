{"version":3,"sources":["../../src/values/AbstractValue.js"],"names":["t","AbstractValue","realm","types","values","hashValue","args","buildNode","optionalArgs","useAbstractInterpretation","intrinsicName","undefined","Function","length","isTypeCompatibleWith","getType","mightBeEmpty","_buildNode","kind","locations","seenValues","Set","has","add","loc","push","val","addSourceLocationsTo","names","gen","$Realm","preludeGenerator","add_intrinsic","name","startsWith","add_args","derivedIds","get","indexOf","addSourceNamesTo","value","slice","getBuildNode","x","thisArgs","n","argsAreEqual","xArgs","m","i","a","b","equals","hasIdentifier","type","mightNotBeFalse","mightNotBeTrue","y","impliesNot","implies","valueType","isTop","mightBeFalse","includesValueOfType","includesValueNotOfType","cond","createFromBinaryOp","intrinsics","empty","result","createFromConditionalOp","promoteEmptyToUndefined","reportIntrospectionError","op","left","right","leftTypes","leftValues","rightTypes","rightValues","resultTypes","binaryOp","resultValues","topVal","hash","binaryExpression","expressionLocation","logicalOp","Constructor","logicalExpression","simplifyAndRefineAbstractValue","condition","joinValues","null","c","conditionalExpression","mightHaveBeenDeleted","operand","prefix","unaryOp","unaryExpression","template","resultType","operands","labels","generatorArgs","arg","charAt","currentLocation","forceHydrateLazyObjects","temp","createFromTemplate","buildNode_","generator","derive","buildFunction","emitVoidExpression","elements","concreteValues","filter","e","concreteSet","abstractValue","find","getElements","forEach","v","join","propertyName","identity","$GlobalObject","generateErrorInformationForAbstractVal","source_locations","location","desc","$Description","throwIfNotConcreteString","message"],"mappings":"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","file":"AbstractValue.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type {\n  BabelBinaryOperator,\n  BabelNodeExpression,\n  BabelNodeIdentifier,\n  BabelNodeLogicalOperator,\n  BabelNodeSourceLocation,\n  BabelUnaryOperator,\n} from \"babel-types\";\nimport { FatalError } from \"../errors.js\";\nimport type { Realm } from \"../realm.js\";\nimport type { PropertyKeyValue } from \"../types.js\";\nimport { PreludeGenerator } from \"../utils/generator.js\";\n\nimport {\n  AbstractObjectValue,\n  BooleanValue,\n  ConcreteValue,\n  NullValue,\n  NumberValue,\n  ObjectValue,\n  PrimitiveValue,\n  StringValue,\n  SymbolValue,\n  UndefinedValue,\n  Value,\n} from \"./index.js\";\nimport { hashBinary, hashCall, hashString, hashTernary, hashUnary } from \"../methods/index.js\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\nimport invariant from \"../invariant.js\";\n\nimport * as t from \"babel-types\";\n\nexport type AbstractValueBuildNodeFunction = (Array<BabelNodeExpression>) => BabelNodeExpression;\n\nexport default class AbstractValue extends Value {\n  constructor(\n    realm: Realm,\n    types: TypesDomain,\n    values: ValuesDomain,\n    hashValue: number,\n    args: Array<Value>,\n    buildNode?: AbstractValueBuildNodeFunction | BabelNodeExpression,\n    optionalArgs?: {| kind?: string, intrinsicName?: string |}\n  ) {\n    invariant(realm.useAbstractInterpretation);\n    super(realm, optionalArgs ? optionalArgs.intrinsicName : undefined);\n    invariant(buildNode instanceof Function || args.length === 0);\n    invariant(!Value.isTypeCompatibleWith(types.getType(), ObjectValue) || this instanceof AbstractObjectValue);\n    invariant(types.getType() !== NullValue && types.getType() !== UndefinedValue);\n    this.types = types;\n    this.values = values;\n    this.mightBeEmpty = false;\n    this._buildNode = buildNode;\n    this.args = args;\n    this.hashValue = hashValue;\n    this.kind = optionalArgs ? optionalArgs.kind : undefined;\n  }\n\n  hashValue: number;\n  kind: ?string;\n  types: TypesDomain;\n  values: ValuesDomain;\n  mightBeEmpty: boolean;\n  args: Array<Value>;\n  _buildNode: void | AbstractValueBuildNodeFunction | BabelNodeExpression;\n\n  addSourceLocationsTo(locations: Array<BabelNodeSourceLocation>, seenValues?: Set<AbstractValue> = new Set()) {\n    if (seenValues.has(this)) return;\n    seenValues.add(this);\n    if (this._buildNode && !(this._buildNode instanceof Function)) {\n      if (this._buildNode.loc) locations.push(this._buildNode.loc);\n    }\n    for (let val of this.args) {\n      if (val instanceof AbstractValue) val.addSourceLocationsTo(locations, seenValues);\n    }\n  }\n\n  addSourceNamesTo(names: Array<string>) {\n    let gen = this.$Realm.preludeGenerator;\n    function add_intrinsic(name: string) {\n      if (name.startsWith(\"_$\")) {\n        if (gen === undefined) return;\n        add_args(gen.derivedIds.get(name));\n      } else if (names.indexOf(name) < 0) {\n        names.push(name);\n      }\n    }\n    function add_args(args: void | Array<Value>) {\n      if (args === undefined) return;\n      for (let val of args) {\n        if (val.intrinsicName) {\n          add_intrinsic(val.intrinsicName);\n        } else if (val instanceof AbstractValue) {\n          val.addSourceNamesTo(names);\n        } else if (val instanceof StringValue) {\n          if (val.value.startsWith(\"__\")) {\n            names.push(val.value.slice(2));\n          }\n        }\n      }\n    }\n    if (this.intrinsicName) {\n      add_intrinsic(this.intrinsicName);\n    }\n    add_args(this.args);\n  }\n\n  buildNode(args: Array<BabelNodeExpression>): BabelNodeExpression {\n    let buildNode = this.getBuildNode();\n    return buildNode instanceof Function\n      ? ((buildNode: any): AbstractValueBuildNodeFunction)(args)\n      : ((buildNode: any): BabelNodeExpression);\n  }\n\n  equals(x: Value) {\n    if (x instanceof ConcreteValue) return false;\n    let thisArgs = this.args;\n    let n = thisArgs.length;\n\n    let argsAreEqual = () => {\n      invariant(x instanceof AbstractValue);\n      let xArgs = x.args;\n      let m = xArgs.length;\n      invariant(n === m); // Will be true if kinds are the same. Caller should see to it.\n      for (let i = 0; i < n; i++) {\n        let a = thisArgs[i];\n        let b = xArgs[i];\n        if (!a.equals(b)) return false;\n      }\n      return true;\n    };\n\n    return (\n      this === x ||\n      (x instanceof AbstractValue &&\n        this.kind === x.kind &&\n        this.hashValue === x.hashValue &&\n        ((this.intrinsicName && this.intrinsicName.length > 0 && this.intrinsicName === x.intrinsicName) ||\n          (n > 0 && argsAreEqual())))\n    );\n  }\n\n  getBuildNode(): AbstractValueBuildNodeFunction | BabelNodeExpression {\n    invariant(this._buildNode);\n    return this._buildNode;\n  }\n\n  getHash(): number {\n    return this.hashValue;\n  }\n\n  getType() {\n    return this.types.getType();\n  }\n\n  getIdentifier() {\n    invariant(this.hasIdentifier());\n    return ((this._buildNode: any): BabelNodeIdentifier);\n  }\n\n  hasIdentifier() {\n    return this._buildNode && this._buildNode.type === \"Identifier\";\n  }\n\n  // this => val. A false value does not imply that !(this => val).\n  implies(val: Value): boolean {\n    if (this.equals(val)) return true; // x => x regardless of its value\n    if (!this.mightNotBeFalse()) return true; // false => val\n    if (!val.mightNotBeTrue()) return true; // x => true regardless of the value of x\n    if (val instanceof AbstractValue) {\n      // Neither this (x) nor val (y) is a known value, so we need to some reasoning based on the structure\n      // x => !y if y => !x\n      if (val.kind === \"!\") {\n        let [y] = val.args;\n        invariant(y instanceof AbstractValue);\n        return y.impliesNot(this);\n      }\n      // x => x !== null && x !== undefined\n      if (val.kind === \"!==\") {\n        let [x, y] = val.args;\n        if (this.implies(x)) return y instanceof NullValue || y instanceof UndefinedValue;\n        if (this.implies(y)) return x instanceof NullValue || x instanceof UndefinedValue;\n      }\n    }\n    return false;\n  }\n\n  // this => !val. A false value does not imply that !(this => !val).\n  impliesNot(val: Value): boolean {\n    if (this.equals(val)) return false; // x => x regardless of its value, hence x => !val is false\n    if (!this.mightNotBeFalse()) return true; // false => !val\n    if (!val.mightNotBeFalse()) return true; // x => !false regardless of the value of x\n    if (val instanceof AbstractValue) {\n      // !x => !y if y => x\n      if (this.kind === \"!\") {\n        let [x] = this.args;\n        return val.implies(x);\n      }\n    }\n    return false;\n  }\n\n  // todo: abstract values should never be of type UndefinedValue or NullValue, assert this\n  mightBeFalse(): boolean {\n    let valueType = this.getType();\n    if (valueType === UndefinedValue) return true;\n    if (valueType === NullValue) return true;\n    if (valueType === SymbolValue) return false;\n    if (Value.isTypeCompatibleWith(valueType, ObjectValue)) return false;\n    if (this.values.isTop()) return true;\n    return this.values.mightBeFalse();\n  }\n\n  mightNotBeFalse(): boolean {\n    let valueType = this.getType();\n    if (valueType === UndefinedValue) return false;\n    if (valueType === NullValue) return false;\n    if (valueType === SymbolValue) return true;\n    if (Value.isTypeCompatibleWith(valueType, ObjectValue)) return true;\n    if (this.values.isTop()) return true;\n    return this.values.mightNotBeFalse();\n  }\n\n  mightBeNull(): boolean {\n    let valueType = this.getType();\n    if (valueType === NullValue) return true;\n    if (valueType !== Value) return false;\n    if (this.values.isTop()) return true;\n    return this.values.includesValueOfType(NullValue);\n  }\n\n  mightNotBeNull(): boolean {\n    let valueType = this.getType();\n    if (valueType === NullValue) return false;\n    if (valueType !== Value) return true;\n    if (this.values.isTop()) return true;\n    return this.values.includesValueNotOfType(NullValue);\n  }\n\n  mightBeNumber(): boolean {\n    let valueType = this.getType();\n    if (valueType === NumberValue) return true;\n    if (valueType !== Value) return false;\n    if (this.values.isTop()) return true;\n    return this.values.includesValueOfType(NumberValue);\n  }\n\n  mightNotBeNumber(): boolean {\n    let valueType = this.getType();\n    if (valueType === NumberValue) return false;\n    if (valueType !== Value) return true;\n    if (this.values.isTop()) return true;\n    return this.values.includesValueNotOfType(NumberValue);\n  }\n\n  mightNotBeObject(): boolean {\n    let valueType = this.getType();\n    if (Value.isTypeCompatibleWith(valueType, PrimitiveValue)) return true;\n    if (Value.isTypeCompatibleWith(valueType, ObjectValue)) return false;\n    if (this.values.isTop()) return true;\n    return this.values.includesValueNotOfType(ObjectValue);\n  }\n\n  mightBeObject(): boolean {\n    let valueType = this.getType();\n    if (Value.isTypeCompatibleWith(valueType, PrimitiveValue)) return false;\n    if (Value.isTypeCompatibleWith(valueType, ObjectValue)) return true;\n    if (this.values.isTop()) return true;\n    return this.values.includesValueOfType(ObjectValue);\n  }\n\n  mightBeString(): boolean {\n    let valueType = this.getType();\n    if (valueType === StringValue) return true;\n    if (valueType !== Value) return false;\n    if (this.values.isTop()) return true;\n    return this.values.includesValueOfType(StringValue);\n  }\n\n  mightNotBeString(): boolean {\n    let valueType = this.getType();\n    if (valueType === StringValue) return false;\n    if (valueType !== Value) return true;\n    if (this.values.isTop()) return true;\n    return this.values.includesValueNotOfType(StringValue);\n  }\n\n  mightBeUndefined(): boolean {\n    let valueType = this.getType();\n    if (valueType === UndefinedValue) return true;\n    if (valueType !== Value) return false;\n    if (this.values.isTop()) return true;\n    return this.values.includesValueOfType(UndefinedValue);\n  }\n\n  mightNotBeUndefined(): boolean {\n    let valueType = this.getType();\n    if (valueType === UndefinedValue) return false;\n    if (valueType !== Value) return true;\n    if (this.values.isTop()) return true;\n    return this.values.includesValueNotOfType(UndefinedValue);\n  }\n\n  mightHaveBeenDeleted(): boolean {\n    return this.mightBeEmpty;\n  }\n\n  promoteEmptyToUndefined(): Value {\n    if (this.values.isTop()) return this;\n    if (!this.mightBeEmpty) return this;\n    let cond = AbstractValue.createFromBinaryOp(this.$Realm, \"===\", this, this.$Realm.intrinsics.empty);\n    let result = AbstractValue.createFromConditionalOp(this.$Realm, cond, this.$Realm.intrinsics.undefined, this);\n    if (result instanceof AbstractValue) result.values = this.values.promoteEmptyToUndefined();\n    return result;\n  }\n\n  throwIfNotConcrete(): ConcreteValue {\n    AbstractValue.reportIntrospectionError(this);\n    throw new FatalError();\n  }\n\n  throwIfNotConcreteNumber(): NumberValue {\n    AbstractValue.reportIntrospectionError(this);\n    throw new FatalError();\n  }\n\n  throwIfNotConcreteString(): StringValue {\n    AbstractValue.reportIntrospectionError(this);\n    throw new FatalError();\n  }\n\n  throwIfNotConcreteBoolean(): BooleanValue {\n    AbstractValue.reportIntrospectionError(this);\n    throw new FatalError();\n  }\n\n  throwIfNotConcreteSymbol(): SymbolValue {\n    AbstractValue.reportIntrospectionError(this);\n    throw new FatalError();\n  }\n\n  throwIfNotConcreteObject(): ObjectValue {\n    AbstractValue.reportIntrospectionError(this);\n    throw new FatalError();\n  }\n\n  throwIfNotConcretePrimitive(): PrimitiveValue {\n    AbstractValue.reportIntrospectionError(this);\n    throw new FatalError();\n  }\n\n  throwIfNotObject(): AbstractObjectValue {\n    invariant(!(this instanceof AbstractObjectValue));\n    AbstractValue.reportIntrospectionError(this);\n    throw new FatalError();\n  }\n\n  static createFromBinaryOp(\n    realm: Realm,\n    op: BabelBinaryOperator,\n    left: Value,\n    right: Value,\n    loc?: ?BabelNodeSourceLocation,\n    kind?: string\n  ): AbstractValue {\n    let leftTypes, leftValues;\n    if (left instanceof AbstractValue) {\n      leftTypes = left.types;\n      leftValues = left.values;\n    } else {\n      leftTypes = new TypesDomain(left.getType());\n      invariant(left instanceof ConcreteValue);\n      leftValues = new ValuesDomain(left);\n    }\n\n    let rightTypes, rightValues;\n    if (right instanceof AbstractValue) {\n      rightTypes = right.types;\n      rightValues = right.values;\n    } else {\n      rightTypes = new TypesDomain(right.getType());\n      invariant(right instanceof ConcreteValue);\n      rightValues = new ValuesDomain(right);\n    }\n\n    let resultTypes = TypesDomain.binaryOp(op, leftTypes, rightTypes);\n    let resultValues =\n      kind === \"template for property name condition\"\n        ? ValuesDomain.topVal\n        : ValuesDomain.binaryOp(realm, op, leftValues, rightValues);\n    let [hash, args] = kind === undefined ? hashBinary(op, left, right) : hashCall(kind, left, right);\n    let result = new AbstractValue(realm, resultTypes, resultValues, hash, args, ([x, y]) =>\n      t.binaryExpression(op, x, y)\n    );\n    result.kind = kind || op;\n    result.expressionLocation = loc;\n    return result;\n  }\n\n  static createFromLogicalOp(\n    realm: Realm,\n    op: BabelNodeLogicalOperator,\n    left: Value,\n    right: Value,\n    loc?: ?BabelNodeSourceLocation\n  ): Value {\n    let leftTypes, leftValues;\n    if (left instanceof AbstractValue) {\n      leftTypes = left.types;\n      leftValues = left.values;\n    } else {\n      leftTypes = new TypesDomain(left.getType());\n      invariant(left instanceof ConcreteValue);\n      leftValues = new ValuesDomain(left);\n    }\n\n    let rightTypes, rightValues;\n    if (right instanceof AbstractValue) {\n      rightTypes = right.types;\n      rightValues = right.values;\n    } else {\n      rightTypes = new TypesDomain(right.getType());\n      invariant(right instanceof ConcreteValue);\n      rightValues = new ValuesDomain(right);\n    }\n\n    let resultTypes = TypesDomain.logicalOp(op, leftTypes, rightTypes);\n    let resultValues = ValuesDomain.logicalOp(realm, op, leftValues, rightValues);\n    let [hash, args] = hashCall(op, left, right);\n    let Constructor = Value.isTypeCompatibleWith(resultTypes.getType(), ObjectValue)\n      ? AbstractObjectValue\n      : AbstractValue;\n    let result = new Constructor(realm, resultTypes, resultValues, hash, args, ([x, y]) =>\n      t.logicalExpression(op, x, y)\n    );\n    result.kind = op;\n    result.expressionLocation = loc;\n    return realm.simplifyAndRefineAbstractValue(result);\n  }\n\n  static createFromConditionalOp(\n    realm: Realm,\n    condition: AbstractValue,\n    left: void | Value,\n    right: void | Value,\n    loc?: ?BabelNodeSourceLocation\n  ): Value {\n    let types = TypesDomain.joinValues(left, right);\n    if (types.getType() === NullValue) return realm.intrinsics.null;\n    if (types.getType() === UndefinedValue) return realm.intrinsics.undefined;\n    let values = ValuesDomain.joinValues(realm, left, right);\n    let [hash, args] = hashTernary(condition, left || realm.intrinsics.undefined, right || realm.intrinsics.undefined);\n    let Constructor = Value.isTypeCompatibleWith(types.getType(), ObjectValue) ? AbstractObjectValue : AbstractValue;\n    let result = new Constructor(realm, types, values, hash, args, ([c, x, y]) => t.conditionalExpression(c, x, y), {\n      kind: \"conditional\",\n    });\n    result.expressionLocation = loc;\n    if (left) result.mightBeEmpty = left.mightHaveBeenDeleted();\n    if (right && !result.mightBeEmpty) result.mightBeEmpty = right.mightHaveBeenDeleted();\n    if (result.mightBeEmpty) return result;\n    return realm.simplifyAndRefineAbstractValue(result);\n  }\n\n  static createFromUnaryOp(\n    realm: Realm,\n    op: BabelUnaryOperator,\n    operand: AbstractValue,\n    prefix?: boolean,\n    loc?: ?BabelNodeSourceLocation\n  ): Value {\n    let resultTypes = TypesDomain.unaryOp(op);\n    let resultValues = ValuesDomain.unaryOp(realm, op, operand.values);\n    let result = new AbstractValue(realm, resultTypes, resultValues, hashUnary(op, operand), [operand], ([x]) =>\n      t.unaryExpression(op, x, prefix)\n    );\n    result.kind = op;\n    result.expressionLocation = loc;\n    return realm.simplifyAndRefineAbstractValue(result);\n  }\n\n  /* Note that the template is parameterized by the names A, B, C and so on.\n     When the abstract value is serialized, the serialized operations are substituted\n     for the corresponding parameters and the resulting template is parsed into an AST subtree\n     that is incorporated into the AST produced by the serializer. */\n  static createFromTemplate(\n    realm: Realm,\n    template: PreludeGenerator => ({}) => BabelNodeExpression,\n    resultType: typeof Value,\n    operands: Array<Value>,\n    kind: string,\n    loc?: ?BabelNodeSourceLocation\n  ): AbstractValue {\n    let resultTypes = new TypesDomain(resultType);\n    let resultValues = ValuesDomain.topVal;\n    let hash;\n    [hash, operands] = hashCall(kind, ...operands);\n    let Constructor = Value.isTypeCompatibleWith(resultType, ObjectValue) ? AbstractObjectValue : AbstractValue;\n    let labels = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    invariant(labels.length >= operands.length);\n    let result = new Constructor(realm, resultTypes, resultValues, hash, operands, args => {\n      invariant(realm.preludeGenerator !== undefined);\n      let generatorArgs = {};\n      let i = 0;\n      for (let arg of args) generatorArgs[labels.charAt(i++)] = arg;\n      return template(realm.preludeGenerator)(generatorArgs);\n    });\n    result.kind = kind;\n    result.expressionLocation = loc || realm.currentLocation;\n    return result;\n  }\n\n  static createFromType(realm: Realm, resultType: typeof Value, kind?: string): AbstractValue {\n    let types = new TypesDomain(resultType);\n    let Constructor = Value.isTypeCompatibleWith(resultType, ObjectValue) ? AbstractObjectValue : AbstractValue;\n    let hash = hashString(resultType.name + (kind || \"\"));\n    let result = new Constructor(realm, types, ValuesDomain.topVal, hash, []);\n    if (kind) result.kind = kind;\n    result.expressionLocation = realm.currentLocation;\n    return result;\n  }\n\n  /* Emits a declaration for an identifier into the generator at the current point in time\n     and initializes it with an expression constructed from the given template.\n     Returns an abstract value that refers to the newly declared identifier.\n     Note that the template must generate an expression which has no side-effects\n     on the prepack state. It is assumed, however, that there could be side-effects\n     on the native state unless the isPure option is specified.  */\n  static createTemporalFromTemplate(\n    realm: Realm,\n    template: PreludeGenerator => ({}) => BabelNodeExpression,\n    resultType: typeof Value,\n    operands: Array<Value>,\n    optionalArgs?: {| kind?: string, isPure?: boolean, skipInvariant?: boolean |},\n    forceHydrateLazyObjects: boolean = false\n  ): AbstractValue {\n    invariant(resultType !== UndefinedValue);\n    let temp = AbstractValue.createFromTemplate(realm, template, resultType, operands, \"\");\n    let types = temp.types;\n    let values = temp.values;\n    let args = temp.args;\n    let buildNode_ = temp.getBuildNode();\n    invariant(realm.generator !== undefined);\n    return realm.generator.derive(types, values, args, buildNode_, optionalArgs, forceHydrateLazyObjects);\n  }\n\n  static createTemporalFromBuildFunction(\n    realm: Realm,\n    resultType: typeof Value,\n    args: Array<Value>,\n    buildFunction: AbstractValueBuildNodeFunction\n  ): AbstractValue | UndefinedValue {\n    let types = new TypesDomain(resultType);\n    let values = ValuesDomain.topVal;\n    invariant(realm.generator !== undefined);\n    if (resultType === UndefinedValue) {\n      return realm.generator.emitVoidExpression(types, values, args, buildFunction);\n    } else {\n      return realm.generator.derive(types, values, args, buildFunction);\n    }\n  }\n\n  // Creates a union of an abstract value with one or more concrete values.\n  // The build node for the abstract values becomes the build node for the union.\n  // Use this only to allow instrinsic abstract objects to be null and/or undefined.\n  static createAbstractConcreteUnion(realm: Realm, ...elements: Array<Value>) {\n    let concreteValues: Array<ConcreteValue> = (elements.filter(e => e instanceof ConcreteValue): any);\n    invariant(concreteValues.length > 0 && concreteValues.length === elements.length - 1);\n    let concreteSet = new Set(concreteValues);\n    let abstractValue = elements.find(e => e instanceof AbstractValue);\n    invariant(abstractValue instanceof AbstractValue);\n    let values;\n    if (!abstractValue.values.isTop()) {\n      abstractValue.values.getElements().forEach(v => concreteSet.add(v));\n      values = new ValuesDomain(concreteSet);\n    } else {\n      values = ValuesDomain.topVal;\n    }\n    let types = TypesDomain.topVal;\n    let [hash, operands] = hashCall(\"abstractConcreteUnion\", ...elements);\n    let result = new AbstractValue(realm, types, values, hash, operands, abstractValue._buildNode, {\n      kind: \"abstractConcreteUnion\",\n    });\n    result.expressionLocation = realm.currentLocation;\n    return result;\n  }\n\n  static generateErrorInformationForAbstractVal(val: AbstractValue): string {\n    let names = [];\n    val.addSourceNamesTo(names);\n    if (names.length === 0) {\n      val.addSourceNamesTo(names);\n    }\n    return `abstract value${names.length > 1 ? \"s\" : \"\"} ${names.join(\" and \")}`;\n  }\n\n  static reportIntrospectionError(val: Value, propertyName: void | PropertyKeyValue) {\n    let realm = val.$Realm;\n\n    let identity;\n    if (val === realm.$GlobalObject) identity = \"global\";\n    else if (val instanceof AbstractValue) {\n      identity = this.generateErrorInformationForAbstractVal(val);\n    } else identity = val.intrinsicName || \"(some value)\";\n\n    let source_locations = [];\n    if (val instanceof AbstractValue) val.addSourceLocationsTo(source_locations);\n\n    let location;\n    if (propertyName instanceof SymbolValue) {\n      let desc = propertyName.$Description;\n      if (desc) {\n        location = `at symbol [${desc.throwIfNotConcreteString().value}]`;\n      } else {\n        location = `at symbol [${\"(no description)\"}]`;\n      }\n    } else if (propertyName instanceof StringValue) location = `at ${propertyName.value}`;\n    else if (typeof propertyName === \"string\") location = `at ${propertyName}`;\n    else location = source_locations.length === 0 ? \"\" : `at ${source_locations.join(\"\\n\")}`;\n\n    let message = `This operation is not yet supported on ${identity} ${location}`;\n\n    return realm.reportIntrospectionError(message);\n  }\n}\n"]}