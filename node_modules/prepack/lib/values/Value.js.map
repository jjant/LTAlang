{"version":3,"sources":["../../src/values/Value.js"],"names":["Value","realm","intrinsicName","$Realm","expressionLocation","currentLocation","x","constructor","val","equals","mightNotBeFalse","mightNotBeTrue","mightBeFalse","Error","stack","Map","has","get","set","_serialize","typeName","undefined","type","Constructor","prototype"],"mappings":"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","file":"Value.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { BabelNodeSourceLocation } from \"babel-types\";\nimport type { Realm } from \"../realm.js\";\nimport {\n  AbstractObjectValue,\n  BooleanValue,\n  ConcreteValue,\n  EmptyValue,\n  FunctionValue,\n  NullValue,\n  NumberValue,\n  ObjectValue,\n  PrimitiveValue,\n  StringValue,\n  SymbolValue,\n  UndefinedValue,\n} from \"./index.js\";\nimport invariant from \"../invariant.js\";\n\nexport default class Value {\n  constructor(realm: Realm, intrinsicName?: string) {\n    invariant(realm, \"realm required\");\n\n    this.$Realm = realm;\n    this.intrinsicName = intrinsicName;\n    this.expressionLocation = realm.currentLocation;\n  }\n  // Name from original source if existant\n  __originalName: void | string;\n\n  equals(x: Value): boolean {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  getHash(): number {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  getType(): typeof Value {\n    return this.constructor;\n  }\n\n  static getTypeFromName(typeName: string): void | typeof Value {\n    switch (typeName) {\n      case \"empty\":\n        return EmptyValue;\n      case \"void\":\n        return UndefinedValue;\n      case \"null\":\n        return NullValue;\n      case \"boolean\":\n        return BooleanValue;\n      case \"string\":\n        return StringValue;\n      case \"symbol\":\n        return SymbolValue;\n      case \"number\":\n        return NumberValue;\n      case \"object\":\n        return ObjectValue;\n      case \"function\":\n        return FunctionValue;\n      default:\n        return undefined;\n    }\n  }\n\n  static isTypeCompatibleWith(type: typeof Value, Constructor: typeof Value): boolean {\n    return type.prototype instanceof Constructor || type.prototype === Constructor.prototype;\n  }\n\n  intrinsicName: void | string;\n\n  // The source location of the expression that first produced this value.\n  expressionLocation: ?BabelNodeSourceLocation;\n  $Realm: Realm;\n\n  implies(val: Value): boolean {\n    if (this.equals(val)) return true;\n    if (!this.mightNotBeFalse()) return true;\n    if (!val.mightNotBeTrue()) return true;\n    return false;\n  }\n\n  isIntrinsic(): boolean {\n    return !!this.intrinsicName;\n  }\n\n  isPartialObject(): boolean {\n    return false;\n  }\n\n  isSimpleObject(): boolean {\n    return false;\n  }\n\n  mightBeFalse(): boolean {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  mightNotBeFalse(): boolean {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  mightBeNull(): boolean {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  mightNotBeNull(): boolean {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  mightBeNumber(): boolean {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  mightNotBeNumber(): boolean {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  mightNotBeObject(): boolean {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  mightBeObject(): boolean {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  mightBeString(): boolean {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  mightNotBeString(): boolean {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  mightBeTrue(): boolean {\n    return this.mightNotBeFalse();\n  }\n\n  mightNotBeTrue(): boolean {\n    return this.mightBeFalse();\n  }\n\n  mightBeUndefined(): boolean {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  mightNotBeUndefined(): boolean {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  mightHaveBeenDeleted(): boolean {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  promoteEmptyToUndefined(): Value {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  throwIfNotConcrete(): ConcreteValue {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  throwIfNotConcreteNumber(): NumberValue {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  throwIfNotConcreteString(): StringValue {\n    throw new Error(\"abstract method; please override\");\n  }\n\n  throwIfNotConcreteBoolean(): BooleanValue {\n    throw new Error(\"abstract method; please override\");\n  }\n\n  throwIfNotConcreteSymbol(): SymbolValue {\n    throw new Error(\"abstract method; please override\");\n  }\n\n  throwIfNotConcreteObject(): ObjectValue {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  throwIfNotConcretePrimitive(): PrimitiveValue {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  throwIfNotObject(): ObjectValue | AbstractObjectValue {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  serialize(stack: Map<Value, any> = new Map()): any {\n    if (stack.has(this)) {\n      return stack.get(this);\n    } else {\n      let set = val => {\n        stack.set(this, val);\n        return val;\n      };\n\n      return set(this._serialize(set, stack));\n    }\n  }\n\n  _serialize(set: Function, stack: Map<Value, any>): any {\n    invariant(false, \"abstract method; please override\");\n  }\n}\n"]}