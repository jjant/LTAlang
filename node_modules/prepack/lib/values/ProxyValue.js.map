{"version":3,"sources":["../../src/values/ProxyValue.js"],"names":["FindPropertyKey","realm","keys","key","i","length","ProxyValue","$Realm","undefined","trackedPropertyNames","handler","$ProxyHandler","createErrorThrowCompletion","intrinsics","TypeError","target","$ProxyTarget","trap","$GetPrototypeOf","handlerProto","extensibleTarget","targetProto","V","$SetPrototypeOf","booleanTrapResult","$IsExtensible","targetResult","$PreventExtensions","targetIsExtensible","P","$GetOwnProperty","trapResultObj","targetDesc","ThrowIfMightHaveBeenDeleted","value","configurable","resultDesc","CompletePropertyDescriptor","valid","IsCompatiblePropertyDescriptor","Desc","$DefineOwnProperty","descObj","FromPropertyDescriptor","settingConfigFalse","$HasProperty","Receiver","$Get","trapResult","writable","targetValue","get","$Set","set","$Delete","$OwnPropertyKeys","trapResultArray","targetKeys","targetConfigurableKeys","targetNonconfigurableKeys","desc","push","uncheckedResultKeys","slice","index","splice","concat"],"mappings":"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","file":"ProxyValue.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { Realm } from \"../realm.js\";\nimport { Value, SymbolValue, NullValue, ObjectValue, UndefinedValue, StringValue } from \"./index.js\";\nimport type { Descriptor, PropertyKeyValue } from \"../types.js\";\nimport invariant from \"../invariant.js\";\nimport { ToBooleanPartial, ToPropertyDescriptor } from \"../methods/to.js\";\nimport { SameValue, SameValuePartial, SamePropertyKey } from \"../methods/abstract.js\";\nimport { GetMethod } from \"../methods/get.js\";\nimport { CreateListFromArrayLike } from \"../methods/create.js\";\nimport { IsExtensible, IsPropertyKey, IsDataDescriptor, IsAccessorDescriptor } from \"../methods/is.js\";\nimport { Properties } from \"../singletons.js\";\nimport { Call } from \"../methods/call.js\";\n\nfunction FindPropertyKey(realm: Realm, keys: Array<PropertyKeyValue>, key: PropertyKeyValue): number {\n  for (let i = 0; i < keys.length; ++i) {\n    if (SamePropertyKey(realm, key, keys[i])) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nexport default class ProxyValue extends ObjectValue {\n  $ProxyTarget: NullValue | ObjectValue;\n  $ProxyHandler: NullValue | ObjectValue;\n\n  realm: Realm;\n\n  constructor(realm: Realm) {\n    super(realm);\n\n    // $FlowFixMe TODO #1022: exotics should not have $Realm\n    this.$Realm = undefined;\n    this.realm = realm;\n  }\n\n  static trackedPropertyNames = ObjectValue.trackedPropertyNames.concat([\"$ProxyTarget\", \"$ProxyHandler\"]);\n\n  getTrackedBindings(): Array<string> {\n    return ProxyValue.trackedPropertyNames;\n  }\n\n  isSimpleObject(): boolean {\n    return false;\n  }\n\n  // ECMA262 9.5.1\n  $GetPrototypeOf(): NullValue | ObjectValue {\n    let realm = this.realm;\n\n    // 1. Let handler be the value of the [[ProxyHandler]] internal slot of O.\n    let handler = this.$ProxyHandler;\n\n    // 2. If handler is null, throw a TypeError exception.\n    if (handler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 3. Assert: Type(handler) is Object.\n    invariant(handler instanceof ObjectValue, \"expected an object\");\n\n    // 4. Let target be the value of the [[ProxyTarget]] internal slot of O.\n    let target = this.$ProxyTarget;\n    invariant(target instanceof ObjectValue);\n\n    // 5. Let trap be ? GetMethod(handler, \"getPrototypeOf\").\n    let trap = GetMethod(realm, handler, \"getPrototypeOf\");\n\n    // 6. If trap is undefined, then\n    if (trap instanceof UndefinedValue) {\n      // a. Return ? target.[[GetPrototypeOf]]().\n      return target.$GetPrototypeOf();\n    }\n\n    // 7. Let handlerProto be ? Call(trap, handler, « target »).\n    let handlerProto = Call(realm, trap, handler, [target]);\n\n    // 8. If Type(handlerProto) is neither Object nor Null, throw a TypeError exception.\n    if (!(handlerProto instanceof ObjectValue) && !(handlerProto instanceof NullValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 9. Let extensibleTarget be ? IsExtensible(target).\n    let extensibleTarget = IsExtensible(realm, target);\n\n    // 10. If extensibleTarget is true, return handlerProto.\n    if (extensibleTarget) return handlerProto;\n\n    // 11. Let targetProto be ? target.[[GetPrototypeOf]]().\n    let targetProto = target.$GetPrototypeOf();\n\n    // 12. If SameValue(handlerProto, targetProto) is false, throw a TypeError exception.\n    if (!SameValue(realm, handlerProto, targetProto)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 13. Return handlerProto.\n    return handlerProto;\n  }\n\n  // ECMA262 9.5.2\n  $SetPrototypeOf(V: ObjectValue | NullValue): boolean {\n    let realm = this.realm;\n\n    // 1. Assert: Either Type(V) is Object or Type(V) is Null.\n    invariant(V instanceof ObjectValue || V instanceof NullValue, \"expected object or null\");\n\n    // 2. Let handler be the value of the [[ProxyHandler]] internal slot of O.\n    let handler = this.$ProxyHandler;\n\n    // 3. If handler is null, throw a TypeError exception.\n    if (handler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 4. Assert: Type(handler) is Object.\n    invariant(handler instanceof ObjectValue, \"expected object\");\n\n    // 5. Let target be the value of the [[ProxyTarget]] internal slot of O.\n    let target = this.$ProxyTarget;\n    invariant(target instanceof ObjectValue);\n\n    // 6. Let trap be ? GetMethod(handler, \"setPrototypeOf\").\n    let trap = GetMethod(realm, handler, \"setPrototypeOf\");\n\n    // 7. If trap is undefined, then\n    if (trap instanceof UndefinedValue) {\n      // a. Return ? target.[[SetPrototypeOf]](V).\n      return target.$SetPrototypeOf(V);\n    }\n\n    // 8. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target, V »)).\n    let booleanTrapResult = ToBooleanPartial(realm, Call(realm, trap, handler, [target, V]));\n\n    // 9. If booleanTrapResult is false, return false.\n    if (!booleanTrapResult) return false;\n\n    // 10. Let extensibleTarget be ? IsExtensible(target).\n    let extensibleTarget = IsExtensible(realm, target);\n\n    // 11. If extensibleTarget is true, return true.\n    if (extensibleTarget) return true;\n\n    // 12. Let targetProto be ? target.[[GetPrototypeOf]]().\n    let targetProto = target.$GetPrototypeOf();\n\n    // 13. If SameValue(V, targetProto) is false, throw a TypeError exception.\n    if (!SameValue(realm, V, targetProto)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 14. Return true.\n    return true;\n  }\n\n  // ECMA262 9.5.3\n  $IsExtensible(): boolean {\n    let realm = this.realm;\n\n    // 1. Let handler be the value of the [[ProxyHandler]] internal slot of O.\n    let handler = this.$ProxyHandler;\n\n    // 2. If handler is null, throw a TypeError exception.\n    if (handler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 3. Assert: Type(handler) is Object.\n    invariant(handler instanceof ObjectValue, \"expected object\");\n\n    // 4. Let target be the value of the [[ProxyTarget]] internal slot of O.\n    let target = this.$ProxyTarget;\n\n    // 5. Let trap be ? GetMethod(handler, \"isExtensible\").\n    let trap = GetMethod(realm, handler, \"isExtensible\");\n\n    // 6. If trap is undefined, then\n    if (trap instanceof UndefinedValue) {\n      // a. Return ? target.[[IsExtensible]]().\n      invariant(target instanceof ObjectValue);\n      return target.$IsExtensible();\n    }\n\n    // 7. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target »)).\n    let booleanTrapResult = ToBooleanPartial(realm, Call(realm, trap, handler, [target]));\n\n    // 8. Let targetResult be ? target.[[IsExtensible]]().\n    invariant(target instanceof ObjectValue);\n    let targetResult = target.$IsExtensible();\n\n    // 9. If SameValue(booleanTrapResult, targetResult) is false, throw a TypeError exception.\n    if (booleanTrapResult !== targetResult) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 10. Return booleanTrapResult.\n    return booleanTrapResult;\n  }\n\n  // ECMA262 9.5.4\n  $PreventExtensions(): boolean {\n    let realm = this.realm;\n\n    // 1. Let handler be the value of the [[ProxyHandler]] internal slot of O.\n    let handler = this.$ProxyHandler;\n\n    // 2. If handler is null, throw a TypeError exception.\n    if (handler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 3. Assert: Type(handler) is Object.\n    invariant(handler instanceof ObjectValue, \"expected object\");\n\n    // 4. Let target be the value of the [[ProxyTarget]] internal slot of O.\n    let target = this.$ProxyTarget;\n\n    // 5. Let trap be ? GetMethod(handler, \"preventExtensions\").\n    let trap = GetMethod(realm, handler, \"preventExtensions\");\n\n    // 6. If trap is undefined, then\n    if (trap instanceof UndefinedValue) {\n      // a. Return ? target.[[PreventExtensions]]().\n      invariant(target instanceof ObjectValue);\n      return target.$PreventExtensions();\n    }\n\n    // 7. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target »)).\n    let booleanTrapResult = ToBooleanPartial(realm, Call(realm, trap, handler, [target]));\n\n    // 8. If booleanTrapResult is true, then\n    if (booleanTrapResult) {\n      // a. Let targetIsExtensible be ? target.[[IsExtensible]]().\n      invariant(target instanceof ObjectValue);\n      let targetIsExtensible = target.$IsExtensible();\n\n      // b. If targetIsExtensible is true, throw a TypeError exception.\n      if (targetIsExtensible) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n    }\n\n    // 9. Return booleanTrapResult.\n    return booleanTrapResult;\n  }\n\n  // ECMA262 9.5.5\n  $GetOwnProperty(P: PropertyKeyValue): Descriptor | void {\n    let realm = this.realm;\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(realm, P), \"expected property key\");\n\n    // 2. Let handler be the value of the [[ProxyHandler]] internal slot of O.\n    let handler = this.$ProxyHandler;\n\n    // 3. If handler is null, throw a TypeError exception.\n    if (handler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 4. Assert: Type(handler) is Object.\n    invariant(handler instanceof ObjectValue, \"expected object\");\n\n    // 5. Let target be the value of the [[ProxyTarget]] internal slot of O.\n    let target = this.$ProxyTarget;\n    invariant(target instanceof ObjectValue);\n\n    // 6. Let trap be ? GetMethod(handler, \"getOwnPropertyDescriptor\").\n    let trap = GetMethod(realm, handler, \"getOwnPropertyDescriptor\");\n\n    // 7. If trap is undefined, then\n    if (trap instanceof UndefinedValue) {\n      // a. Return ? target.[[GetOwnProperty]](P).\n      return target.$GetOwnProperty(P);\n    }\n\n    // 8. Let trapResultObj be ? Call(trap, handler, « target, P »).\n    let trapResultObj = Call(realm, trap, handler, [target, typeof P === \"string\" ? new StringValue(realm, P) : P]);\n\n    // 9. If Type(trapResultObj) is neither Object nor Undefined, throw a TypeError exception.\n    if (!(trapResultObj instanceof ObjectValue) && !(trapResultObj instanceof UndefinedValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 10. Let targetDesc be ? target.[[GetOwnProperty]](P).\n    let targetDesc = target.$GetOwnProperty(P);\n\n    // 11. If trapResultObj is undefined, then\n    if (trapResultObj instanceof UndefinedValue) {\n      // a. If targetDesc is undefined, return undefined.\n      if (!targetDesc) return undefined;\n      Properties.ThrowIfMightHaveBeenDeleted(targetDesc.value);\n\n      // b. If targetDesc.[[Configurable]] is false, throw a TypeError exception.\n      if (!targetDesc.configurable) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n\n      // c. Let extensibleTarget be ? IsExtensible(target).\n      let extensibleTarget = IsExtensible(realm, target);\n\n      // d. Assert: Type(extensibleTarget) is Boolean.\n      invariant(typeof extensibleTarget === \"boolean\", \"expected boolean\");\n\n      // e. If extensibleTarget is false, throw a TypeError exception.\n      if (!extensibleTarget) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n\n      // f. Return undefined.\n      return undefined;\n    }\n\n    // 12. Let extensibleTarget be ? IsExtensible(target).\n    let extensibleTarget = IsExtensible(realm, target);\n\n    // 13. Let resultDesc be ? ToPropertyDescriptor(trapResultObj).\n    let resultDesc = ToPropertyDescriptor(realm, trapResultObj);\n\n    // 14. Call CompletePropertyDescriptor(resultDesc).\n    Properties.CompletePropertyDescriptor(realm, resultDesc);\n\n    // 15. Let valid be IsCompatiblePropertyDescriptor(extensibleTarget, resultDesc, targetDesc).\n    let valid = Properties.IsCompatiblePropertyDescriptor(realm, extensibleTarget, resultDesc, targetDesc);\n\n    // 16. If valid is false, throw a TypeError exception.\n    if (!valid) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 17. If resultDesc.[[Configurable]] is false, then\n    if (!resultDesc.configurable) {\n      // a. If targetDesc is undefined or targetDesc.[[Configurable]] is true, then\n      if (!targetDesc || targetDesc.configurable) {\n        // i. Throw a TypeError exception.\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n    }\n\n    // 18. Return resultDesc.\n    return resultDesc;\n  }\n\n  // ECMA262 9.5.6\n  $DefineOwnProperty(P: PropertyKeyValue, Desc: Descriptor): boolean {\n    let realm = this.realm;\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(realm, P), \"expected property key\");\n\n    // 2. Let handler be the value of the [[ProxyHandler]] internal slot of O.\n    let handler = this.$ProxyHandler;\n\n    // 3. If handler is null, throw a TypeError exception.\n    if (handler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 4. Assert: Type(handler) is Object.\n    invariant(handler instanceof ObjectValue, \"expected object\");\n\n    // 5. Let target be the value of the [[ProxyTarget]] internal slot of O.\n    let target = this.$ProxyTarget;\n    invariant(target instanceof ObjectValue);\n\n    // 6. Let trap be ? GetMethod(handler, \"defineProperty\").\n    let trap = GetMethod(realm, handler, \"defineProperty\");\n\n    // 7. If trap is undefined, then\n    if (trap instanceof UndefinedValue) {\n      // a. Return ? target.[[DefineOwnProperty]](P, Desc).\n      return target.$DefineOwnProperty(P, Desc);\n    }\n\n    // 8. Let descObj be FromPropertyDescriptor(Desc).\n    let descObj = Properties.FromPropertyDescriptor(realm, Desc);\n\n    // 9. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target, P, descObj »)).\n    let booleanTrapResult = ToBooleanPartial(\n      realm,\n      Call(realm, trap, handler, [target, typeof P === \"string\" ? new StringValue(realm, P) : P, descObj])\n    );\n\n    // 10. If booleanTrapResult is false, return false.\n    if (!booleanTrapResult) return false;\n\n    // 11. Let targetDesc be ? target.[[GetOwnProperty]](P).\n    let targetDesc = target.$GetOwnProperty(P);\n\n    // 12. Let extensibleTarget be ? IsExtensible(target).\n    let extensibleTarget = IsExtensible(realm, target);\n\n    // 13. If Desc has a [[Configurable]] field and if Desc.[[Configurable]] is false, then\n    let settingConfigFalse;\n    if (\"configurable\" in Desc && !Desc.configurable) {\n      // a. Let settingConfigFalse be true.\n      settingConfigFalse = true;\n    } else {\n      // 14. Else let settingConfigFalse be false.\n      settingConfigFalse = false;\n    }\n\n    // 15. If targetDesc is undefined, then\n    if (!targetDesc) {\n      // a. If extensibleTarget is false, throw a TypeError exception.\n      if (!extensibleTarget) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n\n      // b. If settingConfigFalse is true, throw a TypeError exception.\n      if (settingConfigFalse) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n    } else {\n      // 16. Else targetDesc is not undefined,\n      Properties.ThrowIfMightHaveBeenDeleted(targetDesc.value);\n\n      // a. If IsCompatiblePropertyDescriptor(extensibleTarget, Desc, targetDesc) is false, throw a TypeError exception.\n      if (!Properties.IsCompatiblePropertyDescriptor(realm, extensibleTarget, Desc, targetDesc)) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n\n      // b. If settingConfigFalse is true and targetDesc.[[Configurable]] is true, throw a TypeError exception.\n      if (settingConfigFalse && targetDesc.configurable) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n    }\n\n    // 17. Return true.\n    return true;\n  }\n\n  // ECMA262 9.5.7\n  $HasProperty(P: PropertyKeyValue): boolean {\n    let realm = this.realm;\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(realm, P), \"expected property key\");\n\n    // 2. Let handler be the value of the [[ProxyHandler]] internal slot of O.\n    let handler = this.$ProxyHandler;\n\n    // 3. If handler is null, throw a TypeError exception.\n    if (handler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 4. Assert: Type(handler) is Object.\n    invariant(handler instanceof ObjectValue, \"expected object\");\n\n    // 5. Let target be the value of the [[ProxyTarget]] internal slot of O.\n    let target = this.$ProxyTarget;\n    invariant(target instanceof ObjectValue);\n\n    // 6. Let trap be ? GetMethod(handler, \"has\").\n    let trap = GetMethod(realm, handler, \"has\");\n\n    // 7. If trap is undefined, then\n    if (trap instanceof UndefinedValue) {\n      // a. Return ? target.[[HasProperty]](P).\n      return target.$HasProperty(P);\n    }\n\n    // 8. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target, P »)).\n    let booleanTrapResult = ToBooleanPartial(\n      realm,\n      Call(realm, trap, handler, [target, typeof P === \"string\" ? new StringValue(realm, P) : P])\n    );\n\n    // 9. If booleanTrapResult is false, then\n    if (!booleanTrapResult) {\n      // a. Let targetDesc be ? target.[[GetOwnProperty]](P).\n      let targetDesc = target.$GetOwnProperty(P);\n\n      // b. If targetDesc is not undefined, then\n      if (targetDesc) {\n        Properties.ThrowIfMightHaveBeenDeleted(targetDesc.value);\n\n        // i. If targetDesc.[[Configurable]] is false, throw a TypeError exception.\n        if (!targetDesc.configurable) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n        }\n\n        // ii. Let extensibleTarget be ? IsExtensible(target).\n        let extensibleTarget = IsExtensible(realm, target);\n\n        // iii. If extensibleTarget is false, throw a TypeError exception.\n        if (!extensibleTarget) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n        }\n      }\n    }\n\n    // 10. Return booleanTrapResult.\n    return booleanTrapResult;\n  }\n\n  // ECMA262 9.5.8\n  $Get(P: PropertyKeyValue, Receiver: Value): Value {\n    let realm = this.realm;\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(realm, P), \"expected property key\");\n\n    // 2. Let handler be the value of the [[ProxyHandler]] internal slot of O.\n    let handler = this.$ProxyHandler;\n\n    // 3. If handler is null, throw a TypeError exception.\n    if (handler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 4. Assert: Type(handler) is Object.\n    invariant(handler instanceof ObjectValue, \"expected object\");\n\n    // 5. Let target be the value of the [[ProxyTarget]] internal slot of O.\n    let target = this.$ProxyTarget;\n    invariant(target instanceof ObjectValue);\n\n    // 6. Let trap be ? GetMethod(handler, \"get\").\n    let trap = GetMethod(realm, handler, \"get\");\n\n    // 7. If trap is undefined, then\n    if (trap instanceof UndefinedValue) {\n      // a. Return ? target.[[Get]](P, Receiver).\n      return target.$Get(P, Receiver);\n    }\n\n    // 8. Let trapResult be ? Call(trap, handler, « target, P, Receiver »).\n    let trapResult = Call(realm, trap, handler, [\n      target,\n      typeof P === \"string\" ? new StringValue(realm, P) : P,\n      Receiver,\n    ]);\n\n    // 9. Let targetDesc be ? target.[[GetOwnProperty]](P).\n    let targetDesc = target.$GetOwnProperty(P);\n\n    // 10. If targetDesc is not undefined, then\n    if (targetDesc) {\n      Properties.ThrowIfMightHaveBeenDeleted(targetDesc.value);\n\n      // a. If IsDataDescriptor(targetDesc) is true and targetDesc.[[Configurable]] is false and targetDesc.[[Writable]] is false, then\n      if (IsDataDescriptor(realm, targetDesc) && targetDesc.configurable === false && targetDesc.writable === false) {\n        // i. If SameValue(trapResult, targetDesc.[[Value]]) is false, throw a TypeError exception.\n        let targetValue = targetDesc.value || realm.intrinsics.undefined;\n        invariant(targetValue instanceof Value);\n        if (!SameValuePartial(realm, trapResult, targetValue)) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n        }\n      }\n\n      // b. If IsAccessorDescriptor(targetDesc) is true and targetDesc.[[Configurable]] is false and targetDesc.[[Get]] is undefined, then\n      if (\n        IsAccessorDescriptor(realm, targetDesc) &&\n        targetDesc.configurable === false &&\n        (!targetDesc.get || targetDesc.get instanceof UndefinedValue)\n      ) {\n        // i. If trapResult is not undefined, throw a TypeError exception.\n        if (!(trapResult instanceof UndefinedValue)) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n        }\n      }\n    }\n\n    // 11. Return trapResult.\n    return trapResult;\n  }\n\n  // ECMA262 9.5.9\n  $Set(P: PropertyKeyValue, V: Value, Receiver: Value): boolean {\n    let realm = this.realm;\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(realm, P), \"expected property key\");\n\n    // 2. Let handler be the value of the [[ProxyHandler]] internal slot of O.\n    let handler = this.$ProxyHandler;\n\n    // 3. If handler is null, throw a TypeError exception.\n    if (handler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 4. Assert: Type(handler) is Object.\n    invariant(handler instanceof ObjectValue, \"expected object\");\n\n    // 5. Let target be the value of the [[ProxyTarget]] internal slot of O.\n    let target = this.$ProxyTarget;\n\n    // 6. Let trap be ? GetMethod(handler, \"set\").\n    let trap = GetMethod(realm, handler, \"set\");\n\n    // 7. If trap is undefined, then\n    if (trap instanceof UndefinedValue) {\n      // a. Return ? target.[[Set]](P, V, Receiver).\n      invariant(target instanceof ObjectValue);\n      return target.$Set(P, V, Receiver);\n    }\n\n    // 8. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target, P, V, Receiver »)).\n    let booleanTrapResult = ToBooleanPartial(\n      realm,\n      Call(realm, trap, handler, [target, typeof P === \"string\" ? new StringValue(realm, P) : P, V, Receiver])\n    );\n\n    // 9. If booleanTrapResult is false, return false.\n    if (!booleanTrapResult) return false;\n\n    // 10. Let targetDesc be ? target.[[GetOwnProperty]](P).\n    invariant(target instanceof ObjectValue);\n    let targetDesc = target.$GetOwnProperty(P);\n\n    // 11. If targetDesc is not undefined, then\n    if (targetDesc) {\n      Properties.ThrowIfMightHaveBeenDeleted(targetDesc.value);\n\n      // a. If IsDataDescriptor(targetDesc) is true and targetDesc.[[Configurable]] is false and targetDesc.[[Writable]] is false, then\n      if (IsDataDescriptor(realm, targetDesc) && !targetDesc.configurable && !targetDesc.writable) {\n        // i. If SameValue(V, targetDesc.[[Value]]) is false, throw a TypeError exception.\n        let targetValue = targetDesc.value || realm.intrinsics.undefined;\n        invariant(targetValue instanceof Value);\n        if (!SameValuePartial(realm, V, targetValue)) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n        }\n      }\n\n      // b. If IsAccessorDescriptor(targetDesc) is true and targetDesc.[[Configurable]] is false, then\n      if (IsAccessorDescriptor(realm, targetDesc) && !targetDesc.configurable) {\n        // i. If targetDesc.[[Set]] is undefined, throw a TypeError exception.\n        if (!targetDesc.set || targetDesc.set instanceof UndefinedValue) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n        }\n      }\n    }\n\n    // 12. Return true.\n    return true;\n  }\n\n  // ECMA262 9.5.10\n  $Delete(P: PropertyKeyValue): boolean {\n    let realm = this.realm;\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(realm, P), \"expected property key\");\n\n    // 2. Let handler be the value of the [[ProxyHandler]] internal slot of O.\n    let handler = this.$ProxyHandler;\n\n    // 3. If handler is null, throw a TypeError exception.\n    if (handler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 4. Assert: Type(handler) is Object.\n    invariant(handler instanceof ObjectValue, \"expected object\");\n\n    // 5. Let target be the value of the [[ProxyTarget]] internal slot of O.\n    let target = this.$ProxyTarget;\n\n    // 6. Let trap be ? GetMethod(handler, \"deleteProperty\").\n    let trap = GetMethod(realm, handler, \"deleteProperty\");\n\n    // 7. If trap is undefined, then\n    if (trap instanceof UndefinedValue) {\n      // a. Return ? target.[[Delete]](P).\n      invariant(target instanceof ObjectValue);\n      return target.$Delete(P);\n    }\n\n    // 8. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target, P »)).\n    let booleanTrapResult = ToBooleanPartial(\n      realm,\n      Call(realm, trap, handler, [target, typeof P === \"string\" ? new StringValue(realm, P) : P])\n    );\n\n    // 9. If booleanTrapResult is false, return false.\n    if (!booleanTrapResult) return false;\n\n    // 10. Let targetDesc be ? target.[[GetOwnProperty]](P).\n    invariant(target instanceof ObjectValue);\n    let targetDesc = target.$GetOwnProperty(P);\n\n    // 11. If targetDesc is undefined, return true.\n    if (!targetDesc) return true;\n    Properties.ThrowIfMightHaveBeenDeleted(targetDesc.value);\n\n    // 12. If targetDesc.[[Configurable]] is false, throw a TypeError exception.\n    if (!targetDesc.configurable) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 13. Return true.\n    return true;\n  }\n\n  // ECMA262 9.5.11\n  $OwnPropertyKeys(): Array<PropertyKeyValue> {\n    let realm = this.realm;\n\n    // 1. Let handler be the value of the [[ProxyHandler]] internal slot of O.\n    let handler = this.$ProxyHandler;\n\n    // 2. If handler is null, throw a TypeError exception.\n    if (handler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 3. Assert: Type(handler) is Object.\n    invariant(handler instanceof ObjectValue, \"expected object\");\n\n    // 4. Let target be the value of the [[ProxyTarget]] internal slot of O.\n    let target = this.$ProxyTarget;\n    invariant(target instanceof ObjectValue);\n\n    // 5. Let trap be ? GetMethod(handler, \"ownKeys\").\n    let trap = GetMethod(realm, handler, \"ownKeys\");\n\n    // 6. If trap is undefined, then\n    if (trap instanceof UndefinedValue) {\n      // a. Return ? target.[[OwnPropertyKeys]]().\n      return target.$OwnPropertyKeys();\n    }\n\n    // 7. Let trapResultArray be ? Call(trap, handler, « target »).\n    let trapResultArray = Call(realm, trap, handler, [target]);\n\n    // 8. Let trapResult be ? CreateListFromArrayLike(trapResultArray, « String, Symbol »).\n    let trapResult: Array<PropertyKeyValue> = ((CreateListFromArrayLike(realm, trapResultArray, [\n      \"String\",\n      \"Symbol\",\n    ]): any): Array<PropertyKeyValue>);\n\n    // 9. Let extensibleTarget be ? IsExtensible(target).\n    let extensibleTarget = IsExtensible(realm, target);\n\n    // 10. Let targetKeys be ? target.[[OwnPropertyKeys]]().\n    let targetKeys = target.$OwnPropertyKeys();\n\n    // 11. Assert: targetKeys is a List containing only String and Symbol values.\n    for (let key of targetKeys) {\n      invariant(key instanceof SymbolValue || key instanceof StringValue, \"expected string or symbol\");\n    }\n\n    // 12. Let targetConfigurableKeys be a new empty List.\n    let targetConfigurableKeys = [];\n\n    // 13. Let targetNonconfigurableKeys be a new empty List.\n    let targetNonconfigurableKeys = [];\n\n    // 14. Repeat, for each element key of targetKeys,\n    for (let key of targetKeys) {\n      // a. Let desc be ? target.[[GetOwnProperty]](key).\n      let desc = target.$GetOwnProperty(key);\n      if (desc) Properties.ThrowIfMightHaveBeenDeleted(desc.value);\n\n      // b. If desc is not undefined and desc.[[Configurable]] is false, then\n      if (desc && desc.configurable === false) {\n        // i. Append key as an element of targetNonconfigurableKeys.\n        targetNonconfigurableKeys.push(key);\n      } else {\n        // c. Else,\n        // i. Append key as an element of targetConfigurableKeys.\n        targetConfigurableKeys.push(key);\n      }\n    }\n\n    // 15. If extensibleTarget is true and targetNonconfigurableKeys is empty, then\n    if (extensibleTarget && !targetNonconfigurableKeys.length) {\n      // a. Return trapResult.\n      return trapResult;\n    }\n\n    // 16. Let uncheckedResultKeys be a new List which is a copy of trapResult.\n    let uncheckedResultKeys = trapResult.slice();\n\n    // 17. Repeat, for each key that is an element of targetNonconfigurableKeys,\n    for (let key of targetNonconfigurableKeys) {\n      // a. If key is not an element of uncheckedResultKeys, throw a TypeError exception.\n      let index = FindPropertyKey(realm, uncheckedResultKeys, key);\n      if (index < 0) {\n        throw realm.createErrorThrowCompletion(\n          realm.intrinsics.TypeError,\n          \"key is not an element of uncheckedResultKeys\"\n        );\n      }\n\n      // b. Remove key from uncheckedResultKeys.\n      uncheckedResultKeys.splice(index, 1);\n    }\n\n    // 18. If extensibleTarget is true, return trapResult.\n    if (extensibleTarget) return trapResult;\n\n    // 19. Repeat, for each key that is an element of targetConfigurableKeys,\n    for (let key of targetConfigurableKeys) {\n      // a. If key is not an element of uncheckedResultKeys, throw a TypeError exception.\n      let index = FindPropertyKey(realm, uncheckedResultKeys, key);\n      if (index < 0) {\n        throw realm.createErrorThrowCompletion(\n          realm.intrinsics.TypeError,\n          \"key is not an element of uncheckedResultKeys\"\n        );\n      }\n\n      // b. Remove key from uncheckedResultKeys.\n      uncheckedResultKeys.splice(index, 1);\n    }\n\n    // 20. If uncheckedResultKeys is not empty, throw a TypeError exception.\n    if (uncheckedResultKeys.length) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 21. Return trapResult.\n    return trapResult;\n  }\n}\n"]}