{"version":3,"sources":["../../src/values/IntegerIndexedExotic.js"],"names":["IntegerIndexedExotic","realm","intrinsicName","intrinsics","ObjectPrototype","P","O","$Realm","$ViewedArrayBuffer","numericIndex","undefined","value","writable","enumerable","configurable","OrdinaryGetOwnProperty","buffer","createErrorThrowCompletion","TypeError","Object","is","$ArrayLength","Desc","length","OrdinaryDefineOwnProperty","Receiver","V","OrdinarySet","keys","$ByteOffset","$TypedArrayName","len","i","push","properties","getOwnPropertyKeysArray","filter","x","key","symbols"],"mappings":"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","file":"IntegerIndexedExotic.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { PropertyKeyValue, Descriptor } from \"../types.js\";\nimport { ObjectValue, NumberValue, StringValue, Value, UndefinedValue } from \"../values/index.js\";\nimport { CanonicalNumericIndexString, ToString } from \"../methods/to.js\";\nimport { IsInteger, IsArrayIndex, IsAccessorDescriptor, IsDetachedBuffer, IsPropertyKey } from \"../methods/is.js\";\nimport { OrdinaryGet } from \"../methods/get.js\";\nimport { OrdinaryHasProperty } from \"../methods/has.js\";\nimport { IntegerIndexedElementSet, IntegerIndexedElementGet } from \"../methods/typedarray.js\";\nimport { Properties } from \"../singletons.js\";\nimport invariant from \"../invariant\";\n\nexport default class IntegerIndexedExotic extends ObjectValue {\n  constructor(realm: Realm, intrinsicName?: string) {\n    super(realm, realm.intrinsics.ObjectPrototype, intrinsicName);\n  }\n\n  // ECMA262 9.4.5.1\n  $GetOwnProperty(P: PropertyKeyValue): Descriptor | void {\n    let O = this;\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(this.$Realm, P), \"IsPropertyKey(P) is true\");\n\n    // 2. Assert: O is an Object that has a [[ViewedArrayBuffer]] internal slot.\n    invariant(O instanceof ObjectValue && O.$ViewedArrayBuffer);\n\n    // 3. If Type(P) is String, then\n    if (typeof P === \"string\" || P instanceof StringValue) {\n      // a. Let numericIndex be ! CanonicalNumericIndexString(P).\n      let numericIndex = CanonicalNumericIndexString(\n        this.$Realm,\n        typeof P === \"string\" ? new StringValue(this.$Realm, P) : P\n      );\n\n      // b. If numericIndex is not undefined, then\n      if (numericIndex !== undefined) {\n        // i. Let value be ? IntegerIndexedElementGet(O, numericIndex).\n        let value = IntegerIndexedElementGet(this.$Realm, O, numericIndex);\n\n        // ii. If value is undefined, return undefined.\n        if (value instanceof UndefinedValue) return undefined;\n\n        // iii. Return a PropertyDescriptor{[[Value]]: value, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: false}.\n        return {\n          value: value,\n          writable: true,\n          enumerable: true,\n          configurable: false,\n        };\n      }\n    }\n    // 4. Return OrdinaryGetOwnProperty(O, P).\n    return Properties.OrdinaryGetOwnProperty(this.$Realm, O, P);\n  }\n\n  // ECMA262 9.4.5.2\n  $HasProperty(P: PropertyKeyValue): boolean {\n    let O = this;\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(this.$Realm, P), \"IsPropertyKey(P) is true\");\n\n    // 2. Assert: O is an Object that has a [[ViewedArrayBuffer]] internal slot.\n    invariant(O instanceof ObjectValue && O.$ViewedArrayBuffer);\n\n    // 3. If Type(P) is String, then\n    if (typeof P === \"string\" || P instanceof StringValue) {\n      // a. Let numericIndex be ! CanonicalNumericIndexString(P).\n      let numericIndex = CanonicalNumericIndexString(\n        this.$Realm,\n        typeof P === \"string\" ? new StringValue(this.$Realm, P) : P\n      );\n\n      // b. If numericIndex is not undefined, then\n      if (numericIndex !== undefined) {\n        // i. Let buffer be O.[[ViewedArrayBuffer]].\n        let buffer = O.$ViewedArrayBuffer;\n        invariant(buffer);\n\n        // ii. If IsDetachedBuffer(buffer) is true, throw a TypeError exception.\n        if (IsDetachedBuffer(this.$Realm, buffer) === true) {\n          throw this.$Realm.createErrorThrowCompletion(\n            this.$Realm.intrinsics.TypeError,\n            \"IsDetachedBuffer(buffer) is true\"\n          );\n        }\n\n        // iii. If IsInteger(numericIndex) is false, return false.\n        if (IsInteger(this.$Realm, numericIndex) === false) return false;\n\n        // iv. If numericIndex = -0, return false.\n        if (Object.is(numericIndex, -0)) return false;\n\n        // v. If numericIndex < 0, return false.\n        if (numericIndex < 0) return false;\n\n        // vi. If numericIndex ≥ O.[[ArrayLength]], return false.\n        invariant(O.$ArrayLength);\n        if (numericIndex >= O.$ArrayLength) return false;\n\n        // vii. Return true.\n        return true;\n      }\n    }\n\n    // 4. Return ? OrdinaryHasProperty(O, P).\n    return OrdinaryHasProperty(this.$Realm, O, P);\n  }\n\n  // ECMA262 9.4.5.3\n  $DefineOwnProperty(P: PropertyKeyValue, Desc: Descriptor): boolean {\n    let O = this;\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(this.$Realm, P), \"IsPropertyKey(P) is true\");\n\n    // 2. Assert: O is an Object that has a [[ViewedArrayBuffer]] internal slot.\n    invariant(O instanceof ObjectValue && this.$ViewedArrayBuffer);\n\n    // 3. If Type(P) is String, then\n    if (typeof P === \"string\" || P instanceof StringValue) {\n      // a. Let numericIndex be ! CanonicalNumericIndexString(P).\n      let numericIndex = CanonicalNumericIndexString(\n        this.$Realm,\n        typeof P === \"string\" ? new StringValue(this.$Realm, P) : P\n      );\n\n      // b. If numericIndex is not undefined, then\n      if (numericIndex !== undefined) {\n        // i. If IsInteger(numericIndex) is false, return false.\n        if (IsInteger(this.$Realm, numericIndex) === false) return false;\n\n        // ii. If numericIndex = -0, return false.\n        if (Object.is(numericIndex, -0)) return false;\n\n        // iii. If numericIndex < 0, return false.\n        if (numericIndex < 0) return false;\n\n        // iv. Let length be O.[[ArrayLength]].\n        let length = this.$ArrayLength;\n        invariant(typeof length === \"number\");\n\n        // v. If numericIndex ≥ length, return false.\n        if (numericIndex >= length) return false;\n\n        // vi. If IsAccessorDescriptor(Desc) is true, return false.\n        if (IsAccessorDescriptor(this.$Realm, Desc) === true) return false;\n\n        // vii. If Desc has a [[Configurable]] field and if Desc.[[Configurable]] is true, return false.\n        if (Desc.configurable === true) return false;\n\n        // viii. If Desc has an [[Enumerable]] field and if Desc.[[Enumerable]] is false, return false.\n        if (Desc.enumerable === false) return false;\n\n        // ix. If Desc has a [[Writable]] field and if Desc.[[Writable]] is false, return false.\n        if (Desc.writable === false) return false;\n\n        // x. If Desc has a [[Value]] field, then\n        if (Desc.value) {\n          // 1. Let value be Desc.[[Value]].\n          let value = Desc.value;\n          invariant(value === undefined || value instanceof Value);\n\n          // 2. Return ? IntegerIndexedElementSet(O, numericIndex, value).\n          return IntegerIndexedElementSet(this.$Realm, O, numericIndex, value);\n        }\n\n        // xi. Return true.\n        return true;\n      }\n    }\n\n    // 4. Return ! OrdinaryDefineOwnProperty(O, P, Desc).\n    return Properties.OrdinaryDefineOwnProperty(this.$Realm, O, P, Desc);\n  }\n\n  // ECMA262 9.4.5.4\n  $Get(P: PropertyKeyValue, Receiver: Value): Value {\n    let O = this;\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(this.$Realm, P), \"IsPropertyKey(P) is true\");\n\n    // 2. If Type(P) is String, then\n    if (typeof P === \"string\" || P instanceof StringValue) {\n      // a. Let numericIndex be ! CanonicalNumericIndexString(P).\n      let numericIndex = CanonicalNumericIndexString(\n        this.$Realm,\n        typeof P === \"string\" ? new StringValue(this.$Realm, P) : P\n      );\n\n      // b. If numericIndex is not undefined, then\n      if (numericIndex !== undefined) {\n        // i. Return ? IntegerIndexedElementGet(O, numericIndex).\n        return IntegerIndexedElementGet(this.$Realm, O, numericIndex);\n      }\n    }\n\n    // 3. Return ? OrdinaryGet(O, P, Receiver).\n    return OrdinaryGet(this.$Realm, O, P, Receiver);\n  }\n\n  // ECMA262 9.4.5.5\n  $Set(P: PropertyKeyValue, V: Value, Receiver: Value): boolean {\n    let O = this;\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(this.$Realm, P), \"IsPropertyKey(P) is true\");\n\n    // 2. If Type(P) is String, then\n    if (typeof P === \"string\" || P instanceof StringValue) {\n      // a. Let numericIndex be ! CanonicalNumericIndexString(P).\n      let numericIndex = CanonicalNumericIndexString(\n        this.$Realm,\n        typeof P === \"string\" ? new StringValue(this.$Realm, P) : P\n      );\n\n      // b. If numericIndex is not undefined, then\n      if (numericIndex !== undefined) {\n        // i. Return ? IntegerIndexedElementSet(O, numericIndex, V).\n        return IntegerIndexedElementSet(this.$Realm, O, numericIndex, V);\n      }\n    }\n\n    // 3. Return ? OrdinarySet(O, P, V, Receiver).\n    return Properties.OrdinarySet(this.$Realm, O, P, V, Receiver);\n  }\n\n  // ECMA262 9.4.5.6\n  $OwnPropertyKeys(): Array<PropertyKeyValue> {\n    let O = this;\n\n    // 1. Let keys be a new empty List.\n    let keys = [];\n\n    // 2. Assert: O is an Object that has [[ViewedArrayBuffer]], [[ArrayLength]], [[ByteOffset]], and [[TypedArrayName]] internal slots.\n    invariant(\n      O instanceof ObjectValue &&\n        O.$ViewedArrayBuffer &&\n        O.$ArrayLength !== undefined &&\n        O.$ByteOffset !== undefined &&\n        O.$TypedArrayName\n    );\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. For each integer i starting with 0 such that i < len, in ascending order,\n    for (let i = 0; i < len; ++i) {\n      // a. Add ! ToString(i) as the last element of keys.\n      keys.push(new StringValue(this.$Realm, ToString(this.$Realm, new NumberValue(this.$Realm, i))));\n    }\n\n    // 5. For each own property key P of O such that Type(P) is String and P is not an integer index, in ascending chronological order of property creation\n    let properties = O.getOwnPropertyKeysArray();\n    for (let key of properties.filter(x => !IsArrayIndex(this.$Realm, x))) {\n      // i. Add P as the last element of keys.\n      keys.push(new StringValue(this.$Realm, key));\n    }\n\n    // 6. For each own property key P of O such that Type(P) is Symbol, in ascending chronological order of property creation\n    for (let key of O.symbols.keys()) {\n      // a. Add P as the last element of keys.\n      keys.push(key);\n    }\n\n    // 7. Return keys.\n    return keys;\n  }\n}\n"]}