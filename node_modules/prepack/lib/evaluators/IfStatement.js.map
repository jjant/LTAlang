{"version":3,"sources":["../../src/evaluators/IfStatement.js"],"names":["evaluate","evaluateWithAbstractConditional","ast","strictCode","env","realm","exprRef","test","exprValue","GetConditionValue","stmtCompletion","evaluateCompletion","consequent","alternate","intrinsics","undefined","mightNotBeTrue","mightNotBeFalse","condValue","withCondition","evaluateNodeForEffects","compl1","gen1","bindings1","properties1","createdObj1","withInverseCondition","compl2","gen2","bindings2","properties2","createdObj2","joinedEffects","joinEffects","completion","composeWithSavedCompletion","applyEffects"],"mappings":"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","file":"IfStatement.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { AbruptCompletion, PossiblyNormalCompletion } from \"../completions.js\";\nimport type { Realm } from \"../realm.js\";\nimport { construct_empty_effects } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { AbstractValue, ConcreteValue, Value } from \"../values/index.js\";\nimport { Reference } from \"../environment.js\";\nimport { ToBoolean, UpdateEmpty } from \"../methods/index.js\";\nimport type { BabelNode, BabelNodeIfStatement } from \"babel-types\";\nimport invariant from \"../invariant.js\";\nimport { Environment, Join, Path } from \"../singletons.js\";\n\nexport function evaluate(ast: BabelNodeIfStatement, strictCode: boolean, env: LexicalEnvironment, realm: Realm): Value {\n  // 1. Let exprRef be the result of evaluating Expression\n  let exprRef = env.evaluate(ast.test, strictCode);\n  // 2. Let exprValue be ToBoolean(? GetValue(exprRef))\n  let exprValue: Value = Environment.GetConditionValue(realm, exprRef);\n\n  if (exprValue instanceof ConcreteValue) {\n    let stmtCompletion;\n    if (ToBoolean(realm, exprValue)) {\n      // 3.a. Let stmtCompletion be the result of evaluating the first Statement\n      stmtCompletion = env.evaluateCompletion(ast.consequent, strictCode);\n    } else {\n      if (ast.alternate)\n        // 4.a. Let stmtCompletion be the result of evaluating the second Statement\n        stmtCompletion = env.evaluateCompletion(ast.alternate, strictCode);\n      else\n        // 3 (of the if only statement). Return NormalCompletion(undefined)\n        stmtCompletion = realm.intrinsics.undefined;\n    }\n    // 5. Return Completion(UpdateEmpty(stmtCompletion, undefined)\n    //if (stmtCompletion instanceof Reference) return stmtCompletion;\n    invariant(!(stmtCompletion instanceof Reference));\n    stmtCompletion = UpdateEmpty(realm, stmtCompletion, realm.intrinsics.undefined);\n    if (stmtCompletion instanceof AbruptCompletion) {\n      throw stmtCompletion;\n    }\n    invariant(stmtCompletion instanceof Value);\n    return stmtCompletion;\n  }\n  invariant(exprValue instanceof AbstractValue);\n\n  if (!exprValue.mightNotBeTrue()) {\n    let stmtCompletion = env.evaluate(ast.consequent, strictCode);\n    invariant(!(stmtCompletion instanceof Reference));\n    stmtCompletion = UpdateEmpty(realm, stmtCompletion, realm.intrinsics.undefined);\n    if (stmtCompletion instanceof AbruptCompletion) {\n      throw stmtCompletion;\n    }\n    invariant(stmtCompletion instanceof Value);\n    return stmtCompletion;\n  } else if (!exprValue.mightNotBeFalse()) {\n    let stmtCompletion;\n    if (ast.alternate) stmtCompletion = env.evaluate(ast.alternate, strictCode);\n    else stmtCompletion = realm.intrinsics.undefined;\n    invariant(!(stmtCompletion instanceof Reference));\n    stmtCompletion = UpdateEmpty(realm, stmtCompletion, realm.intrinsics.undefined);\n    if (stmtCompletion instanceof AbruptCompletion) {\n      throw stmtCompletion;\n    }\n    invariant(stmtCompletion instanceof Value);\n    return stmtCompletion;\n  } else {\n    invariant(exprValue instanceof AbstractValue);\n    return evaluateWithAbstractConditional(exprValue, ast.consequent, ast.alternate, strictCode, env, realm);\n  }\n}\n\nexport function evaluateWithAbstractConditional(\n  condValue: AbstractValue,\n  consequent: BabelNode,\n  alternate: ?BabelNode,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  // Evaluate consequent and alternate in sandboxes and get their effects.\n  let [compl1, gen1, bindings1, properties1, createdObj1] = Path.withCondition(condValue, () => {\n    return realm.evaluateNodeForEffects(consequent, strictCode, env);\n  });\n\n  let [compl2, gen2, bindings2, properties2, createdObj2] = Path.withInverseCondition(condValue, () => {\n    return alternate ? realm.evaluateNodeForEffects(alternate, strictCode, env) : construct_empty_effects(realm);\n  });\n\n  // Join the effects, creating an abstract view of what happened, regardless\n  // of the actual value of condValue.\n  let joinedEffects = Join.joinEffects(\n    realm,\n    condValue,\n    [compl1, gen1, bindings1, properties1, createdObj1],\n    [compl2, gen2, bindings2, properties2, createdObj2]\n  );\n  let completion = joinedEffects[0];\n  if (completion instanceof PossiblyNormalCompletion) {\n    // in this case one of the branches may complete abruptly, which means that\n    // not all control flow branches join into one flow at this point.\n    // Consequently we have to continue tracking changes until the point where\n    // all the branches come together into one.\n    completion = realm.composeWithSavedCompletion(completion);\n  }\n  // Note that the effects of (non joining) abrupt branches are not included\n  // in joinedEffects, but are tracked separately inside completion.\n  realm.applyEffects(joinedEffects);\n\n  // return or throw completion\n  if (completion instanceof AbruptCompletion) throw completion;\n  invariant(completion instanceof Value);\n  return completion;\n}\n"]}