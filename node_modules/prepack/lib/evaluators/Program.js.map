{"version":3,"sources":["../../src/evaluators/Program.js"],"names":["GlobalDeclarationInstantiation","ast","strictCode","env","realm","val","body","node","type","res","evaluateCompletionDeref","useAbstractInterpretation","incorporateSavedCompletion","emitConditionalThrow","joinCondition","consequent","alternate","value","emitThrow","intrinsics","undefined","directives","length","directive","evaluate","stopEffectCaptureJoinApplyAndReturnCompletion","empty","generator","emitStatement","argument","t","throwStatement","condition","trueBranch","falseBranch","deconstruct","args","buildfunc","targs","tfunc","fargs","ffunc","emptyStatement","concat","func","ifStatement","nodes","splice","getRunningContext","isStrict","envRec","environmentRecord","lexNames","varNames","kind","BoundNames","name","HasVarDeclaration","createErrorThrowCompletion","SyntaxError","HasLexicalDeclaration","hasRestrictedGlobal","HasRestrictedGlobalProperty","varDeclarations","FindVarScopedDeclarations","functionsToInitialize","declaredFunctionNames","reverse","d","fn","indexOf","fnDefinable","CanDeclareGlobalFunction","TypeError","push","unshift","declaredVarNames","vn","vnDefinable","CanDeclareGlobalVar","lexDeclarations","s","dn","CreateImmutableBinding","CreateMutableBinding","f","fo","CreateGlobalFunctionBinding","CreateGlobalVarBinding"],"mappings":"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","file":"Program.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport {\n  AbruptCompletion,\n  Completion,\n  JoinedAbruptCompletions,\n  PossiblyNormalCompletion,\n  ReturnCompletion,\n  ThrowCompletion,\n} from \"../completions.js\";\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { AbstractValue, Value, EmptyValue } from \"../values/index.js\";\nimport { GlobalEnvironmentRecord } from \"../environment.js\";\nimport { Environment, Functions, Join } from \"../singletons.js\";\nimport IsStrict from \"../utils/strict.js\";\nimport invariant from \"../invariant.js\";\nimport traverseFast from \"../utils/traverse-fast.js\";\nimport type { BabelNodeProgram } from \"babel-types\";\nimport * as t from \"babel-types\";\n\n// ECMA262 15.1.11\nexport function GlobalDeclarationInstantiation(\n  realm: Realm,\n  ast: BabelNodeProgram,\n  env: LexicalEnvironment,\n  strictCode: boolean\n) {\n  realm.getRunningContext().isStrict = realm.isStrict = strictCode;\n\n  // 1. Let envRec be env's EnvironmentRecord.\n  let envRec = env.environmentRecord;\n\n  // 2. Assert: envRec is a global Environment Record.\n  invariant(envRec instanceof GlobalEnvironmentRecord, \"expected global environment record\");\n\n  // 3. Let lexNames be the LexicallyDeclaredNames of script.\n  let lexNames = [];\n\n  // 4. Let varNames be the VarDeclaredNames of script.\n  let varNames = [];\n\n  traverseFast(ast, node => {\n    if (node.type === \"VariableDeclaration\") {\n      if (node.kind === \"var\") {\n        varNames = varNames.concat(Environment.BoundNames(realm, node));\n      } else {\n        lexNames = lexNames.concat(Environment.BoundNames(realm, node));\n      }\n    } else if (node.type === \"FunctionExpression\" || node.type === \"FunctionDeclaration\") {\n      return true;\n    }\n    return false;\n  });\n\n  // 5. For each name in lexNames, do\n  for (let name of lexNames) {\n    // a. If envRec.HasVarDeclaration(name) is true, throw a SyntaxError exception.\n    if (envRec.HasVarDeclaration(name)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, name + \" already declared with var\");\n    }\n\n    // b. If envRec.HasLexicalDeclaration(name) is true, throw a SyntaxError exception.\n    if (envRec.HasLexicalDeclaration(name)) {\n      throw realm.createErrorThrowCompletion(\n        realm.intrinsics.SyntaxError,\n        name + \" already declared with let or const\"\n      );\n    }\n\n    // c. Let hasRestrictedGlobal be ? envRec.HasRestrictedGlobalProperty(name).\n    let hasRestrictedGlobal = envRec.HasRestrictedGlobalProperty(name);\n\n    // d. If hasRestrictedGlobal is true, throw a SyntaxError exception.\n    if (hasRestrictedGlobal) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, name + \" global object is restricted\");\n    }\n  }\n\n  // 6. For each name in varNames, do\n  for (let name of varNames) {\n    // a. If envRec.HasLexicalDeclaration(name) is true, throw a SyntaxError exception.\n    if (envRec.HasLexicalDeclaration(name)) {\n      throw realm.createErrorThrowCompletion(\n        realm.intrinsics.SyntaxError,\n        name + \" already declared with let or const\"\n      );\n    }\n  }\n\n  // 7. Let varDeclarations be the VarScopedDeclarations of script.\n  let varDeclarations = Functions.FindVarScopedDeclarations(ast);\n\n  // 8. Let functionsToInitialize be a new empty List.\n  let functionsToInitialize = [];\n\n  // 9. Let declaredFunctionNames be a new empty List.\n  let declaredFunctionNames = [];\n\n  // 10. For each d in varDeclarations, in reverse list order do\n  for (let d of varDeclarations.reverse()) {\n    // a. If d is neither a VariableDeclaration or a ForBinding, then\n    if (d.type !== \"VariableDeclaration\") {\n      // i. Assert: d is either a FunctionDeclaration or a GeneratorDeclaration.\n      invariant(d.type === \"FunctionDeclaration\", \"expected function\");\n\n      // ii. NOTE If there are multiple FunctionDeclarations for the same name, the last declaration is used.\n\n      // iii. Let fn be the sole element of the BoundNames of d.\n      let fn = Environment.BoundNames(realm, d)[0];\n\n      // iv. If fn is not an element of declaredFunctionNames, then\n      if (declaredFunctionNames.indexOf(fn) < 0) {\n        // 1. Let fnDefinable be ? envRec.CanDeclareGlobalFunction(fn).\n        let fnDefinable = envRec.CanDeclareGlobalFunction(fn);\n\n        // 2. If fnDefinable is false, throw a TypeError exception.\n        if (!fnDefinable) {\n          throw realm.createErrorThrowCompletion(\n            realm.intrinsics.TypeError,\n            fn + \": global function declarations are not allowed\"\n          );\n        }\n\n        // 3. Append fn to declaredFunctionNames.\n        declaredFunctionNames.push(fn);\n\n        // 4. Insert d as the first element of functionsToInitialize.\n        functionsToInitialize.unshift(d);\n      }\n    }\n  }\n\n  // 11. Let declaredVarNames be a new empty List.\n  let declaredVarNames = [];\n\n  // 12. For each d in varDeclarations, do\n  for (let d of varDeclarations) {\n    // a. If d is a VariableDeclaration or a ForBinding, then\n    if (d.type === \"VariableDeclaration\") {\n      // i. For each String vn in the BoundNames of d, do\n      for (let vn of Environment.BoundNames(realm, d)) {\n        // ii. If vn is not an element of declaredFunctionNames, then\n        if (declaredFunctionNames.indexOf(vn) < 0) {\n          // 1. Let vnDefinable be ? envRec.CanDeclareGlobalVar(vn).\n          let vnDefinable = envRec.CanDeclareGlobalVar(vn);\n\n          // 2. If vnDefinable is false, throw a TypeError exception.\n          if (!vnDefinable) {\n            throw realm.createErrorThrowCompletion(\n              realm.intrinsics.TypeError,\n              vn + \": global variable declarations are not allowed\"\n            );\n          }\n\n          // 3. If vn is not an element of declaredVarNames, then\n          if (declaredVarNames.indexOf(vn) < 0) {\n            // a. Append vn to declaredVarNames.\n            declaredVarNames.push(vn);\n          }\n        }\n      }\n    }\n  }\n\n  // 13. NOTE: No abnormal terminations occur after this algorithm step if the global object is an ordinary object. However, if the global object is a Proxy exotic object it may exhibit behaviours that cause abnormal terminations in some of the following steps.\n\n  // 14. NOTE: Annex B.3.3.2 adds additional steps at this point.\n\n  // 15. Let lexDeclarations be the LexicallyScopedDeclarations of script.\n  let lexDeclarations = [];\n  for (let s of ast.body) {\n    if (s.type === \"VariableDeclaration\" && s.kind !== \"var\") {\n      lexDeclarations.push(s);\n    }\n  }\n\n  // 16. For each element d in lexDeclarations do\n  for (let d of lexDeclarations) {\n    // a. NOTE Lexically declared names are only instantiated here but not initialized.\n\n    // b. For each element dn of the BoundNames of d do\n    for (let dn of Environment.BoundNames(realm, d)) {\n      // i. If IsConstantDeclaration of d is true, then\n      if (d.kind === \"const\") {\n        // 1. Perform ? envRec.CreateImmutableBinding(dn, true).\n        envRec.CreateImmutableBinding(dn, true);\n      } else {\n        // ii. Else,\n        // 1. Perform ? envRec.CreateMutableBinding(dn, false).\n        envRec.CreateMutableBinding(dn, false);\n      }\n    }\n  }\n\n  // 17. For each production f in functionsToInitialize, do\n  for (let f of functionsToInitialize) {\n    // a. Let fn be the sole element of the BoundNames of f.\n    let fn = Environment.BoundNames(realm, f)[0];\n\n    // b. Let fo be the result of performing InstantiateFunctionObject for f with argument env.\n    let fo = env.evaluate(f, strictCode);\n    invariant(fo instanceof Value);\n\n    // c. Perform ? envRec.CreateGlobalFunctionBinding(fn, fo, false).\n    envRec.CreateGlobalFunctionBinding(fn, fo, false);\n  }\n\n  // 18. For each String vn in declaredVarNames, in list order do\n  for (let vn of declaredVarNames) {\n    // a. Perform ? envRec.CreateGlobalVarBinding(vn, false).\n    envRec.CreateGlobalVarBinding(vn, false);\n  }\n\n  // 19. Return NormalCompletion(empty).\n  return realm.intrinsics.empty;\n}\n\nexport default function(ast: BabelNodeProgram, strictCode: boolean, env: LexicalEnvironment, realm: Realm): Value {\n  strictCode = IsStrict(ast);\n\n  GlobalDeclarationInstantiation(realm, ast, env, strictCode);\n\n  let val;\n\n  for (let node of ast.body) {\n    if (node.type !== \"FunctionDeclaration\") {\n      let res = env.evaluateCompletionDeref(node, strictCode);\n      if (res instanceof AbruptCompletion) {\n        if (!realm.useAbstractInterpretation) throw res;\n        // We are about the leave this program and this presents a join point where all non exeptional control flows\n        // converge into a single flow using the joined effects as the new state.\n        res = Functions.incorporateSavedCompletion(realm, res);\n        // The call to incorporateSavedCompletion above, has taken care of the join because res is abrupt.\n        // What remains to be done is to emit throw statements to the generator.\n        if (res instanceof JoinedAbruptCompletions) {\n          emitConditionalThrow(res.joinCondition, res.consequent, res.alternate);\n          res = res.value;\n        } else if (res instanceof ThrowCompletion) {\n          emitThrow(res.value);\n          res = realm.intrinsics.undefined;\n        } else {\n          invariant(false); // other kinds of abrupt completions should not get this far\n        }\n      }\n      if (!(res instanceof EmptyValue)) {\n        val = res;\n      }\n    }\n  }\n  let directives = ast.directives;\n  if (!val && directives && directives.length) {\n    let directive = directives[directives.length - 1];\n    val = env.evaluate(directive, strictCode);\n    invariant(val instanceof Value);\n  }\n\n  // We are about to leave this program and this presents a join point where all control flows\n  // converge into a single flow and the joined effects become the final state.\n  if (val instanceof Value) {\n    val = Functions.incorporateSavedCompletion(realm, val);\n    if (val instanceof PossiblyNormalCompletion) {\n      // There are still some conditional throws to emit and state still has to be joined in.\n      Join.stopEffectCaptureJoinApplyAndReturnCompletion(val, new ReturnCompletion(realm.intrinsics.undefined), realm);\n      // The global state has now been updated to the join of all the flows reaching this join point\n      emitConditionalThrow(val.joinCondition, val.consequent, val.alternate);\n      val = val.value;\n    }\n  } else {\n    // program was empty. Nothing to do.\n  }\n\n  invariant(val === undefined || val instanceof Value);\n  return val || realm.intrinsics.empty;\n\n  function emitThrow(value: Value) {\n    let generator = realm.generator;\n    invariant(generator !== undefined);\n    generator.emitStatement([value], ([argument]) => t.throwStatement(argument));\n  }\n\n  function emitConditionalThrow(\n    condition: AbstractValue,\n    trueBranch: Completion | Value,\n    falseBranch: Completion | Value\n  ) {\n    let generator = realm.generator;\n    invariant(generator !== undefined);\n    let [args, buildfunc] = deconstruct(condition, trueBranch, falseBranch);\n    generator.emitStatement(args, buildfunc);\n  }\n\n  function deconstruct(condition: AbstractValue, trueBranch: Completion | Value, falseBranch: Completion | Value) {\n    let targs;\n    let tfunc;\n    let fargs;\n    let ffunc;\n    if (trueBranch instanceof JoinedAbruptCompletions) {\n      [targs, tfunc] = deconstruct(trueBranch.joinCondition, trueBranch.consequent, trueBranch.alternate);\n    } else if (trueBranch instanceof ThrowCompletion) {\n      targs = [trueBranch.value];\n      tfunc = ([argument]) => t.throwStatement(argument);\n    } else {\n      targs = [];\n      tfunc = nodes => t.emptyStatement();\n    }\n    if (falseBranch instanceof JoinedAbruptCompletions) {\n      [fargs, ffunc] = deconstruct(falseBranch.joinCondition, falseBranch.consequent, falseBranch.alternate);\n    } else if (falseBranch instanceof ThrowCompletion) {\n      fargs = [falseBranch.value];\n      ffunc = ([argument]) => t.throwStatement(argument);\n    } else {\n      fargs = [];\n      ffunc = nodes => t.emptyStatement();\n    }\n    let args = [condition].concat(targs).concat(fargs);\n    let func = nodes => {\n      return t.ifStatement(\n        nodes[0],\n        tfunc(nodes.splice(1, targs.length)),\n        ffunc(nodes.splice(targs.length + 1, fargs.length))\n      );\n    };\n    return [args, func];\n  }\n}\n"]}