"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Copyright (c) 2017-present, Facebook, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * This source code is licensed under the BSD-style license found in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * LICENSE file in the root directory of this source tree. An additional grant
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * of patent rights can be found in the PATENTS file in the same directory.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */

exports.default = function (ast, strictCode, env, realm) {
  if (ast.callee.type === "Super") {
    return (0, _SuperCall2.default)(ast.arguments, strictCode, env, realm);
  }

  // ECMA262 12.3.4.1
  realm.setNextExecutionContextLocation(ast.loc);

  // 1. Let ref be the result of evaluating MemberExpression.
  var ref = env.evaluate(ast.callee, strictCode);

  // 2. Let func be ? GetValue(ref).
  var func = _singletons.Environment.GetValue(realm, ref);

  return EvaluateCall(ref, func, ast, strictCode, env, realm);
};

var _errors = require("../errors.js");

var _completions = require("../completions.js");

var _environment = require("../environment.js");

var _index = require("../values/index.js");

var _singletons = require("../singletons.js");

var _index2 = require("../methods/index.js");

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

var _SuperCall = require("./SuperCall");

var _SuperCall2 = _interopRequireDefault(_SuperCall);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function callBothFunctionsAndJoinTheirEffects(args, ast, strictCode, env, realm) {
  var _args = _slicedToArray(args, 3),
      cond = _args[0],
      func1 = _args[1],
      func2 = _args[2];

  (0, _invariant2.default)(cond instanceof _index.AbstractValue && cond.getType() === _index.BooleanValue);
  (0, _invariant2.default)(_index.Value.isTypeCompatibleWith(func1.getType(), _index.FunctionValue));
  (0, _invariant2.default)(_index.Value.isTypeCompatibleWith(func2.getType(), _index.FunctionValue));

  var _realm$evaluateForEff = realm.evaluateForEffects(function () {
    return EvaluateCall(func1, func1, ast, strictCode, env, realm);
  }),
      _realm$evaluateForEff2 = _slicedToArray(_realm$evaluateForEff, 5),
      compl1 = _realm$evaluateForEff2[0],
      gen1 = _realm$evaluateForEff2[1],
      bindings1 = _realm$evaluateForEff2[2],
      properties1 = _realm$evaluateForEff2[3],
      createdObj1 = _realm$evaluateForEff2[4];

  var _realm$evaluateForEff3 = realm.evaluateForEffects(function () {
    return EvaluateCall(func2, func2, ast, strictCode, env, realm);
  }),
      _realm$evaluateForEff4 = _slicedToArray(_realm$evaluateForEff3, 5),
      compl2 = _realm$evaluateForEff4[0],
      gen2 = _realm$evaluateForEff4[1],
      bindings2 = _realm$evaluateForEff4[2],
      properties2 = _realm$evaluateForEff4[3],
      createdObj2 = _realm$evaluateForEff4[4];

  var joinedEffects = _singletons.Join.joinEffects(realm, cond, [compl1, gen1, bindings1, properties1, createdObj1], [compl2, gen2, bindings2, properties2, createdObj2]);
  var completion = joinedEffects[0];
  if (completion instanceof _completions.PossiblyNormalCompletion) {
    // in this case one of the branches may complete abruptly, which means that
    // not all control flow branches join into one flow at this point.
    // Consequently we have to continue tracking changes until the point where
    // all the branches come together into one.
    completion = realm.composeWithSavedCompletion(completion);
  }

  // Note that the effects of (non joining) abrupt branches are not included
  // in joinedEffects, but are tracked separately inside completion.
  realm.applyEffects(joinedEffects);

  // return or throw completion
  if (completion instanceof _completions.AbruptCompletion) throw completion;
  (0, _invariant2.default)(completion instanceof _index.Value);
  return completion;
}

function EvaluateCall(ref, func, ast, strictCode, env, realm) {
  function generateRuntimeCall() {
    var args = [func];

    var _ref = ref instanceof _environment.Reference ? [ref.base, ref.referencedName] : [],
        _ref2 = _slicedToArray(_ref, 2),
        thisArg = _ref2[0],
        propName = _ref2[1];

    if (thisArg instanceof _index.Value) args = [thisArg];
    if (propName !== undefined && typeof propName !== "string") args.push(propName);
    args = args.concat((0, _index2.ArgumentListEvaluation)(realm, strictCode, env, ast.arguments));
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = args[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var arg = _step.value;

        if (arg !== func && arg instanceof _index.ObjectValue && !(0, _index2.TestIntegrityLevel)(realm, arg, "frozen")) {
          var diag = new _errors.CompilerDiagnostic("Unfrozen object leaked before end of global code", ast.loc, "PP0017", "RecoverableError");
          if (realm.handleError(diag) !== "Recover") throw new _errors.FatalError();
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return _index.AbstractValue.createTemporalFromBuildFunction(realm, _index.Value, args, function (nodes) {
      var callFunc = void 0;
      var argStart = 1;
      if (thisArg instanceof _index.Value) {
        if (typeof propName === "string") {
          callFunc = t.memberExpression(nodes[0], t.identifier(propName), !t.isValidIdentifier(propName));
        } else {
          callFunc = t.memberExpression(nodes[0], nodes[1], true);
          argStart = 2;
        }
      } else {
        callFunc = nodes[0];
      }
      var fun_args = nodes.slice(argStart);
      return t.callExpression(callFunc, fun_args);
    });
  }

  if (func instanceof _index.AbstractValue) {
    if (!_index.Value.isTypeCompatibleWith(func.getType(), _index.FunctionValue)) {
      var loc = ast.callee.type === "MemberExpression" ? ast.callee.property.loc : ast.callee.loc;
      var error = new _errors.CompilerDiagnostic("might not be a function", loc, "PP0005", "RecoverableError");
      if (realm.handleError(error) === "Fail") throw new _errors.FatalError();
    } else if (func.kind === "conditional") {
      return callBothFunctionsAndJoinTheirEffects(func.args, ast, strictCode, env, realm);
    } else {
      // Assume that it is a safe function. TODO #705: really?
    }
    return generateRuntimeCall();
  }
  (0, _invariant2.default)(func instanceof _index.ConcreteValue);

  // 3. If Type(ref) is Reference and IsPropertyReference(ref) is false and GetReferencedName(ref) is "eval", then
  if (ref instanceof _environment.Reference && !_singletons.Environment.IsPropertyReference(realm, ref) && _singletons.Environment.GetReferencedName(realm, ref) === "eval") {
    // a. If SameValue(func, %eval%) is true, then
    if ((0, _index2.SameValue)(realm, func, realm.intrinsics.eval)) {
      // i. Let argList be ? ArgumentListEvaluation(Arguments).
      var argList = (0, _index2.ArgumentListEvaluation)(realm, strictCode, env, ast.arguments);
      // ii. If argList has no elements, return undefined.
      if (argList.length === 0) return realm.intrinsics.undefined;
      // iii. Let evalText be the first element of argList.
      var evalText = argList[0];
      // iv. If the source code matching this CallExpression is strict code, let strictCaller be true. Otherwise let strictCaller be false.
      var strictCaller = strictCode;
      // v. Let evalRealm be the current Realm Record.
      var evalRealm = realm;
      // vi. Return ? PerformEval(evalText, evalRealm, strictCaller, true).
      if (evalText instanceof _index.AbstractValue) {
        var _loc = ast.arguments[0].loc;
        var _error = new _errors.CompilerDiagnostic("eval argument must be a known value", _loc, "PP0006", "RecoverableError");
        if (realm.handleError(_error) === "Fail") throw new _errors.FatalError();
        // Assume that it is a safe eval with no visible heap changes or abrupt control flow.
        return generateRuntimeCall();
      }
      return _singletons.Functions.PerformEval(realm, evalText, evalRealm, strictCaller, true);
    }
  }

  var thisValue = void 0;

  // 4. If Type(ref) is Reference, then
  if (ref instanceof _environment.Reference) {
    // a. If IsPropertyReference(ref) is true, then
    if (_singletons.Environment.IsPropertyReference(realm, ref)) {
      // i. Let thisValue be GetThisValue(ref).
      thisValue = (0, _index2.GetThisValue)(realm, ref);
    } else {
      // b. Else, the base of ref is an Environment Record
      // i. Let refEnv be GetBase(ref).
      var refEnv = _singletons.Environment.GetBase(realm, ref);
      (0, _invariant2.default)(refEnv instanceof _environment.EnvironmentRecord);

      // ii. Let thisValue be refEnv.WithBaseObject().
      thisValue = refEnv.WithBaseObject();
    }
  } else {
    // 5. Else Type(ref) is not Reference,
    // a. Let thisValue be undefined.
    thisValue = realm.intrinsics.undefined;
  }

  // 6. Let thisCall be this CallExpression.
  var thisCall = ast;

  // 7. Let tailCall be IsInTailPosition(thisCall). (See 14.6.1)
  var tailCall = (0, _index2.IsInTailPosition)(realm, thisCall);

  // 8. Return ? EvaluateDirectCall(func, thisValue, Arguments, tailCall).
  return (0, _index2.EvaluateDirectCall)(realm, strictCode, env, ref, func, thisValue, ast.arguments, tailCall);
}
//# sourceMappingURL=CallExpression.js.map