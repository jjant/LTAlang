{"version":3,"sources":["../../src/evaluators/ObjectExpression.js"],"names":["EvalPropertyName","ast","strictCode","env","realm","obj","intrinsics","ObjectPrototype","properties","prop","type","propKey","EvalPropertyNamePartial","exprValueRef","evaluate","value","propValue","GetValue","hasNameProperty","SetFunctionName","mightNotBeString","error","loc","handleError","$SetPartial","PropertyDefinitionEvaluation","result","computed","propertyKeyName","key","name"],"mappings":";;;;;QAkCgBA,gB,GAAAA,gB;;kBAsCD,UACbC,GADa,EAEbC,UAFa,EAGbC,GAHa,EAIbC,KAJa,EAKA;AACb;AACA,MAAIC,MAAM,0BAAaD,KAAb,EAAoBA,MAAME,UAAN,CAAiBC,eAArC,CAAV;;AAEA;AAJa;AAAA;AAAA;;AAAA;AAKb,yBAAiBN,IAAIO,UAArB,8HAAiC;AAAA,UAAxBC,IAAwB;;AAC/B,UAAIA,KAAKC,IAAL,KAAc,gBAAlB,EAAoC;AAClC;AACA;AACA,YAAIC,UAAUC,wBAAwBH,IAAxB,EAA8BN,GAA9B,EAAmCC,KAAnC,EAA0CF,UAA1C,CAAd;;AAEA;;AAEA;AACA,YAAIW,eAAeV,IAAIW,QAAJ,CAAaL,KAAKM,KAAlB,EAAyBb,UAAzB,CAAnB;;AAEA;AACA,YAAIc,YAAY,wBAAYC,QAAZ,CAAqBb,KAArB,EAA4BS,YAA5B,CAAhB;;AAEA;AACA,YAAI,2CAA8BT,KAA9B,EAAqCK,KAAKM,KAA1C,CAAJ,EAAsD;AACpD,mCAAUC,uCAAV;;AAEA;AACA,cAAIE,kBAAkB,4BAAed,KAAf,EAAsBY,SAAtB,EAAiC,MAAjC,CAAtB;;AAEA;AACA,mCAAU,CAACE,eAAX,EAPoD,CAOvB;AAC7B,gCAAUC,eAAV,CAA0Bf,KAA1B,EAAiCY,SAAjC,EAA4CL,OAA5C;AACD;;AAED;;AAEA;AACA,YAAIA,uCAAJ,EAAsC;AACpC,cAAIA,QAAQS,gBAAR,EAAJ,EAAgC;AAC9B,gBAAIC,QAAQ,+BAAuB,+BAAvB,EAAwDZ,KAAKa,GAA7D,EAAkE,QAAlE,EAA4E,YAA5E,CAAZ;AACA,gBAAIlB,MAAMmB,WAAN,CAAkBF,KAAlB,MAA6B,MAAjC,EAAyC,MAAM,wBAAN;AACzC,qBAH8B,CAGpB;AACV;AACD;AACDhB,cAAImB,WAAJ,CAAgBb,OAAhB,EAAyBK,SAAzB,EAAoCX,GAApC;AACD,SARD,MAQO;AACL,iDAA0BD,KAA1B,EAAiCC,GAAjC,EAAsCM,OAAtC,EAA+CK,SAA/C;AACD;AACF,OAvCD,MAuCO;AACL,iCAAUP,KAAKC,IAAL,KAAc,cAAxB;AACA,+BAAWe,4BAAX,CAAwCrB,KAAxC,EAA+CK,IAA/C,EAAqDJ,GAArD,EAA2DF,GAA3D,EAAsED,UAAtE,EAAkF,IAAlF;AACD;AACF;;AAED;;AAEA;AArDa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAsDb,SAAOG,GAAP;AACD,C;;AAtHD;;AACA;;AACA;;AAQA;;AACA;;;;;;AAQA;AAjCA;;;;;;;;;AAkCO,SAASL,gBAAT,CACLS,IADK,EAELN,GAFK,EAGLC,KAHK,EAILF,UAJK,EAKa;AAClB,MAAIwB,SAASd,wBAAwBH,IAAxB,EAA8BN,GAA9B,EAAmCC,KAAnC,EAA0CF,UAA1C,CAAb;AACA,MAAIwB,sCAAJ,EAAqC;AACnC,QAAIL,QAAQ,+BAAuB,gCAAvB,EAAyDZ,KAAKa,GAA9D,EAAmE,QAAnE,EAA6E,YAA7E,CAAZ;AACAlB,UAAMmB,WAAN,CAAkBF,KAAlB;AACA,UAAM,wBAAN;AACD;AACD,SAAQK,MAAR;AACD;;AAED,SAASd,uBAAT,CACEH,IADF,EAEEN,GAFF,EAGEC,KAHF,EAIEF,UAJF,EAKoC;AAClC,MAAIO,KAAKkB,QAAT,EAAmB;AACjB,QAAIC,kBAAkB,wBAAYX,QAAZ,CAAqBb,KAArB,EAA4BD,IAAIW,QAAJ,CAAaL,KAAKoB,GAAlB,EAAuB3B,UAAvB,CAA5B,CAAtB;AACA,QAAI0B,+CAAJ,EAA8C,OAAOA,eAAP;AAC9C,6BAAUA,+CAAV;AACA,WAAO,2BAAcxB,KAAd,EAAqBwB,eAArB,CAAP;AACD,GALD,MAKO;AACL,QAAInB,KAAKoB,GAAL,CAASnB,IAAT,KAAkB,YAAtB,EAAoC;AAClC,aAAO,uBAAgBN,KAAhB,EAAuBK,KAAKoB,GAAL,CAASC,IAAhC,CAAP;AACD,KAFD,MAEO;AACL,UAAIF,mBAAkB,wBAAYX,QAAZ,CAAqBb,KAArB,EAA4BD,IAAIW,QAAJ,CAAaL,KAAKoB,GAAlB,EAAuB3B,UAAvB,CAA5B,CAAtB;AACA,+BAAU0B,gDAAV,EAFK,CAEgD;AACrD,aAAO,sBAASxB,KAAT,EAAgBwB,gBAAhB,CAAP;AACD;AACF;AACF;;AAED","file":"ObjectExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport type { PropertyKeyValue } from \"../types.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { AbstractValue, ConcreteValue, ObjectValue, StringValue } from \"../values/index.js\";\nimport {\n  ObjectCreate,\n  CreateDataPropertyOrThrow,\n  IsAnonymousFunctionDefinition,\n  HasOwnProperty,\n  ToPropertyKey,\n  ToString,\n} from \"../methods/index.js\";\nimport { Environment, Functions, Properties } from \"../singletons.js\";\nimport invariant from \"../invariant.js\";\nimport type {\n  BabelNodeObjectExpression,\n  BabelNodeObjectProperty,\n  BabelNodeObjectMethod,\n  BabelNodeClassMethod,\n} from \"babel-types\";\n\n// Returns the result of evaluating PropertyName.\nexport function EvalPropertyName(\n  prop: BabelNodeObjectProperty | BabelNodeObjectMethod | BabelNodeClassMethod,\n  env: LexicalEnvironment,\n  realm: Realm,\n  strictCode: boolean\n): PropertyKeyValue {\n  let result = EvalPropertyNamePartial(prop, env, realm, strictCode);\n  if (result instanceof AbstractValue) {\n    let error = new CompilerDiagnostic(\"unknown computed property name\", prop.loc, \"PP0014\", \"FatalError\");\n    realm.handleError(error);\n    throw new FatalError();\n  }\n  return (result: any);\n}\n\nfunction EvalPropertyNamePartial(\n  prop: BabelNodeObjectProperty | BabelNodeObjectMethod | BabelNodeClassMethod,\n  env: LexicalEnvironment,\n  realm: Realm,\n  strictCode: boolean\n): AbstractValue | PropertyKeyValue {\n  if (prop.computed) {\n    let propertyKeyName = Environment.GetValue(realm, env.evaluate(prop.key, strictCode));\n    if (propertyKeyName instanceof AbstractValue) return propertyKeyName;\n    invariant(propertyKeyName instanceof ConcreteValue);\n    return ToPropertyKey(realm, propertyKeyName);\n  } else {\n    if (prop.key.type === \"Identifier\") {\n      return new StringValue(realm, prop.key.name);\n    } else {\n      let propertyKeyName = Environment.GetValue(realm, env.evaluate(prop.key, strictCode));\n      invariant(propertyKeyName instanceof ConcreteValue); // syntax only allows literals if !prop.computed\n      return ToString(realm, propertyKeyName);\n    }\n  }\n}\n\n// ECMA262 12.2.6.8\nexport default function(\n  ast: BabelNodeObjectExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): ObjectValue {\n  // 1. Let obj be ObjectCreate(%ObjectPrototype%).\n  let obj = ObjectCreate(realm, realm.intrinsics.ObjectPrototype);\n\n  // 2. Let status be the result of performing PropertyDefinitionEvaluation of PropertyDefinitionList with arguments obj and true.\n  for (let prop of ast.properties) {\n    if (prop.type === \"ObjectProperty\") {\n      // 12.2.6.9 case 3\n      // 1. Let propKey be the result of evaluating PropertyName.\n      let propKey = EvalPropertyNamePartial(prop, env, realm, strictCode);\n\n      // 2. ReturnIfAbrupt(propKey).\n\n      // 3. Let exprValueRef be the result of evaluating AssignmentExpression.\n      let exprValueRef = env.evaluate(prop.value, strictCode);\n\n      // 4. Let propValue be ? GetValue(exprValueRef).\n      let propValue = Environment.GetValue(realm, exprValueRef);\n\n      // 5. If IsAnonymousFunctionDefinition(AssignmentExpression) is true, then\n      if (IsAnonymousFunctionDefinition(realm, prop.value)) {\n        invariant(propValue instanceof ObjectValue);\n\n        // a. Let hasNameProperty be ? HasOwnProperty(propValue, \"name\").\n        let hasNameProperty = HasOwnProperty(realm, propValue, \"name\");\n\n        // b. If hasNameProperty is false, perform SetFunctionName(propValue, propKey).\n        invariant(!hasNameProperty); // No expression that passes through IsAnonymousFunctionDefinition can have it here\n        Functions.SetFunctionName(realm, propValue, propKey);\n      }\n\n      // 6. Assert: enumerable is true.\n\n      // 7. Return CreateDataPropertyOrThrow(object, propKey, propValue).\n      if (propKey instanceof AbstractValue) {\n        if (propKey.mightNotBeString()) {\n          let error = new CompilerDiagnostic(\"property key value is unknown\", prop.loc, \"PP0011\", \"FatalError\");\n          if (realm.handleError(error) === \"Fail\") throw new FatalError();\n          continue; // recover by ignoring the property, which is only ever safe to do if the property is dead,\n          // which is assuming a bit much, hence the designation as a FatalError.\n        }\n        obj.$SetPartial(propKey, propValue, obj);\n      } else {\n        CreateDataPropertyOrThrow(realm, obj, propKey, propValue);\n      }\n    } else {\n      invariant(prop.type === \"ObjectMethod\");\n      Properties.PropertyDefinitionEvaluation(realm, prop, obj, (env: any), strictCode, true);\n    }\n  }\n\n  // 3. ReturnIfAbrupt(status).\n\n  // 4. Return obj.\n  return obj;\n}\n"]}