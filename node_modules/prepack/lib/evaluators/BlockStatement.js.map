{"version":3,"sources":["../../src/evaluators/BlockStatement.js"],"names":["ast","strictCode","env","realm","oldEnv","getRunningContext","lexicalEnvironment","blockEnv","NewDeclarativeEnvironment","BlockDeclarationInstantiation","body","blockValue","directives","directive","value","EvaluateStatements"],"mappings":";;;;;;kBAmBe,UACbA,GADa,EAEbC,UAFa,EAGbC,GAHa,EAIbC,KAJa,EAKN;AACP;AACA,MAAIC,SAASD,MAAME,iBAAN,GAA0BC,kBAAvC;;AAEA;AACA,MAAIC,WAAW,wBAAYC,yBAAZ,CAAsCL,KAAtC,EAA6CC,MAA7C,CAAf;;AAEA;AACA,0BAAYK,6BAAZ,CAA0CN,KAA1C,EAAiDF,UAAjD,EAA6DD,IAAIU,IAAjE,EAAuEH,QAAvE;;AAEA;AACAJ,QAAME,iBAAN,GAA0BC,kBAA1B,GAA+CC,QAA/C;;AAEA,MAAI;AACF;AACA,QAAII,mBAAJ;;AAEA,QAAIX,IAAIY,UAAR,EAAoB;AAAA;AAAA;AAAA;;AAAA;AAClB,6BAAsBZ,IAAIY,UAA1B,8HAAsC;AAAA,cAA7BC,SAA6B;;AACpCF,uBAAa,uBAAgBR,KAAhB,EAAuBU,UAAUC,KAAV,CAAgBA,KAAvC,CAAb;AACD;AAHiB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAInB;;AAED,WAAO,sBAAUC,kBAAV,CAA6Bf,IAAIU,IAAjC,EAAuCC,UAAvC,EAAmDV,UAAnD,EAA+DM,QAA/D,EAAyEJ,KAAzE,CAAP;AACD,GAXD,SAWU;AACR;AACAA,UAAME,iBAAN,GAA0BC,kBAA1B,GAA+CF,MAA/C;AACD;AACF,C;;AArCD;;AACA","file":"BlockStatement.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { BabelNodeBlockStatement } from \"babel-types\";\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\n\nimport { StringValue, Value } from \"../values/index.js\";\nimport { Environment, Functions } from \"../singletons.js\";\n\n// ECMA262 13.2.13\nexport default function(\n  ast: BabelNodeBlockStatement,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  // 1. Let oldEnv be the running execution context's LexicalEnvironment.\n  let oldEnv = realm.getRunningContext().lexicalEnvironment;\n\n  // 2. Let blockEnv be NewDeclarativeEnvironment(oldEnv).\n  let blockEnv = Environment.NewDeclarativeEnvironment(realm, oldEnv);\n\n  // 3. Perform BlockDeclarationInstantiation(StatementList, blockEnv).\n  Environment.BlockDeclarationInstantiation(realm, strictCode, ast.body, blockEnv);\n\n  // 4. Set the running execution context's LexicalEnvironment to blockEnv.\n  realm.getRunningContext().lexicalEnvironment = blockEnv;\n\n  try {\n    // 5. Let blockValue be the result of evaluating StatementList.\n    let blockValue: void | Value;\n\n    if (ast.directives) {\n      for (let directive of ast.directives) {\n        blockValue = new StringValue(realm, directive.value.value);\n      }\n    }\n\n    return Functions.EvaluateStatements(ast.body, blockValue, strictCode, blockEnv, realm);\n  } finally {\n    // 6. Set the running execution context's LexicalEnvironment to oldEnv.\n    realm.getRunningContext().lexicalEnvironment = oldEnv;\n  }\n}\n"]}