{"version":3,"sources":["../../src/evaluators/ArrayExpression.js"],"names":["ast","strictCode","env","realm","array","elements","len","length","nextIndex","i","elem","type","spreadRef","evaluate","argument","spreadObj","GetValue","iterator","next","nextValue","status","initResult","initValue","created","Set"],"mappings":";;;;;;kBAuBe,UACbA,GADa,EAEbC,UAFa,EAGbC,GAHa,EAIbC,KAJa,EAKN;AACP;AACA,MAAIC,QAAQ,yBAAYD,KAAZ,EAAmB,CAAnB,CAAZ;;AAEA;AACA,MAAIE,WAAWL,IAAIK,QAAJ,IAAgB,EAA/B;AACA,MAAIC,MAAMD,SAASE,MAAnB;AACA,MAAIC,YAAY,CAAhB;AACA,OAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAIH,GAApB,EAAyBG,GAAzB,EAA8B;AAC5B,QAAIC,OAAOL,SAASI,CAAT,CAAX;AACA,QAAI,CAACC,IAAL,EAAW;AACTF;AACA;AACD;;AAED;AACA,QAAIE,KAAKC,IAAL,KAAc,eAAlB,EAAmC;AACjC;AACA,UAAIC,YAAYV,IAAIW,QAAJ,CAAaH,KAAKI,QAAlB,EAA4Bb,UAA5B,CAAhB;;AAEA;AACA,UAAIc,YAAY,wBAAYC,QAAZ,CAAqBb,KAArB,EAA4BS,SAA5B,CAAhB;;AAEA;AACA,UAAIK,WAAW,yBAAYd,KAAZ,EAAmBY,SAAnB,CAAf;;AAEA;AACA,aAAO,IAAP,EAAa;AACX;AACA,YAAIG,OAAO,4BAAaf,KAAb,EAAoBc,QAApB,CAAX;;AAEA;AACA,YAAIC,SAAS,KAAb,EAAoB;;AAEpB;AACA,YAAIC,YAAY,6BAAchB,KAAd,EAAqBe,IAArB,CAAhB;;AAEA;AACA,YAAIE,SAAS,gCAAmBjB,KAAnB,EAA0BC,KAA1B,EAAiC,uBAAgBD,KAAhB,EAAuBK,cAAc,EAArC,CAAjC,EAA2EW,SAA3E,CAAb;;AAEA;AACA,iCAAUC,WAAW,IAArB;;AAEA;AACD;AACF,KA7BD,MA6BO;AACL;AACA;AACA;AACA;;AAEA;AACA,UAAIC,aAAanB,IAAIW,QAAJ,CAAaH,IAAb,EAAmBT,UAAnB,CAAjB;;AAEA;AACA,UAAIqB,YAAY,wBAAYN,QAAZ,CAAqBb,KAArB,EAA4BkB,UAA5B,CAAhB;;AAEA;AACA,UAAIE,UAAU,gCAAmBpB,KAAnB,EAA0BC,KAA1B,EAAiC,uBAAgBD,KAAhB,EAAuBK,cAAc,EAArC,CAAjC,EAA2Ec,SAA3E,CAAd;;AAEA;AACA,+BAAUC,YAAY,IAAtB,EAA4B,iCAA5B;AACD;AACF;;AAED;AACA;;AAEA;AACA,yBAAWC,GAAX,CAAerB,KAAf,EAAsBC,KAAtB,EAA6B,QAA7B,EAAuC,uBAAgBD,KAAhB,EAAuBK,SAAvB,CAAvC,EAA0E,KAA1E;;AAEA;;AAEA;AACA,SAAOJ,KAAP;AACD,C;;AAzFD;;AACA;;AAEA;;;;AACA;;AACA","file":"ArrayExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport type { Value } from \"../values/index.js\";\nimport { StringValue, NumberValue } from \"../values/index.js\";\nimport { GetIterator } from \"../methods/index.js\";\nimport { ArrayCreate, CreateDataProperty } from \"../methods/index.js\";\nimport invariant from \"../invariant.js\";\nimport { IteratorStep, IteratorValue } from \"../methods/iterator.js\";\nimport { Environment, Properties } from \"../singletons.js\";\nimport type { BabelNodeArrayExpression } from \"babel-types\";\n\n// ECMA262 2.2.5.3\nexport default function(\n  ast: BabelNodeArrayExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  // 1. Let array be ArrayCreate(0).\n  let array = ArrayCreate(realm, 0);\n\n  // 2. Let len be the result of performing ArrayAccumulation for ElementList with arguments array and 0.\n  let elements = ast.elements || [];\n  let len = elements.length;\n  let nextIndex = 0;\n  for (let i = 0; i < len; i++) {\n    let elem = elements[i];\n    if (!elem) {\n      nextIndex++;\n      continue;\n    }\n\n    // ECMA262 12.2.5.2\n    if (elem.type === \"SpreadElement\") {\n      // 1. Let spreadRef be the result of evaluating AssignmentExpression.\n      let spreadRef = env.evaluate(elem.argument, strictCode);\n\n      // 2. Let spreadObj be ? GetValue(spreadRef).\n      let spreadObj = Environment.GetValue(realm, spreadRef);\n\n      // 3. Let iterator be ? GetIterator(spreadObj).\n      let iterator = GetIterator(realm, spreadObj);\n\n      // 4. Repeat\n      while (true) {\n        // a. Let next be ? IteratorStep(iterator).\n        let next = IteratorStep(realm, iterator);\n\n        // b. If next is false, return nextIndex.\n        if (next === false) break;\n\n        // c. Let nextValue be ? IteratorValue(next).\n        let nextValue = IteratorValue(realm, next);\n\n        // d. Let status be CreateDataProperty(array, ToString(ToUint32(nextIndex)), nextValue).\n        let status = CreateDataProperty(realm, array, new StringValue(realm, nextIndex++ + \"\"), nextValue);\n\n        // e. Assert: status is true.\n        invariant(status === true);\n\n        // f. Let nextIndex be nextIndex + 1.\n      }\n    } else {\n      // Redundant steps.\n      // 1. Let postIndex be the result of performing ArrayAccumulation for ElementList with arguments array and nextIndex.\n      // 2. ReturnIfAbrupt(postIndex).\n      // 3. Let padding be the ElisionWidth of Elision; if Elision is not present, use the numeric value zero.\n\n      // 4. Let initResult be the result of evaluating AssignmentExpression.\n      let initResult = env.evaluate(elem, strictCode);\n\n      // 5. Let initValue be ? GetValue(initResult).\n      let initValue = Environment.GetValue(realm, initResult);\n\n      // 6. Let created be CreateDataProperty(array, ToString(ToUint32(postIndex+padding)), initValue).\n      let created = CreateDataProperty(realm, array, new StringValue(realm, nextIndex++ + \"\"), initValue);\n\n      // 7. Assert: created is true.\n      invariant(created === true, \"expected data property creation\");\n    }\n  }\n\n  // Not necessary since we propagate completions with exceptions.\n  // 3. ReturnIfAbrupt(len).\n\n  // 4. Perform Set(array, \"length\", ToUint32(len), false).\n  Properties.Set(realm, array, \"length\", new NumberValue(realm, nextIndex), false);\n\n  // 5. NOTE: The above Set cannot fail because of the nature of the object returned by ArrayCreate.\n\n  // 6. Return array.\n  return array;\n}\n"]}