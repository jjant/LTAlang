{"version":3,"sources":["../../src/evaluators/FunctionExpression.js"],"names":["ast","strictCode","env","realm","id","generator","strict","body","scope","funcEnv","NewDeclarativeEnvironment","envRec","environmentRecord","name","CreateImmutableBinding","closure","GeneratorFunctionCreate","params","loc","prototype","intrinsics","GeneratorPrototype","originalConstructor","DefinePropertyOrThrow","value","writable","enumerable","configurable","SetFunctionName","InitializeBinding","FunctionCreate"],"mappings":"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","file":"FunctionExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport type { Value } from \"../values/index.js\";\nimport { MakeConstructor } from \"../methods/index.js\";\nimport { ObjectCreate } from \"../methods/create.js\";\nimport { Environment, Functions, Properties } from \"../singletons.js\";\nimport { StringValue } from \"../values/index.js\";\nimport IsStrict from \"../utils/strict.js\";\nimport type { BabelNodeFunctionExpression } from \"babel-types\";\nimport invariant from \"../invariant.js\";\n\nexport default function(\n  ast: BabelNodeFunctionExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  // ECMA262 14.1.21\n\n  if (ast.id) {\n    if (ast.generator) {\n      // 1. If the function code for this GeneratorExpression is strict mode code, let strict be true. Otherwise let strict be false.\n      let strict = strictCode || IsStrict(ast.body);\n\n      // 2. Let scope be the running execution context's LexicalEnvironment.\n      let scope = env;\n\n      // 3. Let funcEnv be NewDeclarativeEnvironment(scope).\n      let funcEnv = Environment.NewDeclarativeEnvironment(realm, scope);\n\n      // 4. Let envRec be funcEnv's EnvironmentRecord.\n      let envRec = funcEnv.environmentRecord;\n\n      // 5. Let name be StringValue of BindingIdentifier.\n      invariant(ast.id);\n      let name = ast.id.name;\n\n      // 6. Perform envRec.CreateImmutableBinding(name, false).\n      envRec.CreateImmutableBinding(name, false);\n\n      // 7. Let closure be GeneratorFunctionCreate(Normal, FormalParameters, GeneratorBody, funcEnv, strict).\n      let closure = Functions.GeneratorFunctionCreate(realm, \"normal\", ast.params, ast.body, funcEnv, strict);\n      closure.loc = ast.loc;\n\n      // 8. Let prototype be ObjectCreate(%GeneratorPrototype%).\n      let prototype = ObjectCreate(realm, realm.intrinsics.GeneratorPrototype);\n      prototype.originalConstructor = closure;\n\n      // 9. Perform DefinePropertyOrThrow(closure, \"prototype\", PropertyDescriptor{[[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false}).\n      Properties.DefinePropertyOrThrow(realm, closure, \"prototype\", {\n        value: prototype,\n        writable: true,\n        enumerable: false,\n        configurable: false,\n      });\n\n      // 10. Perform SetFunctionName(closure, name).\n      Functions.SetFunctionName(realm, closure, new StringValue(realm, name));\n\n      // 11. Perform envRec.InitializeBinding(name, closure).\n      envRec.InitializeBinding(name, closure);\n\n      // 12. Return closure.\n      return closure;\n    } else {\n      // 1. If the function code for FunctionExpression is strict mode code, let strict be true. Otherwise let strict be false.\n      let strict = strictCode || IsStrict(ast.body);\n\n      // 2. Let scope be the running execution context's LexicalEnvironment.\n      let scope = env;\n\n      // 3. Let funcEnv be NewDeclarativeEnvironment(scope).\n      let funcEnv = Environment.NewDeclarativeEnvironment(realm, scope);\n\n      // 4. Let envRec be funcEnv's EnvironmentRecord.\n      let envRec = funcEnv.environmentRecord;\n\n      // 5. Let name be StringValue of BindingIdentifier.\n      invariant(ast.id);\n      let name = ast.id.name;\n\n      // 6. Perform envRec.CreateImmutableBinding(name, false).\n      envRec.CreateImmutableBinding(name, false);\n\n      // 7. Let closure be FunctionCreate(Normal, FormalParameters, FunctionBody, funcEnv, strict).\n      let closure = Functions.FunctionCreate(realm, \"normal\", ast.params, ast.body, funcEnv, strict);\n      closure.loc = ast.loc;\n\n      // 8. Perform MakeConstructor(closure).\n      MakeConstructor(realm, closure);\n\n      // 9. Perform SetFunctionName(closure, name).\n      Functions.SetFunctionName(realm, closure, new StringValue(realm, name));\n\n      // 10. Perform envRec.InitializeBinding(name, closure).\n      envRec.InitializeBinding(name, closure);\n\n      // 11. Return closure.\n      return closure;\n    }\n  } else {\n    if (ast.generator) {\n      // 1. If the function code for this GeneratorExpression is strict mode code, let strict be true. Otherwise let strict be false.\n      let strict = strictCode || IsStrict(ast.body);\n\n      // 2. Let scope be the LexicalEnvironment of the running execution context.\n      let scope = env;\n\n      // 3. Let closure be GeneratorFunctionCreate(Normal, FormalParameters, GeneratorBody, scope, strict).\n      let closure = Functions.GeneratorFunctionCreate(realm, \"normal\", ast.params, ast.body, scope, strict);\n\n      // 4. Let prototype be ObjectCreate(%GeneratorPrototype%).\n      let prototype = ObjectCreate(realm, realm.intrinsics.GeneratorPrototype);\n      prototype.originalConstructor = closure;\n\n      // 5. Perform DefinePropertyOrThrow(closure, \"prototype\", PropertyDescriptor{[[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false}).\n      Properties.DefinePropertyOrThrow(realm, closure, \"prototype\", {\n        value: prototype,\n        writable: true,\n        enumerable: false,\n        configurable: false,\n      });\n\n      // 6. Return closure.\n      return closure;\n    } else {\n      // 1. If the function code for FunctionExpression is strict mode code, let strict be true. Otherwise let strict be false.\n      let strict = strictCode || IsStrict(ast.body);\n\n      // 2. Let scope be the LexicalEnvironment of the running execution context.\n      let scope = env;\n\n      // 3. Let closure be FunctionCreate(Normal, FormalParameters, FunctionBody, scope, strict).\n      let closure = Functions.FunctionCreate(realm, \"normal\", ast.params, ast.body, scope, strict);\n\n      // 4. Perform MakeConstructor(closure).\n      MakeConstructor(realm, closure);\n\n      // 5. Return closure.\n      return closure;\n    }\n  }\n}\n"]}