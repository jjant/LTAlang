{"version":3,"sources":["../../src/evaluators/LogicalExpression.js"],"names":["ast","strictCode","env","realm","lref","evaluate","left","lval","GetValue","lbool","operator","rref","right","mightNotBeFalse","mightNotBeTrue","compl1","gen1","bindings1","properties1","createdObj1","wrapper","withCondition","withInverseCondition","evaluateNodeForEffects","compl2","gen2","bindings2","properties2","createdObj2","joinedEffects","joinEffects","completion","composeWithSavedCompletion","applyEffects","createFromLogicalOp","loc"],"mappings":"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","file":"LogicalExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport { AbruptCompletion, PossiblyNormalCompletion } from \"../completions.js\";\nimport { construct_empty_effects } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { AbstractValue, ConcreteValue, Value } from \"../values/index.js\";\nimport { Reference } from \"../environment.js\";\nimport { ToBoolean } from \"../methods/index.js\";\nimport { Environment } from \"../singletons.js\";\nimport type { BabelNodeLogicalExpression } from \"babel-types\";\nimport invariant from \"../invariant.js\";\nimport { Join, Path } from \"../singletons.js\";\n\nexport default function(\n  ast: BabelNodeLogicalExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value | Reference {\n  let lref = env.evaluate(ast.left, strictCode);\n  let lval = Environment.GetValue(realm, lref);\n\n  if (lval instanceof ConcreteValue) {\n    let lbool = ToBoolean(realm, lval);\n\n    if (ast.operator === \"&&\") {\n      // ECMA262 12.13.3\n      if (lbool === false) return lval;\n    } else {\n      invariant(ast.operator === \"||\");\n      // ECMA262 12.13.3\n      if (lbool === true) return lval;\n    }\n\n    let rref = env.evaluate(ast.right, strictCode);\n    return Environment.GetValue(realm, rref);\n  }\n  invariant(lval instanceof AbstractValue);\n\n  if (!lval.mightNotBeFalse()) return ast.operator === \"||\" ? env.evaluate(ast.right, strictCode) : lval;\n  if (!lval.mightNotBeTrue()) return ast.operator === \"&&\" ? env.evaluate(ast.right, strictCode) : lval;\n\n  // Create empty effects for the case where ast.right is not evaluated\n  let [compl1, gen1, bindings1, properties1, createdObj1] = construct_empty_effects(realm);\n  compl1; // ignore\n\n  // Evaluate ast.right in a sandbox to get its effects\n  let wrapper = ast.operator === \"&&\" ? Path.withCondition : Path.withInverseCondition;\n  let [compl2, gen2, bindings2, properties2, createdObj2] = wrapper(lval, () =>\n    realm.evaluateNodeForEffects(ast.right, strictCode, env)\n  );\n\n  // Join the effects, creating an abstract view of what happened, regardless\n  // of the actual value of lval.\n  // Note that converting a value to boolean never has a side effect, so we can\n  // use lval as is for the join condition.\n  let joinedEffects;\n  if (ast.operator === \"&&\") {\n    joinedEffects = Join.joinEffects(\n      realm,\n      lval,\n      [compl2, gen2, bindings2, properties2, createdObj2],\n      [lval, gen1, bindings1, properties1, createdObj1]\n    );\n  } else {\n    joinedEffects = Join.joinEffects(\n      realm,\n      lval,\n      [lval, gen1, bindings1, properties1, createdObj1],\n      [compl2, gen2, bindings2, properties2, createdObj2]\n    );\n  }\n  let completion = joinedEffects[0];\n  if (completion instanceof PossiblyNormalCompletion) {\n    // in this case the evaluation of ast.right may complete abruptly, which means that\n    // not all control flow branches join into one flow at this point.\n    // Consequently we have to continue tracking changes until the point where\n    // all the branches come together into one.\n    completion = realm.composeWithSavedCompletion(completion);\n  }\n  // Note that the effects of (non joining) abrupt branches are not included\n  // in joinedEffects, but are tracked separately inside completion.\n  realm.applyEffects(joinedEffects);\n\n  // return or throw completion\n  if (completion instanceof AbruptCompletion) throw completion;\n  invariant(completion instanceof Value); // references do not survive join\n  if (lval instanceof Value && compl2 instanceof Value) {\n    // joinEffects does the right thing for the side effects of the second expression but for the result the join\n    // produces a conditional expressions of the form (a ? b : a) for a && b and (a ? a : b) for a || b\n    // Rather than look for this pattern everywhere, we override this behavior and replace the completion with\n    // the actual logical operator. This helps with simplification and reasoning when dealing with path conditions.\n    completion = AbstractValue.createFromLogicalOp(realm, ast.operator, lval, compl2, ast.loc);\n  }\n  return completion;\n}\n"]}