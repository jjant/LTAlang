{"version":3,"sources":["../../src/evaluators/ForOfStatement.js"],"names":["InternalGetResultValue","LoopContinues","ForInOfHeadEvaluation","ForInOfBodyEvaluation","ast","strictCode","env","realm","labelSet","left","right","body","type","kind","keyResult","declarations","id","BoundNames","e","target","intrinsics","undefined","value","result","completion","indexOf","BindingInstantiation","envRec","environmentRecord","name","CreateImmutableBinding","CreateMutableBinding","TDZnames","expr","iterationKind","oldEnv","getRunningContext","lexicalEnvironment","length","TDZ","NewDeclarativeEnvironment","TDZEnvRec","exprRef","evaluate","exprValue","GetValue","empty","loc","obj","isPartialObject","EnumerateObjectProperties","error","handleError","lhs","stmt","iterator","lhsKind","V","destructuring","IsDestructuring","nextResult","nextValue","iterationEnv","lhsRef","evaluateCompletion","names","lhsName","ResolveBinding","status","InitializeReferencedBinding","PutValue","BindingInitialization","resultValue"],"mappings":"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","file":"ForOfStatement.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { DeclarativeEnvironmentRecord } from \"../environment.js\";\nimport { Reference } from \"../environment.js\";\nimport { BreakCompletion, AbruptCompletion, ContinueCompletion } from \"../completions.js\";\nimport {\n  AbstractObjectValue,\n  AbstractValue,\n  EmptyValue,\n  NullValue,\n  ObjectValue,\n  UndefinedValue,\n  Value,\n} from \"../values/index.js\";\nimport invariant from \"../invariant.js\";\nimport {\n  IteratorStep,\n  IteratorValue,\n  IteratorClose,\n  ToObjectPartial,\n  UpdateEmpty,\n  DestructuringAssignmentEvaluation,\n  GetIterator,\n} from \"../methods/index.js\";\nimport { Environment, Properties } from \"../singletons.js\";\nimport type {\n  BabelNode,\n  BabelNodeForOfStatement,\n  BabelNodeLVal,\n  BabelNodeStatement,\n  BabelNodeVariableDeclaration,\n} from \"babel-types\";\n\nexport type IterationKind = \"iterate\" | \"enumerate\";\nexport type LhsKind = \"lexicalBinding\" | \"varBinding\" | \"assignment\";\n\nexport function InternalGetResultValue(realm: Realm, result: Value | AbruptCompletion): Value {\n  if (result instanceof AbruptCompletion) {\n    return result.value;\n  } else {\n    return result;\n  }\n}\n\n// ECMA262 13.7.1.2\nexport function LoopContinues(realm: Realm, completion: Value | AbruptCompletion, labelSet: ?Array<string>): boolean {\n  // 1. If completion.[[Type]] is normal, return true.\n  if (completion instanceof Value) return true;\n  invariant(completion instanceof AbruptCompletion);\n\n  // 2. If completion.[[Type]] is not continue, return false.\n  if (!(completion instanceof ContinueCompletion)) return false;\n\n  // 3. If completion.[[Target]] is empty, return true.\n  if (!completion.target) return true;\n\n  // 4. If completion.[[Target]] is an element of labelSet, return true.\n  if (labelSet != null && labelSet.indexOf(completion.target) >= 0) return true;\n\n  // 5. Return false.\n  return false;\n}\n\n// ECMA262 13.7.5.10\nfunction BindingInstantiation(realm: Realm, ast: BabelNodeVariableDeclaration, env: LexicalEnvironment) {\n  // ast = ForDeclaration : LetOrConst ForBinding\n\n  // 1. Let envRec be environment's EnvironmentRecord.\n  let envRec = env.environmentRecord;\n\n  // 2. Assert: envRec is a declarative Environment Record.\n  invariant(envRec instanceof DeclarativeEnvironmentRecord);\n\n  // 3. For each element name of the BoundNames of ForBinding do\n  for (let name of Environment.BoundNames(realm, ast)) {\n    // a. If IsConstantDeclaration of LetOrConst is true, then\n    if (ast.kind === \"const\") {\n      // i. Perform ! envRec.CreateImmutableBinding(name, true).\n      envRec.CreateImmutableBinding(name, true);\n    } else {\n      // b.\n      // i. Perform ! envRec.CreateMutableBinding(name, false).\n      envRec.CreateMutableBinding(name, false);\n    }\n  }\n}\n\n// ECMA262 13.7.5.12\nexport function ForInOfHeadEvaluation(\n  realm: Realm,\n  env: LexicalEnvironment,\n  TDZnames: Array<string>,\n  expr: BabelNode,\n  iterationKind: IterationKind,\n  strictCode: boolean\n): ObjectValue | AbstractObjectValue {\n  // 1. Let oldEnv be the running execution context's LexicalEnvironment.\n  let oldEnv = realm.getRunningContext().lexicalEnvironment;\n\n  // 2. If TDZnames is not an empty List, then\n  if (TDZnames.length) {\n    // a. Assert: TDZnames has no duplicate entries.\n\n    // b. Let TDZ be NewDeclarativeEnvironment(oldEnv).\n    let TDZ = Environment.NewDeclarativeEnvironment(realm, oldEnv);\n\n    // c. Let TDZEnvRec be TDZ's EnvironmentRecord.\n    let TDZEnvRec = TDZ.environmentRecord;\n\n    // d. For each string name in TDZnames, do\n    for (let name of TDZnames) {\n      // i. Perform ! TDZEnvRec.CreateMutableBinding(name, false).\n      TDZEnvRec.CreateMutableBinding(name, false);\n    }\n\n    // e. Set the running execution context's LexicalEnvironment to TDZ.\n    realm.getRunningContext().lexicalEnvironment = TDZ;\n    env = TDZ;\n  }\n\n  let exprRef;\n  try {\n    // 3. Let exprRef be the result of evaluating expr.\n    exprRef = env.evaluate(expr, strictCode);\n  } finally {\n    // 4. Set the running execution context's LexicalEnvironment to oldEnv.\n    realm.getRunningContext().lexicalEnvironment = oldEnv;\n  }\n  env = oldEnv;\n\n  // 5. Let exprValue be ? GetValue(exprRef).\n  let exprValue = Environment.GetValue(realm, exprRef);\n\n  // 6. If iterationKind is enumerate, then\n  if (iterationKind === \"enumerate\") {\n    // a. If exprValue.[[Value]] is null or undefined, then\n    if (exprValue instanceof NullValue || exprValue instanceof UndefinedValue) {\n      // i. Return Completion{[[Type]]: break, [[Value]]: empty, [[Target]]: empty}.\n      throw new BreakCompletion(realm.intrinsics.empty, expr.loc, undefined);\n    }\n\n    // b. Let obj be ToObject(exprValue).\n    let obj = ToObjectPartial(realm, exprValue);\n\n    // c. Return ? EnumerateObjectProperties(obj).\n    if (obj.isPartialObject() || obj instanceof AbstractObjectValue) {\n      return obj;\n    } else {\n      return Properties.EnumerateObjectProperties(realm, obj);\n    }\n  } else {\n    // 8. Else,\n    // 1. Assert: iterationKind is iterate.\n    invariant(iterationKind === \"iterate\", \"expected iterationKind to be iterate\");\n\n    if (exprValue instanceof AbstractValue) {\n      let error = new CompilerDiagnostic(\n        \"for of loops over unknown collections are not yet supported\",\n        expr.loc,\n        \"PP0014\",\n        \"FatalError\"\n      );\n      realm.handleError(error);\n      throw new FatalError();\n    }\n\n    // 1. Return ? GetIterator(exprValue).\n    return GetIterator(realm, exprValue);\n  }\n}\n\n// ECMA262 13.7.5.13\nexport function ForInOfBodyEvaluation(\n  realm: Realm,\n  env: LexicalEnvironment,\n  lhs: BabelNodeVariableDeclaration | BabelNodeLVal,\n  stmt: BabelNodeStatement,\n  iterator: ObjectValue,\n  lhsKind: LhsKind,\n  labelSet: ?Array<string>,\n  strictCode: boolean\n): Value {\n  // 1. Let oldEnv be the running execution context's LexicalEnvironment.\n  let oldEnv = realm.getRunningContext().lexicalEnvironment;\n\n  // 2. Let V be undefined.\n  let V: Value = realm.intrinsics.undefined;\n\n  // 3. Let destructuring be IsDestructuring of lhs.\n  let destructuring = Environment.IsDestructuring(lhs);\n\n  // 4. If destructuring is true and if lhsKind is assignment, then\n  if (destructuring && lhsKind === \"assignment\") {\n    // a. Assert: lhs is a LeftHandSideExpression.\n    invariant(lhs.type !== \"VariableDeclaration\");\n\n    // b. Let assignmentPattern be the parse of the source text corresponding to lhs using AssignmentPattern as the goal symbol.\n  }\n\n  // 5. Repeat\n  while (true) {\n    // a. Let nextResult be ? IteratorStep(iterator).\n    let nextResult = IteratorStep(realm, iterator);\n\n    // b. If nextResult is false, return NormalCompletion(V).\n    if (!nextResult) return V;\n\n    // c. Let nextValue be ? IteratorValue(nextResult).\n    let nextValue = IteratorValue(realm, nextResult);\n\n    // d. If lhsKind is either assignment or varBinding, then\n    let iterationEnv: void | LexicalEnvironment;\n    let lhsRef;\n    if (lhsKind === \"assignment\" || lhsKind === \"varBinding\") {\n      // i. If destructuring is false, then\n      if (!destructuring) {\n        // 1. Let lhsRef be the result of evaluating lhs. (It may be evaluated repeatedly.)\n        lhsRef = env.evaluateCompletion(lhs, strictCode);\n      }\n    } else {\n      // e. Else,\n      // i. Assert: lhsKind is lexicalBinding.\n      invariant(lhsKind === \"lexicalBinding\", \"expected lhsKind to be lexicalBinding\");\n      invariant(lhs.type === \"VariableDeclaration\");\n\n      // ii. Assert: lhs is a ForDeclaration.\n\n      // iii. Let iterationEnv be NewDeclarativeEnvironment(oldEnv).\n      iterationEnv = Environment.NewDeclarativeEnvironment(realm, oldEnv);\n\n      // iv. Perform BindingInstantiation for lhs passing iterationEnv as the argument.\n      BindingInstantiation(realm, lhs, iterationEnv);\n\n      // v. Set the running execution context's LexicalEnvironment to iterationEnv.\n      realm.getRunningContext().lexicalEnvironment = iterationEnv;\n      env = iterationEnv;\n\n      // vi. If destructuring is false, then\n      if (!destructuring) {\n        let names = Environment.BoundNames(realm, lhs);\n\n        // 1. Assert: lhs binds a single name.\n        invariant(names.length === 1, \"expected single name\");\n\n        // 2. Let lhsName be the sole element of BoundNames of lhs.\n        let lhsName = names[0];\n\n        // 3. Let lhsRef be ! ResolveBinding(lhsName).\n        lhsRef = Environment.ResolveBinding(realm, lhsName, strictCode);\n      }\n    }\n\n    // f. If destructuring is false, then\n    let status;\n    try {\n      if (!destructuring) {\n        // i. If lhsRef is an abrupt completion, then\n        if (lhsRef instanceof AbruptCompletion) {\n          // 1. Let status be lhsRef.\n          status = lhsRef;\n        } else if (lhsKind === \"lexicalBinding\") {\n          // ii. Else if lhsKind is lexicalBinding, then\n          // 1. Let status be InitializeReferencedBinding(lhsRef, nextValue).\n          invariant(lhsRef instanceof Reference);\n          status = Environment.InitializeReferencedBinding(realm, lhsRef, nextValue);\n        } else {\n          // iii. Else,\n          // 1. Let status be PutValue(lhsRef, nextValue).\n          invariant(lhsRef !== undefined);\n          status = Properties.PutValue(realm, lhsRef, nextValue);\n        }\n      } else {\n        // g. Else,\n        // i. If lhsKind is assignment, then\n        if (lhsKind === \"assignment\") {\n          invariant(lhs.type === \"ArrayPattern\" || lhs.type === \"ObjectPattern\");\n\n          // 1. Let status be the result of performing DestructuringAssignmentEvaluation of assignmentPattern using nextValue as the argument.\n          status = DestructuringAssignmentEvaluation(realm, lhs, nextValue, strictCode, iterationEnv || env);\n        } else if (lhsKind === \"varBinding\") {\n          // ii. Else if lhsKind is varBinding, then\n          // 1. Assert: lhs is a ForBinding.\n\n          // 2. Let status be the result of performing BindingInitialization for lhs passing nextValue and undefined as the arguments.\n          status = Environment.BindingInitialization(realm, lhs, nextValue, strictCode, undefined);\n        } else {\n          // iii. Else,\n          // 1. Assert: lhsKind is lexicalBinding.\n          invariant(lhsKind === \"lexicalBinding\");\n\n          // 2. Assert: lhs is a ForDeclaration.\n\n          // 3. Let status be the result of performing BindingInitialization for lhs passing nextValue and iterationEnv as arguments.\n          invariant(iterationEnv !== undefined);\n          status = Environment.BindingInitialization(realm, lhs, nextValue, strictCode, iterationEnv);\n        }\n      }\n    } catch (e) {\n      if (e instanceof AbruptCompletion) {\n        status = e;\n      } else {\n        throw e;\n      }\n    }\n\n    // h. If status is an abrupt completion, then\n    if (status instanceof AbruptCompletion) {\n      // i. Set the running execution context's LexicalEnvironment to oldEnv.\n      realm.getRunningContext().lexicalEnvironment = oldEnv;\n\n      // ii. Return ? IteratorClose(iterator, status).\n      throw IteratorClose(realm, iterator, status);\n    }\n\n    // i. Let result be the result of evaluating stmt.\n    let result = env.evaluateCompletion(stmt, strictCode);\n    invariant(result instanceof Value || result instanceof AbruptCompletion);\n\n    // j. Set the running execution context's LexicalEnvironment to oldEnv.\n    realm.getRunningContext().lexicalEnvironment = oldEnv;\n    env = oldEnv;\n\n    // k. If LoopContinues(result, labelSet) is false, return ? IteratorClose(iterator, UpdateEmpty(result, V)).\n    if (!LoopContinues(realm, result, labelSet)) {\n      invariant(result instanceof AbruptCompletion);\n      result = UpdateEmpty(realm, result, V);\n      invariant(result instanceof AbruptCompletion);\n      throw IteratorClose(realm, iterator, result);\n    }\n\n    // l. If result.[[Value]] is not empty, let V be result.[[Value]].\n    let resultValue = InternalGetResultValue(realm, result);\n    if (!(resultValue instanceof EmptyValue)) V = resultValue;\n  }\n\n  /* istanbul ignore next */\n  invariant(false); // can't get here but there is no other way to make Flow happy\n}\n\n// ECMA262 13.7.5.11\nexport default function(\n  ast: BabelNodeForOfStatement,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm,\n  labelSet: ?Array<string>\n): Value {\n  let { left, right, body } = ast;\n\n  try {\n    if (left.type === \"VariableDeclaration\") {\n      if (left.kind === \"var\") {\n        // for (var ForBinding o fAssignmentExpression) Statement\n        // 1. Let keyResult be the result of performing ? ForIn/OfHeadEvaluation(« », AssignmentExpression, iterate).\n        let keyResult = ForInOfHeadEvaluation(realm, env, [], right, \"iterate\", strictCode);\n        invariant(keyResult instanceof ObjectValue);\n\n        // 2. Return ? ForIn/OfBodyEvaluation(ForBinding, Statement, keyResult, varBinding, labelSet).\n        return ForInOfBodyEvaluation(\n          realm,\n          env,\n          left.declarations[0].id,\n          body,\n          keyResult,\n          \"varBinding\",\n          labelSet,\n          strictCode\n        );\n      } else {\n        // for (ForDeclaration of AssignmentExpression) Statement\n        // 1. Let keyResult be the result of performing ? ForIn/OfHeadEvaluation(BoundNames of ForDeclaration, AssignmentExpression, iterate).\n        let keyResult = ForInOfHeadEvaluation(\n          realm,\n          env,\n          Environment.BoundNames(realm, left),\n          right,\n          \"iterate\",\n          strictCode\n        );\n        invariant(keyResult instanceof ObjectValue);\n\n        // 2. Return ? ForIn/OfBodyEvaluation(ForDeclaration, Statement, keyResult, lexicalBinding, labelSet).\n        return ForInOfBodyEvaluation(realm, env, left, body, keyResult, \"lexicalBinding\", labelSet, strictCode);\n      }\n    } else {\n      // for (LeftHandSideExpression of AssignmentExpression) Statement\n      // 1. Let keyResult be the result of performing ? ForIn/OfHeadEvaluation(« », AssignmentExpression, iterate).\n      let keyResult = ForInOfHeadEvaluation(realm, env, [], right, \"iterate\", strictCode);\n      invariant(keyResult instanceof ObjectValue);\n\n      // 2. Return ? ForIn/OfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, assignment, labelSet).\n      return ForInOfBodyEvaluation(realm, env, left, body, keyResult, \"assignment\", labelSet, strictCode);\n    }\n  } catch (e) {\n    if (e instanceof BreakCompletion) {\n      if (!e.target) return (UpdateEmpty(realm, e, realm.intrinsics.undefined): any).value;\n    }\n    throw e;\n  }\n}\n"]}