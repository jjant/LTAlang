{"version":3,"sources":["../../src/evaluators/ClassDeclaration.js"],"names":["ClassDefinitionEvaluation","ast","strictCode","env","realm","BindingClassDeclarationEvaluation","intrinsics","empty","EvaluateClassHeritage","ClassHeritage","ref","getRunningContext","lexicalEnvironment","evaluate","val","GetValue","error","loc","handleError","className","lex","classScope","NewDeclarativeEnvironment","classScopeEnvRec","environmentRecord","undefined","CreateImmutableBinding","protoParent","constructorParent","superClass","ObjectPrototype","FunctionPrototype","superclass","null","createErrorThrowCompletion","TypeError","$FunctionKind","proto","react","enabled","flowRequired","superTypeParameters","$SuperTypeParameters","constructor","ClassBody","body","elem","type","push","length","constructorFile","program","classDeclaration","F","constructorInfo","DefineMethod","$Closure","$ConstructorKind","methods","m","PropertyDefinitionEvaluation","InitializeBinding","id","name","value","hasNameProperty","SetFunctionName","InitializeBoundName"],"mappings":";;;;;;ypBAAA;;;;;;;;;QAwDgBA,yB,GAAAA,yB;;kBAwPD,UACbC,GADa,EAEbC,UAFa,EAGbC,GAHa,EAIbC,KAJa,EAKN;AACP;AACAC,oCAAkCD,KAAlC,EAAyCH,GAAzC,EAA8CC,UAA9C,EAA0DC,GAA1D;;AAEA;;AAEA;AACA,SAAOC,MAAME,UAAN,CAAiBC,KAAxB;AACD,C;;AAhTD;;AACA;;AAQA;;;;AACA;;AAYA;;AACA;;;;;;AAEA,SAASC,qBAAT,CACEJ,KADF,EAEEK,aAFF,EAGEP,UAHF,EAIsB;AACpB,MAAIQ,MAAMN,MAAMO,iBAAN,GAA0BC,kBAA1B,CAA6CC,QAA7C,CAAsDJ,aAAtD,EAAqEP,UAArE,CAAV;AACA,MAAIY,MAAM,wBAAYC,QAAZ,CAAqBX,KAArB,EAA4BM,GAA5B,CAAV;AACA,MAAII,mCAAJ,EAAkC;AAChC,QAAIE,QAAQ,+BAAuB,qBAAvB,EAA8CP,cAAcQ,GAA5D,EAAiE,QAAjE,EAA2E,kBAA3E,CAAZ;AACA,QAAIb,MAAMc,WAAN,CAAkBF,KAAlB,MAA6B,MAAjC,EAAyC,MAAM,wBAAN;AAC1C;AACD,MAAI,EAAEF,iCAAF,CAAJ,EAAmC;AACjC,WAAO,IAAP;AACD;AACD,SAAOA,GAAP;AACD;;AAED;AACO,SAASd,yBAAT,CACLI,KADK,EAELH,GAFK,EAGLkB,SAHK,EAILjB,UAJK,EAKLC,GALK,EAML;AACA;AACA,MAAIiB,MAAMjB,GAAV;;AAEA;AACA,MAAIkB,aAAa,wBAAYC,yBAAZ,CAAsClB,KAAtC,EAA6CgB,GAA7C,CAAjB;;AAEA;AACA,MAAIG,mBAAmBF,WAAWG,iBAAlC;;AAEA;AACA,MAAIL,cAAcM,SAAlB,EAA6B;AAC3B;AACAF,qBAAiBG,sBAAjB,CAAwCP,SAAxC,EAAmD,IAAnD;AACD;;AAED,MAAIQ,oBAAJ;AACA,MAAIC,0BAAJ;AACA;AACA,MAAInB,gBAAgBR,IAAI4B,UAAxB;AACA,MAAI,CAACpB,aAAL,EAAoB;AAClB;AACAkB,kBAAcvB,MAAME,UAAN,CAAiBwB,eAA/B;;AAEA;AACAF,wBAAoBxB,MAAME,UAAN,CAAiByB,iBAArC;AACD,GAND,MAMO;AACL;AACA;AACA3B,UAAMO,iBAAN,GAA0BC,kBAA1B,GAA+CS,UAA/C;AACA,QAAIW,aAAa,IAAjB;AACA,QAAI;AACF;AACAA,mBAAaxB,sBAAsBJ,KAAtB,EAA6BK,aAA7B,EAA4CP,UAA5C,CAAb;AACD,KAHD,SAGU;AACR;AACAE,YAAMO,iBAAN,GAA0BC,kBAA1B,GAA+CQ,GAA/C;AACD;;AAED;;AAEA;AACA,QAAIY,eAAe,IAAnB,EAAyB;AACvB;AACAL,oBAAcvB,MAAME,UAAN,CAAiB2B,IAA/B;;AAEA;AACAL,0BAAoBxB,MAAME,UAAN,CAAiByB,iBAArC;AACD,KAND,MAMO,IAAI,CAAC,2BAAc3B,KAAd,EAAqB4B,UAArB,CAAL,EAAuC;AAC5C;AACA,YAAM5B,MAAM8B,0BAAN,CAAiC9B,MAAME,UAAN,CAAiB6B,SAAlD,EAA6D,kCAA7D,CAAN;AACD,KAHM,MAGA;AACL;AACA;AACA,UAAIH,wDAAiDA,WAAWI,aAAX,KAA6B,WAAlF,EAA+F;AAC7F,cAAMhC,MAAM8B,0BAAN,CAAiC9B,MAAME,UAAN,CAAiB6B,SAAlD,EAA6D,kCAA7D,CAAN;AACD;;AAED;AACAR,oBAAc,iBAAIvB,KAAJ,EAAW4B,UAAX,EAAuB,WAAvB,CAAd;;AAEA;;AAEA;AACA,UAAI,EAAEL,6CAAsCA,uCAAxC,CAAJ,EAA+E;AAC7E,YAAIA,2CAAJ,EAA0C;AACxC,cAAIX,QAAQ,+BACV,+BADU,EAEVP,cAAcQ,GAFJ,EAGV,QAHU,EAIV,kBAJU,CAAZ;AAMA,cAAIb,MAAMc,WAAN,CAAkBF,KAAlB,MAA6B,MAAjC,EAAyC,MAAM,wBAAN;AACzCW,wBAAcvB,MAAME,UAAN,CAAiBwB,eAA/B;AACD,SATD,MASO;AACL,gBAAM1B,MAAM8B,0BAAN,CACJ9B,MAAME,UAAN,CAAiB6B,SADb,EAEJ,mDAFI,CAAN;AAID;AACF;;AAED;AACAP,0BAAoBI,UAApB;AACD;AACF;;AAED;AACA,MAAIK,QAAQ,0BAAajC,KAAb,EAAoBuB,WAApB,CAAZ;;AAEA;AACA,MAAIvB,MAAMkC,KAAN,CAAYC,OAAZ,IAAuBnC,MAAMkC,KAAN,CAAYE,YAAnC,IAAmDvC,IAAIwC,mBAA3D,EAAgF;AAC9EJ,UAAMK,oBAAN,GAA6BzC,IAAIwC,mBAAjC;AACD;AACD,MAAIE,oBAAJ;AACA,MAAIC,YAAyC,EAA7C;AA/FA;AAAA;AAAA;;AAAA;AAgGA,yBAAiB3C,IAAI4C,IAAJ,CAASA,IAA1B,8HAAgC;AAAA,UAAvBC,IAAuB;;AAC9B,UAAIA,KAAKC,IAAL,KAAc,aAAlB,EAAiC;AAC/BH,kBAAUI,IAAV,CAAeF,IAAf;AACD;AACF;AACD;AArGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAsGA,MAAIF,UAAUK,MAAV,KAAqB,CAAzB,EAA4B;AAC1BN,kBAAcvC,MAAME,UAAN,CAAiBC,KAA/B;AACD,GAFD,MAEO;AACL;AACAoC,kBAAc,+BAAkBvC,KAAlB,EAAyBwC,SAAzB,CAAd;AACD;;AAED;AACA,MAAID,wCAAJ,EAAuC;AACrC,QAAIO,wBAAJ;AACA;AACA,QAAIjD,IAAI4B,UAAR,EAAoB;AAClB;AACA;AACA;AACAqB,wBAAkB,qBAAM9C,KAAN,EAAa,wEAAb,EAAuF,EAAvF,CAAlB;AACD,KALD,MAKO;AACL;AACA;AACA;AACA;AACA8C,wBAAkB,qBAAM9C,KAAN,EAAa,iDAAb,EAAgE,EAAhE,CAAlB;AACD;;AAdoC,2BAgBW8C,eAhBX;AAAA,gEAgB/BC,OAhB+B,CAgBpBN,IAhBoB;AAAA,QAgBbO,gBAhBa;;AAiBrC,6BAAUA,iBAAiBL,IAAjB,KAA0B,kBAApC;AAjBqC,eAkBpBK,gBAlBoB;AAAA,QAkB/BP,IAlB+B,QAkB/BA,IAlB+B;;AAmBrC,6BAAUA,KAAKA,IAAL,CAAU,CAAV,EAAaE,IAAb,KAAsB,aAAhC;AACAJ,kBAAgBE,KAAKA,IAAL,CAAU,CAAV,CAAhB;AACD;;AAED;AACAzC,QAAMO,iBAAN,GAA0BC,kBAA1B,GAA+CS,UAA/C;;AAEA,MAAIgC,UAAJ;AACA,MAAI;AACF;AACA,QAAIC,kBAAkB,sBAAUC,YAAV,CAAuBnD,KAAvB,EAA8BuC,WAA9B,EAA2CN,KAA3C,EAAkDlC,GAAlD,EAAuDD,UAAvD,EAAmE0B,iBAAnE,CAAtB;;AAEA;;AAEA;AACAyB,QAAIC,gBAAgBE,QAApB;;AAEA;AACA,QAAIvD,IAAI4B,UAAR,EAAoB;AAClBwB,QAAEI,gBAAF,GAAqB,SAArB;AACD;;AAED;AACA,iCAAgBrD,KAAhB,EAAuBiD,CAAvB,EAA0B,KAA1B,EAAiChB,KAAjC;;AAEA;AACA,sCAAqBjC,KAArB,EAA4BiD,CAA5B;;AAEA;AACA,sCAAqBjD,KAArB,EAA4BiC,KAA5B,EAAmC,aAAnC,EAAkDgB,CAAlD;;AAEA,QAAIK,gBAAJ;AACA;AACA,QAAId,UAAUK,MAAV,KAAqB,CAAzB,EAA4B;AAC1BS,gBAAU,EAAV;AACD,KAFD,MAEO;AACL;AACAA,gBAAU,6CAAgCtD,KAAhC,EAAuCwC,SAAvC,CAAV;AACD;;AAED;AAhCE;AAAA;AAAA;;AAAA;AAiCF,4BAAcc,OAAd,mIAAuB;AAAA,YAAdC,CAAc;;AACrB;AACA,YAAI,CAAC,sBAASA,CAAT,CAAL,EAAkB;AAChB;AACA,iCAAWC,4BAAX,CAAwCxD,KAAxC,EAA+CuD,CAA/C,EAAkDtB,KAAlD,EAA0DlC,GAA1D,EAAqED,UAArE,EAAiF,KAAjF;AACD,SAHD,MAGO;AACL;AACA;AACA,iCAAW0D,4BAAX,CAAwCxD,KAAxC,EAA+CuD,CAA/C,EAAkDN,CAAlD,EAAsDlD,GAAtD,EAAiED,UAAjE,EAA6E,KAA7E;AACD;AACD;AACA;AACA;AACD;AA9CC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA+CH,GA/CD,SA+CU;AACR;AACAE,UAAMO,iBAAN,GAA0BC,kBAA1B,GAA+CQ,GAA/C;AACD;;AAED;AACA,MAAID,cAAcM,SAAlB,EAA6B;AAC3B;AACAF,qBAAiBsC,iBAAjB,CAAmC1C,SAAnC,EAA8CkC,CAA9C;AACD;AACD;AACA,SAAOA,CAAP;AACD;;AAED;AACA,SAAShD,iCAAT,CACED,KADF,EAEEH,GAFF,EAGEC,UAHF,EAIEC,GAJF,EAKE;AACA;AACA,MAAIF,IAAI6D,EAAR,EAAY;AACV;AACA,QAAI3C,YAAYlB,IAAI6D,EAAJ,CAAOC,IAAvB;;AAEA;AACA,QAAIC,QAAQhE,0BAA0BI,KAA1B,EAAiCH,GAAjC,EAAsCkB,SAAtC,EAAiDjB,UAAjD,EAA6DC,GAA7D,CAAZ;;AAEA;;AAEA;AACA,QAAI8D,kBAAkB,4BAAe7D,KAAf,EAAsB4D,KAAtB,EAA6B,MAA7B,CAAtB;;AAEA;;AAEA;AACA,QAAIC,oBAAoB,KAAxB,EAA+B;AAC7B,4BAAUC,eAAV,CAA0B9D,KAA1B,EAAiC4D,KAAjC,EAAwC7C,SAAxC;AACD;;AAED;;AAEA;AACA,4BAAYgD,mBAAZ,CAAgC/D,KAAhC,EAAuCe,SAAvC,EAAkD6C,KAAlD,EAAyD7D,GAAzD;;AAEA;;AAEA;AACA,WAAO6D,KAAP;AACD,GA5BD,MA4BO;AACL;AACA;AACA,WAAOhE,0BAA0BI,KAA1B,EAAiCH,GAAjC,EAAsCwB,SAAtC,EAAiDvB,UAAjD,EAA6DC,GAA7D,CAAP;AACD;AACF;;AAED","file":"ClassDeclaration.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { AbstractValue, Value } from \"../values/index.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { NullValue, EmptyValue, ObjectValue, ECMAScriptFunctionValue } from \"../values/index.js\";\nimport type {\n  BabelNodeClassDeclaration,\n  BabelNodeClassExpression,\n  BabelNodeClassMethod,\n  BabelNodeExpression,\n} from \"babel-types\";\nimport parse from \"../utils/parse.js\";\nimport {\n  HasOwnProperty,\n  IsConstructor,\n  Get,\n  MakeConstructor,\n  CreateMethodProperty,\n  MakeClassConstructor,\n  ObjectCreate,\n  ConstructorMethod,\n  IsStatic,\n  NonConstructorMethodDefinitions,\n} from \"../methods/index.js\";\nimport { Environment, Functions, Properties } from \"../singletons.js\";\nimport invariant from \"../invariant.js\";\n\nfunction EvaluateClassHeritage(\n  realm: Realm,\n  ClassHeritage: BabelNodeExpression,\n  strictCode: boolean\n): ObjectValue | null {\n  let ref = realm.getRunningContext().lexicalEnvironment.evaluate(ClassHeritage, strictCode);\n  let val = Environment.GetValue(realm, ref);\n  if (val instanceof AbstractValue) {\n    let error = new CompilerDiagnostic(\"unknown super class\", ClassHeritage.loc, \"PP0009\", \"RecoverableError\");\n    if (realm.handleError(error) === \"Fail\") throw new FatalError();\n  }\n  if (!(val instanceof ObjectValue)) {\n    return null;\n  }\n  return val;\n}\n\n// ECMA262 14.5.14\nexport function ClassDefinitionEvaluation(\n  realm: Realm,\n  ast: BabelNodeClassDeclaration | BabelNodeClassExpression,\n  className: string | void,\n  strictCode: boolean,\n  env: LexicalEnvironment\n) {\n  // 1. Let lex be the LexicalEnvironment of the running execution context.\n  let lex = env;\n\n  // 2. Let classScope be NewDeclarativeEnvironment(lex).\n  let classScope = Environment.NewDeclarativeEnvironment(realm, lex);\n\n  // 3. Let classScopeEnvRec be classScope’s EnvironmentRecord.\n  let classScopeEnvRec = classScope.environmentRecord;\n\n  // 4. If className is not undefined, then\n  if (className !== undefined) {\n    // a. Perform classScopeEnvRec.CreateImmutableBinding(className, true).\n    classScopeEnvRec.CreateImmutableBinding(className, true);\n  }\n\n  let protoParent;\n  let constructorParent;\n  // 5. If ClassHeritage opt is not present, then\n  let ClassHeritage = ast.superClass;\n  if (!ClassHeritage) {\n    // a. Let protoParent be the intrinsic object %ObjectPrototype%.\n    protoParent = realm.intrinsics.ObjectPrototype;\n\n    // b. Let constructorParent be the intrinsic object %FunctionPrototype%.\n    constructorParent = realm.intrinsics.FunctionPrototype;\n  } else {\n    // 6. Else\n    // a. Set the running execution context’s LexicalEnvironment to classScope.\n    realm.getRunningContext().lexicalEnvironment = classScope;\n    let superclass = null;\n    try {\n      // b. Let superclass be the result of evaluating ClassHeritage.\n      superclass = EvaluateClassHeritage(realm, ClassHeritage, strictCode);\n    } finally {\n      // c. Set the running execution context’s LexicalEnvironment to lex.\n      realm.getRunningContext().lexicalEnvironment = lex;\n    }\n\n    // d. ReturnIfAbrupt(superclass).\n\n    // e. If superclass is null, then\n    if (superclass === null) {\n      // i. Let protoParent be null.\n      protoParent = realm.intrinsics.null;\n\n      // ii. Let constructorParent be the intrinsic object %FunctionPrototype%.\n      constructorParent = realm.intrinsics.FunctionPrototype;\n    } else if (!IsConstructor(realm, superclass)) {\n      // f. Else if IsConstructor(superclass) is false, throw a TypeError exception.\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"superclass must be a constructor\");\n    } else {\n      // g. Else\n      // i. If superclass has a [[FunctionKind]] internal slot whose value is \"generator\", throw a TypeError exception.\n      if (superclass instanceof ECMAScriptFunctionValue && superclass.$FunctionKind === \"generator\") {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"superclass cannot be a generator\");\n      }\n\n      // ii. Let protoParent be Get(superclass, \"prototype\").\n      protoParent = Get(realm, superclass, \"prototype\");\n\n      // iii. ReturnIfAbrupt(protoParent).\n\n      // iv. If Type(protoParent) is neither Object nor Null, throw a TypeError exception.\n      if (!(protoParent instanceof ObjectValue || protoParent instanceof NullValue)) {\n        if (protoParent instanceof AbstractValue) {\n          let error = new CompilerDiagnostic(\n            \"unknown super class prototype\",\n            ClassHeritage.loc,\n            \"PP0010\",\n            \"RecoverableError\"\n          );\n          if (realm.handleError(error) === \"Fail\") throw new FatalError();\n          protoParent = realm.intrinsics.ObjectPrototype;\n        } else {\n          throw realm.createErrorThrowCompletion(\n            realm.intrinsics.TypeError,\n            \"protoParent must be an instance of Object or Null\"\n          );\n        }\n      }\n\n      // v. Let constructorParent be superclass.\n      constructorParent = superclass;\n    }\n  }\n\n  // 7. Let proto be ObjectCreate(protoParent).\n  let proto = ObjectCreate(realm, protoParent);\n\n  // react. Check the Flow class paramater annotations, stored in \"superTypeParameters\"\n  if (realm.react.enabled && realm.react.flowRequired && ast.superTypeParameters) {\n    proto.$SuperTypeParameters = ast.superTypeParameters;\n  }\n  let constructor;\n  let ClassBody: Array<BabelNodeClassMethod> = [];\n  for (let elem of ast.body.body) {\n    if (elem.type === \"ClassMethod\") {\n      ClassBody.push(elem);\n    }\n  }\n  // 8. If ClassBody opt is not present, let constructor be empty.\n  if (ClassBody.length === 0) {\n    constructor = realm.intrinsics.empty;\n  } else {\n    // 9. Else, let constructor be ConstructorMethod of ClassBody.\n    constructor = ConstructorMethod(realm, ClassBody);\n  }\n\n  // 10. If constructor is empty, then,\n  if (constructor instanceof EmptyValue) {\n    let constructorFile;\n    // a. If ClassHeritage opt is present, then\n    if (ast.superClass) {\n      // i. Let constructor be the result of parsing the source text\n      //     constructor(... args){ super (...args);}\n      // using the syntactic grammar with the goal symbol MethodDefinition.\n      constructorFile = parse(realm, \"class NeedClassForParsing { constructor(... args){ super (...args);} }\", \"\");\n    } else {\n      // b. Else,\n      // i. Let constructor be the result of parsing the source text\n      //     constructor( ){ }\n      // using the syntactic grammar with the goal symbol MethodDefinition.\n      constructorFile = parse(realm, \"class NeedClassForParsing { constructor( ){ } }\", \"\");\n    }\n\n    let { program: { body: [classDeclaration] } } = constructorFile;\n    invariant(classDeclaration.type === \"ClassDeclaration\");\n    let { body } = ((classDeclaration: any): BabelNodeClassDeclaration);\n    invariant(body.body[0].type === \"ClassMethod\");\n    constructor = ((body.body[0]: any): BabelNodeClassMethod);\n  }\n\n  // 11. Set the running execution context’s LexicalEnvironment to classScope.\n  realm.getRunningContext().lexicalEnvironment = classScope;\n\n  let F;\n  try {\n    // 12. Let constructorInfo be the result of performing DefineMethod for constructor with arguments proto and constructorParent as the optional functionPrototype argument.\n    let constructorInfo = Functions.DefineMethod(realm, constructor, proto, env, strictCode, constructorParent);\n\n    // 13. Assert: constructorInfo is not an abrupt completion.\n\n    // 14. Let F be constructorInfo.[[closure]]\n    F = constructorInfo.$Closure;\n\n    // 15. If ClassHeritage opt is present, set F’s [[ConstructorKind]] internal slot to \"derived\".\n    if (ast.superClass) {\n      F.$ConstructorKind = \"derived\";\n    }\n\n    // 16. Perform MakeConstructor(F, false, proto).\n    MakeConstructor(realm, F, false, proto);\n\n    // 17. Perform MakeClassConstructor(F).\n    MakeClassConstructor(realm, F);\n\n    // 18. Perform CreateMethodProperty(proto, \"constructor\", F).\n    CreateMethodProperty(realm, proto, \"constructor\", F);\n\n    let methods;\n    // 19. If ClassBody opt is not present, let methods be a new empty List.\n    if (ClassBody.length === 0) {\n      methods = [];\n    } else {\n      // 20. Else, let methods be NonConstructorMethodDefinitions of ClassBody.\n      methods = NonConstructorMethodDefinitions(realm, ClassBody);\n    }\n\n    // 21. For each ClassElement m in order from methods\n    for (let m of methods) {\n      // a. If IsStatic of m is false, then\n      if (!IsStatic(m)) {\n        // Let status be the result of performing PropertyDefinitionEvaluation for m with arguments proto and false.\n        Properties.PropertyDefinitionEvaluation(realm, m, proto, (env: any), strictCode, false);\n      } else {\n        // Else,\n        // Let status be the result of performing PropertyDefinitionEvaluation for m with arguments F and false.\n        Properties.PropertyDefinitionEvaluation(realm, m, F, (env: any), strictCode, false);\n      }\n      // c. If status is an abrupt completion, then\n      // i. Set the running execution context's LexicalEnvironment to lex.\n      // ii. Return Completion(status).\n    }\n  } finally {\n    // 22. Set the running execution context’s LexicalEnvironment to lex.\n    realm.getRunningContext().lexicalEnvironment = lex;\n  }\n\n  // 23. If className is not undefined, then\n  if (className !== undefined) {\n    // Perform classScopeEnvRec.InitializeBinding(className, F).\n    classScopeEnvRec.InitializeBinding(className, F);\n  }\n  // Return F.\n  return F;\n}\n\n// ECMA2 14.5.15\nfunction BindingClassDeclarationEvaluation(\n  realm: Realm,\n  ast: BabelNodeClassDeclaration,\n  strictCode: boolean,\n  env: LexicalEnvironment\n) {\n  // ClassDeclaration : class BindingIdentifier ClassTail\n  if (ast.id) {\n    // 1. Let className be StringValue of BindingIdentifier.\n    let className = ast.id.name;\n\n    // 2. Let value be the result of ClassDefinitionEvaluation of ClassTail with argument className.\n    let value = ClassDefinitionEvaluation(realm, ast, className, strictCode, env);\n\n    // 3. ReturnIfAbrupt(value).\n\n    // 4. Let hasNameProperty be HasOwnProperty(value, \"name\").\n    let hasNameProperty = HasOwnProperty(realm, value, \"name\");\n\n    // 5. ReturnIfAbrupt(hasNameProperty).\n\n    // 6. If hasNameProperty is false, then perform SetFunctionName(value, className).\n    if (hasNameProperty === false) {\n      Functions.SetFunctionName(realm, value, className);\n    }\n\n    // 7. Let env be the running execution context’s LexicalEnvironment.\n\n    // 8. Let status be InitializeBoundName(className, value, env).\n    Environment.InitializeBoundName(realm, className, value, env);\n\n    // 9. ReturnIfAbrupt(status).\n\n    // 10. Return value.\n    return value;\n  } else {\n    // ClassDeclaration : class ClassTail\n    // 1. Return the result of ClassDefinitionEvaluation of ClassTail with argument undefined.\n    return ClassDefinitionEvaluation(realm, ast, undefined, strictCode, env);\n  }\n}\n\n// ECMA262 14.5.16\nexport default function(\n  ast: BabelNodeClassDeclaration,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  // 1. Let status be the result of BindingClassDeclarationEvaluation of this ClassDeclaration.\n  BindingClassDeclarationEvaluation(realm, ast, strictCode, env);\n\n  // 2. ReturnIfAbrupt(status).\n\n  // 3. Return NormalCompletion(empty).\n  return realm.intrinsics.empty;\n}\n"]}