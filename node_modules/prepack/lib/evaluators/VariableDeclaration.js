"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (ast, strictCode, env, realm) {
  if (ast.kind === "let" || ast.kind === "const") {
    return letAndConst(ast, strictCode, env, realm);
  }

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = ast.declarations[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var declar = _step2.value;

      var Initializer = declar.init;

      if (declar.id.type === "Identifier" && !Initializer) {
        // VariableDeclaration : BindingIdentifier

        // 1. Return NormalCompletion(empty).
        continue;
      } else if (declar.id.type === "Identifier" && Initializer) {
        // VariableDeclaration : BindingIdentifier Initializer

        // 1. Let bindingId be StringValue of BindingIdentifier.
        var bindingId = declar.id.name;

        // 2. Let lhs be ? ResolveBinding(bindingId).
        var lhs = _singletons.Environment.ResolveBinding(realm, bindingId, strictCode);

        // 3. Let rhs be the result of evaluating Initializer.
        var rhs = env.evaluate(Initializer, strictCode);

        // 4. Let value be ? GetValue(rhs).
        var value = _singletons.Environment.GetValue(realm, rhs);
        if (declar.id && declar.id.name) value.__originalName = bindingId;

        // 5. If IsAnonymousFunctionDefinition(Initializer) is true, then
        if ((0, _index2.IsAnonymousFunctionDefinition)(realm, Initializer)) {
          (0, _invariant2.default)(value instanceof _index.ObjectValue);

          // a. Let hasNameProperty be ? HasOwnProperty(value, "name").
          var hasNameProperty = (0, _index2.HasOwnProperty)(realm, value, "name");

          // b. If hasNameProperty is false, perform SetFunctionName(value, bindingId).
          if (!hasNameProperty) _singletons.Functions.SetFunctionName(realm, value, new _index.StringValue(realm, bindingId));
        }

        // 6. Return ? PutValue(lhs, value).
        _singletons.Properties.PutValue(realm, lhs, value);
      } else if ((declar.id.type === "ObjectPattern" || declar.id.type === "ArrayPattern") && Initializer) {
        // 1. Let rhs be the result of evaluating Initializer.
        var _rhs = env.evaluate(Initializer, strictCode);

        // 2. Let rval be ? GetValue(rhs).
        var rval = _singletons.Environment.GetValue(realm, _rhs);

        // 3. Return the result of performing BindingInitialization for BindingPattern passing rval and undefined as arguments.
        _singletons.Environment.BindingInitialization(realm, declar.id, rval, strictCode, undefined);
      } else {
        (0, _invariant2.default)(false, "unrecognized declaration");
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return realm.intrinsics.empty;
};

var _errors = require("../errors.js");

var _index = require("../values/index.js");

var _index2 = require("../methods/index.js");

var _singletons = require("../singletons.js");

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// ECMA262 13.3.1.4
function letAndConst(ast, strictCode, env, realm) {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = ast.declarations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var declar = _step.value;

      if (declar.id.type !== "Identifier") {
        throw new _errors.FatalError("TODO #415: Patterns aren't supported yet");
      }

      var Initializer = declar.init;
      if (!Initializer) {
        (0, _invariant2.default)(ast.kind !== "const", "const without an initializer");

        // 1. Let lhs be ResolveBinding(StringValue of BindingIdentifier).
        var _bindingId = declar.id.name;
        var _lhs = _singletons.Environment.ResolveBinding(realm, _bindingId, strictCode);

        // 2. Return InitializeReferencedBinding(lhs, undefined).
        _singletons.Environment.InitializeReferencedBinding(realm, _lhs, realm.intrinsics.undefined);
        continue;
      }

      // 1. Let bindingId be StringValue of BindingIdentifier.
      var bindingId = declar.id.name;

      // 2. Let lhs be ResolveBinding(bindingId).
      var lhs = _singletons.Environment.ResolveBinding(realm, bindingId, strictCode);

      // 3. Let rhs be the result of evaluating Initializer.
      var rhs = env.evaluate(Initializer, strictCode);

      // 4. Let value be ? GetValue(rhs).
      var value = _singletons.Environment.GetValue(realm, rhs);

      // 5. If IsAnonymousFunctionDefinition(Initializer) is true, then
      if ((0, _index2.IsAnonymousFunctionDefinition)(realm, Initializer)) {
        (0, _invariant2.default)(value instanceof _index.ObjectValue);

        // a. Let hasNameProperty be ? HasOwnProperty(value, "name").
        var hasNameProperty = (0, _index2.HasOwnProperty)(realm, value, "name");

        // b. If hasNameProperty is false, perform SetFunctionName(value, bindingId).
        if (!hasNameProperty) _singletons.Functions.SetFunctionName(realm, value, new _index.StringValue(realm, bindingId));
      }

      // 6. Return InitializeReferencedBinding(lhs, value).
      _singletons.Environment.InitializeReferencedBinding(realm, lhs, value);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return realm.intrinsics.empty;
}

// ECMA262 13.3.2.4
/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
//# sourceMappingURL=VariableDeclaration.js.map