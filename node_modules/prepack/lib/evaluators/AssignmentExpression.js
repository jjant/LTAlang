"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (ast, strictCode, env, realm) {
  if (!ast.hasOwnProperty("operator") || ast.operator === null) throw Error("Unexpected AST form");

  var LeftHandSideExpression = ast.left;
  var AssignmentExpression = ast.right;
  var AssignmentOperator = ast.operator;

  // AssignmentExpression : LeftHandSideExpression = AssignmentExpression
  if (AssignmentOperator === "=") {
    // 1. If LeftHandSideExpression is neither an ObjectLiteral nor an ArrayLiteral, then
    //
    // The spec assumes we haven't yet distinguished between literals and
    // patterns, but our parser does that work for us. That means we check for
    // "*Pattern" instead of "*Literal" like the spec text suggests.
    if (LeftHandSideExpression.type !== "ObjectPattern" && LeftHandSideExpression.type !== "ArrayPattern") {
      // a. Let lref be the result of evaluating LeftHandSideExpression.
      var _lref = env.evaluate(LeftHandSideExpression, strictCode);
      // b. ReturnIfAbrupt(lref). -- Not neccessary
      // c. Let rref be the result of evaluating AssignmentExpression.
      var _rref2 = env.evaluate(AssignmentExpression, strictCode);
      // d. Let rval be ? GetValue(rref).
      var _rval2 = _singletons.Environment.GetValue(realm, _rref2);
      // e. If IsAnonymousFunctionDefinition(AssignmentExpression) and IsIdentifierRef of LeftHandSideExpression are both true, then
      if ((0, _index2.IsAnonymousFunctionDefinition)(realm, AssignmentExpression) && (0, _index2.IsIdentifierRef)(realm, LeftHandSideExpression)) {
        (0, _invariant2.default)(_rval2 instanceof _index.ObjectValue);
        // i. Let hasNameProperty be ? HasOwnProperty(rval, "name").
        var hasNameProperty = (0, _index2.HasOwnProperty)(realm, _rval2, "name");
        // ii. If hasNameProperty is false, perform SetFunctionName(rval, GetReferencedName(lref)).
        if (!hasNameProperty) {
          (0, _invariant2.default)(_lref instanceof _environment.Reference);
          _singletons.Functions.SetFunctionName(realm, _rval2, _singletons.Environment.GetReferencedName(realm, _lref));
        }
      }
      // f. Perform ? PutValue(lref, rval).
      _singletons.Properties.PutValue(realm, _lref, _rval2);
      // g. Return rval.
      return _rval2;
    }

    // 2. Let assignmentPattern be the parse of the source text corresponding to LeftHandSideExpression using AssignmentPattern[?Yield] as the goal symbol.
    var assignmentPattern = LeftHandSideExpression;

    // 3. Let rref be the result of evaluating AssignmentExpression.
    var _rref = env.evaluate(AssignmentExpression, strictCode);

    // 4. Let rval be ? GetValue(rref).
    var _rval = _singletons.Environment.GetValue(realm, _rref);

    // 5. Let status be the result of performing DestructuringAssignmentEvaluation of assignmentPattern using rval as the argument.
    (0, _index2.DestructuringAssignmentEvaluation)(realm, assignmentPattern, _rval, strictCode, env);

    // 6. ReturnIfAbrupt(status).

    // 7. Return rval.
    return _rval;
  }

  // AssignmentExpression : LeftHandSideExpression AssignmentOperator AssignmentExpression

  // 1. Let lref be the result of evaluating LeftHandSideExpression.
  var lref = env.evaluate(LeftHandSideExpression, strictCode);
  // 2. Let lval be ? GetValue(lref).
  var lval = _singletons.Environment.GetValue(realm, lref);
  // 3. Let rref be the result of evaluating AssignmentExpression.
  var rref = env.evaluate(AssignmentExpression, strictCode);
  // 4. Let rval be ? GetValue(rref).
  var rval = _singletons.Environment.GetValue(realm, rref);
  // 5. Let op be the @ where AssignmentOperator is @=.
  var op = AssignmentOperator.slice(0, -1);
  // 6. Let r be the result of applying op to lval and rval as if evaluating the expression lval op rval.
  var r = _singletons.Environment.GetValue(realm, (0, _BinaryExpression.computeBinary)(realm, op, lval, rval, ast.left.loc, ast.right.loc));
  // 7. Perform ? PutValue(lref, r).
  _singletons.Properties.PutValue(realm, lref, r);
  // 8. Return r.
  return r;
};

var _index = require("../values/index.js");

var _environment = require("../environment.js");

var _index2 = require("../methods/index.js");

var _singletons = require("../singletons.js");

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _BinaryExpression = require("./BinaryExpression.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
//# sourceMappingURL=AssignmentExpression.js.map