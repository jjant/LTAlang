{"version":3,"sources":["../../src/evaluators/CatchClause.js"],"names":["ast","strictCode","env","realm","thrownValue","oldEnv","getRunningContext","lexicalEnvironment","catchEnv","NewDeclarativeEnvironment","catchEnvRec","environmentRecord","BoundNames","param","argName","CreateMutableBinding","BindingInitialization","value","B","evaluate","body"],"mappings":";;;;;;kBAoBe,UACbA,GADa,EAEbC,UAFa,EAGbC,GAHa,EAIbC,KAJa,EAKbC,WALa,EAMN;AACP,2BAAUA,mDAAV,EAAkD,mCAAlD;;AAEA;AACA,MAAIC,SAASF,MAAMG,iBAAN,GAA0BC,kBAAvC;;AAEA;AACA,MAAIC,WAAW,wBAAYC,yBAAZ,CAAsCN,KAAtC,EAA6CE,MAA7C,CAAf;;AAEA;AACA,MAAIK,cAAcF,SAASG,iBAA3B;;AAEA;AAZO;AAAA;AAAA;;AAAA;AAaP,yBAAoB,wBAAYC,UAAZ,CAAuBT,KAAvB,EAA8BH,IAAIa,KAAlC,CAApB,8HAA8D;AAAA,UAArDC,OAAqD;;AAC5D;AACAJ,kBAAYK,oBAAZ,CAAiCD,OAAjC,EAA0C,KAA1C;AACD;;AAED;AAlBO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAmBPX,QAAMG,iBAAN,GAA0BC,kBAA1B,GAA+CC,QAA/C;;AAEA,MAAI;AACF;AACA,4BAAYQ,qBAAZ,CAAkCb,KAAlC,EAAyCH,IAAIa,KAA7C,EAAoDT,YAAYa,KAAhE,EAAuEhB,UAAvE,EAAmFO,QAAnF;;AAEA;AACA;AACA;;AAEA;AACA,QAAIU,IAAIV,SAASW,QAAT,CAAkBnB,IAAIoB,IAAtB,EAA4BnB,UAA5B,CAAR;AACA,6BAAUiB,yBAAV;;AAEA;AACA,WAAOA,CAAP;AACD,GAdD,SAcU;AACR;AACAf,UAAMG,iBAAN,GAA0BC,kBAA1B,GAA+CF,MAA/C;AACD;AACF,C;;AApDD;;AACA;;AACA;;;;AACA","file":"CatchClause.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { Value } from \"../values/index.js\";\nimport { ThrowCompletion } from \"../completions.js\";\nimport invariant from \"../invariant.js\";\nimport { Environment } from \"../singletons.js\";\nimport type { BabelNodeCatchClause } from \"babel-types\";\n\n// ECAM262 13.15.7\nexport default function(\n  ast: BabelNodeCatchClause,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm,\n  thrownValue: any\n): Value {\n  invariant(thrownValue instanceof ThrowCompletion, \"Metadata isn't a throw completion\");\n\n  // 1. Let oldEnv be the running execution context's LexicalEnvironment.\n  let oldEnv = realm.getRunningContext().lexicalEnvironment;\n\n  // 2. Let catchEnv be NewDeclarativeEnvironment(oldEnv).\n  let catchEnv = Environment.NewDeclarativeEnvironment(realm, oldEnv);\n\n  // 3. Let catchEnvRec be catchEnv's EnvironmentRecord.\n  let catchEnvRec = catchEnv.environmentRecord;\n\n  // 4. For each element argName of the BoundNames of CatchParameter, do\n  for (let argName of Environment.BoundNames(realm, ast.param)) {\n    // a. Perform ! catchEnvRec.CreateMutableBinding(argName, false).\n    catchEnvRec.CreateMutableBinding(argName, false);\n  }\n\n  // 5. Set the running execution context's LexicalEnvironment to catchEnv.\n  realm.getRunningContext().lexicalEnvironment = catchEnv;\n\n  try {\n    // 6. Let status be the result of performing BindingInitialization for CatchParameter passing thrownValue and catchEnv as arguments.\n    Environment.BindingInitialization(realm, ast.param, thrownValue.value, strictCode, catchEnv);\n\n    // 7. If status is an abrupt completion, then\n    // a. Set the running execution context's LexicalEnvironment to oldEnv.\n    // b. Return Completion(status).\n\n    // 8. Let B be the result of evaluating Block.\n    let B = catchEnv.evaluate(ast.body, strictCode);\n    invariant(B instanceof Value);\n\n    // 10. Return Completion(B).\n    return B;\n  } finally {\n    // 9. Set the running execution context's LexicalEnvironment to oldEnv.\n    realm.getRunningContext().lexicalEnvironment = oldEnv;\n  }\n}\n"]}