"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (ast, strictCode, env, realm) {
  function reportError() {
    var error = new _errors.CompilerDiagnostic("might be a symbol or an object with an unknown valueOf or toString or Symbol.toPrimitive method", ast.argument.loc, "PP0008", "RecoverableError");
    if (realm.handleError(error) === "Fail") throw new _errors.FatalError();
  }

  var expr = env.evaluate(ast.argument, strictCode);

  if (ast.operator === "+") {
    // ECMA262 12.5.6.1

    // 1. Let expr be the result of evaluating UnaryExpression.
    expr;

    // 2. Return ? ToNumber(? GetValue(expr)).
    var value = _singletons.Environment.GetValue(realm, expr);
    if (value instanceof _index.AbstractValue) {
      if (!(0, _index2.IsToNumberPure)(realm, value)) reportError();
      return _index.AbstractValue.createFromUnaryOp(realm, "+", value);
    }
    (0, _invariant2.default)(value instanceof _index.ConcreteValue);

    return new _index.NumberValue(realm, (0, _index2.ToNumber)(realm, value));
  } else if (ast.operator === "-") {
    // ECMA262 12.5.7.1

    // 1. Let expr be the result of evaluating UnaryExpression.
    expr;

    // 2. Let oldValue be ? ToNumber(? GetValue(expr)).
    var _value = _singletons.Environment.GetValue(realm, expr);
    if (_value instanceof _index.AbstractValue) {
      if (!(0, _index2.IsToNumberPure)(realm, _value)) reportError();
      return _index.AbstractValue.createFromUnaryOp(realm, "-", _value);
    }
    (0, _invariant2.default)(_value instanceof _index.ConcreteValue);
    var oldValue = (0, _index2.ToNumber)(realm, _value);

    // 3. If oldValue is NaN, return NaN.
    if (isNaN(oldValue)) {
      return realm.intrinsics.NaN;
    }

    // 4. Return the result of negating oldValue; that is, compute a Number with the same magnitude but opposite sign.
    return new _index.NumberValue(realm, -oldValue);
  } else if (ast.operator === "~") {
    // ECMA262 12.5.8

    // 1. Let expr be the result of evaluating UnaryExpression.
    expr;

    // 2. Let oldValue be ? ToInt32(? GetValue(expr)).
    var _value2 = _singletons.Environment.GetValue(realm, expr);
    if (_value2 instanceof _index.AbstractValue) {
      if (!(0, _index2.IsToNumberPure)(realm, _value2)) reportError();
      return _index.AbstractValue.createFromUnaryOp(realm, "~", _value2);
    }
    (0, _invariant2.default)(_value2 instanceof _index.ConcreteValue);
    var _oldValue = (0, _index2.ToInt32)(realm, _value2);

    // 3. Return the result of applying bitwise complement to oldValue. The result is a signed 32-bit integer.
    return new _index.NumberValue(realm, ~_oldValue);
  } else if (ast.operator === "!") {
    // ECMA262 12.6.9

    // 1. Let expr be the result of evaluating UnaryExpression.
    expr;

    // 2. Let oldValue be ToBoolean(? GetValue(expr)).
    var _value3 = _singletons.Environment.GetValue(realm, expr);
    if (_value3 instanceof _index.AbstractValue) return _index.AbstractValue.createFromUnaryOp(realm, "!", _value3);
    (0, _invariant2.default)(_value3 instanceof _index.ConcreteValue);
    var _oldValue2 = (0, _index2.ToBoolean)(realm, _value3);

    // 3. If oldValue is true, return false.
    if (_oldValue2 === true) return realm.intrinsics.false;

    // 4. Return true.
    return realm.intrinsics.true;
  } else if (ast.operator === "void") {
    // 1. Let expr be the result of evaluating UnaryExpression.
    expr;

    // 2. Perform ? GetValue(expr).
    _singletons.Environment.GetValue(realm, expr);

    // 3. Return undefined.
    return realm.intrinsics.undefined;
  } else if (ast.operator === "typeof") {
    // ECMA262 12.6.5

    // 1. Let val be the result of evaluating UnaryExpression.
    var val = expr;

    // 2. If Type(val) is Reference, then
    if (val instanceof _environment.Reference) {
      // a. If IsUnresolvableReference(val) is true, return "undefined".
      if (_singletons.Environment.IsUnresolvableReference(realm, val)) {
        return new _index.StringValue(realm, "undefined");
      }
    }

    // 3. Let val be ? GetValue(val).
    val = _singletons.Environment.GetValue(realm, val);

    // 4. Return a String according to Table 35.
    var proto = val.getType().prototype;
    if (isInstance(proto, _index.UndefinedValue)) {
      return new _index.StringValue(realm, "undefined");
    } else if (isInstance(proto, _index.NullValue)) {
      return new _index.StringValue(realm, "object");
    } else if (isInstance(proto, _index.StringValue)) {
      return new _index.StringValue(realm, "string");
    } else if (isInstance(proto, _index.BooleanValue)) {
      return new _index.StringValue(realm, "boolean");
    } else if (isInstance(proto, _index.NumberValue)) {
      return new _index.StringValue(realm, "number");
    } else if (isInstance(proto, _index.SymbolValue)) {
      return new _index.StringValue(realm, "symbol");
    } else if (isInstance(proto, _index.ObjectValue)) {
      if ((0, _index2.IsCallable)(realm, val)) {
        return new _index.StringValue(realm, "function");
      }
      return new _index.StringValue(realm, "object");
    } else {
      (0, _invariant2.default)(val instanceof _index.AbstractValue);
      return _index.AbstractValue.createFromUnaryOp(realm, "typeof", val);
    }
  } else {
    (0, _invariant2.default)(ast.operator === "delete");
    // ECMA262 12.5.3.2

    // 1. Let ref be the result of evaluating UnaryExpression.
    var ref = expr;

    // 2. ReturnIfAbrupt(ref).

    // 3. If Type(ref) is not Reference, return true.
    if (!(ref instanceof _environment.Reference)) return realm.intrinsics.true;

    // 4. If IsUnresolvableReference(ref) is true, then
    if (_singletons.Environment.IsUnresolvableReference(realm, ref)) {
      // a. Assert: IsStrictReference(ref) is false.
      (0, _invariant2.default)(!_singletons.Environment.IsStrictReference(realm, ref), "did not expect a strict reference");

      // b. Return true.
      return realm.intrinsics.true;
    }

    // 5. If IsPropertyReference(ref) is true, then
    if (_singletons.Environment.IsPropertyReference(realm, ref)) {
      // a. If IsSuperReference(ref) is true, throw a ReferenceError exception.
      if (_singletons.Environment.IsSuperReference(realm, ref)) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError);
      }

      // b. Let baseObj be ! ToObject(GetBase(ref)).
      var base = _singletons.Environment.GetBase(realm, ref);
      // Constructing the reference checks that base is coercible to an object hence
      (0, _invariant2.default)(base instanceof _index.ConcreteValue || base instanceof _index.AbstractObjectValue);
      var baseObj = base instanceof _index.ConcreteValue ? (0, _index2.ToObject)(realm, base) : base;

      // c. Let deleteStatus be ? baseObj.[[Delete]](GetReferencedName(ref)).
      var deleteStatus = baseObj.$Delete(_singletons.Environment.GetReferencedName(realm, ref));

      // d. If deleteStatus is false and IsStrictReference(ref) is true, throw a TypeError exception.
      if (!deleteStatus && _singletons.Environment.IsStrictReference(realm, ref)) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
      }

      // e. Return deleteStatus.
      return new _index.BooleanValue(realm, deleteStatus);
    }

    // 6. Else ref is a Reference to an Environment Record binding,
    // a. Let bindings be GetBase(ref).
    var bindings = _singletons.Environment.GetBase(realm, ref);
    (0, _invariant2.default)(bindings instanceof _environment.EnvironmentRecord);

    // b. Return ? bindings.DeleteBinding(GetReferencedName(ref)).
    var referencedName = _singletons.Environment.GetReferencedName(realm, ref);
    (0, _invariant2.default)(typeof referencedName === "string");
    return new _index.BooleanValue(realm, bindings.DeleteBinding(referencedName));
  }
};

var _errors = require("../errors.js");

var _index = require("../values/index.js");

var _environment = require("../environment.js");

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _index2 = require("../methods/index.js");

var _singletons = require("../singletons.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

function isInstance(proto, Constructor) {
  return proto instanceof Constructor || proto === Constructor.prototype;
}
//# sourceMappingURL=UnaryExpression.js.map