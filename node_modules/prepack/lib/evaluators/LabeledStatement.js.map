{"version":3,"sources":["../../src/evaluators/LabeledStatement.js"],"names":["ast","strictCode","env","realm","newLabelSet","LabelledEvaluation","labelSet","type","labeledAst","label","name","push","normalCompletionStmtResult","body","stmtResult","target","value","kind","r","evaluate","createErrorThrowCompletion","intrinsics","SyntaxError"],"mappings":";;;;;;kBAyEe,UACbA,GADa,EAEbC,UAFa,EAGbC,GAHa,EAIbC,KAJa,EAKM;AACnB;AACA,MAAIC,cAAc,EAAlB;;AAEA;AACA,SAAOC,mBAAmBD,WAAnB,EAAgCJ,GAAhC,EAAqCC,UAArC,EAAiDC,GAAjD,EAAsDC,KAAtD,CAAP;AACD,C;;AAvED;;AAEA;;AAEA;;;;;;AAEA;AACA,SAASE,kBAAT,CACEC,QADF,EAEEN,GAFF,EAGEC,UAHF,EAIEC,GAJF,EAKEC,KALF,EAMS;AACP;AACA,UAAQH,IAAIO,IAAZ;AACE,SAAK,kBAAL;AACE,UAAIC,aAAeR,GAAnB;AACA;AACA,UAAIS,QAAQD,WAAWC,KAAX,CAAiBC,IAA7B;;AAEA;AACAJ,eAASK,IAAT,CAAcF,KAAd;;AAEA;AACA,UAAIG,mCAAJ;AACA,UAAI;AACFA,qCAA6BP,mBAAmBC,QAAnB,EAA6BE,WAAWK,IAAxC,EAA8CZ,UAA9C,EAA0DC,GAA1D,EAA+DC,KAA/D,CAA7B;AACD,OAFD,CAEE,OAAOW,UAAP,EAAmB;AACnB;AACA,YAAIA,sDAAyCA,WAAWC,MAAX,KAAsBN,KAAnE,EAA0E;AACxE;AACAG,uCAA6BE,WAAWE,KAAxC;AACD,SAHD,MAGO;AACL;AACA,gBAAMF,UAAN;AACD;AACF;AACD;AACA,aAAOF,0BAAP;;AAEF,SAAK,qBAAL;AACE,UAAIZ,IAAIiB,IAAJ,KAAa,KAAjB,EAAwB;AACtB,YAAIC,KAAIhB,IAAIiB,QAAJ,CAAanB,GAAb,EAAkBC,UAAlB,CAAR;AACA,iCAAUiB,0BAAV;AACA,eAAOA,EAAP;AACD;AACH;AACA,SAAK,qBAAL;AACA,SAAK,kBAAL;AACE,YAAMf,MAAMiB,0BAAN,CAAiCjB,MAAMkB,UAAN,CAAiBC,WAAlD,EAA+DtB,IAAIO,IAAJ,GAAW,uBAA1E,CAAN;;AAEF;AACE,UAAIW,IAAIhB,IAAIiB,QAAJ,CAAanB,GAAb,EAAkBC,UAAlB,EAA8BK,QAA9B,CAAR;AACA,+BAAUY,yBAAV;AACA,aAAOA,CAAP;AAxCJ;AA0CD;;AAED;AAxEA","file":"LabeledStatement.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { Value } from \"../values/index.js\";\nimport type { Reference } from \"../environment.js\";\nimport { BreakCompletion } from \"../completions.js\";\nimport type { BabelNodeLabeledStatement, BabelNode } from \"babel-types\";\nimport invariant from \"../invariant.js\";\n\n// ECMA262 13.13.14\nfunction LabelledEvaluation(\n  labelSet: Array<string>,\n  ast: BabelNode,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  // LabelledStatement:LabelIdentifier:LabelledItem\n  switch (ast.type) {\n    case \"LabeledStatement\":\n      let labeledAst = ((ast: any): BabelNodeLabeledStatement);\n      // 1. Let label be the StringValue of LabelIdentifier.\n      let label = labeledAst.label.name;\n\n      // 2. Append label as an element of labelSet.\n      labelSet.push(label);\n\n      // 3. Let stmtResult be LabelledEvaluation of LabelledItem with argument labelSet.\n      let normalCompletionStmtResult;\n      try {\n        normalCompletionStmtResult = LabelledEvaluation(labelSet, labeledAst.body, strictCode, env, realm);\n      } catch (stmtResult) {\n        // 4. If stmtResult.[[Type]] is break and SameValue(stmtResult.[[Target]], label) is true, then\n        if (stmtResult instanceof BreakCompletion && stmtResult.target === label) {\n          // a. Let stmtResult be NormalCompletion(stmtResult.[[Value]]).\n          normalCompletionStmtResult = stmtResult.value;\n        } else {\n          // 5. Return Completion(stmtResult).\n          throw stmtResult;\n        }\n      }\n      // 5. Return Completion(stmtResult).\n      return normalCompletionStmtResult;\n\n    case \"VariableDeclaration\":\n      if (ast.kind === \"var\") {\n        let r = env.evaluate(ast, strictCode);\n        invariant(r instanceof Value);\n        return r;\n      }\n    // fall through to throw\n    case \"FunctionDeclaration\":\n    case \"ClassDeclaration\":\n      throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, ast.type + \" may not have a label\");\n\n    default:\n      let r = env.evaluate(ast, strictCode, labelSet);\n      invariant(r instanceof Value);\n      return r;\n  }\n}\n\n// ECMA262 13.13.15\nexport default function(\n  ast: BabelNodeLabeledStatement,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value | Reference {\n  //1. Let newLabelSet be a new empty List.\n  let newLabelSet = [];\n\n  //2. Return LabelledEvaluation of this LabelledStatement with argument newLabelSet.\n  return LabelledEvaluation(newLabelSet, ast, strictCode, env, realm);\n}\n"]}