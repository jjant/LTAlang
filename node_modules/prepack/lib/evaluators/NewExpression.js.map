{"version":3,"sources":["../../src/evaluators/NewExpression.js"],"names":["ast","strictCode","env","realm","setNextExecutionContextLocation","loc","constructProduction","callee","args","arguments","ref","evaluate","constructor","GetValue","argsList","length","createErrorThrowCompletion","intrinsics","TypeError"],"mappings":";;;;;;kBAqBe,UACbA,GADa,EAEbC,UAFa,EAGbC,GAHa,EAIbC,KAJa,EAKA;AACbA,QAAMC,+BAAN,CAAsCJ,IAAIK,GAA1C;;AAEA;AACA;;AAEA;;AAEA,MAAIC,sBAAsBN,IAAIO,MAA9B;AACA,MAAIC,OAAOR,IAAIS,SAAf;;AAEA;AACA;AACA;;AAEA;AACA,MAAIC,MAAMR,IAAIS,QAAJ,CAAaL,mBAAb,EAAkCL,UAAlC,CAAV;;AAEA;AACA,MAAIW,cAAc,wBAAYC,QAAZ,CAAqBV,KAArB,EAA4BO,GAA5B,CAAlB;;AAEA,MAAII,iBAAJ;;AAEA;AACA,MAAI,CAACN,KAAKO,MAAV,EAAkB;AAChBD,eAAW,EAAX;AACD,GAFD,MAEO;AACL;AACA;AACAA,eAAW,oCAAuBX,KAAvB,EAA8BF,UAA9B,EAA0CC,GAA1C,EAAgDM,IAAhD,CAAX,CAHK,CAGmE;;AAExE;AACA;AACD;;AAED;AACA,MAAI,2BAAcL,KAAd,EAAqBS,WAArB,MAAsC,KAA1C,EAAiD;AAC/C,UAAMT,MAAMa,0BAAN,CAAiCb,MAAMc,UAAN,CAAiBC,SAAlD,CAAN;AACD;AACD,2BAAUN,yCAAV;;AAEA;AACA,SAAO,uBAAUT,KAAV,EAAiBS,WAAjB,EAA8BE,QAA9B,CAAP;AACD,C;;AAxDD;;AACA;;AACA;;AAGA","file":"NewExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { ObjectValue } from \"../values/index.js\";\nimport { Environment } from \"../singletons.js\";\nimport { IsConstructor } from \"../methods/index.js\";\nimport { ArgumentListEvaluation } from \"../methods/index.js\";\nimport { Construct } from \"../methods/index.js\";\nimport invariant from \"../invariant.js\";\nimport type { BabelNodeNewExpression } from \"babel-types\";\n\nexport default function(\n  ast: BabelNodeNewExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): ObjectValue {\n  realm.setNextExecutionContextLocation(ast.loc);\n\n  // ECMA262 12.3.3.1 We just implement this method inline since it's only called here.\n  // 1. Return ? EvaluateNew(NewExpression, empty).\n\n  // ECMA262 2.3.3.1.1\n\n  let constructProduction = ast.callee;\n  let args = ast.arguments;\n\n  // These steps not necessary due to our AST representation.\n  // 1. Assert: constructProduction is either a NewExpression or a MemberExpression.\n  // 2. Assert: arguments is either empty or an Arguments production.\n\n  // 3. Let ref be the result of evaluating constructProduction.\n  let ref = env.evaluate(constructProduction, strictCode);\n\n  // 4. Let constructor be ? GetValue(ref).\n  let constructor = Environment.GetValue(realm, ref);\n\n  let argsList;\n\n  // 5. If arguments is empty, let argList be a new empty List.\n  if (!args.length) {\n    argsList = [];\n  } else {\n    // 6. Else,\n    // a. Let argList be ArgumentListEvaluation of arguments.\n    argsList = ArgumentListEvaluation(realm, strictCode, env, (args: any)); // BabelNodeNewExpression needs updating\n\n    // This step not necessary since we propagate completions with exceptions.\n    // b. ReturnIfAbrupt(argList).\n  }\n\n  // 7. If IsConstructor(constructor) is false, throw a TypeError exception.\n  if (IsConstructor(realm, constructor) === false) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n  }\n  invariant(constructor instanceof ObjectValue);\n\n  // 8. Return ? Construct(constructor, argList).\n  return Construct(realm, constructor, argsList);\n}\n"]}