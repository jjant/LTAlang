{"version":3,"sources":["../../src/evaluators/TryStatement.js"],"names":["ast","strictCode","env","realm","blockRes","evaluateCompletionDeref","block","handlerRes","handler","incorporateSavedCompletion","subsequentEffects","getCapturedEffects","value","undefined","stopEffectCaptureAndUndoEffects","updatePossiblyNormalCompletionWithSubsequentEffects","handlerEffects","composeNestedThrowEffectsWithHandler","applyEffects","finalizerRes","finalizer","finalizerEffects","composeNestedEffectsWithFinalizer","evaluateCompletion","composeWithSavedCompletion","intrinsics","c","priorEffects","consequent","consequentEffects","push","evaluateForEffects","priorEffect","pop","alternate","alternateEffects","joinEffects","joinCondition"],"mappings":"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","file":"TryStatement.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Effects, Realm } from \"../realm.js\";\nimport { type LexicalEnvironment } from \"../environment.js\";\nimport {\n  AbruptCompletion,\n  JoinedAbruptCompletions,\n  PossiblyNormalCompletion,\n  ThrowCompletion,\n} from \"../completions.js\";\nimport { UpdateEmpty } from \"../methods/index.js\";\nimport { Functions, Join } from \"../singletons.js\";\nimport { Value } from \"../values/index.js\";\nimport type { BabelNodeTryStatement } from \"babel-types\";\nimport invariant from \"../invariant.js\";\n\nexport default function(ast: BabelNodeTryStatement, strictCode: boolean, env: LexicalEnvironment, realm: Realm): Value {\n  let blockRes = env.evaluateCompletionDeref(ast.block, strictCode);\n\n  let handlerRes = blockRes;\n  let handler = ast.handler;\n  if (handler) {\n    // The start of the catch handler is a join point where all throw completions come together\n    blockRes = Functions.incorporateSavedCompletion(realm, blockRes);\n    if (blockRes instanceof ThrowCompletion) {\n      handlerRes = env.evaluateCompletionDeref(handler, strictCode, blockRes);\n      // Note: The handler may have introduced new forks\n    } else if (blockRes instanceof JoinedAbruptCompletions || blockRes instanceof PossiblyNormalCompletion) {\n      if (blockRes instanceof PossiblyNormalCompletion) {\n        // Nothing has been joined and we are going to keep it that way.\n        // The current state may have advanced since the time control forked into the various paths recorded in blockRes.\n        // Update the normal path and restore the global state to what it was at the time of the fork.\n        let subsequentEffects = realm.getCapturedEffects(blockRes, blockRes.value);\n        invariant(subsequentEffects !== undefined);\n        realm.stopEffectCaptureAndUndoEffects(blockRes);\n        Join.updatePossiblyNormalCompletionWithSubsequentEffects(realm, blockRes, subsequentEffects);\n      }\n      // All of the forked threads of control are now joined together and the global state reflects their joint effects\n      let handlerEffects = composeNestedThrowEffectsWithHandler(blockRes);\n      handlerRes = handlerEffects[0];\n      if (handlerRes instanceof Value) {\n        // This can happen if all of the abrupt completions in blockRes were throw completions\n        // and if the handler does not introduce any abrupt completions of its own.\n        realm.applyEffects(handlerEffects);\n        // The global state is now all joined up\n      } else {\n        // more than thread of control leaves the handler\n        // The effects of each thread is tracked in handlerRes\n      }\n    } else {\n      // The handler is not invoked, so just carry on.\n    }\n  }\n\n  let finalizerRes = handlerRes;\n  if (ast.finalizer) {\n    // The start of the finalizer is a join point where all threads of control come together.\n    // However, we choose to keep the threads unjoined and to apply the finalizer separately to each thread.\n    if (blockRes instanceof PossiblyNormalCompletion || blockRes instanceof JoinedAbruptCompletions) {\n      // The current global state is a the point of the fork that led to blockRes\n      // All subsequent effects are kept inside the branches of blockRes.\n      let finalizerEffects = composeNestedEffectsWithFinalizer(blockRes);\n      finalizerRes = finalizerEffects[0];\n      // The result may become abrupt because of the finalizer, but it cannot become normal.\n      invariant(!(finalizerRes instanceof Value));\n    } else {\n      // A single thread of control has produced a normal blockRes and the global state is up to date.\n      finalizerRes = env.evaluateCompletion(ast.finalizer, strictCode);\n    }\n  }\n\n  if (finalizerRes instanceof AbruptCompletion) throw finalizerRes;\n  if (finalizerRes instanceof PossiblyNormalCompletion) realm.composeWithSavedCompletion(finalizerRes);\n  if (handlerRes instanceof PossiblyNormalCompletion) handlerRes = handlerRes.value;\n  if (handlerRes instanceof Value) return (UpdateEmpty(realm, handlerRes, realm.intrinsics.undefined): any);\n  throw handlerRes;\n\n  // The handler is a potential join point for all throw completions, but is easier to not do the join here because\n  // it is tricky to join the joined and composed result of the throw completions with the non exceptional completions.\n  // Unfortunately, things are still complicated because the handler may turn abrupt completions into normal\n  // completions and the other way around. When this happens the container has to change its type.\n  // We do this by call joinEffects to create a new container at every level of the recursion.\n  function composeNestedThrowEffectsWithHandler(\n    c: PossiblyNormalCompletion | JoinedAbruptCompletions,\n    priorEffects: Array<Effects> = []\n  ): Effects {\n    let consequent = c.consequent;\n    let consequentEffects = c.consequentEffects;\n    priorEffects.push(consequentEffects);\n    if (consequent instanceof JoinedAbruptCompletions || consequent instanceof PossiblyNormalCompletion) {\n      consequentEffects = composeNestedThrowEffectsWithHandler(consequent, priorEffects);\n    } else if (consequent instanceof ThrowCompletion) {\n      consequentEffects = realm.evaluateForEffects(() => {\n        for (let priorEffect of priorEffects) realm.applyEffects(priorEffect);\n        invariant(ast.handler);\n        return env.evaluateCompletionDeref(ast.handler, strictCode, consequent);\n      });\n    }\n    priorEffects.pop();\n    let alternate = c.alternate;\n    let alternateEffects = c.alternateEffects;\n    priorEffects.push(alternateEffects);\n    if (alternate instanceof PossiblyNormalCompletion || alternate instanceof JoinedAbruptCompletions) {\n      alternateEffects = composeNestedThrowEffectsWithHandler(alternate, priorEffects);\n    } else if (alternate instanceof ThrowCompletion) {\n      alternateEffects = realm.evaluateForEffects(() => {\n        for (let priorEffect of priorEffects) realm.applyEffects(priorEffect);\n        invariant(ast.handler);\n        return env.evaluateCompletionDeref(ast.handler, strictCode, alternate);\n      });\n    }\n    priorEffects.pop();\n    return Join.joinEffects(realm, c.joinCondition, consequentEffects, alternateEffects);\n  }\n\n  // The finalizer is not a join point, so update each path in the completion separately.\n  // Things are complicated because the finalizer may turn normal completions into abrupt completions.\n  // When this happens the container has to change its type.\n  // We do this by call joinEffects to create a new container at every level of the recursion.\n  function composeNestedEffectsWithFinalizer(\n    c: PossiblyNormalCompletion | JoinedAbruptCompletions,\n    priorEffects: Array<Effects> = []\n  ): Effects {\n    let consequent = c.consequent;\n    let consequentEffects = c.consequentEffects;\n    priorEffects.push(consequentEffects);\n    if (consequent instanceof JoinedAbruptCompletions || consequent instanceof PossiblyNormalCompletion) {\n      consequentEffects = composeNestedThrowEffectsWithHandler(consequent, priorEffects);\n    } else {\n      consequentEffects = realm.evaluateForEffects(() => {\n        for (let priorEffect of priorEffects) realm.applyEffects(priorEffect);\n        invariant(ast.finalizer);\n        return env.evaluateCompletionDeref(ast.finalizer, strictCode);\n      });\n      if (!(consequentEffects[0] instanceof AbruptCompletion)) consequentEffects[0] = consequent;\n    }\n    priorEffects.pop();\n    let alternate = c.alternate;\n    let alternateEffects = c.alternateEffects;\n    priorEffects.push(alternateEffects);\n    if (alternate instanceof PossiblyNormalCompletion || alternate instanceof JoinedAbruptCompletions) {\n      alternateEffects = composeNestedThrowEffectsWithHandler(alternate, priorEffects);\n    } else {\n      alternateEffects = realm.evaluateForEffects(() => {\n        for (let priorEffect of priorEffects) realm.applyEffects(priorEffect);\n        invariant(ast.finalizer);\n        return env.evaluateCompletionDeref(ast.finalizer, strictCode);\n      });\n      if (!(alternateEffects[0] instanceof AbruptCompletion)) alternateEffects[0] = alternate;\n    }\n    priorEffects.pop();\n    return Join.joinEffects(realm, c.joinCondition, consequentEffects, alternateEffects);\n  }\n}\n"]}