"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Copyright (c) 2017-present, Facebook, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * This source code is licensed under the BSD-style license found in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * LICENSE file in the root directory of this source tree. An additional grant
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * of patent rights can be found in the PATENTS file in the same directory.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */

exports.default = function (ast, strictCode, env, realm, labelSet) {
  var expression = ast.discriminant;
  var cases = ast.cases;

  // 1. Let exprRef be the result of evaluating Expression.
  var exprRef = env.evaluate(expression, strictCode);

  // 2. Let switchValue be ? GetValue(exprRef).
  var switchValue = _singletons.Environment.GetValue(realm, exprRef);

  // 3. Let oldEnv be the running execution context's LexicalEnvironment.
  var oldEnv = realm.getRunningContext().lexicalEnvironment;

  // 4. Let blockEnv be NewDeclarativeEnvironment(oldEnv).
  var blockEnv = _singletons.Environment.NewDeclarativeEnvironment(realm, oldEnv);

  // 5. Perform BlockDeclarationInstantiation(CaseBlock, blockEnv).
  var CaseBlock = cases.map(function (c) {
    return c.consequent;
  }).reduce(function (stmts, case_blk) {
    return stmts.concat(case_blk);
  }, []);
  _singletons.Environment.BlockDeclarationInstantiation(realm, strictCode, CaseBlock, blockEnv);

  // 6. Set the running execution context's LexicalEnvironment to blockEnv.
  realm.getRunningContext().lexicalEnvironment = blockEnv;

  var R = void 0;
  try {
    // 7. Let R be the result of performing CaseBlockEvaluation of CaseBlock with argument switchValue.
    R = CaseBlockEvaluation(cases, switchValue, strictCode, blockEnv, realm);

    // 9. Return R.
    return R;
  } catch (e) {
    if (e instanceof _completions.BreakCompletion) {
      if (!e.target) return (0, _index2.UpdateEmpty)(realm, e, realm.intrinsics.undefined).value;
    }
    throw e;
  } finally {
    // 8. Set the running execution context's LexicalEnvironment to oldEnv.
    realm.getRunningContext().lexicalEnvironment = oldEnv;
  }
};

var _completions = require("../completions.js");

var _ForOfStatement = require("./ForOfStatement.js");

var _index = require("../values/index.js");

var _index2 = require("../methods/index.js");

var _singletons = require("../singletons.js");

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// 13.12.10 Runtime Semantics: CaseSelectorEvaluation
function CaseSelectorEvaluation(expression, strictCode, env, realm) {
  // 1. Let exprRef be the result of evaluating Expression.
  var exprRef = env.evaluate(expression, strictCode);

  // 2. Return ? GetValue(exprRef).
  return _singletons.Environment.GetValue(realm, exprRef);
}

function CaseBlockEvaluation(cases, input, strictCode, env, realm) {
  var EvaluateCase = function EvaluateCase(c) {
    var r = realm.intrinsics.empty;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = c.consequent[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var node = _step.value;

        var res = env.evaluateCompletion(node, strictCode);
        if (res instanceof _completions.AbruptCompletion) return (0, _index2.UpdateEmpty)(realm, res, r);
        if (!(res instanceof _index.EmptyValue)) r = res;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return r;
  };

  var EvaluateCaseClauses = function EvaluateCaseClauses(A, V) {
    // 2. Let A be the List of CaseClause items in CaseClauses, in source text order.
    // A is passed in

    // 3. Let found be false.
    var found = false;

    // 4. Repeat for each CaseClause C in A,
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = A[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var C = _step2.value;

        // a. If found is false, then
        if (!found) {
          // i. Let clauseSelector be the result of CaseSelectorEvaluation of C.
          var test = C.test;
          (0, _invariant2.default)(test);
          var clauseSelector = CaseSelectorEvaluation(test, strictCode, env, realm);

          // ii. ReturnIfAbrupt(clauseSelector).
          // above will throw a Completion which will return

          // iii. Let found be the result of performing Strict Equality Comparison input === clauseSelector.[[Value]].
          found = (0, _index2.StrictEqualityComparisonPartial)(realm, input, clauseSelector);
        }
        if (found) {
          // b. If found is true, then
          // i. Let R be the result of evaluating C.
          var R = EvaluateCase(C);

          // ii. If R.[[Value]] is not empty, let V be R.[[Value]].
          var val = (0, _ForOfStatement.InternalGetResultValue)(realm, R);
          if (!(val instanceof _index.EmptyValue)) V = val;

          // iii. If R is an abrupt completion, return Completion(UpdateEmpty(R, V)).
          if (R instanceof _completions.AbruptCompletion) {
            throw (0, _index2.UpdateEmpty)(realm, R, V);
          }
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    return [found, V];
  };

  // CaseBlock:{}
  // 1. Return NormalCompletion(undefined).
  if (cases.length === 0) return realm.intrinsics.undefined;

  // CaseBlock:{CaseClauses DefaultClause CaseClauses}
  var default_case_num = cases.findIndex(function (clause) {
    return clause.test === null;
  });

  if (default_case_num !== -1) {
    // 2. Let A be the List of CaseClause items in the first CaseClauses, in source text order. If the first CaseClauses is not present, A is « ».
    var A = cases.slice(0, default_case_num);

    var V = realm.intrinsics.undefined;

    // 4. Repeat for each CaseClause C in A

    // 5. Let foundInB be false.
    var _EvaluateCaseClauses = EvaluateCaseClauses(A, V);

    var _EvaluateCaseClauses2 = _slicedToArray(_EvaluateCaseClauses, 2);

    V = _EvaluateCaseClauses2[1];
    var foundInB = false;

    // 6. Let B be the List containing the CaseClause items in the second CaseClauses, in source text order. If the second CaseClauses is not present, B is « ».
    var B = cases.slice(default_case_num + 1);

    // 8. If foundInB is true, return NormalCompletion(V).
    var _EvaluateCaseClauses3 = EvaluateCaseClauses(B, V);

    var _EvaluateCaseClauses4 = _slicedToArray(_EvaluateCaseClauses3, 2);

    foundInB = _EvaluateCaseClauses4[0];
    V = _EvaluateCaseClauses4[1];
    if (foundInB) return V;

    // 9. Let R be the result of evaluating DefaultClause.
    var R = EvaluateCase(cases[default_case_num]);

    // 10. If R.[[Value]] is not empty, let V be R.[[Value]].
    var val = (0, _ForOfStatement.InternalGetResultValue)(realm, R);
    if (!(val instanceof _index.EmptyValue)) V = val;

    // 11. If R is an abrupt completion, return Completion(UpdateEmpty(R, V)).
    if (R instanceof _completions.AbruptCompletion) {
      throw (0, _index2.UpdateEmpty)(realm, R, V);
    }

    // 12: Repeat for each CaseClause C in B (NOTE this is another complete iteration of the second CaseClauses)
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = B[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var C = _step3.value;

        // a. Let R be the result of evaluating CaseClause C.
        R = EvaluateCase(C);

        // b. If R.[[Value]] is not empty, let V be R.[[Value]].
        var value = (0, _ForOfStatement.InternalGetResultValue)(realm, R);
        if (!(value instanceof _index.EmptyValue)) V = value;

        // c. If R is an abrupt completion, return Completion(UpdateEmpty(R, V)).
        if (R instanceof _completions.AbruptCompletion) {
          throw (0, _index2.UpdateEmpty)(realm, R, V);
        }
      }

      // 13. Return NormalCompletion(V).
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return) {
          _iterator3.return();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    return V;
  } else {
    // CaseBlock:{CaseClauses}
    var _V = void 0;

    var _EvaluateCaseClauses5 = EvaluateCaseClauses(cases, realm.intrinsics.undefined);

    var _EvaluateCaseClauses6 = _slicedToArray(_EvaluateCaseClauses5, 2);

    _V = _EvaluateCaseClauses6[1];

    return _V;
  }
}

// 13.12.11
//# sourceMappingURL=SwitchStatement.js.map