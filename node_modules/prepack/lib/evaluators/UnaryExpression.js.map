{"version":3,"sources":["../../src/evaluators/UnaryExpression.js"],"names":["ast","strictCode","env","realm","reportError","error","argument","loc","handleError","expr","evaluate","operator","value","GetValue","createFromUnaryOp","oldValue","isNaN","intrinsics","NaN","false","true","undefined","val","IsUnresolvableReference","proto","getType","prototype","isInstance","ref","IsStrictReference","IsPropertyReference","IsSuperReference","createErrorThrowCompletion","ReferenceError","base","GetBase","baseObj","deleteStatus","$Delete","GetReferencedName","TypeError","bindings","referencedName","DeleteBinding","Constructor"],"mappings":";;;;;;kBAqCe,UACbA,GADa,EAEbC,UAFa,EAGbC,GAHa,EAIbC,KAJa,EAKN;AACP,WAASC,WAAT,GAAuB;AACrB,QAAIC,QAAQ,+BACV,iGADU,EAEVL,IAAIM,QAAJ,CAAaC,GAFH,EAGV,QAHU,EAIV,kBAJU,CAAZ;AAMA,QAAIJ,MAAMK,WAAN,CAAkBH,KAAlB,MAA6B,MAAjC,EAAyC,MAAM,wBAAN;AAC1C;;AAED,MAAII,OAAOP,IAAIQ,QAAJ,CAAaV,IAAIM,QAAjB,EAA2BL,UAA3B,CAAX;;AAEA,MAAID,IAAIW,QAAJ,KAAiB,GAArB,EAA0B;AACxB;;AAEA;AACAF;;AAEA;AACA,QAAIG,QAAQ,wBAAYC,QAAZ,CAAqBV,KAArB,EAA4BM,IAA5B,CAAZ;AACA,QAAIG,qCAAJ,EAAoC;AAClC,UAAI,CAAC,4BAAeT,KAAf,EAAsBS,KAAtB,CAAL,EAAmCR;AACnC,aAAO,qBAAcU,iBAAd,CAAgCX,KAAhC,EAAuC,GAAvC,EAA4CS,KAA5C,CAAP;AACD;AACD,6BAAUA,qCAAV;;AAEA,WAAO,uBAAgBT,KAAhB,EAAuB,sBAASA,KAAT,EAAgBS,KAAhB,CAAvB,CAAP;AACD,GAfD,MAeO,IAAIZ,IAAIW,QAAJ,KAAiB,GAArB,EAA0B;AAC/B;;AAEA;AACAF;;AAEA;AACA,QAAIG,SAAQ,wBAAYC,QAAZ,CAAqBV,KAArB,EAA4BM,IAA5B,CAAZ;AACA,QAAIG,sCAAJ,EAAoC;AAClC,UAAI,CAAC,4BAAeT,KAAf,EAAsBS,MAAtB,CAAL,EAAmCR;AACnC,aAAO,qBAAcU,iBAAd,CAAgCX,KAAhC,EAAuC,GAAvC,EAA4CS,MAA5C,CAAP;AACD;AACD,6BAAUA,sCAAV;AACA,QAAIG,WAAW,sBAASZ,KAAT,EAAgBS,MAAhB,CAAf;;AAEA;AACA,QAAII,MAAMD,QAAN,CAAJ,EAAqB;AACnB,aAAOZ,MAAMc,UAAN,CAAiBC,GAAxB;AACD;;AAED;AACA,WAAO,uBAAgBf,KAAhB,EAAuB,CAACY,QAAxB,CAAP;AACD,GAtBM,MAsBA,IAAIf,IAAIW,QAAJ,KAAiB,GAArB,EAA0B;AAC/B;;AAEA;AACAF;;AAEA;AACA,QAAIG,UAAQ,wBAAYC,QAAZ,CAAqBV,KAArB,EAA4BM,IAA5B,CAAZ;AACA,QAAIG,uCAAJ,EAAoC;AAClC,UAAI,CAAC,4BAAeT,KAAf,EAAsBS,OAAtB,CAAL,EAAmCR;AACnC,aAAO,qBAAcU,iBAAd,CAAgCX,KAAhC,EAAuC,GAAvC,EAA4CS,OAA5C,CAAP;AACD;AACD,6BAAUA,uCAAV;AACA,QAAIG,YAAW,qBAAQZ,KAAR,EAAeS,OAAf,CAAf;;AAEA;AACA,WAAO,uBAAgBT,KAAhB,EAAuB,CAACY,SAAxB,CAAP;AACD,GAjBM,MAiBA,IAAIf,IAAIW,QAAJ,KAAiB,GAArB,EAA0B;AAC/B;;AAEA;AACAF;;AAEA;AACA,QAAIG,UAAQ,wBAAYC,QAAZ,CAAqBV,KAArB,EAA4BM,IAA5B,CAAZ;AACA,QAAIG,uCAAJ,EAAoC,OAAO,qBAAcE,iBAAd,CAAgCX,KAAhC,EAAuC,GAAvC,EAA4CS,OAA5C,CAAP;AACpC,6BAAUA,uCAAV;AACA,QAAIG,aAAW,uBAAUZ,KAAV,EAAiBS,OAAjB,CAAf;;AAEA;AACA,QAAIG,eAAa,IAAjB,EAAuB,OAAOZ,MAAMc,UAAN,CAAiBE,KAAxB;;AAEvB;AACA,WAAOhB,MAAMc,UAAN,CAAiBG,IAAxB;AACD,GAjBM,MAiBA,IAAIpB,IAAIW,QAAJ,KAAiB,MAArB,EAA6B;AAClC;AACAF;;AAEA;AACA,4BAAYI,QAAZ,CAAqBV,KAArB,EAA4BM,IAA5B;;AAEA;AACA,WAAON,MAAMc,UAAN,CAAiBI,SAAxB;AACD,GATM,MASA,IAAIrB,IAAIW,QAAJ,KAAiB,QAArB,EAA+B;AACpC;;AAEA;AACA,QAAIW,MAAMb,IAAV;;AAEA;AACA,QAAIa,qCAAJ,EAA8B;AAC5B;AACA,UAAI,wBAAYC,uBAAZ,CAAoCpB,KAApC,EAA2CmB,GAA3C,CAAJ,EAAqD;AACnD,eAAO,uBAAgBnB,KAAhB,EAAuB,WAAvB,CAAP;AACD;AACF;;AAED;AACAmB,UAAM,wBAAYT,QAAZ,CAAqBV,KAArB,EAA4BmB,GAA5B,CAAN;;AAEA;AACA,QAAIE,QAAQF,IAAIG,OAAJ,GAAcC,SAA1B;AACA,QAAIC,WAAWH,KAAX,wBAAJ,EAAuC;AACrC,aAAO,uBAAgBrB,KAAhB,EAAuB,WAAvB,CAAP;AACD,KAFD,MAEO,IAAIwB,WAAWH,KAAX,mBAAJ,EAAkC;AACvC,aAAO,uBAAgBrB,KAAhB,EAAuB,QAAvB,CAAP;AACD,KAFM,MAEA,IAAIwB,WAAWH,KAAX,qBAAJ,EAAoC;AACzC,aAAO,uBAAgBrB,KAAhB,EAAuB,QAAvB,CAAP;AACD,KAFM,MAEA,IAAIwB,WAAWH,KAAX,sBAAJ,EAAqC;AAC1C,aAAO,uBAAgBrB,KAAhB,EAAuB,SAAvB,CAAP;AACD,KAFM,MAEA,IAAIwB,WAAWH,KAAX,qBAAJ,EAAoC;AACzC,aAAO,uBAAgBrB,KAAhB,EAAuB,QAAvB,CAAP;AACD,KAFM,MAEA,IAAIwB,WAAWH,KAAX,qBAAJ,EAAoC;AACzC,aAAO,uBAAgBrB,KAAhB,EAAuB,QAAvB,CAAP;AACD,KAFM,MAEA,IAAIwB,WAAWH,KAAX,qBAAJ,EAAoC;AACzC,UAAI,wBAAWrB,KAAX,EAAkBmB,GAAlB,CAAJ,EAA4B;AAC1B,eAAO,uBAAgBnB,KAAhB,EAAuB,UAAvB,CAAP;AACD;AACD,aAAO,uBAAgBA,KAAhB,EAAuB,QAAvB,CAAP;AACD,KALM,MAKA;AACL,+BAAUmB,mCAAV;AACA,aAAO,qBAAcR,iBAAd,CAAgCX,KAAhC,EAAuC,QAAvC,EAAiDmB,GAAjD,CAAP;AACD;AACF,GAxCM,MAwCA;AACL,6BAAUtB,IAAIW,QAAJ,KAAiB,QAA3B;AACA;;AAEA;AACA,QAAIiB,MAAMnB,IAAV;;AAEA;;AAEA;AACA,QAAI,EAAEmB,qCAAF,CAAJ,EAAiC,OAAOzB,MAAMc,UAAN,CAAiBG,IAAxB;;AAEjC;AACA,QAAI,wBAAYG,uBAAZ,CAAoCpB,KAApC,EAA2CyB,GAA3C,CAAJ,EAAqD;AACnD;AACA,+BAAU,CAAC,wBAAYC,iBAAZ,CAA8B1B,KAA9B,EAAqCyB,GAArC,CAAX,EAAsD,mCAAtD;;AAEA;AACA,aAAOzB,MAAMc,UAAN,CAAiBG,IAAxB;AACD;;AAED;AACA,QAAI,wBAAYU,mBAAZ,CAAgC3B,KAAhC,EAAuCyB,GAAvC,CAAJ,EAAiD;AAC/C;AACA,UAAI,wBAAYG,gBAAZ,CAA6B5B,KAA7B,EAAoCyB,GAApC,CAAJ,EAA8C;AAC5C,cAAMzB,MAAM6B,0BAAN,CAAiC7B,MAAMc,UAAN,CAAiBgB,cAAlD,CAAN;AACD;;AAED;AACA,UAAIC,OAAO,wBAAYC,OAAZ,CAAoBhC,KAApB,EAA2ByB,GAA3B,CAAX;AACA;AACA,+BAAUM,wCAAiCA,0CAA3C;AACA,UAAIE,UAAUF,uCAAgC,sBAAS/B,KAAT,EAAgB+B,IAAhB,CAAhC,GAAwDA,IAAtE;;AAEA;AACA,UAAIG,eAAeD,QAAQE,OAAR,CAAgB,wBAAYC,iBAAZ,CAA8BpC,KAA9B,EAAqCyB,GAArC,CAAhB,CAAnB;;AAEA;AACA,UAAI,CAACS,YAAD,IAAiB,wBAAYR,iBAAZ,CAA8B1B,KAA9B,EAAqCyB,GAArC,CAArB,EAAgE;AAC9D,cAAMzB,MAAM6B,0BAAN,CAAiC7B,MAAMc,UAAN,CAAiBuB,SAAlD,CAAN;AACD;;AAED;AACA,aAAO,wBAAiBrC,KAAjB,EAAwBkC,YAAxB,CAAP;AACD;;AAED;AACA;AACA,QAAII,WAAW,wBAAYN,OAAZ,CAAoBhC,KAApB,EAA2ByB,GAA3B,CAAf;AACA,6BAAUa,kDAAV;;AAEA;AACA,QAAIC,iBAAiB,wBAAYH,iBAAZ,CAA8BpC,KAA9B,EAAqCyB,GAArC,CAArB;AACA,6BAAU,OAAOc,cAAP,KAA0B,QAApC;AACA,WAAO,wBAAiBvC,KAAjB,EAAwBsC,SAASE,aAAT,CAAuBD,cAAvB,CAAxB,CAAP;AACD;AACF,C;;AA1ND;;AACA;;AAaA;;AACA;;;;AACA;;AACA;;;;AA9BA;;;;;;;;;AAiCA,SAASf,UAAT,CAAoBH,KAApB,EAA2BoB,WAA3B,EAAiD;AAC/C,SAAOpB,iBAAiBoB,WAAjB,IAAgCpB,UAAUoB,YAAYlB,SAA7D;AACD","file":"UnaryExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport {\n  AbstractObjectValue,\n  Value,\n  BooleanValue,\n  ConcreteValue,\n  NumberValue,\n  StringValue,\n  UndefinedValue,\n  NullValue,\n  SymbolValue,\n  ObjectValue,\n  AbstractValue,\n} from \"../values/index.js\";\nimport { Reference, EnvironmentRecord } from \"../environment.js\";\nimport invariant from \"../invariant.js\";\nimport { ToBoolean, ToObject, ToNumber, ToInt32, IsCallable, IsToNumberPure } from \"../methods/index.js\";\nimport { Environment } from \"../singletons.js\";\nimport type { BabelNodeUnaryExpression } from \"babel-types\";\n\nfunction isInstance(proto, Constructor): boolean {\n  return proto instanceof Constructor || proto === Constructor.prototype;\n}\n\nexport default function(\n  ast: BabelNodeUnaryExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  function reportError() {\n    let error = new CompilerDiagnostic(\n      \"might be a symbol or an object with an unknown valueOf or toString or Symbol.toPrimitive method\",\n      ast.argument.loc,\n      \"PP0008\",\n      \"RecoverableError\"\n    );\n    if (realm.handleError(error) === \"Fail\") throw new FatalError();\n  }\n\n  let expr = env.evaluate(ast.argument, strictCode);\n\n  if (ast.operator === \"+\") {\n    // ECMA262 12.5.6.1\n\n    // 1. Let expr be the result of evaluating UnaryExpression.\n    expr;\n\n    // 2. Return ? ToNumber(? GetValue(expr)).\n    let value = Environment.GetValue(realm, expr);\n    if (value instanceof AbstractValue) {\n      if (!IsToNumberPure(realm, value)) reportError();\n      return AbstractValue.createFromUnaryOp(realm, \"+\", value);\n    }\n    invariant(value instanceof ConcreteValue);\n\n    return new NumberValue(realm, ToNumber(realm, value));\n  } else if (ast.operator === \"-\") {\n    // ECMA262 12.5.7.1\n\n    // 1. Let expr be the result of evaluating UnaryExpression.\n    expr;\n\n    // 2. Let oldValue be ? ToNumber(? GetValue(expr)).\n    let value = Environment.GetValue(realm, expr);\n    if (value instanceof AbstractValue) {\n      if (!IsToNumberPure(realm, value)) reportError();\n      return AbstractValue.createFromUnaryOp(realm, \"-\", value);\n    }\n    invariant(value instanceof ConcreteValue);\n    let oldValue = ToNumber(realm, value);\n\n    // 3. If oldValue is NaN, return NaN.\n    if (isNaN(oldValue)) {\n      return realm.intrinsics.NaN;\n    }\n\n    // 4. Return the result of negating oldValue; that is, compute a Number with the same magnitude but opposite sign.\n    return new NumberValue(realm, -oldValue);\n  } else if (ast.operator === \"~\") {\n    // ECMA262 12.5.8\n\n    // 1. Let expr be the result of evaluating UnaryExpression.\n    expr;\n\n    // 2. Let oldValue be ? ToInt32(? GetValue(expr)).\n    let value = Environment.GetValue(realm, expr);\n    if (value instanceof AbstractValue) {\n      if (!IsToNumberPure(realm, value)) reportError();\n      return AbstractValue.createFromUnaryOp(realm, \"~\", value);\n    }\n    invariant(value instanceof ConcreteValue);\n    let oldValue = ToInt32(realm, value);\n\n    // 3. Return the result of applying bitwise complement to oldValue. The result is a signed 32-bit integer.\n    return new NumberValue(realm, ~oldValue);\n  } else if (ast.operator === \"!\") {\n    // ECMA262 12.6.9\n\n    // 1. Let expr be the result of evaluating UnaryExpression.\n    expr;\n\n    // 2. Let oldValue be ToBoolean(? GetValue(expr)).\n    let value = Environment.GetValue(realm, expr);\n    if (value instanceof AbstractValue) return AbstractValue.createFromUnaryOp(realm, \"!\", value);\n    invariant(value instanceof ConcreteValue);\n    let oldValue = ToBoolean(realm, value);\n\n    // 3. If oldValue is true, return false.\n    if (oldValue === true) return realm.intrinsics.false;\n\n    // 4. Return true.\n    return realm.intrinsics.true;\n  } else if (ast.operator === \"void\") {\n    // 1. Let expr be the result of evaluating UnaryExpression.\n    expr;\n\n    // 2. Perform ? GetValue(expr).\n    Environment.GetValue(realm, expr);\n\n    // 3. Return undefined.\n    return realm.intrinsics.undefined;\n  } else if (ast.operator === \"typeof\") {\n    // ECMA262 12.6.5\n\n    // 1. Let val be the result of evaluating UnaryExpression.\n    let val = expr;\n\n    // 2. If Type(val) is Reference, then\n    if (val instanceof Reference) {\n      // a. If IsUnresolvableReference(val) is true, return \"undefined\".\n      if (Environment.IsUnresolvableReference(realm, val)) {\n        return new StringValue(realm, \"undefined\");\n      }\n    }\n\n    // 3. Let val be ? GetValue(val).\n    val = Environment.GetValue(realm, val);\n\n    // 4. Return a String according to Table 35.\n    let proto = val.getType().prototype;\n    if (isInstance(proto, UndefinedValue)) {\n      return new StringValue(realm, \"undefined\");\n    } else if (isInstance(proto, NullValue)) {\n      return new StringValue(realm, \"object\");\n    } else if (isInstance(proto, StringValue)) {\n      return new StringValue(realm, \"string\");\n    } else if (isInstance(proto, BooleanValue)) {\n      return new StringValue(realm, \"boolean\");\n    } else if (isInstance(proto, NumberValue)) {\n      return new StringValue(realm, \"number\");\n    } else if (isInstance(proto, SymbolValue)) {\n      return new StringValue(realm, \"symbol\");\n    } else if (isInstance(proto, ObjectValue)) {\n      if (IsCallable(realm, val)) {\n        return new StringValue(realm, \"function\");\n      }\n      return new StringValue(realm, \"object\");\n    } else {\n      invariant(val instanceof AbstractValue);\n      return AbstractValue.createFromUnaryOp(realm, \"typeof\", val);\n    }\n  } else {\n    invariant(ast.operator === \"delete\");\n    // ECMA262 12.5.3.2\n\n    // 1. Let ref be the result of evaluating UnaryExpression.\n    let ref = expr;\n\n    // 2. ReturnIfAbrupt(ref).\n\n    // 3. If Type(ref) is not Reference, return true.\n    if (!(ref instanceof Reference)) return realm.intrinsics.true;\n\n    // 4. If IsUnresolvableReference(ref) is true, then\n    if (Environment.IsUnresolvableReference(realm, ref)) {\n      // a. Assert: IsStrictReference(ref) is false.\n      invariant(!Environment.IsStrictReference(realm, ref), \"did not expect a strict reference\");\n\n      // b. Return true.\n      return realm.intrinsics.true;\n    }\n\n    // 5. If IsPropertyReference(ref) is true, then\n    if (Environment.IsPropertyReference(realm, ref)) {\n      // a. If IsSuperReference(ref) is true, throw a ReferenceError exception.\n      if (Environment.IsSuperReference(realm, ref)) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError);\n      }\n\n      // b. Let baseObj be ! ToObject(GetBase(ref)).\n      let base = Environment.GetBase(realm, ref);\n      // Constructing the reference checks that base is coercible to an object hence\n      invariant(base instanceof ConcreteValue || base instanceof AbstractObjectValue);\n      let baseObj = base instanceof ConcreteValue ? ToObject(realm, base) : base;\n\n      // c. Let deleteStatus be ? baseObj.[[Delete]](GetReferencedName(ref)).\n      let deleteStatus = baseObj.$Delete(Environment.GetReferencedName(realm, ref));\n\n      // d. If deleteStatus is false and IsStrictReference(ref) is true, throw a TypeError exception.\n      if (!deleteStatus && Environment.IsStrictReference(realm, ref)) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n\n      // e. Return deleteStatus.\n      return new BooleanValue(realm, deleteStatus);\n    }\n\n    // 6. Else ref is a Reference to an Environment Record binding,\n    // a. Let bindings be GetBase(ref).\n    let bindings = Environment.GetBase(realm, ref);\n    invariant(bindings instanceof EnvironmentRecord);\n\n    // b. Return ? bindings.DeleteBinding(GetReferencedName(ref)).\n    let referencedName = Environment.GetReferencedName(realm, ref);\n    invariant(typeof referencedName === \"string\");\n    return new BooleanValue(realm, bindings.DeleteBinding(referencedName));\n  }\n}\n"]}