"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (ast, strictCode, env, realm) {
  // ECMA262 14.1.21

  if (ast.id) {
    if (ast.generator) {
      // 1. If the function code for this GeneratorExpression is strict mode code, let strict be true. Otherwise let strict be false.
      var strict = strictCode || (0, _strict5.default)(ast.body);

      // 2. Let scope be the running execution context's LexicalEnvironment.
      var scope = env;

      // 3. Let funcEnv be NewDeclarativeEnvironment(scope).
      var funcEnv = _singletons.Environment.NewDeclarativeEnvironment(realm, scope);

      // 4. Let envRec be funcEnv's EnvironmentRecord.
      var envRec = funcEnv.environmentRecord;

      // 5. Let name be StringValue of BindingIdentifier.
      (0, _invariant2.default)(ast.id);
      var name = ast.id.name;

      // 6. Perform envRec.CreateImmutableBinding(name, false).
      envRec.CreateImmutableBinding(name, false);

      // 7. Let closure be GeneratorFunctionCreate(Normal, FormalParameters, GeneratorBody, funcEnv, strict).
      var closure = _singletons.Functions.GeneratorFunctionCreate(realm, "normal", ast.params, ast.body, funcEnv, strict);
      closure.loc = ast.loc;

      // 8. Let prototype be ObjectCreate(%GeneratorPrototype%).
      var prototype = (0, _create.ObjectCreate)(realm, realm.intrinsics.GeneratorPrototype);
      prototype.originalConstructor = closure;

      // 9. Perform DefinePropertyOrThrow(closure, "prototype", PropertyDescriptor{[[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false}).
      _singletons.Properties.DefinePropertyOrThrow(realm, closure, "prototype", {
        value: prototype,
        writable: true,
        enumerable: false,
        configurable: false
      });

      // 10. Perform SetFunctionName(closure, name).
      _singletons.Functions.SetFunctionName(realm, closure, new _index2.StringValue(realm, name));

      // 11. Perform envRec.InitializeBinding(name, closure).
      envRec.InitializeBinding(name, closure);

      // 12. Return closure.
      return closure;
    } else {
      // 1. If the function code for FunctionExpression is strict mode code, let strict be true. Otherwise let strict be false.
      var _strict = strictCode || (0, _strict5.default)(ast.body);

      // 2. Let scope be the running execution context's LexicalEnvironment.
      var _scope = env;

      // 3. Let funcEnv be NewDeclarativeEnvironment(scope).
      var _funcEnv = _singletons.Environment.NewDeclarativeEnvironment(realm, _scope);

      // 4. Let envRec be funcEnv's EnvironmentRecord.
      var _envRec = _funcEnv.environmentRecord;

      // 5. Let name be StringValue of BindingIdentifier.
      (0, _invariant2.default)(ast.id);
      var _name = ast.id.name;

      // 6. Perform envRec.CreateImmutableBinding(name, false).
      _envRec.CreateImmutableBinding(_name, false);

      // 7. Let closure be FunctionCreate(Normal, FormalParameters, FunctionBody, funcEnv, strict).
      var _closure = _singletons.Functions.FunctionCreate(realm, "normal", ast.params, ast.body, _funcEnv, _strict);
      _closure.loc = ast.loc;

      // 8. Perform MakeConstructor(closure).
      (0, _index.MakeConstructor)(realm, _closure);

      // 9. Perform SetFunctionName(closure, name).
      _singletons.Functions.SetFunctionName(realm, _closure, new _index2.StringValue(realm, _name));

      // 10. Perform envRec.InitializeBinding(name, closure).
      _envRec.InitializeBinding(_name, _closure);

      // 11. Return closure.
      return _closure;
    }
  } else {
    if (ast.generator) {
      // 1. If the function code for this GeneratorExpression is strict mode code, let strict be true. Otherwise let strict be false.
      var _strict2 = strictCode || (0, _strict5.default)(ast.body);

      // 2. Let scope be the LexicalEnvironment of the running execution context.
      var _scope2 = env;

      // 3. Let closure be GeneratorFunctionCreate(Normal, FormalParameters, GeneratorBody, scope, strict).
      var _closure2 = _singletons.Functions.GeneratorFunctionCreate(realm, "normal", ast.params, ast.body, _scope2, _strict2);

      // 4. Let prototype be ObjectCreate(%GeneratorPrototype%).
      var _prototype = (0, _create.ObjectCreate)(realm, realm.intrinsics.GeneratorPrototype);
      _prototype.originalConstructor = _closure2;

      // 5. Perform DefinePropertyOrThrow(closure, "prototype", PropertyDescriptor{[[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false}).
      _singletons.Properties.DefinePropertyOrThrow(realm, _closure2, "prototype", {
        value: _prototype,
        writable: true,
        enumerable: false,
        configurable: false
      });

      // 6. Return closure.
      return _closure2;
    } else {
      // 1. If the function code for FunctionExpression is strict mode code, let strict be true. Otherwise let strict be false.
      var _strict3 = strictCode || (0, _strict5.default)(ast.body);

      // 2. Let scope be the LexicalEnvironment of the running execution context.
      var _scope3 = env;

      // 3. Let closure be FunctionCreate(Normal, FormalParameters, FunctionBody, scope, strict).
      var _closure3 = _singletons.Functions.FunctionCreate(realm, "normal", ast.params, ast.body, _scope3, _strict3);

      // 4. Perform MakeConstructor(closure).
      (0, _index.MakeConstructor)(realm, _closure3);

      // 5. Return closure.
      return _closure3;
    }
  }
};

var _index = require("../methods/index.js");

var _create = require("../methods/create.js");

var _singletons = require("../singletons.js");

var _index2 = require("../values/index.js");

var _strict4 = require("../utils/strict.js");

var _strict5 = _interopRequireDefault(_strict4);

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
//# sourceMappingURL=FunctionExpression.js.map