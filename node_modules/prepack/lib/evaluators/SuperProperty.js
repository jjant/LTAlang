"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = SuperProperty;

var _environment = require("../environment.js");

var _index = require("../values/index.js");

var _index2 = require("../methods/index.js");

var _singletons = require("../singletons.js");

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

function MakeSuperPropertyReference(realm, propertyKey, strict) {
  // 1. Let env be GetThisEnvironment( ).
  var env = _singletons.Environment.GetThisEnvironment(realm);
  (0, _invariant2.default)(env instanceof _environment.FunctionEnvironmentRecord);

  // 2. If env.HasSuperBinding() is false, throw a ReferenceError exception.
  if (!env.HasSuperBinding()) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError, "env does not have super binding");
  }

  // 3. Let actualThis be env.GetThisBinding().
  var actualThis = env.GetThisBinding();

  // 4. ReturnIfAbrupt(actualThis).

  // 5. Let baseValue be env.GetSuperBase().
  var baseValue = env.GetSuperBase();

  // 6. Let bv be RequireObjectCoercible(baseValue).
  var bv = (0, _index2.RequireObjectCoercible)(realm, baseValue);

  // 7. ReturnIfAbrupt(bv).

  // 8. Return a value of type Reference that is a Super Reference whose base value is bv, whose referenced name is propertyKey, whose thisValue is actualThis, and whose strict reference flag is strict.
  return new _environment.Reference(bv, propertyKey, strict, actualThis);
}

// ECMA262 12.3.5.1
function SuperProperty(ast, strictCode, env, realm) {
  // SuperProperty : super [ Expression ]
  if (ast.computed) {
    // 1. Let propertyNameReference be the result of evaluating Expression.
    var propertyNameReference = env.evaluate(ast.property, strictCode);

    // 2. Let propertyNameValue be GetValue(propertyNameReference).
    var propertyNameValue = _singletons.Environment.GetValue(realm, propertyNameReference);

    // 3. Let propertyKey be ToPropertyKey(propertyNameValue).
    var propertyKey = (0, _index2.ToPropertyKeyPartial)(realm, propertyNameValue);

    // 4. ReturnIfAbrupt(propertyKey).

    // 5. If the code matched by the syntactic production that is being evaluated is strict mode code, let strict be true, else let strict be false.
    var strict = strictCode;

    // 6. Return MakeSuperPropertyReference(propertyKey, strict).
    return MakeSuperPropertyReference(realm, propertyKey, strict);
  } else {
    // SuperProperty : super . IdentifierName
    // 1. Let propertyKey be StringValue of IdentifierName.
    var _propertyKey = new _index.StringValue(realm, ast.property.name);

    // 2. If the code matched by the syntactic production that is being evaluated is strict mode code, let strict be true, else let strict be false.
    var _strict = strictCode;

    // 3. Return MakeSuperPropertyReference(propertyKey, strict).
    return MakeSuperPropertyReference(realm, _propertyKey, _strict);
  }
}
//# sourceMappingURL=SuperProperty.js.map