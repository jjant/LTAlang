{"version":3,"sources":["../../src/evaluators/ForStatement.js"],"names":["CreatePerIterationEnvironment","ast","strictCode","env","realm","labelSet","init","test","update","body","type","kind","varDcl","evaluate","ForBodyEvaluation","oldEnv","loopEnv","NewDeclarativeEnvironment","loopEnvRec","environmentRecord","isConst","boundNames","BoundNames","dn","CreateImmutableBinding","CreateMutableBinding","getRunningContext","lexicalEnvironment","forDcl","evaluateCompletion","perIterationLets","bodyResult","exprRef","GetValue","perIterationBindings","length","lastIterationEnv","lastIterationEnvRec","outer","parent","thisIterationEnv","thisIterationEnvRec","bn","lastValue","GetBindingValue","InitializeBinding","intrinsics","undefined","increment","stmt","V","testRef","testValue","result","target","value","resultValue","incRef"],"mappings":"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","file":"ForStatement.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport type { Realm } from \"../realm.js\";\nimport { Value, EmptyValue } from \"../values/index.js\";\nimport { AbruptCompletion, BreakCompletion } from \"../completions.js\";\nimport { ToBooleanPartial, UpdateEmpty } from \"../methods/index.js\";\nimport { LoopContinues, InternalGetResultValue } from \"./ForOfStatement.js\";\nimport { Environment } from \"../singletons.js\";\nimport invariant from \"../invariant.js\";\nimport type { BabelNodeForStatement } from \"babel-types\";\n\n// ECMA262 13.7.4.9\nexport function CreatePerIterationEnvironment(realm: Realm, perIterationBindings: Array<string>) {\n  // 1. If perIterationBindings has any elements, then\n  if (perIterationBindings.length > 0) {\n    // a. Let lastIterationEnv be the running execution context's LexicalEnvironment.\n    let lastIterationEnv = realm.getRunningContext().lexicalEnvironment;\n    // b. Let lastIterationEnvRec be lastIterationEnv's EnvironmentRecord.\n    let lastIterationEnvRec = lastIterationEnv.environmentRecord;\n    // c. Let outer be lastIterationEnv's outer environment reference.\n    let outer = lastIterationEnv.parent;\n    // d. Assert: outer is not null.\n    invariant(outer !== null);\n    // e. Let thisIterationEnv be NewDeclarativeEnvironment(outer).\n    let thisIterationEnv = Environment.NewDeclarativeEnvironment(realm, outer);\n    // f. Let thisIterationEnvRec be thisIterationEnv's EnvironmentRecord.\n    let thisIterationEnvRec = thisIterationEnv.environmentRecord;\n    // g. For each element bn of perIterationBindings do,\n    for (let bn of perIterationBindings) {\n      // i. Perform ! thisIterationEnvRec.CreateMutableBinding(bn, false).\n      thisIterationEnvRec.CreateMutableBinding(bn, false);\n      // ii. Let lastValue be ? lastIterationEnvRec.GetBindingValue(bn, true).\n      let lastValue = lastIterationEnvRec.GetBindingValue(bn, true);\n      // iii.Perform thisIterationEnvRec.InitializeBinding(bn, lastValue).\n      thisIterationEnvRec.InitializeBinding(bn, lastValue);\n    }\n    // h. Set the running execution context's LexicalEnvironment to thisIterationEnv.\n    realm.getRunningContext().lexicalEnvironment = thisIterationEnv;\n  }\n  // 2. Return undefined.\n  return realm.intrinsics.undefined;\n}\n\n// ECMA262 13.7.4.8\nfunction ForBodyEvaluation(\n  realm: Realm,\n  test,\n  increment,\n  stmt,\n  perIterationBindings: Array<string>,\n  labelSet,\n  strictCode: boolean\n): Value {\n  // 1. Let V be undefined.\n  let V: Value = realm.intrinsics.undefined;\n\n  // 2. Perform ? CreatePerIterationEnvironment(perIterationBindings).\n  CreatePerIterationEnvironment(realm, perIterationBindings);\n  let env = realm.getRunningContext().lexicalEnvironment;\n\n  // 3. Repeat\n  while (true) {\n    // a. If test is not [empty], then\n    if (test) {\n      // i. Let testRef be the result of evaluating test.\n      let testRef = env.evaluate(test, strictCode);\n\n      // ii. Let testValue be ? GetValue(testRef).\n      let testValue = Environment.GetValue(realm, testRef);\n\n      // iii. If ToBoolean(testValue) is false, return NormalCompletion(V).\n      if (!ToBooleanPartial(realm, testValue)) return V;\n    }\n\n    // b. Let result be the result of evaluating stmt.\n    let result = env.evaluateCompletion(stmt, strictCode);\n    invariant(result instanceof Value || result instanceof AbruptCompletion);\n\n    // c. If LoopContinues(result, labelSet) is false, return Completion(UpdateEmpty(result, V)).\n    if (!LoopContinues(realm, result, labelSet)) {\n      invariant(result instanceof AbruptCompletion);\n      // ECMA262 13.1.7\n      if (result instanceof BreakCompletion) {\n        if (!result.target) return (UpdateEmpty(realm, result, V): any).value;\n      }\n      throw UpdateEmpty(realm, result, V);\n    }\n\n    // d. If result.[[Value]] is not empty, let V be result.[[Value]].\n    let resultValue = InternalGetResultValue(realm, result);\n    if (!(resultValue instanceof EmptyValue)) V = resultValue;\n\n    // e. Perform ? CreatePerIterationEnvironment(perIterationBindings).\n    CreatePerIterationEnvironment(realm, perIterationBindings);\n    env = realm.getRunningContext().lexicalEnvironment;\n\n    // f. If increment is not [empty], then\n    if (increment) {\n      // i. Let incRef be the result of evaluating increment.\n      let incRef = env.evaluate(increment, strictCode);\n\n      // ii. Perform ? GetValue(incRef).\n      Environment.GetValue(realm, incRef);\n    }\n  }\n\n  invariant(false);\n}\n\n// ECMA262 13.7.4.7\nexport default function(\n  ast: BabelNodeForStatement,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm,\n  labelSet: ?Array<string>\n): Value {\n  let { init, test, update, body } = ast;\n\n  if (init && init.type === \"VariableDeclaration\") {\n    if (init.kind === \"var\") {\n      // for (var VariableDeclarationList; Expression; Expression) Statement\n      // 1. Let varDcl be the result of evaluating VariableDeclarationList.\n      let varDcl = env.evaluate(init, strictCode);\n\n      // 2. ReturnIfAbrupt(varDcl).\n      varDcl;\n\n      // 3. Return ? ForBodyEvaluation(the first Expression, the second Expression, Statement, « », labelSet).\n      return ForBodyEvaluation(realm, test, update, body, [], labelSet, strictCode);\n    } else {\n      // for (LexicalDeclaration Expression; Expression) Statement\n      // 1. Let oldEnv be the running execution context's LexicalEnvironment.\n      let oldEnv = env;\n\n      // 2. Let loopEnv be NewDeclarativeEnvironment(oldEnv).\n      let loopEnv = Environment.NewDeclarativeEnvironment(realm, oldEnv);\n\n      // 3. Let loopEnvRec be loopEnv's EnvironmentRecord.\n      let loopEnvRec = loopEnv.environmentRecord;\n\n      // 4. Let isConst be the result of performing IsConstantDeclaration of LexicalDeclaration.\n      let isConst = init.kind === \"const\";\n\n      // 5. Let boundNames be the BoundNames of LexicalDeclaration.\n      let boundNames = Environment.BoundNames(realm, init);\n\n      // 6. For each element dn of boundNames do\n      for (let dn of boundNames) {\n        // a. If isConst is true, then\n        if (isConst) {\n          // i. Perform ! loopEnvRec.CreateImmutableBinding(dn, true).\n          loopEnvRec.CreateImmutableBinding(dn, true);\n        } else {\n          // b. Else,\n          // i. Perform ! loopEnvRec.CreateMutableBinding(dn, false).\n          loopEnvRec.CreateMutableBinding(dn, false);\n        }\n      }\n\n      // 7. Set the running execution context's LexicalEnvironment to loopEnv.\n      realm.getRunningContext().lexicalEnvironment = loopEnv;\n\n      // 8. Let forDcl be the result of evaluating LexicalDeclaration.\n      let forDcl = loopEnv.evaluateCompletion(init, strictCode);\n\n      // 9. If forDcl is an abrupt completion, then\n      if (forDcl instanceof AbruptCompletion) {\n        // a. Set the running execution context's LexicalEnvironment to oldEnv.\n        realm.getRunningContext().lexicalEnvironment = oldEnv;\n\n        // b. Return Completion(forDcl).\n        throw forDcl;\n      }\n\n      // 10. If isConst is false, let perIterationLets be boundNames; otherwise let perIterationLets be « ».\n      let perIterationLets = !isConst ? boundNames : [];\n\n      let bodyResult;\n      try {\n        // 11. Let bodyResult be ForBodyEvaluation(the first Expression, the second Expression, Statement, perIterationLets, labelSet).\n        bodyResult = ForBodyEvaluation(realm, test, update, body, perIterationLets, labelSet, strictCode);\n      } finally {\n        // 12. Set the running execution context's LexicalEnvironment to oldEnv.\n        realm.getRunningContext().lexicalEnvironment = oldEnv;\n      }\n      // 13. Return Completion(bodyResult).\n      return bodyResult;\n    }\n  } else {\n    // for (Expression; Expression; Expression) Statement\n    // 1. If the first Expression is present, then\n    if (init) {\n      // a. Let exprRef be the result of evaluating the first Expression.\n      let exprRef = env.evaluate(init, strictCode);\n\n      // b. Perform ? GetValue(exprRef).\n      Environment.GetValue(realm, exprRef);\n    }\n\n    // 2. Return ? ForBodyEvaluation(the second Expression, the third Expression, Statement, « », labelSet).\n    return ForBodyEvaluation(realm, test, update, body, [], labelSet, strictCode);\n  }\n}\n"]}