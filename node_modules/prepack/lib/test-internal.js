"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Copyright (c) 2017-present, Facebook, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * This source code is licensed under the BSD-style license found in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * LICENSE file in the root directory of this source tree. An additional grant
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * of patent rights can be found in the PATENTS file in the same directory.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */

var _errors = require("../lib/errors.js");

var _prepackStandalone = require("../lib/prepack-standalone.js");

var chalk = require("chalk");
var path = require("path");
var fs = require("fs");

function search(dir, relative) {
  var tests = [];

  if (fs.existsSync(dir)) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = fs.readdirSync(dir)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var name = _step.value;

        var loc = path.join(dir, name);
        var stat = fs.statSync(loc);

        if (stat.isFile()) {
          tests.push({
            file: fs.readFileSync(loc, "utf8"),
            name: path.join(relative, name)
          });
        } else if (stat.isDirectory()) {
          tests = tests.concat(search(loc, path.join(relative, name)));
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  return tests;
}

var tests = search(__dirname + "/../facebook/test", "facebook/test");

var errors = void 0;
var errorList = void 0;
function errorHandler(diagnostic) {
  if (diagnostic.location) errors.set(diagnostic.location, diagnostic);else errorList.push(diagnostic);
  return "Fail";
}

function runTest(name, code) {
  console.log(chalk.inverse(name));
  try {
    errors = new Map();
    errorList = [];
    var modelName = name + ".model";
    var sourceMapName = name + ".map";
    var sourceCode = fs.readFileSync(name, "utf8");
    var modelCode = fs.existsSync(modelName) ? fs.readFileSync(modelName, "utf8") : undefined;
    var sourceMap = fs.existsSync(sourceMapName) ? fs.readFileSync(sourceMapName, "utf8") : undefined;
    var sources = [];
    var additionalFunctions = void 0;
    if (modelCode) {
      /* allows specifying additional functions by a comment of the form:
      // additional function: additional1, additional2
      */
      var marker = "// additional functions:";
      if (modelCode.includes(marker)) {
        var i = modelCode.indexOf(marker);
        var value = modelCode.substring(i + marker.length, modelCode.indexOf("\n", i));
        additionalFunctions = value.split(",").map(function (funcStr) {
          return funcStr.trim();
        });
      }
      sources.push({ filePath: modelName, fileContents: modelCode });
    }
    sources.push({ filePath: name, fileContents: sourceCode, sourceMapContents: sourceMap });

    var options = {
      internalDebug: true,
      compatibility: "jsc-600-1-4-17",
      delayUnsupportedRequires: true,
      mathRandomSeed: "0",
      errorHandler: errorHandler,
      serialize: true,
      initializeMoreModules: !modelCode,
      sourceMaps: !!sourceMap,
      additionalFunctions: additionalFunctions
    };
    if (name.endsWith("/bundle.js~")) options.additionalFunctions = ["global.WildeBundle.prepareComponentScript", "global.WildeBundle.prepareReact"];
    var serialized = (0, _prepackStandalone.prepackSources)(sources, options);
    var new_map = serialized.map; // force source maps to get computed
    if (!new_map) console.log(chalk.red("No source map"));
    if (!serialized) {
      console.log(chalk.red("Error during serialization"));
      return false;
    } else {
      return true;
    }
  } catch (e) {
    if (!(e instanceof _errors.FatalError)) console.log(e);
    return false;
  } finally {
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = errors[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var _ref = _step2.value;

        var _ref2 = _slicedToArray(_ref, 2);

        var loc = _ref2[0];
        var error = _ref2[1];

        console.log(error.severity + ": " + (loc.source || "") + " " + loc.start.line + ":" + (loc.start.column + 1) + " " + error.errorCode + " " + error.message);
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = errorList[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var _error = _step3.value;

        console.log(_error.severity + ": " + _error.errorCode + " " + _error.message);
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return) {
          _iterator3.return();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }
  }
}

function run() {
  var failed = 0;
  var passed = 0;
  var total = 0;

  var _iteratorNormalCompletion4 = true;
  var _didIteratorError4 = false;
  var _iteratorError4 = undefined;

  try {
    for (var _iterator4 = tests[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
      var test = _step4.value;

      if (!test.name.endsWith(".js")) continue;

      total++;
      if (runTest(test.name, test.file)) passed++;else failed++;
    }
  } catch (err) {
    _didIteratorError4 = true;
    _iteratorError4 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion4 && _iterator4.return) {
        _iterator4.return();
      }
    } finally {
      if (_didIteratorError4) {
        throw _iteratorError4;
      }
    }
  }

  console.log("Passed:", passed + "/" + total, (Math.round(passed / total * 100) || 0) + "%");
  return failed === 0;
}

if (!run()) process.exit(1);
//# sourceMappingURL=test-internal.js.map