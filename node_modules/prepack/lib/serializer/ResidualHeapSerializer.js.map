{"version":3,"sources":["../../src/serializer/ResidualHeapSerializer.js"],"names":["t","commentStatement","text","s","emptyStatement","leadingComments","type","value","ResidualHeapSerializer","realm","logger","modules","residualHeapValueIdentifiers","residualHeapInspector","residualValues","residualFunctionInstances","residualFunctionInfos","options","referencedDeclaredValues","additionalFunctionValuesAndEffects","additionalFunctionValueInfos","statistics","react","realmGenerator","generator","realmPreludeGenerator","preludeGenerator","prelude","_descriptors","Map","needsEmptyVar","needsAuxiliaryConstructor","valueNameGenerator","createNameGenerator","descriptorNameGenerator","factoryNameGenerator","intrinsicNameGenerator","functionNameGenerator","requireReturns","serializedValues","Set","additionalFunctionValueNestedFunctions","residualFunctions","getLocation","getSerializeObjectIdentifierOptional","createLocation","location","identifier","generate","currentFunctionBody","entries","push","variableDeclaration","variableDeclarator","emitter","mainBody","getBody","_options","activeGeneratorBodies","functionNames","f","n","get","undefined","set","__originalName","id","_getFunctionName","obj","properties","objectPrototypeAlreadyEstablished","cleanupDummyProperties","symbol","propertyBinding","desc","descriptor","emitNowOrAfterWaitingForDependencies","_getDescriptorValues","concat","_emitProperty","symbols","key","canIgnoreProperty","has","unknownProperty","val","_getNestedAbstractValues","_emitPropertiesWithComputedNames","_emitObjectPrototype","_emitConstructorPrototype","objects","objectProperties","size","kind","getKind","proto","$Prototype","serializedProto","serializeValue","uid","getSerializeObjectIdentifier","condition","binaryExpression","memberExpression","throwblock","blockStatement","throwStatement","newExpression","stringLiteral","emit","ifStatement","intrinsics","isCompatibleWith","MOBILE_JSC_VERSION","expressionStatement","callExpression","memoizeReference","assignmentExpression","func","prototype","getPropertyValue","absVal","values","args","length","cond","P","V","W","consequent","alternate","earlier_props","serializedP","serializedV","serializedCond","oldBody","beginEmitting","consequentBody","endEmitting","consequentStatement","alternateBody","alternateStatement","getIdentifierAndIncrementReferenceCount","getIdentifierAndIncrementReferenceCountOptional","deleteIfMightHaveBeenDeleted","locationFunction","serializedKey","getAsPropertyNameExpression","computed","isIdentifier","_deleteProperty","emitDefinePropertyBody","joinCondition","trueBody","falseBody","descriptor1","descriptor2","unaryExpression","_canEmbedProperty","descValue","getReasonToWaitForDependencies","mightHaveBeenDeleted","_getPropertyAssignment","body","descProps","boolKeys","valKeys","descriptorsKey","boolKey","b","objectProperty","booleanLiteral","toString","join","descriptorId","declar","objectExpression","descKey","sequenceExpression","residualFunctionBinding","serializedValue","declarativeEnvironmentRecord","referentialized","mightBeObject","incrementReferenceCount","scopes","functionValues","generators","scope","description","numAdditionalFunctionReferences","additionalFuncValuesAndEffects","filter","funcValue","delayInitializations","usedOnlyByAdditionalFunctions","residualFunctionInitializers","registerValueOnlyReferencedByResidualFunctions","usedOnlyByResidualFunctions","commonAncestor","Array","from","reduce","x","y","parent","referenceOnly","bindingType","refuseSerialization","ref","add","isLeaf","res","_serializeValue","target","_getTarget","name","setIdentifier","init","result","needsIdentifier","debugScopes","comment","map","_getScopeName","assignment","valueIds","delayedValues","deleteIdentifier","valuesInlined","intrinsicName","intrinsicNameGenerated","convertStringToMember","locationFn","valueFn","empty","deletion","array","indexPropertyLength","remainingProperties","elems","i","elem","elemVal","delayReason","getReasonToWaitForActiveValue","delete","numberOfIndexProperties","lenProperty","_assignProperty","initProperties","_serializeArrayIndexProperties","_serializeArrayLengthIfNeeded","_emitObjectProperties","arrayExpression","child","reactChild","_serializeValueObject","jSXExpressionContainer","expr","isStringLiteral","isNumericLiteral","jSXText","isJSXElement","typeValue","keyValue","refValue","propsValue","attributes","children","keyExpr","refExpr","childrenValue","childrenLength","childrenLengthValue","_serializeValueReactElementChild","logError","openingElement","jSXOpeningElement","closingElement","jSXClosingElement","jsxElement","jSXElement","$BailOutReason","$MapData","$WeakMapData","len","mapConstructorDoesntTakeArguments","entry","$Key","$Value","emitAfterWaiting","$SetData","$WeakSetData","setConstructorDoesntTakeArguments","buf","$ViewedArrayBuffer","outlinedArrayBuffer","$ArrayBufferByteLength","db","$ArrayBufferData","allzero","numericLiteral","arrayValue","consExpr","$BoundTargetFunction","$BoundThis","$BoundArguments","boundArg","instance","residualBindings","residualFunctionBindings","inAdditionalFunction","containingAdditionalFunction","currentAdditionalFunction","delayed","undelay","insertionPoint","getBodyReference","boundName","residualBinding","referencedValues","serializeBindingFunc","_serializeGlobalBinding","_serializeDeclarativeEnvironmentRecordBinding","bindingValue","referencedOnlyFromAdditionalFunctions","prop","writable","configurable","enumerable","source","$OriginalSource","flags","$OriginalFlags","RegExp","regExpLiteral","createViaAuxiliaryConstructor","ObjectPrototype","_findLastObjectPrototype","dummyProperties","props","propValue","constructor","originalConstructor","prototypeId","getIdentifier","setFunctionPrototype","_serializeValueRegExpObject","numberData","$NumberData","throwIfNotConcreteNumber","stringData","$StringData","throwIfNotConcreteString","booleanData","$BooleanData","throwIfNotConcreteBoolean","dateValue","$DateValue","serializedDateValue","_serializeValueTypedArrayOrDataView","_serializeValueArrayBuffer","_serializeValueReactElement","_serializeValueMap","_serializeValueSet","$ParameterMap","serializeValueRawObject","$Description","serializedArg","globalReg","globalSymbolRegistry","find","e","$Symbol","$ProxyTarget","$ProxyHandler","serializedArgs","abstractArg","abstractIndex","findIndex","v","buildNode","derivedIds","hasBeenDeclared","hasIdentifier","_serializeAbstractValueHelper","_serializeAbstractValue","isIntrinsic","_serializeValueIntrinsic","valueToNode","serialize","_serializeValueArray","_serializeValueProxy","_serializeValueFunction","_serializeValueSymbol","getGlobalLetBinding","rval","equals","globalReference","callback","newBody","context","bind","serializeGenerator","statements","_withGeneratorScope","unshift","statement","canOmit","declare","postGeneratorCallback","_getContext","oldCurBody","item","_shouldBeWrapped","rewrittenAdditionalFunctions","shouldEmitLog","collectValToRefCountOnly","processAdditionalFunctionValuesFn","additionalFVEffects","additionalFunctionValue","effects","modifiedBindings","modifiedProperties","createdObjects","nestedFunctions","object","applyEffects","forEach","serializePropertiesAndBindings","keys","binding","additionalFunctionValueInfo","modifiedBinding","newVal","additionalValueSerialized","returnStatement","_serializeAdditionalFunction","resolveInitializedModules","moduleIds","console","log","initializedModules","restoreBindings","restoreProperties","evaluateAndRevertInGlobalEnv","_declaredAbstractValues","postGeneratorSerialization","apply","moduleId","moduleValue","processAdditionalFunctionValues","finalize","factorifyInitializers","spliceFunctions","unstrictFunctionBodies","strictFunctionBodies","requireStatistics","replaced","count","strictDirective","directive","directiveLiteral","globalDirectives","isStrict","funcLoop","directives","functionExpression","ast_body","declaredGlobals","globalExpression","thisExpression","usesThis","program_directives","file","program"],"mappings":"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","file":"ResidualHeapSerializer.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { Realm } from \"../realm.js\";\nimport type { Descriptor, PropertyBinding } from \"../types.js\";\nimport { ToLength, IsArray, Get, IsAccessorDescriptor } from \"../methods/index.js\";\nimport {\n  ArrayValue,\n  BoundFunctionValue,\n  ProxyValue,\n  SymbolValue,\n  NumberValue,\n  StringValue,\n  BooleanValue,\n  AbstractValue,\n  EmptyValue,\n  FunctionValue,\n  ECMAScriptSourceFunctionValue,\n  Value,\n  ObjectValue,\n  NativeFunctionValue,\n  UndefinedValue,\n} from \"../values/index.js\";\nimport { convertExpressionToJSXIdentifier, convertKeyValueToJSXAttribute } from \"../react/jsx.js\";\nimport { isReactElement } from \"../react/utils.js\";\nimport * as t from \"babel-types\";\nimport type {\n  BabelNodeExpression,\n  BabelNodeStatement,\n  BabelNodeIdentifier,\n  BabelNodeBlockStatement,\n  BabelNodeLVal,\n  BabelNodeMemberExpression,\n  BabelVariableKind,\n  BabelNodeFile,\n} from \"babel-types\";\nimport { Generator, PreludeGenerator, NameGenerator } from \"../utils/generator.js\";\nimport type { SerializationContext } from \"../utils/generator.js\";\nimport invariant from \"../invariant.js\";\nimport type {\n  ResidualFunctionBinding,\n  FunctionInfo,\n  FunctionInstance,\n  AdditionalFunctionInfo,\n  ReactSerializerState,\n  SerializedBody,\n} from \"./types.js\";\nimport type { SerializerOptions } from \"../options.js\";\nimport { TimingStatistics, SerializerStatistics } from \"./types.js\";\nimport { Logger } from \"./logger.js\";\nimport { Modules } from \"./modules.js\";\nimport { ResidualHeapInspector } from \"./ResidualHeapInspector.js\";\nimport { ResidualFunctions } from \"./ResidualFunctions.js\";\nimport type { Scope } from \"./ResidualHeapVisitor.js\";\nimport { factorifyObjects } from \"./factorify.js\";\nimport { voidExpression, emptyExpression, constructorExpression, protoExpression } from \"../utils/internalizer.js\";\nimport { Emitter } from \"./Emitter.js\";\nimport { ResidualHeapValueIdentifiers } from \"./ResidualHeapValueIdentifiers.js\";\nimport { commonAncestorOf, getSuggestedArrayLiteralLength } from \"./utils.js\";\nimport type { Effects } from \"../realm.js\";\n\nfunction commentStatement(text: string) {\n  let s = t.emptyStatement();\n  s.leadingComments = [({ type: \"BlockComment\", value: text }: any)];\n  return s;\n}\n\nexport class ResidualHeapSerializer {\n  constructor(\n    realm: Realm,\n    logger: Logger,\n    modules: Modules,\n    residualHeapValueIdentifiers: ResidualHeapValueIdentifiers,\n    residualHeapInspector: ResidualHeapInspector,\n    residualValues: Map<Value, Set<Scope>>,\n    residualFunctionInstances: Map<FunctionValue, FunctionInstance>,\n    residualFunctionInfos: Map<BabelNodeBlockStatement, FunctionInfo>,\n    options: SerializerOptions,\n    referencedDeclaredValues: Set<AbstractValue>,\n    additionalFunctionValuesAndEffects: Map<FunctionValue, Effects> | void,\n    additionalFunctionValueInfos: Map<FunctionValue, AdditionalFunctionInfo>,\n    statistics: SerializerStatistics,\n    react: ReactSerializerState\n  ) {\n    this.realm = realm;\n    this.logger = logger;\n    this.modules = modules;\n    this.residualHeapValueIdentifiers = residualHeapValueIdentifiers;\n    this.statistics = statistics;\n    this.react = react;\n\n    let realmGenerator = this.realm.generator;\n    invariant(realmGenerator);\n    this.generator = realmGenerator;\n    let realmPreludeGenerator = this.realm.preludeGenerator;\n    invariant(realmPreludeGenerator);\n    this.preludeGenerator = realmPreludeGenerator;\n\n    this.prelude = [];\n    this._descriptors = new Map();\n    this.needsEmptyVar = false;\n    this.needsAuxiliaryConstructor = false;\n    this.valueNameGenerator = this.preludeGenerator.createNameGenerator(\"_\");\n    this.descriptorNameGenerator = this.preludeGenerator.createNameGenerator(\"$$\");\n    this.factoryNameGenerator = this.preludeGenerator.createNameGenerator(\"$_\");\n    this.intrinsicNameGenerator = this.preludeGenerator.createNameGenerator(\"$i_\");\n    this.functionNameGenerator = this.preludeGenerator.createNameGenerator(\"$f_\");\n    this.requireReturns = new Map();\n    this.serializedValues = new Set();\n    this.additionalFunctionValueNestedFunctions = new Set();\n    this.residualFunctions = new ResidualFunctions(\n      this.realm,\n      this.statistics,\n      this.modules,\n      this.requireReturns,\n      {\n        getLocation: value => this.getSerializeObjectIdentifierOptional(value),\n        createLocation: () => {\n          let location = t.identifier(this.valueNameGenerator.generate(\"initialized\"));\n          this.currentFunctionBody.entries.push(t.variableDeclaration(\"var\", [t.variableDeclarator(location)]));\n          return location;\n        },\n      },\n      this.prelude,\n      this.preludeGenerator.createNameGenerator(\"__init_\"),\n      this.factoryNameGenerator,\n      this.preludeGenerator.createNameGenerator(\"__scope_\"),\n      residualFunctionInfos,\n      residualFunctionInstances,\n      additionalFunctionValueInfos,\n      this.additionalFunctionValueNestedFunctions\n    );\n    this.emitter = new Emitter(this.residualFunctions);\n    this.mainBody = this.emitter.getBody();\n    this.currentFunctionBody = this.mainBody;\n    this.residualHeapInspector = residualHeapInspector;\n    this.residualValues = residualValues;\n    this.residualFunctionInstances = residualFunctionInstances;\n    this.residualFunctionInfos = residualFunctionInfos;\n    this._options = options;\n    this.referencedDeclaredValues = referencedDeclaredValues;\n    this.activeGeneratorBodies = new Map();\n    this.additionalFunctionValuesAndEffects = additionalFunctionValuesAndEffects;\n    this.additionalFunctionValueInfos = additionalFunctionValueInfos;\n    this.functionNames = new Map();\n  }\n\n  emitter: Emitter;\n  functions: Map<BabelNodeBlockStatement, Array<FunctionInstance>>;\n  functionInstances: Array<FunctionInstance>;\n  prelude: Array<BabelNodeStatement>;\n  body: Array<BabelNodeStatement>;\n  mainBody: SerializedBody;\n  // if we're in an additional function we need to access both mainBody and the\n  // additional function's body which will be currentFunctionBody.\n  currentFunctionBody: SerializedBody;\n  realm: Realm;\n  preludeGenerator: PreludeGenerator;\n  generator: Generator;\n  _descriptors: Map<string, BabelNodeIdentifier>;\n  needsEmptyVar: boolean;\n  needsAuxiliaryConstructor: boolean;\n  valueNameGenerator: NameGenerator;\n  descriptorNameGenerator: NameGenerator;\n  factoryNameGenerator: NameGenerator;\n  intrinsicNameGenerator: NameGenerator;\n  functionNameGenerator: NameGenerator;\n  logger: Logger;\n  modules: Modules;\n  residualHeapValueIdentifiers: ResidualHeapValueIdentifiers;\n  requireReturns: Map<number | string, BabelNodeExpression>;\n  statistics: SerializerStatistics;\n  timingStats: TimingStatistics;\n  residualHeapInspector: ResidualHeapInspector;\n  residualValues: Map<Value, Set<Scope>>;\n  residualFunctionInstances: Map<FunctionValue, FunctionInstance>;\n  residualFunctionInfos: Map<BabelNodeBlockStatement, FunctionInfo>;\n  serializedValues: Set<Value>;\n  residualFunctions: ResidualFunctions;\n  _options: SerializerOptions;\n  referencedDeclaredValues: Set<AbstractValue>;\n  activeGeneratorBodies: Map<Generator, SerializedBody>;\n  additionalFunctionValuesAndEffects: Map<FunctionValue, Effects> | void;\n  additionalFunctionValueInfos: Map<FunctionValue, AdditionalFunctionInfo>;\n  react: ReactSerializerState;\n\n  // function values nested in additional functions can't delay initializations\n  // TODO: revisit this and fix additional functions to be capable of delaying initializations\n  additionalFunctionValueNestedFunctions: Set<FunctionValue>;\n  currentAdditionalFunction: void | FunctionValue;\n  functionNames: Map<FunctionValue, string>;\n\n  _getFunctionName(f: FunctionValue): string {\n    let n = this.functionNames.get(f);\n    if (n === undefined) this.functionNames.set(f, (n = this.functionNameGenerator.generate(f.__originalName || \"\")));\n    return n;\n  }\n\n  _getScopeName(s: Scope): string {\n    if (s instanceof Generator) return `#${s.id}`;\n    invariant(s instanceof FunctionValue);\n    return this._getFunctionName(s);\n  }\n\n  // Configures all mutable aspects of an object, in particular:\n  // symbols, properties, prototype.\n  // For every created object that corresponds to a value,\n  // this function should be invoked once.\n  // Thus, as a side effects, we gather statistics here on all emitted objects.\n  _emitObjectProperties(\n    obj: ObjectValue,\n    properties: Map<string, PropertyBinding> = obj.properties,\n    objectPrototypeAlreadyEstablished: boolean = false,\n    cleanupDummyProperties: ?Set<string>\n  ) {\n    //inject symbols\n    for (let [symbol, propertyBinding] of obj.symbols) {\n      invariant(propertyBinding);\n      let desc = propertyBinding.descriptor;\n      if (desc === undefined) continue; //deleted\n      this.emitter.emitNowOrAfterWaitingForDependencies(this._getDescriptorValues(desc).concat([symbol, obj]), () => {\n        invariant(desc !== undefined);\n        return this._emitProperty(obj, symbol, desc);\n      });\n    }\n\n    // inject properties\n    for (let [key, propertyBinding] of properties) {\n      invariant(propertyBinding);\n      let desc = propertyBinding.descriptor;\n      if (desc === undefined) continue; //deleted\n      if (this.residualHeapInspector.canIgnoreProperty(obj, key)) continue;\n      invariant(desc !== undefined);\n      this.emitter.emitNowOrAfterWaitingForDependencies(this._getDescriptorValues(desc).concat(obj), () => {\n        invariant(desc !== undefined);\n        return this._emitProperty(obj, key, desc, cleanupDummyProperties != null && cleanupDummyProperties.has(key));\n      });\n    }\n\n    // inject properties with computed names\n    if (obj.unknownProperty !== undefined) {\n      let desc = obj.unknownProperty.descriptor;\n      if (desc !== undefined) {\n        let val = desc.value;\n        invariant(val instanceof AbstractValue);\n        this.emitter.emitNowOrAfterWaitingForDependencies(this._getNestedAbstractValues(val, [obj]), () => {\n          invariant(val instanceof AbstractValue);\n          this._emitPropertiesWithComputedNames(obj, val);\n        });\n      }\n    }\n\n    // prototype\n    this._emitObjectPrototype(obj, objectPrototypeAlreadyEstablished);\n    if (obj instanceof FunctionValue) this._emitConstructorPrototype(obj);\n\n    this.statistics.objects++;\n    this.statistics.objectProperties += obj.properties.size;\n  }\n\n  _emitObjectPrototype(obj: ObjectValue, objectPrototypeAlreadyEstablished: boolean) {\n    let kind = obj.getKind();\n    let proto = obj.$Prototype;\n    if (objectPrototypeAlreadyEstablished) {\n      // Emitting an assertion. This can be removed in the future, or put under a DEBUG flag.\n      this.emitter.emitNowOrAfterWaitingForDependencies([proto, obj], () => {\n        invariant(proto);\n        let serializedProto = this.serializeValue(proto);\n        let uid = this.getSerializeObjectIdentifier(obj);\n        let condition = t.binaryExpression(\"!==\", t.memberExpression(uid, protoExpression), serializedProto);\n        let throwblock = t.blockStatement([\n          t.throwStatement(t.newExpression(t.identifier(\"Error\"), [t.stringLiteral(\"unexpected prototype\")])),\n        ]);\n        this.emitter.emit(t.ifStatement(condition, throwblock));\n      });\n      return;\n    }\n    if (proto === this.realm.intrinsics[kind + \"Prototype\"]) return;\n\n    this.emitter.emitNowOrAfterWaitingForDependencies([proto, obj], () => {\n      invariant(proto);\n      let serializedProto = this.serializeValue(proto);\n      let uid = this.getSerializeObjectIdentifier(obj);\n      if (!this.realm.isCompatibleWith(this.realm.MOBILE_JSC_VERSION))\n        this.emitter.emit(\n          t.expressionStatement(\n            t.callExpression(this.preludeGenerator.memoizeReference(\"Object.setPrototypeOf\"), [uid, serializedProto])\n          )\n        );\n      else {\n        this.emitter.emit(\n          t.expressionStatement(t.assignmentExpression(\"=\", t.memberExpression(uid, protoExpression), serializedProto))\n        );\n      }\n    });\n  }\n\n  _emitConstructorPrototype(func: FunctionValue) {\n    // If the original prototype object was mutated,\n    // request its serialization here as this might be observable by\n    // residual code.\n    let prototype = ResidualHeapInspector.getPropertyValue(func, \"prototype\");\n    if (prototype instanceof ObjectValue && this.residualValues.has(prototype)) {\n      this.emitter.emitNowOrAfterWaitingForDependencies([func], () => {\n        invariant(prototype instanceof Value);\n        this.serializeValue(prototype);\n      });\n    }\n  }\n\n  _getNestedAbstractValues(absVal: AbstractValue, values: Array<Value>): Array<Value> {\n    invariant(absVal.args.length === 3);\n    let cond = absVal.args[0];\n    invariant(cond instanceof AbstractValue);\n    if (cond.kind === \"template for property name condition\") {\n      let P = cond.args[0];\n      values.push(P);\n      let V = absVal.args[1];\n      values.push(V);\n      let W = absVal.args[2];\n      if (W instanceof AbstractValue) this._getNestedAbstractValues(W, values);\n      else values.push(W);\n    } else {\n      // conditional assignment\n      values.push(cond);\n      let consequent = absVal.args[1];\n      invariant(consequent instanceof AbstractValue);\n      let alternate = absVal.args[2];\n      invariant(alternate instanceof AbstractValue);\n      this._getNestedAbstractValues(consequent, values);\n      this._getNestedAbstractValues(alternate, values);\n    }\n    return values;\n  }\n\n  _emitPropertiesWithComputedNames(obj: ObjectValue, absVal: AbstractValue) {\n    invariant(absVal.args.length === 3);\n    let cond = absVal.args[0];\n    invariant(cond instanceof AbstractValue);\n    if (cond.kind === \"template for property name condition\") {\n      let P = cond.args[0];\n      invariant(P instanceof AbstractValue);\n      let V = absVal.args[1];\n      let earlier_props = absVal.args[2];\n      if (earlier_props instanceof AbstractValue) this._emitPropertiesWithComputedNames(obj, earlier_props);\n      let uid = this.getSerializeObjectIdentifier(obj);\n      let serializedP = this.serializeValue(P);\n      let serializedV = this.serializeValue(V);\n      this.emitter.emit(\n        t.expressionStatement(t.assignmentExpression(\"=\", t.memberExpression(uid, serializedP, true), serializedV))\n      );\n    } else {\n      // conditional assignment\n      let serializedCond = this.serializeValue(cond);\n      let consequent = absVal.args[1];\n      invariant(consequent instanceof AbstractValue);\n      let alternate = absVal.args[2];\n      invariant(alternate instanceof AbstractValue);\n      let oldBody = this.emitter.beginEmitting(\"consequent\", { type: \"ConditionalAssignmentBranch\", entries: [] });\n      this._emitPropertiesWithComputedNames(obj, consequent);\n      let consequentBody = this.emitter.endEmitting(\"consequent\", oldBody);\n      let consequentStatement = t.blockStatement(consequentBody.entries);\n      oldBody = this.emitter.beginEmitting(\"alternate\", { type: \"ConditionalAssignmentBranch\", entries: [] });\n      this._emitPropertiesWithComputedNames(obj, alternate);\n      let alternateBody = this.emitter.endEmitting(\"alternate\", oldBody);\n      let alternateStatement = t.blockStatement(alternateBody.entries);\n      this.emitter.emit(t.ifStatement(serializedCond, consequentStatement, alternateStatement));\n    }\n  }\n\n  // Overridable.\n  getSerializeObjectIdentifier(val: Value) {\n    return this.residualHeapValueIdentifiers.getIdentifierAndIncrementReferenceCount(val);\n  }\n\n  // Overridable.\n  getSerializeObjectIdentifierOptional(val: Value) {\n    return this.residualHeapValueIdentifiers.getIdentifierAndIncrementReferenceCountOptional(val);\n  }\n\n  _emitProperty(\n    val: ObjectValue,\n    key: string | SymbolValue,\n    desc: Descriptor | void,\n    deleteIfMightHaveBeenDeleted: boolean = false\n  ): void {\n    // Location for the property to be assigned to\n    let locationFunction = () => {\n      let serializedKey =\n        key instanceof SymbolValue ? this.serializeValue(key) : this.generator.getAsPropertyNameExpression(key);\n      let computed = key instanceof SymbolValue || !t.isIdentifier(serializedKey);\n      return t.memberExpression(this.getSerializeObjectIdentifier(val), serializedKey, computed);\n    };\n    if (desc === undefined) {\n      this._deleteProperty(locationFunction());\n    } else {\n      this.emitter.emit(this.emitDefinePropertyBody(deleteIfMightHaveBeenDeleted, locationFunction, val, key, desc));\n    }\n  }\n\n  emitDefinePropertyBody(\n    deleteIfMightHaveBeenDeleted: boolean,\n    locationFunction: void | (() => BabelNodeLVal),\n    val: ObjectValue,\n    key: string | SymbolValue,\n    desc: Descriptor\n  ): BabelNodeStatement {\n    if (desc.joinCondition) {\n      let cond = this.serializeValue(desc.joinCondition);\n      invariant(cond !== undefined);\n      let trueBody;\n      let falseBody;\n      if (desc.descriptor1)\n        trueBody = this.emitDefinePropertyBody(\n          deleteIfMightHaveBeenDeleted,\n          locationFunction,\n          val,\n          key,\n          desc.descriptor1\n        );\n      if (desc.descriptor2)\n        falseBody = this.emitDefinePropertyBody(\n          deleteIfMightHaveBeenDeleted,\n          locationFunction,\n          val,\n          key,\n          desc.descriptor2\n        );\n      if (trueBody && falseBody) return t.ifStatement(cond, trueBody, falseBody);\n      if (trueBody) return t.ifStatement(cond, trueBody);\n      if (falseBody) return t.ifStatement(t.unaryExpression(\"!\", cond), falseBody);\n      invariant(false);\n    }\n    if (locationFunction !== undefined && this._canEmbedProperty(val, key, desc)) {\n      let descValue = desc.value;\n      invariant(descValue instanceof Value);\n      invariant(!this.emitter.getReasonToWaitForDependencies([descValue, val]), \"precondition of _emitProperty\");\n      let mightHaveBeenDeleted = descValue.mightHaveBeenDeleted();\n      // The only case we do not need to remove the dummy property is array index property.\n      return this._getPropertyAssignment(\n        locationFunction,\n        () => {\n          invariant(descValue instanceof Value);\n          return this.serializeValue(descValue);\n        },\n        mightHaveBeenDeleted,\n        deleteIfMightHaveBeenDeleted\n      );\n    }\n    let body = [];\n    let descProps = [];\n    let boolKeys = [\"enumerable\", \"configurable\"];\n    let valKeys = [];\n\n    if (!desc.get && !desc.set) {\n      boolKeys.push(\"writable\");\n      valKeys.push(\"value\");\n    } else {\n      valKeys.push(\"set\", \"get\");\n    }\n\n    let descriptorsKey = [];\n    for (let boolKey of boolKeys) {\n      if (boolKey in desc) {\n        let b = desc[boolKey];\n        invariant(b !== undefined);\n        descProps.push(t.objectProperty(t.identifier(boolKey), t.booleanLiteral(b)));\n        descriptorsKey.push(`${boolKey}:${b.toString()}`);\n      }\n    }\n\n    descriptorsKey = descriptorsKey.join(\",\");\n    let descriptorId = this._descriptors.get(descriptorsKey);\n    if (descriptorId === undefined) {\n      descriptorId = t.identifier(this.descriptorNameGenerator.generate(descriptorsKey));\n      let declar = t.variableDeclaration(\"var\", [t.variableDeclarator(descriptorId, t.objectExpression(descProps))]);\n      // The descriptors are used across all scopes, and thus must be declared in the prelude.\n      this.prelude.push(declar);\n      this._descriptors.set(descriptorsKey, descriptorId);\n    }\n    invariant(descriptorId !== undefined);\n\n    for (let descKey of valKeys) {\n      if (descKey in desc) {\n        let descValue = desc[descKey];\n        invariant(descValue instanceof Value);\n        if (descValue instanceof UndefinedValue) {\n          this.serializeValue(descValue);\n          continue;\n        }\n        invariant(!this.emitter.getReasonToWaitForDependencies([descValue]), \"precondition of _emitProperty\");\n        body.push(\n          t.assignmentExpression(\n            \"=\",\n            t.memberExpression(descriptorId, t.identifier(descKey)),\n            this.serializeValue(descValue)\n          )\n        );\n      }\n    }\n    let serializedKey =\n      key instanceof SymbolValue\n        ? this.serializeValue(key)\n        : this.generator.getAsPropertyNameExpression(key, /*canBeIdentifier*/ false);\n    invariant(!this.emitter.getReasonToWaitForDependencies([val]), \"precondition of _emitProperty\");\n    body.push(\n      t.callExpression(this.preludeGenerator.memoizeReference(\"Object.defineProperty\"), [\n        this.getSerializeObjectIdentifier(val),\n        serializedKey,\n        descriptorId,\n      ])\n    );\n    return t.expressionStatement(t.sequenceExpression(body));\n  }\n\n  _serializeDeclarativeEnvironmentRecordBinding(residualFunctionBinding: ResidualFunctionBinding) {\n    if (!residualFunctionBinding.serializedValue) {\n      let value = residualFunctionBinding.value;\n      invariant(value);\n      invariant(residualFunctionBinding.declarativeEnvironmentRecord);\n\n      // Set up binding identity before starting to serialize value. This is needed in case of recursive dependencies.\n      residualFunctionBinding.referentialized = false;\n      residualFunctionBinding.serializedValue = this.serializeValue(value);\n      if (value.mightBeObject()) {\n        // Increment ref count one more time to ensure that this object will be assigned a unique id.\n        // This ensures that only once instance is created across all possible residual function invocations.\n        this.residualHeapValueIdentifiers.incrementReferenceCount(value);\n      }\n    }\n  }\n\n  // Determine whether initialization code for a value should go into the main body, or a more specific initialization body.\n  _getTarget(\n    val: Value,\n    scopes: Set<Scope>\n  ): {\n    body: SerializedBody,\n    usedOnlyByResidualFunctions?: true,\n    usedOnlyByAdditionalFunctions?: boolean,\n    commonAncestor?: Scope,\n    description?: string,\n  } {\n    // All relevant values were visited in at least one scope.\n    invariant(scopes.size >= 1);\n\n    // First, let's figure out from which function and generator scopes this value is referenced.\n    let functionValues = [];\n    let generators = [];\n    for (let scope of scopes) {\n      if (scope instanceof FunctionValue) functionValues.push(scope);\n      else {\n        invariant(scope instanceof Generator);\n        if (scope === this.realm.generator) {\n          // This value is used from the main generator scope. This means that we need to emit the value and its\n          // initialization code into the main body, and cannot delay initialization.\n          return { body: this.currentFunctionBody, description: \"this.realm.generator\" };\n        }\n        generators.push(scope);\n      }\n    }\n\n    if (generators.length === 0) {\n      // This value is only referenced from residual functions.\n      invariant(functionValues.length > 0);\n      let additionalFunctionValuesAndEffects = this.additionalFunctionValuesAndEffects;\n      let numAdditionalFunctionReferences = 0;\n      // Make sure we don't delay things referenced by additional functions or nested functions\n      if (additionalFunctionValuesAndEffects) {\n        // flow forces me to do this\n        let additionalFuncValuesAndEffects = additionalFunctionValuesAndEffects;\n        numAdditionalFunctionReferences = functionValues.filter(\n          funcValue =>\n            additionalFuncValuesAndEffects.has(funcValue) || this.additionalFunctionValueNestedFunctions.has(funcValue)\n        ).length;\n      }\n\n      if (numAdditionalFunctionReferences > 0 || !this._options.delayInitializations) {\n        // We can just emit it into the current function body.\n        return {\n          body: this.currentFunctionBody,\n          usedOnlyByAdditionalFunctions: numAdditionalFunctionReferences === functionValues.length,\n          description: \"this.currentFunctionBody\",\n        };\n      } else {\n        // We can delay the initialization, and move it into a conditional code block in the residual functions!\n        let body = this.residualFunctions.residualFunctionInitializers.registerValueOnlyReferencedByResidualFunctions(\n          functionValues,\n          val\n        );\n        return { body, usedOnlyByResidualFunctions: true, description: \"initializer\" };\n      }\n    }\n\n    // This value is referenced from more than one generator or function.\n    // We can emit the initialization of this value into the body associated with their common ancestor.\n    let commonAncestor = Array.from(scopes).reduce((x, y) => commonAncestorOf(x, y), generators[0]);\n    invariant(commonAncestor instanceof Generator); // every scope is either the root, or a descendant\n    let body;\n    while (true) {\n      if (commonAncestor === this.generator) {\n        body = this.currentFunctionBody;\n      } else {\n        body = this.activeGeneratorBodies.get(commonAncestor);\n      }\n      if (body !== undefined) break;\n      commonAncestor = commonAncestor.parent;\n      invariant(commonAncestor !== undefined);\n    }\n    invariant(body !== undefined);\n    return { body, commonAncestor };\n  }\n\n  serializeValue(val: Value, referenceOnly?: boolean, bindingType?: BabelVariableKind): BabelNodeExpression {\n    invariant(!val.refuseSerialization);\n    let scopes = this.residualValues.get(val);\n    invariant(scopes !== undefined);\n\n    let ref = this.getSerializeObjectIdentifierOptional(val);\n    if (ref) {\n      return ref;\n    }\n\n    this.serializedValues.add(val);\n    if (!referenceOnly && ResidualHeapInspector.isLeaf(val)) {\n      let res = this._serializeValue(val);\n      invariant(res !== undefined);\n      return res;\n    }\n\n    let target = this._getTarget(val, scopes);\n\n    let name;\n    if (val instanceof FunctionValue) name = this._getFunctionName(val);\n    else name = this.valueNameGenerator.generate(val.__originalName || \"\");\n    let id = t.identifier(name);\n    this.residualHeapValueIdentifiers.setIdentifier(val, id);\n    let oldBody = this.emitter.beginEmitting(val, target.body);\n    let init = this._serializeValue(val);\n    let result = id;\n    this.residualHeapValueIdentifiers.incrementReferenceCount(val);\n\n    if (this.residualHeapValueIdentifiers.needsIdentifier(val)) {\n      if (init) {\n        if (this._options.debugScopes) {\n          let comment = `${name} referenced from scopes ${Array.from(scopes)\n            .map(s => this._getScopeName(s))\n            .join(\",\")}`;\n          if (target.commonAncestor !== undefined)\n            comment = `${comment} with common ancestor ${this._getScopeName(target.commonAncestor)}`;\n          if (target.description !== undefined) comment = `${comment} => ${target.description} `;\n          this.emitter.emit(commentStatement(comment));\n        }\n        if (init !== id) {\n          if (target.usedOnlyByResidualFunctions) {\n            let declar = t.variableDeclaration(bindingType ? bindingType : \"var\", [t.variableDeclarator(id)]);\n            this.mainBody.entries.push(declar);\n            let assignment = t.expressionStatement(t.assignmentExpression(\"=\", id, init));\n            this.emitter.emit(assignment);\n          } else {\n            let declar = t.variableDeclaration(bindingType ? bindingType : \"var\", [t.variableDeclarator(id, init)]);\n            this.emitter.emit(declar);\n          }\n        }\n        this.statistics.valueIds++;\n        if (target.usedOnlyByResidualFunctions) this.statistics.delayedValues++;\n      }\n    } else {\n      if (init) {\n        this.residualHeapValueIdentifiers.deleteIdentifier(val);\n        result = init;\n        this.statistics.valuesInlined++;\n      }\n    }\n\n    this.emitter.endEmitting(val, oldBody);\n    return result;\n  }\n\n  _serializeValueIntrinsic(val: Value): BabelNodeExpression {\n    let intrinsicName = val.intrinsicName;\n    invariant(intrinsicName);\n    if (val instanceof ObjectValue && val.intrinsicNameGenerated) {\n      // The intrinsic was generated at a particular point in time.\n      return this.preludeGenerator.convertStringToMember(intrinsicName);\n    } else {\n      // The intrinsic conceptually exists ahead of time.\n      invariant(this.emitter.getBody() === this.currentFunctionBody);\n      return this.preludeGenerator.memoizeReference(intrinsicName);\n    }\n  }\n\n  _getDescriptorValues(desc: Descriptor): Array<Value> {\n    if (desc.joinCondition !== undefined) return [desc.joinCondition];\n    invariant(desc.value === undefined || desc.value instanceof Value);\n    if (desc.value !== undefined) return [desc.value];\n    invariant(desc.get !== undefined);\n    invariant(desc.set !== undefined);\n    return [desc.get, desc.set];\n  }\n\n  _deleteProperty(location: BabelNodeLVal) {\n    invariant(location.type === \"MemberExpression\");\n    this.emitter.emit(\n      t.expressionStatement(t.unaryExpression(\"delete\", ((location: any): BabelNodeMemberExpression), true))\n    );\n  }\n\n  _assignProperty(\n    locationFn: () => BabelNodeLVal,\n    valueFn: () => BabelNodeExpression,\n    mightHaveBeenDeleted: boolean,\n    deleteIfMightHaveBeenDeleted: boolean = false\n  ) {\n    this.emitter.emit(\n      this._getPropertyAssignment(locationFn, valueFn, mightHaveBeenDeleted, deleteIfMightHaveBeenDeleted)\n    );\n  }\n\n  _getPropertyAssignment(\n    locationFn: () => BabelNodeLVal,\n    valueFn: () => BabelNodeExpression,\n    mightHaveBeenDeleted: boolean,\n    deleteIfMightHaveBeenDeleted: boolean = false\n  ) {\n    let location = locationFn();\n    let value = valueFn();\n    let assignment = t.expressionStatement(t.assignmentExpression(\"=\", location, value));\n    if (mightHaveBeenDeleted) {\n      let condition = t.binaryExpression(\"!==\", value, this.serializeValue(this.realm.intrinsics.empty));\n      let deletion = null;\n      if (deleteIfMightHaveBeenDeleted) {\n        invariant(location.type === \"MemberExpression\");\n        deletion = t.expressionStatement(\n          t.unaryExpression(\"delete\", ((location: any): BabelNodeMemberExpression), true)\n        );\n      }\n      return t.ifStatement(condition, assignment, deletion);\n    } else {\n      return assignment;\n    }\n  }\n\n  _serializeArrayIndexProperties(\n    array: ObjectValue,\n    indexPropertyLength: number,\n    remainingProperties: Map<string, PropertyBinding>\n  ) {\n    let elems = [];\n    for (let i = 0; i < indexPropertyLength; i++) {\n      let key = i + \"\";\n      let propertyBinding = remainingProperties.get(key);\n      let elem = null;\n      // \"propertyBinding === undefined\" means array has a hole in the middle.\n      if (propertyBinding !== undefined) {\n        let descriptor = propertyBinding.descriptor;\n        // \"descriptor === undefined\" means this array item has been deleted.\n        if (\n          descriptor !== undefined &&\n          descriptor.value !== undefined &&\n          this._canEmbedProperty(array, key, descriptor)\n        ) {\n          let elemVal = descriptor.value;\n          invariant(elemVal instanceof Value);\n          let mightHaveBeenDeleted = elemVal.mightHaveBeenDeleted();\n          let delayReason =\n            this.emitter.getReasonToWaitForDependencies(elemVal) ||\n            this.emitter.getReasonToWaitForActiveValue(array, mightHaveBeenDeleted);\n          if (!delayReason) {\n            elem = this.serializeValue(elemVal);\n            remainingProperties.delete(key);\n          }\n        }\n      }\n      elems.push(elem);\n    }\n    return elems;\n  }\n\n  _serializeArrayLengthIfNeeded(\n    val: ObjectValue,\n    numberOfIndexProperties: number,\n    remainingProperties: Map<string, PropertyBinding>\n  ): void {\n    const realm = this.realm;\n    let lenProperty = Get(realm, val, \"length\");\n    // Need to serialize length property if:\n    // 1. array length is abstract.\n    // 2. array length is concrete, but different from number of index properties\n    //  we put into initialization list.\n    if (lenProperty instanceof AbstractValue || ToLength(realm, lenProperty) !== numberOfIndexProperties) {\n      this.emitter.emitNowOrAfterWaitingForDependencies([val], () => {\n        this._assignProperty(\n          () => t.memberExpression(this.getSerializeObjectIdentifier(val), t.identifier(\"length\")),\n          () => {\n            return this.serializeValue(lenProperty);\n          },\n          false /*mightHaveBeenDeleted*/\n        );\n      });\n      remainingProperties.delete(\"length\");\n    }\n  }\n\n  _serializeValueArray(val: ObjectValue): BabelNodeExpression {\n    let remainingProperties = new Map(val.properties);\n\n    const indexPropertyLength = getSuggestedArrayLiteralLength(this.realm, val);\n    // Use the serialized index properties as array initialization list.\n    const initProperties = this._serializeArrayIndexProperties(val, indexPropertyLength, remainingProperties);\n    this._serializeArrayLengthIfNeeded(val, indexPropertyLength, remainingProperties);\n    this._emitObjectProperties(val, remainingProperties);\n    return t.arrayExpression(initProperties);\n  }\n\n  _serializeValueReactElementChild(child: Value): BabelNode {\n    if (isReactElement(child)) {\n      // if we know it's a ReactElement, we add the value to the serializedValues\n      // and short cut to get back the JSX expression so we don't emit additional data\n      // we do this to ensure child JSXElements can get keys assigned if needed\n      this.serializedValues.add(child);\n      let reactChild = this._serializeValueObject(((child: any): ObjectValue));\n      if (reactChild.leadingComments != null) {\n        return t.jSXExpressionContainer(reactChild);\n      }\n      return reactChild;\n    }\n    const expr = this.serializeValue(child);\n\n    if (t.isStringLiteral(expr) || t.isNumericLiteral(expr)) {\n      return t.jSXText(((expr: any).value: string) + \"\");\n    } else if (t.isJSXElement(expr)) {\n      return expr;\n    }\n    return t.jSXExpressionContainer(expr);\n  }\n\n  _serializeValueReactElement(val: ObjectValue): BabelNodeExpression {\n    let typeValue = Get(this.realm, val, \"type\");\n    let keyValue = Get(this.realm, val, \"key\");\n    let refValue = Get(this.realm, val, \"ref\");\n    let propsValue = Get(this.realm, val, \"props\");\n\n    invariant(typeValue !== null, \"JSXElement type of null\");\n\n    let identifier = convertExpressionToJSXIdentifier(this.serializeValue(typeValue), true);\n    let attributes = [];\n    let children = [];\n\n    if (keyValue !== null) {\n      let keyExpr = this.serializeValue(keyValue);\n      if (keyExpr.type !== \"NullLiteral\") {\n        attributes.push(convertKeyValueToJSXAttribute(\"key\", keyExpr));\n      }\n    }\n\n    if (refValue !== null) {\n      let refExpr = this.serializeValue(refValue);\n      if (refExpr.type !== \"NullLiteral\") {\n        attributes.push(convertKeyValueToJSXAttribute(\"ref\", refExpr));\n      }\n    }\n\n    if (propsValue instanceof ObjectValue) {\n      // the propsValue is visited to get the properties, but we don't emit it as the object\n      // is contained within a JSXOpeningElement\n      this.serializedValues.add(propsValue);\n      // have to case propsValue to ObjectValue or Flow complains that propsValues can be null/undefined\n      for (let [key, propertyBinding] of (propsValue: ObjectValue).properties) {\n        let desc = propertyBinding.descriptor;\n        if (desc === undefined) continue; // deleted\n        invariant(!IsAccessorDescriptor(this.realm, desc), \"expected descriptor to be a non-accessor property\");\n\n        invariant(key !== \"key\" && key !== \"ref\", `\"${key}\" is a reserved prop name`);\n\n        if (key === \"children\" && desc.value !== undefined) {\n          let childrenValue = desc.value;\n          if (childrenValue instanceof ArrayValue) {\n            this.serializedValues.add(childrenValue);\n            let childrenLength = Get(this.realm, childrenValue, \"length\");\n            let childrenLengthValue = 0;\n            if (childrenLength instanceof NumberValue) {\n              childrenLengthValue = childrenLength.value;\n              for (let i = 0; i < childrenLengthValue; i++) {\n                let child = Get(this.realm, childrenValue, \"\" + i);\n                if (child instanceof Value) {\n                  children.push(this._serializeValueReactElementChild(child));\n                } else {\n                  this.logger.logError(val, `JSXElement \"props.children[${i}]\" failed to serialize due to a non-value`);\n                }\n              }\n              continue;\n            }\n          }\n          // otherwise it must be a value, as desc.value !== undefined.\n          children.push(this._serializeValueReactElementChild(((childrenValue: any): Value)));\n          continue;\n        }\n        if (desc.value instanceof Value) {\n          attributes.push(convertKeyValueToJSXAttribute(key, this.serializeValue(desc.value)));\n        }\n      }\n    }\n    let openingElement = t.jSXOpeningElement(identifier, (attributes: any), children.length === 0);\n    let closingElement = t.jSXClosingElement(identifier);\n\n    let jsxElement = t.jSXElement(openingElement, closingElement, children, children.length === 0);\n    // if there has been a bail-out, we create an inline BlockComment node before the JSX element\n    if (val.$BailOutReason !== undefined) {\n      // $BailOutReason contains an optional string of what to print out in the comment\n      jsxElement.leadingComments = [({ type: \"BlockComment\", value: `${val.$BailOutReason}` }: any)];\n    }\n    return jsxElement;\n  }\n\n  _serializeValueMap(val: ObjectValue): BabelNodeExpression {\n    let kind = val.getKind();\n    let elems = [];\n\n    let entries;\n    if (kind === \"Map\") {\n      entries = val.$MapData;\n    } else {\n      invariant(kind === \"WeakMap\");\n      entries = val.$WeakMapData;\n    }\n    invariant(entries !== undefined);\n    let len = entries.length;\n    let mapConstructorDoesntTakeArguments = this.realm.isCompatibleWith(this.realm.MOBILE_JSC_VERSION);\n\n    for (let i = 0; i < len; i++) {\n      let entry = entries[i];\n      let key = entry.$Key;\n      let value = entry.$Value;\n      if (key === undefined || value === undefined) continue;\n      let mightHaveBeenDeleted = key.mightHaveBeenDeleted();\n      let delayReason =\n        this.emitter.getReasonToWaitForDependencies(key) ||\n        this.emitter.getReasonToWaitForDependencies(value) ||\n        this.emitter.getReasonToWaitForActiveValue(val, mightHaveBeenDeleted || mapConstructorDoesntTakeArguments);\n      if (delayReason) {\n        this.emitter.emitAfterWaiting(delayReason, [key, value, val], () => {\n          invariant(key !== undefined);\n          invariant(value !== undefined);\n          this.emitter.emit(\n            t.expressionStatement(\n              t.callExpression(\n                t.memberExpression(\n                  this.residualHeapValueIdentifiers.getIdentifierAndIncrementReferenceCount(val),\n                  t.identifier(\"set\")\n                ),\n                [this.serializeValue(key), this.serializeValue(value)]\n              )\n            )\n          );\n        });\n      } else {\n        let serializedKey = this.serializeValue(key);\n        let serializedValue = this.serializeValue(value);\n        let elem = t.arrayExpression([serializedKey, serializedValue]);\n        elems.push(elem);\n      }\n    }\n\n    this._emitObjectProperties(val);\n    let args = elems.length > 0 ? [t.arrayExpression(elems)] : [];\n    return t.newExpression(this.preludeGenerator.memoizeReference(kind), args);\n  }\n\n  _serializeValueSet(val: ObjectValue): BabelNodeExpression {\n    let kind = val.getKind();\n    let elems = [];\n\n    let entries;\n    if (kind === \"Set\") {\n      entries = val.$SetData;\n    } else {\n      invariant(kind === \"WeakSet\");\n      entries = val.$WeakSetData;\n    }\n    invariant(entries !== undefined);\n    let len = entries.length;\n    let setConstructorDoesntTakeArguments = this.realm.isCompatibleWith(this.realm.MOBILE_JSC_VERSION);\n\n    for (let i = 0; i < len; i++) {\n      let entry = entries[i];\n      if (entry === undefined) continue;\n      let mightHaveBeenDeleted = entry.mightHaveBeenDeleted();\n      let delayReason =\n        this.emitter.getReasonToWaitForDependencies(entry) ||\n        this.emitter.getReasonToWaitForActiveValue(val, mightHaveBeenDeleted || setConstructorDoesntTakeArguments);\n      if (delayReason) {\n        this.emitter.emitAfterWaiting(delayReason, [entry, val], () => {\n          invariant(entry !== undefined);\n          this.emitter.emit(\n            t.expressionStatement(\n              t.callExpression(\n                t.memberExpression(\n                  this.residualHeapValueIdentifiers.getIdentifierAndIncrementReferenceCount(val),\n                  t.identifier(\"add\")\n                ),\n                [this.serializeValue(entry)]\n              )\n            )\n          );\n        });\n      } else {\n        let elem = this.serializeValue(entry);\n        elems.push(elem);\n      }\n    }\n\n    this._emitObjectProperties(val);\n    let args = elems.length > 0 ? [t.arrayExpression(elems)] : [];\n    return t.newExpression(this.preludeGenerator.memoizeReference(kind), args);\n  }\n\n  _serializeValueTypedArrayOrDataView(val: ObjectValue): BabelNodeExpression {\n    let buf = val.$ViewedArrayBuffer;\n    invariant(buf !== undefined);\n    let outlinedArrayBuffer = this.serializeValue(buf, true);\n    this._emitObjectProperties(val);\n    return t.newExpression(this.preludeGenerator.memoizeReference(val.getKind()), [outlinedArrayBuffer]);\n  }\n\n  _serializeValueArrayBuffer(val: ObjectValue): BabelNodeExpression {\n    let elems = [];\n\n    let len = val.$ArrayBufferByteLength;\n    let db = val.$ArrayBufferData;\n    invariant(len !== undefined);\n    invariant(db);\n    let allzero = true;\n    for (let i = 0; i < len; i++) {\n      if (db[i] !== 0) {\n        allzero = false;\n      }\n      let elem = t.numericLiteral(db[i]);\n      elems.push(elem);\n    }\n\n    this._emitObjectProperties(val);\n    if (allzero) {\n      // if they're all zero, just emit the array buffer constructor\n      return t.newExpression(this.preludeGenerator.memoizeReference(val.getKind()), [t.numericLiteral(len)]);\n    } else {\n      // initialize from a byte array otherwise\n      let arrayValue = t.arrayExpression(elems);\n      let consExpr = t.newExpression(this.preludeGenerator.memoizeReference(\"Uint8Array\"), [arrayValue]);\n      // access the Uint8Array.buffer property to extract the created buffer\n      return t.memberExpression(consExpr, t.identifier(\"buffer\"));\n    }\n  }\n\n  _serializeValueFunction(val: FunctionValue): void | BabelNodeExpression {\n    if (val instanceof BoundFunctionValue) {\n      this._emitObjectProperties(val);\n      return t.callExpression(\n        t.memberExpression(this.serializeValue(val.$BoundTargetFunction), t.identifier(\"bind\")),\n        [].concat(\n          this.serializeValue(val.$BoundThis),\n          val.$BoundArguments.map((boundArg, i) => this.serializeValue(boundArg))\n        )\n      );\n    }\n\n    invariant(!(val instanceof NativeFunctionValue), \"all native function values should be intrinsics\");\n    invariant(val instanceof ECMAScriptSourceFunctionValue);\n\n    let instance = this.residualFunctionInstances.get(val);\n    invariant(instance);\n    let residualBindings = instance.residualFunctionBindings;\n\n    let inAdditionalFunction = this.currentFunctionBody !== this.mainBody;\n    if (inAdditionalFunction) instance.containingAdditionalFunction = this.currentAdditionalFunction;\n    let delayed = 1;\n    let undelay = () => {\n      if (--delayed === 0) {\n        invariant(instance);\n        instance.insertionPoint = this.emitter.getBodyReference();\n      }\n    };\n    for (let [boundName, residualBinding] of residualBindings) {\n      let referencedValues = [];\n      let serializeBindingFunc;\n      if (!residualBinding.declarativeEnvironmentRecord) {\n        serializeBindingFunc = () => this._serializeGlobalBinding(boundName, residualBinding);\n      } else {\n        serializeBindingFunc = () => {\n          return this._serializeDeclarativeEnvironmentRecordBinding(residualBinding);\n        };\n        let bindingValue = residualBinding.value;\n        invariant(bindingValue !== undefined);\n        referencedValues.push(bindingValue);\n        if (inAdditionalFunction) {\n          let scopes = this.residualValues.get(bindingValue);\n          invariant(scopes);\n          let { usedOnlyByAdditionalFunctions } = this._getTarget(bindingValue, scopes);\n          if (usedOnlyByAdditionalFunctions)\n            residualBinding.referencedOnlyFromAdditionalFunctions = this.currentAdditionalFunction;\n        }\n      }\n      delayed++;\n      this.emitter.emitNowOrAfterWaitingForDependencies(referencedValues, () => {\n        serializeBindingFunc();\n        undelay();\n      });\n    }\n\n    undelay();\n\n    this._emitObjectProperties(val);\n  }\n\n  // Checks whether a property can be defined via simple assignment, or using object literal syntax.\n  _canEmbedProperty(obj: ObjectValue, key: string | SymbolValue, prop: Descriptor): boolean {\n    if (prop.joinCondition !== undefined) return false;\n    if ((obj instanceof FunctionValue && key === \"prototype\") || (obj.getKind() === \"RegExp\" && key === \"lastIndex\"))\n      return !!prop.writable && !prop.configurable && !prop.enumerable && !prop.set && !prop.get;\n    else return !!prop.writable && !!prop.configurable && !!prop.enumerable && !prop.set && !prop.get;\n  }\n\n  _findLastObjectPrototype(obj: ObjectValue): ObjectValue {\n    while (obj.$Prototype instanceof ObjectValue) obj = obj.$Prototype;\n    return obj;\n  }\n\n  _serializeValueRegExpObject(val: ObjectValue): BabelNodeExpression {\n    let source = val.$OriginalSource;\n    let flags = val.$OriginalFlags;\n    invariant(typeof source === \"string\");\n    invariant(typeof flags === \"string\");\n    this._emitObjectProperties(val);\n    source = new RegExp(source).source; // add escapes as per 21.2.3.2.4\n    return t.regExpLiteral(source, flags);\n  }\n\n  // Overridable.\n  serializeValueRawObject(val: ObjectValue): BabelNodeExpression {\n    let proto = val.$Prototype;\n    let createViaAuxiliaryConstructor =\n      proto !== this.realm.intrinsics.ObjectPrototype &&\n      this._findLastObjectPrototype(val) === this.realm.intrinsics.ObjectPrototype &&\n      proto instanceof ObjectValue;\n\n    let remainingProperties = new Map(val.properties);\n    const dummyProperties = new Set();\n    let props = [];\n    for (let [key, propertyBinding] of val.properties) {\n      let descriptor = propertyBinding.descriptor;\n      if (descriptor === undefined || descriptor.value === undefined) continue; // deleted\n      if (!createViaAuxiliaryConstructor && this._canEmbedProperty(val, key, descriptor)) {\n        let propValue = descriptor.value;\n        invariant(propValue instanceof Value);\n        if (this.residualHeapInspector.canIgnoreProperty(val, key)) continue;\n        let mightHaveBeenDeleted = propValue.mightHaveBeenDeleted();\n        let serializedKey = this.generator.getAsPropertyNameExpression(key);\n        let delayReason =\n          this.emitter.getReasonToWaitForDependencies(propValue) ||\n          this.emitter.getReasonToWaitForActiveValue(val, mightHaveBeenDeleted);\n        // Although the property needs to be delayed, we still want to emit dummy \"undefined\"\n        // value as part of the object literal to ensure a consistent property ordering.\n        let serializedValue = voidExpression;\n        if (delayReason) {\n          // May need to be cleaned up later.\n          dummyProperties.add(key);\n        } else {\n          remainingProperties.delete(key);\n          serializedValue = this.serializeValue(propValue);\n        }\n        props.push(t.objectProperty(serializedKey, serializedValue));\n      } else if (descriptor.value instanceof Value && descriptor.value.mightHaveBeenDeleted()) {\n        dummyProperties.add(key);\n        let serializedKey = this.generator.getAsPropertyNameExpression(key);\n        props.push(t.objectProperty(serializedKey, voidExpression));\n      }\n    }\n    this._emitObjectProperties(val, remainingProperties, createViaAuxiliaryConstructor, dummyProperties);\n\n    if (createViaAuxiliaryConstructor) {\n      this.needsAuxiliaryConstructor = true;\n      let serializedProto = this.serializeValue(proto);\n      return t.sequenceExpression([\n        t.assignmentExpression(\n          \"=\",\n          t.memberExpression(constructorExpression, t.identifier(\"prototype\")),\n          serializedProto\n        ),\n        t.newExpression(constructorExpression, []),\n      ]);\n    } else {\n      return t.objectExpression(props);\n    }\n  }\n\n  _serializeValueObject(val: ObjectValue): BabelNodeExpression {\n    // If this object is a prototype object that was implicitly created by the runtime\n    // for a constructor, then we can obtain a reference to this object\n    // in a special way that's handled alongside function serialization.\n    let constructor = val.originalConstructor;\n    if (constructor !== undefined) {\n      let prototypeId = this.residualHeapValueIdentifiers.getIdentifier(val);\n      this.emitter.emitNowOrAfterWaitingForDependencies([constructor], () => {\n        invariant(constructor !== undefined);\n        invariant(prototypeId !== undefined);\n        this.serializeValue(constructor);\n        this._emitObjectProperties(val);\n        invariant(prototypeId.type === \"Identifier\");\n        this.residualFunctions.setFunctionPrototype(constructor, prototypeId);\n      });\n      return prototypeId;\n    }\n\n    let kind = val.getKind();\n    switch (kind) {\n      case \"RegExp\":\n        return this._serializeValueRegExpObject(val);\n      case \"Number\":\n        let numberData = val.$NumberData;\n        invariant(numberData !== undefined);\n        numberData.throwIfNotConcreteNumber();\n        invariant(numberData instanceof NumberValue, \"expected number data internal slot to be a number value\");\n        this._emitObjectProperties(val);\n        return t.newExpression(this.preludeGenerator.memoizeReference(\"Number\"), [t.numericLiteral(numberData.value)]);\n      case \"String\":\n        let stringData = val.$StringData;\n        invariant(stringData !== undefined);\n        stringData.throwIfNotConcreteString();\n        invariant(stringData instanceof StringValue, \"expected string data internal slot to be a string value\");\n        this._emitObjectProperties(val);\n        return t.newExpression(this.preludeGenerator.memoizeReference(\"String\"), [t.stringLiteral(stringData.value)]);\n      case \"Boolean\":\n        let booleanData = val.$BooleanData;\n        invariant(booleanData !== undefined);\n        booleanData.throwIfNotConcreteBoolean();\n        invariant(booleanData instanceof BooleanValue, \"expected boolean data internal slot to be a boolean value\");\n        this._emitObjectProperties(val);\n        return t.newExpression(this.preludeGenerator.memoizeReference(\"Boolean\"), [\n          t.booleanLiteral(booleanData.value),\n        ]);\n      case \"Date\":\n        let dateValue = val.$DateValue;\n        invariant(dateValue !== undefined);\n        let serializedDateValue = this.serializeValue(dateValue);\n        this._emitObjectProperties(val);\n        return t.newExpression(this.preludeGenerator.memoizeReference(\"Date\"), [serializedDateValue]);\n      case \"Float32Array\":\n      case \"Float64Array\":\n      case \"Int8Array\":\n      case \"Int16Array\":\n      case \"Int32Array\":\n      case \"Uint8Array\":\n      case \"Uint16Array\":\n      case \"Uint32Array\":\n      case \"Uint8ClampedArray\":\n      case \"DataView\":\n        return this._serializeValueTypedArrayOrDataView(val);\n      case \"ArrayBuffer\":\n        return this._serializeValueArrayBuffer(val);\n      case \"ReactElement\":\n        return this._serializeValueReactElement(val);\n      case \"Map\":\n      case \"WeakMap\":\n        return this._serializeValueMap(val);\n      case \"Set\":\n      case \"WeakSet\":\n        return this._serializeValueSet(val);\n      default:\n        invariant(kind === \"Object\", \"invariant established by visitor\");\n        invariant(this.$ParameterMap === undefined, \"invariant established by visitor\");\n        return this.serializeValueRawObject(val);\n    }\n  }\n\n  _serializeValueSymbol(val: SymbolValue): BabelNodeExpression {\n    let args = [];\n    if (val.$Description instanceof Value) {\n      let serializedArg = this.serializeValue(val.$Description);\n      invariant(serializedArg);\n      args.push(serializedArg);\n    }\n    // check if symbol value exists in the global symbol map, in that case we emit an invocation of System.for\n    // to look it up\n    let globalReg = this.realm.globalSymbolRegistry.find(e => e.$Symbol === val) !== undefined;\n    if (globalReg) {\n      return t.callExpression(this.preludeGenerator.memoizeReference(\"Symbol.for\"), args);\n    } else {\n      return t.callExpression(this.preludeGenerator.memoizeReference(\"Symbol\"), args);\n    }\n  }\n\n  _serializeValueProxy(val: ProxyValue): BabelNodeExpression {\n    return t.newExpression(this.preludeGenerator.memoizeReference(\"Proxy\"), [\n      this.serializeValue(val.$ProxyTarget),\n      this.serializeValue(val.$ProxyHandler),\n    ]);\n  }\n\n  _serializeAbstractValueHelper(val: AbstractValue): BabelNodeExpression {\n    let serializedArgs = val.args.map((abstractArg, i) => this.serializeValue(abstractArg));\n    if (val.kind === \"abstractConcreteUnion\") {\n      let abstractIndex = val.args.findIndex(v => v instanceof AbstractValue);\n      invariant(abstractIndex >= 0 && abstractIndex < val.args.length);\n      return serializedArgs[abstractIndex];\n    }\n    let serializedValue = val.buildNode(serializedArgs);\n    if (serializedValue.type === \"Identifier\") {\n      let id = ((serializedValue: any): BabelNodeIdentifier);\n      invariant(!this.preludeGenerator.derivedIds.has(id.name) || this.emitter.hasBeenDeclared(val));\n    }\n    return serializedValue;\n  }\n\n  _serializeAbstractValue(val: AbstractValue): void | BabelNodeExpression {\n    invariant(val.kind !== \"sentinel member expression\", \"invariant established by visitor\");\n    if (val.hasIdentifier()) {\n      return this._serializeAbstractValueHelper(val);\n    } else {\n      // This abstract value's dependencies should all be declared\n      // but still need to check it again in case their serialized bodies are in different generator scope.\n      this.emitter.emitNowOrAfterWaitingForDependencies(val.args, () => {\n        const serializedValue = this._serializeAbstractValueHelper(val);\n        let uid = this.getSerializeObjectIdentifier(val);\n        let declar = t.variableDeclaration(\"var\", [t.variableDeclarator(uid, serializedValue)]);\n        this.emitter.emit(declar);\n      });\n    }\n  }\n\n  _serializeValue(val: Value): void | BabelNodeExpression {\n    if (val instanceof AbstractValue) {\n      return this._serializeAbstractValue(val);\n    } else if (val.isIntrinsic()) {\n      return this._serializeValueIntrinsic(val);\n    } else if (val instanceof EmptyValue) {\n      this.needsEmptyVar = true;\n      return emptyExpression;\n    } else if (val instanceof UndefinedValue) {\n      return voidExpression;\n    } else if (ResidualHeapInspector.isLeaf(val)) {\n      return t.valueToNode(val.serialize());\n    } else if (IsArray(this.realm, val)) {\n      invariant(val instanceof ObjectValue);\n      return this._serializeValueArray(val);\n    } else if (val instanceof ProxyValue) {\n      return this._serializeValueProxy(val);\n    } else if (val instanceof FunctionValue) {\n      return this._serializeValueFunction(val);\n    } else if (val instanceof SymbolValue) {\n      return this._serializeValueSymbol(val);\n    } else {\n      invariant(val instanceof ObjectValue);\n      return this._serializeValueObject(val);\n    }\n  }\n\n  _serializeGlobalBinding(boundName: string, residualFunctionBinding: ResidualFunctionBinding) {\n    invariant(!residualFunctionBinding.declarativeEnvironmentRecord);\n    if (!residualFunctionBinding.serializedValue) {\n      residualFunctionBinding.referentialized = true;\n      if (boundName === \"undefined\") {\n        residualFunctionBinding.serializedValue = voidExpression;\n      } else {\n        let value = this.realm.getGlobalLetBinding(boundName);\n        // Check for let binding vs global property\n        if (value) {\n          let rval = residualFunctionBinding.value;\n          invariant(rval !== undefined && value.equals(rval));\n          let id = this.serializeValue(rval, true, \"let\");\n          // increment ref count one more time as the value has been\n          // referentialized (stored in a variable) by serializeValue\n          this.residualHeapValueIdentifiers.incrementReferenceCount(rval);\n          residualFunctionBinding.serializedValue = id;\n        } else {\n          residualFunctionBinding.serializedValue = this.preludeGenerator.globalReference(boundName);\n        }\n      }\n    }\n  }\n\n  _withGeneratorScope(generator: Generator, callback: SerializedBody => void): Array<BabelNodeStatement> {\n    let newBody = { type: \"Generator\", entries: [] };\n    let oldBody = this.emitter.beginEmitting(generator, newBody);\n    this.activeGeneratorBodies.set(generator, newBody);\n    callback(newBody);\n    this.activeGeneratorBodies.delete(generator);\n    return this.emitter.endEmitting(generator, oldBody).entries;\n  }\n\n  _getContext(): SerializationContext {\n    // TODO #482: Values serialized by nested generators would currently only get defined\n    // along the code of the nested generator; their definitions need to get hoisted\n    // or repeated so that they are accessible and defined from all using scopes\n    let context = {\n      serializeValue: this.serializeValue.bind(this),\n      serializeGenerator: (generator: Generator): Array<BabelNodeStatement> => {\n        let statements = this._withGeneratorScope(generator, () => generator.serialize(context));\n        if (this._options.debugScopes) {\n          let comment = `generator ${this._getScopeName(generator)}`;\n          if (generator.parent !== undefined)\n            comment = `${comment} with parent ${this._getScopeName(generator.parent)}`;\n          statements.unshift(commentStatement(\"begin \" + comment));\n          statements.push(commentStatement(\"end \" + comment));\n        }\n        return statements;\n      },\n      emit: (statement: BabelNodeStatement) => {\n        this.emitter.emit(statement);\n      },\n      emitDefinePropertyBody: this.emitDefinePropertyBody.bind(this, false, undefined),\n      canOmit: (value: AbstractValue) => {\n        return !this.referencedDeclaredValues.has(value);\n      },\n      declare: (value: AbstractValue) => {\n        this.emitter.declare(value);\n      },\n    };\n    return context;\n  }\n\n  _serializeAdditionalFunction(generator: Generator, postGeneratorCallback: () => void) {\n    let context = this._getContext();\n    return this._withGeneratorScope(generator, newBody => {\n      let oldCurBody = this.currentFunctionBody;\n      this.currentFunctionBody = newBody;\n      generator.serialize(context);\n      if (postGeneratorCallback) postGeneratorCallback();\n      this.currentFunctionBody = oldCurBody;\n    });\n  }\n\n  _shouldBeWrapped(body: Array<any>) {\n    for (let i = 0; i < body.length; i++) {\n      let item = body[i];\n      if (item.type === \"ExpressionStatement\") {\n        continue;\n      } else if (item.type === \"VariableDeclaration\" || item.type === \"FunctionDeclaration\") {\n        return true;\n      } else if (item.type === \"BlockStatement\") {\n        if (this._shouldBeWrapped(item.body)) {\n          return true;\n        }\n      } else if (item.type === \"IfStatement\") {\n        if (item.alternate) {\n          if (this._shouldBeWrapped(item.alternate.body)) {\n            return true;\n          }\n        }\n        if (item.consequent) {\n          if (this._shouldBeWrapped(item.consequent.body)) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  processAdditionalFunctionValues(): Map<FunctionValue, Array<BabelNodeStatement>> {\n    let rewrittenAdditionalFunctions: Map<FunctionValue, Array<BabelNodeStatement>> = new Map();\n    let shouldEmitLog = !this.residualHeapValueIdentifiers.collectValToRefCountOnly;\n    let processAdditionalFunctionValuesFn = () => {\n      let additionalFVEffects = this.additionalFunctionValuesAndEffects;\n      if (additionalFVEffects) {\n        for (let [additionalFunctionValue, effects] of additionalFVEffects.entries()) {\n          let [\n            result,\n            generator,\n            modifiedBindings,\n            modifiedProperties: Map<PropertyBinding, void | Descriptor>,\n            createdObjects,\n          ] = effects;\n          let nestedFunctions = new Set([...createdObjects].filter(object => object instanceof FunctionValue));\n          // result -- ignore TODO: return the result from the function somehow\n          // Generator -- visit all entries\n          // Bindings -- only need to serialize bindings if they're captured by some nested function ??\n          //          -- need to apply them and maybe need to revisit functions in ancestors to make sure\n          //          -- we don't overwrite anything they capture\n          //          -- TODO: deal with these properly\n          // PropertyBindings -- visit any property bindings that aren't to createdobjects\n          // CreatedObjects -- should take care of itself\n          this.realm.applyEffects([\n            result,\n            new Generator(this.realm),\n            modifiedBindings,\n            modifiedProperties,\n            createdObjects,\n          ]);\n          // Allows us to emit function declarations etc. inside of this additional\n          // function instead of adding them at global scope\n          // TODO: make sure this generator isn't getting mutated oddly\n          ((nestedFunctions: any): Set<FunctionValue>).forEach(val =>\n            this.additionalFunctionValueNestedFunctions.add(val)\n          );\n          let serializePropertiesAndBindings = () => {\n            for (let propertyBinding of modifiedProperties.keys()) {\n              let binding: PropertyBinding = ((propertyBinding: any): PropertyBinding);\n              let object = binding.object;\n              if (object instanceof ObjectValue && createdObjects.has(object)) continue;\n              if (object.refuseSerialization) continue;\n              if (object.isIntrinsic()) continue;\n              invariant(object instanceof ObjectValue);\n              this._emitProperty(object, binding.key, binding.descriptor, true);\n            }\n            invariant(result instanceof Value);\n            // Handle ModifiedBindings\n            let additionalFunctionValueInfo = this.additionalFunctionValueInfos.get(additionalFunctionValue);\n            invariant(additionalFunctionValueInfo);\n            for (let [modifiedBinding, residualBinding] of additionalFunctionValueInfo.modifiedBindings) {\n              let newVal = modifiedBinding.value;\n              invariant(newVal);\n              residualBinding.additionalValueSerialized = this.serializeValue(newVal);\n            }\n            this.emitter.emit(t.returnStatement(this.serializeValue(result)));\n          };\n          this.currentAdditionalFunction = additionalFunctionValue;\n          let body = this._serializeAdditionalFunction(generator, serializePropertiesAndBindings);\n          invariant(additionalFunctionValue instanceof ECMAScriptSourceFunctionValue);\n          rewrittenAdditionalFunctions.set(additionalFunctionValue, body);\n          // re-resolve initialized modules to include things from additional functions\n          this.modules.resolveInitializedModules();\n          if (shouldEmitLog && this.modules.moduleIds.size > 0)\n            console.log(\n              `=== ${this.modules.initializedModules.size} of ${this.modules.moduleIds\n                .size} modules initialized after additional function ${additionalFunctionValue.intrinsicName\n                ? additionalFunctionValue.intrinsicName\n                : \"\"}`\n            );\n          // These don't restore themselves properly otherwise.\n          this.realm.restoreBindings(modifiedBindings);\n          this.realm.restoreProperties(modifiedProperties);\n        }\n      }\n      return this.realm.intrinsics.undefined;\n    };\n    this.realm.evaluateAndRevertInGlobalEnv(processAdditionalFunctionValuesFn);\n    return rewrittenAdditionalFunctions;\n  }\n\n  // Hook point for any serialization needs to be done after generator serialization is complete.\n  postGeneratorSerialization(): void {\n    // For overriding only.\n  }\n\n  serialize(): BabelNodeFile {\n    this.generator.serialize(this._getContext());\n    invariant(this.emitter._declaredAbstractValues.size <= this.preludeGenerator.derivedIds.size);\n\n    this.postGeneratorSerialization();\n    Array.prototype.push.apply(this.prelude, this.preludeGenerator.prelude);\n\n    // TODO #20: add timers\n\n    // TODO #21: add event listeners\n\n    for (let [moduleId, moduleValue] of this.modules.initializedModules)\n      this.requireReturns.set(moduleId, this.serializeValue(moduleValue));\n\n    // Make sure additional functions get serialized.\n    let rewrittenAdditionalFunctions = this.processAdditionalFunctionValues();\n\n    this.modules.resolveInitializedModules();\n\n    this.emitter.finalize();\n\n    this.residualFunctions.residualFunctionInitializers.factorifyInitializers(this.factoryNameGenerator);\n    let { unstrictFunctionBodies, strictFunctionBodies, requireStatistics } = this.residualFunctions.spliceFunctions(\n      rewrittenAdditionalFunctions\n    );\n    if (this.modules.moduleIds.size > 0 && !this.residualHeapValueIdentifiers.collectValToRefCountOnly) {\n      console.log(\n        `=== ${this.modules.initializedModules.size} of ${this.modules.moduleIds\n          .size} modules initialized, ${requireStatistics.replaced} of ${requireStatistics.count} require calls inlined.`\n      );\n    }\n\n    // add strict modes\n    let strictDirective = t.directive(t.directiveLiteral(\"use strict\"));\n    let globalDirectives = [];\n    if (!this.realm.isStrict && !unstrictFunctionBodies.length && strictFunctionBodies.length) {\n      // no unstrict functions, only strict ones\n      globalDirectives.push(strictDirective);\n    } else if (unstrictFunctionBodies.length && strictFunctionBodies.length) {\n      // strict and unstrict functions\n      funcLoop: for (let func of strictFunctionBodies) {\n        if (func.body.directives) {\n          for (let directive of func.body.directives) {\n            if (directive.value.value === \"use strict\") {\n              // already have a use strict directive\n              continue funcLoop;\n            }\n          }\n        } else func.body.directives = [];\n\n        func.body.directives.unshift(strictDirective);\n      }\n    }\n\n    // build ast\n    if (this.needsEmptyVar) {\n      this.prelude.push(t.variableDeclaration(\"var\", [t.variableDeclarator(emptyExpression, t.objectExpression([]))]));\n    }\n    if (this.needsAuxiliaryConstructor) {\n      this.prelude.push(\n        t.variableDeclaration(\"var\", [\n          t.variableDeclarator(constructorExpression, t.functionExpression(null, [], t.blockStatement([]))),\n        ])\n      );\n    }\n\n    let body = this.prelude.concat(this.emitter.getBody().entries);\n    factorifyObjects(body, this.factoryNameGenerator);\n\n    let ast_body = [];\n    if (this.preludeGenerator.declaredGlobals.size > 0)\n      ast_body.push(\n        t.variableDeclaration(\n          \"var\",\n          Array.from(this.preludeGenerator.declaredGlobals).map(key => t.variableDeclarator(t.identifier(key)))\n        )\n      );\n    if (body.length) {\n      if (this.realm.isCompatibleWith(\"node-source-maps\")) {\n        ast_body.push(\n          t.expressionStatement(\n            t.callExpression(\n              t.memberExpression(\n                t.callExpression(t.identifier(\"require\"), [t.stringLiteral(\"source-map-support\")]),\n                t.identifier(\"install\")\n              ),\n              []\n            )\n          )\n        );\n      }\n\n      if (this._shouldBeWrapped(body)) {\n        let globalExpression = this.realm.isCompatibleWith(\"node-cli\") ? t.identifier(\"global\") : t.thisExpression();\n\n        let functionExpression = t.functionExpression(null, [], t.blockStatement(body, globalDirectives));\n        let callExpression = this.preludeGenerator.usesThis\n          ? t.callExpression(t.memberExpression(functionExpression, t.identifier(\"call\")), [globalExpression])\n          : t.callExpression(functionExpression, []);\n        ast_body.push(t.expressionStatement(callExpression));\n      } else {\n        ast_body = body;\n      }\n    }\n\n    // Make sure that the visitor visited as many values as the serializer\n    invariant(\n      this.serializedValues.size === this.residualValues.size,\n      \"serialized \" + this.serializedValues.size + \" of \" + this.residualValues.size\n    );\n\n    // TODO: find better way to do this?\n    // revert changes to functionInstances in case we do multiple serialization passes\n    for (let instance of this.residualFunctionInstances.values()) {\n      for (let binding of ((instance: any): FunctionInstance).residualFunctionBindings.values()) {\n        let b = ((binding: any): ResidualFunctionBinding);\n        delete b.serializedValue;\n        delete b.referentialized;\n      }\n    }\n\n    let program_directives = [];\n    if (this.realm.isStrict) program_directives.push(strictDirective);\n    return t.file(t.program(ast_body, program_directives));\n  }\n}\n"]}