{"version":3,"sources":["../../src/serializer/LoggingTracer.js"],"names":["describeValue","realm","v","value","toString","LoggingTracer","nesting","message","console","log","map","join","state","push","effects","name","pop","F","thisArgument","argumentsList","newTarget","result"],"mappings":";;;;;;;;;AAWA;;AACA;;AAEA;;AACA;;AACA;;AAWA;;;;;;;;;;+eA3BA;;;;;;;;;AA6BA,SAASA,aAAT,CAAuBC,KAAvB,EAAqCC,CAArC,EAAuD;AACrD,MAAIA,oCAA4BA,iCAAhC,EAA2D,OAAOA,EAAEC,KAAF,CAAQC,QAAR,EAAP;AAC3D,MAAIF,mCAAJ,EAAiC,OAAO,WAAP;AACjC,MAAIA,8BAAJ,EAA4B,OAAO,MAAP;AAC5B,MAAIA,gCAAJ,EAA8B,cAAWA,EAAEC,KAAb,QAJuB,CAIA;AACrD,MAAID,kCAAJ,EAAgC,OAAO,4BAAgBD,KAAhB,EAAuB,gBAAIA,KAAJ,EAAWC,CAAX,EAAc,MAAd,CAAvB,KAAiD,sBAAxD;AAChC,MAAIA,gCAAJ,EAA8B,OAAO,eAAP;AAC9B,MAAIA,kCAAJ,EAAgC,OAAO,uBAAP;AAChC,2BAAU,KAAV;AACD;;IAEYG,a,WAAAA,a;;;AACX,yBAAYJ,KAAZ,EAA0B;AAAA;;AAAA;;AAExB,UAAKA,KAAL,GAAaA,KAAb;AACA,UAAKK,OAAL,GAAe,EAAf;AAHwB;AAIzB;;;;wBAKGC,O,EAAiB;AACnBC,cAAQC,GAAR,cAAuB,KAAKH,OAAL,CAAaI,GAAb,CAAiB;AAAA,eAAK,IAAL;AAAA,OAAjB,EAA4BC,IAA5B,CAAiC,EAAjC,CAAvB,GAA8DJ,OAA9D;AACD;;;4CAEuBK,K,EAAY;AAClC,WAAKH,GAAL;AACA,WAAKH,OAAL,CAAaO,IAAb,CAAkB,wBAAlB;AACD;;;0CAEqBD,K,EAAYE,O,EAAyB;AACzD,UAAIC,OAAO,KAAKT,OAAL,CAAaU,GAAb,EAAX;AACA,+BAAUD,SAAS,wBAAnB;AACA,WAAKN,GAAL;AACD;;;+BAEUQ,C,EAAkBC,Y,EAA4BC,a,EAA6BC,S,EAA+B;AACnH,UAAInB,QAAQ,KAAKA,KAAjB;AACA,UAAIc,OAAOf,cAAcC,KAAd,EAAqBgB,CAArB,CAAX;AACA,WAAKR,GAAL,OAAaM,IAAb,SAAqBI,cAAcT,GAAd,CAAkB;AAAA,eAAKV,cAAcC,KAAd,EAAqBC,CAArB,CAAL;AAAA,OAAlB,EAAgDS,IAAhD,CAAqD,IAArD,CAArB;AACA,WAAKL,OAAL,CAAaO,IAAb,CAAkBE,IAAlB;AACD;;;8BAGCE,C,EACAC,Y,EACAC,a,EACAC,S,EACAC,M,EACA;AACA,UAAIN,OAAO,KAAKT,OAAL,CAAaU,GAAb,EAAX;AACA,WAAKP,GAAL,OAAaM,IAAb,IAAoBM,iDAAoC,SAApC,GAAgD,EAApE;AACD","file":"LoggingTracer.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { Reference } from \"../environment.js\";\nimport { Realm, Tracer } from \"../realm.js\";\nimport type { Effects } from \"../realm.js\";\nimport { ToStringPartial, Get } from \"../methods/index.js\";\nimport { ThrowCompletion, AbruptCompletion } from \"../completions.js\";\nimport {\n  FunctionValue,\n  Value,\n  NumberValue,\n  BooleanValue,\n  StringValue,\n  UndefinedValue,\n  NullValue,\n  ObjectValue,\n  AbstractValue,\n} from \"../values/index.js\";\nimport invariant from \"../invariant.js\";\n\nfunction describeValue(realm: Realm, v: Value): string {\n  if (v instanceof NumberValue || v instanceof BooleanValue) return v.value.toString();\n  if (v instanceof UndefinedValue) return \"undefined\";\n  if (v instanceof NullValue) return \"null\";\n  if (v instanceof StringValue) return `\"${v.value}\"`; // TODO: proper escaping\n  if (v instanceof FunctionValue) return ToStringPartial(realm, Get(realm, v, \"name\")) || \"(anonymous function)\";\n  if (v instanceof ObjectValue) return \"(some object)\";\n  if (v instanceof AbstractValue) return \"(some abstract value)\";\n  invariant(false);\n}\n\nexport class LoggingTracer extends Tracer {\n  constructor(realm: Realm) {\n    super();\n    this.realm = realm;\n    this.nesting = [];\n  }\n\n  realm: Realm;\n  nesting: Array<string>;\n\n  log(message: string) {\n    console.log(`[calls] ${this.nesting.map(_ => \"  \").join(\"\")}${message}`);\n  }\n\n  beginEvaluateForEffects(state: any) {\n    this.log(`>evaluate for effects`);\n    this.nesting.push(\"(evaluate for effects)\");\n  }\n\n  endEvaluateForEffects(state: any, effects: void | Effects) {\n    let name = this.nesting.pop();\n    invariant(name === \"(evaluate for effects)\");\n    this.log(`<evaluate for effects`);\n  }\n\n  beforeCall(F: FunctionValue, thisArgument: void | Value, argumentsList: Array<Value>, newTarget: void | ObjectValue) {\n    let realm = this.realm;\n    let name = describeValue(realm, F);\n    this.log(`>${name}(${argumentsList.map(v => describeValue(realm, v)).join(\", \")})`);\n    this.nesting.push(name);\n  }\n\n  afterCall(\n    F: FunctionValue,\n    thisArgument: void | Value,\n    argumentsList: Array<Value>,\n    newTarget: void | ObjectValue,\n    result: void | Reference | Value | AbruptCompletion\n  ) {\n    let name = this.nesting.pop();\n    this.log(`<${name}${result instanceof ThrowCompletion ? \": error\" : \"\"}`);\n  }\n}\n"]}