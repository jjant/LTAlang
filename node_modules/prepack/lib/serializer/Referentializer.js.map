{"version":3,"sources":["../../src/serializer/Referentializer.js"],"names":["t","Referentializer","scopeNameGenerator","statistics","referentializationState","Map","capturedScopeInstanceIdx","capturedScopesArray","identifier","generate","capturedScopeAccessFunctionId","serializedScopes","referentializationScope","_createReferentializationState","bind","body","selectorParam","captured","_getReferentializationState","selectorExpression","memberExpression","cases","values","scopeBinding","scopeObjectExpression","arrayExpression","initializationValues","push","switchCase","numericLiteral","id","expressionStatement","assignmentExpression","breakStatement","throwStatement","newExpression","stringLiteral","variableDeclaration","variableDeclarator","ifStatement","unaryExpression","blockStatement","switchStatement","returnStatement","factoryFunction","functionExpression","accessFunctionId","residualBinding","declarativeEnvironmentRecord","referencedOnlyFromAdditionalFunctions","scope","get","refState","name","containingAdditionalFunction","set","capturedScope","funcName","callExpression","unbound","instances","shouldReferentializeInstanceFn","instance","residualBindings","residualFunctionBindings","undefined","modified","referentialized","_getSerializedBindingScopeInstance","variableIndexInScope","length","serializedValue","scopeInstances","add"],"mappings":"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","file":"Referentializer.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { DeclarativeEnvironmentRecord } from \"../environment.js\";\nimport { FatalError } from \"../errors.js\";\nimport { FunctionValue } from \"../values/index.js\";\nimport * as t from \"babel-types\";\nimport type { BabelNodeStatement, BabelNodeIdentifier } from \"babel-types\";\nimport { NameGenerator } from \"../utils/generator.js\";\nimport invariant from \"../invariant.js\";\nimport type { ResidualFunctionBinding, ScopeBinding, FunctionInstance } from \"./types.js\";\nimport { SerializerStatistics } from \"./types.js\";\nimport { getOrDefault } from \"./utils.js\";\n\n// Each of these will correspond to a different preludeGenerator and thus will\n// have different values available for initialization. FunctionValues should\n// only be additional functions.\nexport type ReferentializationScope = FunctionValue | \"GLOBAL\";\n\ntype ReferentializationState = {|\n  capturedScopeInstanceIdx: number,\n  capturedScopesArray: BabelNodeIdentifier,\n  capturedScopeAccessFunctionId: BabelNodeIdentifier,\n  serializedScopes: Map<DeclarativeEnvironmentRecord, ScopeBinding>,\n|};\n\n/*\n * This class helps fixup names in residual functions for variables that these\n * functions capture from parent scopes.\n * For each ReferentializationScope it creates a _get_scope_binding function\n * that contains the initialization for all of that scope's FunctionInstances\n * which will contain a switch statement with all the initializations.\n */\nexport class Referentializer {\n  constructor(scopeNameGenerator: NameGenerator, statistics: SerializerStatistics) {\n    this.scopeNameGenerator = scopeNameGenerator;\n    this.statistics = statistics;\n\n    this.referentializationState = new Map();\n  }\n\n  scopeNameGenerator: NameGenerator;\n  statistics: SerializerStatistics;\n\n  _newCapturedScopeInstanceIdx: number;\n  referentializationState: Map<ReferentializationScope, ReferentializationState>;\n\n  _createReferentializationState(): ReferentializationState {\n    return {\n      capturedScopeInstanceIdx: 0,\n      capturedScopesArray: t.identifier(this.scopeNameGenerator.generate(\"main\")),\n      capturedScopeAccessFunctionId: t.identifier(this.scopeNameGenerator.generate(\"get_scope_binding\")),\n      serializedScopes: new Map(),\n    };\n  }\n\n  _getReferentializationState(referentializationScope: ReferentializationScope): ReferentializationState {\n    return getOrDefault(\n      this.referentializationState,\n      referentializationScope,\n      this._createReferentializationState.bind(this)\n    );\n  }\n\n  // Generate a shared function for accessing captured scope bindings.\n  // TODO: skip generating this function if the captured scope is not shared by multiple residual funcitons.\n  createCaptureScopeAccessFunction(referentializationScope: ReferentializationScope): BabelNodeStatement {\n    const body = [];\n    const selectorParam = t.identifier(\"selector\");\n    const captured = t.identifier(\"__captured\");\n    const capturedScopesArray = this._getReferentializationState(referentializationScope).capturedScopesArray;\n    const selectorExpression = t.memberExpression(capturedScopesArray, selectorParam, /*Indexer syntax*/ true);\n\n    // One switch case for one scope.\n    const cases = [];\n    const serializedScopes = this._getReferentializationState(referentializationScope).serializedScopes;\n    for (const scopeBinding of serializedScopes.values()) {\n      const scopeObjectExpression = t.arrayExpression((scopeBinding.initializationValues: any));\n      cases.push(\n        t.switchCase(t.numericLiteral(scopeBinding.id), [\n          t.expressionStatement(t.assignmentExpression(\"=\", selectorExpression, scopeObjectExpression)),\n          t.breakStatement(),\n        ])\n      );\n    }\n    // Default case.\n    cases.push(\n      t.switchCase(null, [\n        t.throwStatement(t.newExpression(t.identifier(\"Error\"), [t.stringLiteral(\"Unknown scope selector\")])),\n      ])\n    );\n\n    body.push(t.variableDeclaration(\"var\", [t.variableDeclarator(captured, selectorExpression)]));\n    body.push(\n      t.ifStatement(\n        t.unaryExpression(\"!\", captured),\n        t.blockStatement([\n          t.switchStatement(selectorParam, cases),\n          t.expressionStatement(t.assignmentExpression(\"=\", captured, selectorExpression)),\n        ])\n      )\n    );\n    body.push(t.returnStatement(captured));\n    const factoryFunction = t.functionExpression(null, [selectorParam], t.blockStatement(body));\n    const accessFunctionId = this._getReferentializationState(referentializationScope).capturedScopeAccessFunctionId;\n    return t.variableDeclaration(\"var\", [t.variableDeclarator(accessFunctionId, factoryFunction)]);\n  }\n\n  _getSerializedBindingScopeInstance(residualBinding: ResidualFunctionBinding): ScopeBinding {\n    let declarativeEnvironmentRecord = residualBinding.declarativeEnvironmentRecord;\n    let referentializationScope = residualBinding.referencedOnlyFromAdditionalFunctions || \"GLOBAL\";\n    invariant(declarativeEnvironmentRecord);\n\n    // figure out if this is accessed only from additional functions\n    let serializedScopes = this._getReferentializationState(referentializationScope).serializedScopes;\n    let scope = serializedScopes.get(declarativeEnvironmentRecord);\n    if (!scope) {\n      let refState: ReferentializationState = this._getReferentializationState(referentializationScope);\n      scope = {\n        name: this.scopeNameGenerator.generate(),\n        id: refState.capturedScopeInstanceIdx++,\n        initializationValues: [],\n        containingAdditionalFunction: residualBinding.referencedOnlyFromAdditionalFunctions,\n      };\n      serializedScopes.set(declarativeEnvironmentRecord, scope);\n    }\n\n    residualBinding.scope = scope;\n    return scope;\n  }\n\n  getReferentializedScopeInitialization(scope: ScopeBinding) {\n    let capturedScope = scope.capturedScope;\n    invariant(capturedScope);\n    const funcName = this._getReferentializationState(scope.containingAdditionalFunction || \"GLOBAL\")\n      .capturedScopeAccessFunctionId;\n    return [\n      t.variableDeclaration(\"var\", [\n        t.variableDeclarator(t.identifier(capturedScope), t.callExpression(funcName, [t.identifier(scope.name)])),\n      ]),\n    ];\n  }\n\n  referentialize(\n    unbound: Set<string>,\n    instances: Array<FunctionInstance>,\n    shouldReferentializeInstanceFn: FunctionInstance => boolean\n  ): void {\n    for (let instance of instances) {\n      let residualBindings = instance.residualFunctionBindings;\n\n      for (let name of unbound) {\n        let residualBinding = residualBindings.get(name);\n        invariant(residualBinding !== undefined);\n        if (residualBinding.modified) {\n          // Initialize captured scope at function call instead of globally\n          if (!residualBinding.referentialized) {\n            if (!shouldReferentializeInstanceFn(instance)) {\n              // TODO #989: Fix additional functions and referentialization\n              throw new FatalError(\"TODO: implement referentialization for prepacked functions\");\n            }\n            let scope = this._getSerializedBindingScopeInstance(residualBinding);\n            let capturedScope = \"__captured\" + scope.name;\n            // Save the serialized value for initialization at the top of\n            // the factory.\n            // This can serialize more variables than are necessary to execute\n            // the function because every function serializes every\n            // modified variable of its parent scope. In some cases it could be\n            // an improvement to split these variables into multiple\n            // scopes.\n            const variableIndexInScope = scope.initializationValues.length;\n            invariant(residualBinding.serializedValue);\n            scope.initializationValues.push(residualBinding.serializedValue);\n            scope.capturedScope = capturedScope;\n\n            // Replace binding usage with scope references\n            residualBinding.serializedValue = t.memberExpression(\n              t.identifier(capturedScope),\n              t.numericLiteral(variableIndexInScope),\n              true // Array style access.\n            );\n\n            residualBinding.referentialized = true;\n            this.statistics.referentialized++;\n          }\n\n          // Already referentialized in prior scope\n          if (residualBinding.declarativeEnvironmentRecord) {\n            invariant(residualBinding.scope);\n            instance.scopeInstances.add(residualBinding.scope);\n          }\n        }\n      }\n    }\n  }\n\n  createCapturedScopesArrayInitialization(referentializationScope: ReferentializationScope): BabelNodeStatement {\n    return t.variableDeclaration(\"var\", [\n      t.variableDeclarator(\n        this._getReferentializationState(referentializationScope).capturedScopesArray,\n        t.callExpression(t.identifier(\"Array\"), [\n          t.numericLiteral(this._getReferentializationState(referentializationScope).capturedScopeInstanceIdx),\n        ])\n      ),\n    ]);\n  }\n}\n"]}