{"version":3,"sources":["../../src/serializer/modules.js"],"names":["t","downgradeErrorsToWarnings","realm","f","savedHandler","errorHandler","handler","e","severity","handleError","ModuleTracer","modules","statistics","logModules","evaluateForEffectsNesting","requireStack","requireSequence","uninitializedModuleIdsRequiredInEvaluateForEffects","Set","message","console","log","map","join","state","push","undefined","effects","popped","pop","F","thisArgument","argumentsList","newTarget","performCall","getRequire","disallowDelayingRequiresOverride","length","moduleId","moduleIdValue","value","moduleIds","has","delayUnsupportedRequires","logger","logError","recordModuleInitialized","completion","incorporateSavedCompletion","stopEffectCapture","warning","location","isTopLevelRequire","diagnostic","currentLocation","isModuleInitialized","add","result","requireSequenceStart","acceleratedModuleIds","previousNumDelayedModules","delayedModules","evaluateForEffects","err","nestedModuleId","nestedEffects","tryInitializeModule","clear","acceleratedModules","nestedModulesIds","i","createTemporalFromBuildFunction","callExpression","identifier","valueToNode","applyEffects","getDefine","factoryFunction","factoryFunctions","Modules","_require","intrinsics","_define","initializedModules","Map","tracers","moduleTracer","globalInitializedModulesMap","_getGlobalProperty","properties","keys","property","get","moduleValue","descriptor","set","name","active","tryQuery","$GlobalObject","formalParameters","functions","scope","node","isIdentifier","callee","arguments","argument","isNumericLiteral","isStringLiteral","innerName","scopedBinding","getBinding","path","kind","doesNotMatter","reference","ResolveBinding","$Environment","IsUnresolvableReference","referencedBase","base","referencedName","binding","bindings","initialized","assignToGlobal","memberExpression","previousDisallowDelayingRequiresOverride","evaluateNodeForEffectsInGlobalEnv","count","oldReadOnly","setReadOnly","oldDisallowDelayingRequiresOverride","compl","generator","createdObjects","empty","escapes","object"],"mappings":"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","file":"modules.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { GlobalEnvironmentRecord, DeclarativeEnvironmentRecord } from \"../environment.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { Realm, Tracer } from \"../realm.js\";\nimport type { Effects } from \"../realm.js\";\nimport { Get } from \"../methods/index.js\";\nimport { AbruptCompletion, Completion, PossiblyNormalCompletion, ThrowCompletion } from \"../completions.js\";\nimport { Environment, Functions } from \"../singletons.js\";\nimport { AbstractValue, Value, FunctionValue, ObjectValue, NumberValue, StringValue } from \"../values/index.js\";\nimport * as t from \"babel-types\";\nimport type { BabelNodeIdentifier, BabelNodeLVal, BabelNodeCallExpression } from \"babel-types\";\nimport invariant from \"../invariant.js\";\nimport { Logger } from \"./logger.js\";\nimport { SerializerStatistics } from \"./types.js\";\n\nfunction downgradeErrorsToWarnings(realm: Realm, f: () => any) {\n  let savedHandler = realm.errorHandler;\n  function handler(e) {\n    e.severity = \"Warning\";\n    realm.errorHandler = savedHandler;\n    try {\n      return realm.handleError(e);\n    } finally {\n      realm.errorHandler = handler;\n    }\n  }\n  realm.errorHandler = handler;\n  try {\n    return f();\n  } finally {\n    realm.errorHandler = savedHandler;\n  }\n}\n\nexport class ModuleTracer extends Tracer {\n  constructor(modules: Modules, statistics: SerializerStatistics, logModules: boolean) {\n    super();\n    this.modules = modules;\n    this.evaluateForEffectsNesting = 0;\n    this.requireStack = [];\n    this.requireSequence = [];\n    this.logModules = logModules;\n    this.uninitializedModuleIdsRequiredInEvaluateForEffects = new Set();\n    this.statistics = statistics;\n  }\n\n  modules: Modules;\n  evaluateForEffectsNesting: number;\n  requireStack: Array<number | string | void>;\n  requireSequence: Array<number | string>;\n  uninitializedModuleIdsRequiredInEvaluateForEffects: Set<number | string>;\n  // We can't say that a module has been initialized if it was initialized in a\n  // evaluate for effects context until we know the effects are applied.\n  logModules: boolean;\n  statistics: SerializerStatistics;\n\n  log(message: string) {\n    if (this.logModules) console.log(`[modules] ${this.requireStack.map(_ => \"  \").join(\"\")}${message}`);\n  }\n\n  beginEvaluateForEffects(state: any) {\n    if (state !== this) {\n      this.log(\">evaluate for effects\");\n      this.evaluateForEffectsNesting++;\n      this.requireStack.push(undefined);\n    }\n  }\n\n  endEvaluateForEffects(state: any, effects: void | Effects) {\n    if (state !== this) {\n      let popped = this.requireStack.pop();\n      invariant(popped === undefined);\n      this.evaluateForEffectsNesting--;\n      this.log(\"<evaluate for effects\");\n    }\n  }\n\n  detourCall(\n    F: FunctionValue,\n    thisArgument: void | Value,\n    argumentsList: Array<Value>,\n    newTarget: void | ObjectValue,\n    performCall: () => Value\n  ): void | Value {\n    let realm = this.modules.realm;\n    if (\n      F === this.modules.getRequire() &&\n      !this.modules.disallowDelayingRequiresOverride &&\n      argumentsList.length === 1\n    ) {\n      let moduleId = argumentsList[0];\n      let moduleIdValue;\n      if (moduleId instanceof NumberValue || moduleId instanceof StringValue) {\n        moduleIdValue = moduleId.value;\n        if (!this.modules.moduleIds.has(moduleIdValue) && this.modules.delayUnsupportedRequires) {\n          this.modules.logger.logError(moduleId, \"Module referenced by require call has not been defined.\");\n        }\n      } else {\n        if (this.modules.delayUnsupportedRequires) {\n          this.modules.logger.logError(moduleId, \"First argument to require function is not a number or string value.\");\n        }\n        return undefined;\n      }\n\n      if (!this.modules.delayUnsupportedRequires) {\n        if (\n          (this.requireStack.length === 0 || this.requireStack[this.requireStack.length - 1] !== moduleIdValue) &&\n          this.modules.moduleIds.has(moduleIdValue)\n        ) {\n          this.requireStack.push(moduleIdValue);\n          try {\n            let value = performCall();\n            this.modules.recordModuleInitialized(moduleIdValue, value);\n            // Make this into a join point by suppressing the conditional exception.\n            // TODO: delete this code and let the caller deal with the conditional exception.\n            let completion = Functions.incorporateSavedCompletion(realm, value);\n            if (completion instanceof PossiblyNormalCompletion) {\n              realm.stopEffectCapture(completion);\n              let warning = new CompilerDiagnostic(\n                \"Module import may fail with an exception\",\n                completion.location,\n                \"PP0018\",\n                \"Warning\"\n              );\n              realm.handleError(warning);\n            }\n            return value;\n          } finally {\n            invariant(this.requireStack.pop() === moduleIdValue);\n          }\n        }\n        return undefined;\n      }\n\n      // If a require fails, recover from it and delay the factory call until runtime\n      this.log(`>require(${moduleIdValue})`);\n      let isTopLevelRequire = this.requireStack.length === 0;\n      if (this.evaluateForEffectsNesting > 0) {\n        if (isTopLevelRequire) {\n          let diagnostic = new CompilerDiagnostic(\n            \"Non-deterministically conditional top-level require not currently supported\",\n            realm.currentLocation,\n            \"PP0017\",\n            \"FatalError\"\n          );\n          realm.handleError(diagnostic);\n          throw new FatalError();\n        } else if (!this.modules.isModuleInitialized(moduleIdValue))\n          this.uninitializedModuleIdsRequiredInEvaluateForEffects.add(moduleIdValue);\n        return undefined;\n      } else {\n        return downgradeErrorsToWarnings(realm, () => {\n          let result;\n          try {\n            this.requireStack.push(moduleIdValue);\n            let requireSequenceStart = this.requireSequence.length;\n            this.requireSequence.push(moduleIdValue);\n            let acceleratedModuleIds, effects;\n            const previousNumDelayedModules = this.statistics.delayedModules;\n            do {\n              try {\n                effects = realm.evaluateForEffects(() => {\n                  try {\n                    return performCall();\n                  } catch (e) {\n                    if (e instanceof Completion) return e;\n                    throw e;\n                  }\n                }, this);\n              } catch (err) {\n                if (err instanceof FatalError) effects = undefined;\n                else throw err;\n              }\n\n              acceleratedModuleIds = [];\n              if (isTopLevelRequire) {\n                // We gathered all effects, but didn't apply them yet.\n                // Let's check if there was any call to `require` in a\n                // evaluate-for-effects context. If so, try to initialize\n                // that module right now. Acceleration module initialization in this\n                // way might not actually be desirable, but it works around\n                // general prepack-limitations around joined abstract values involving\n                // conditionals. Long term, Prepack needs to implement a notion of refinement\n                // of conditional abstract values under the known path condition.\n                for (let nestedModuleId of this.uninitializedModuleIdsRequiredInEvaluateForEffects) {\n                  let nestedEffects = this.modules.tryInitializeModule(\n                    nestedModuleId,\n                    `accelerated initialization of conditional module ${nestedModuleId} as it's required in an evaluate-for-effects context by module ${moduleIdValue}`\n                  );\n                  if (\n                    nestedEffects !== undefined &&\n                    nestedEffects[0] instanceof Value &&\n                    this.modules.isModuleInitialized(nestedModuleId)\n                  ) {\n                    acceleratedModuleIds.push(nestedModuleId);\n                  }\n                }\n                this.uninitializedModuleIdsRequiredInEvaluateForEffects.clear();\n                // Keep restarting for as long as we find additional modules to accelerate.\n                if (acceleratedModuleIds.length > 0) {\n                  console.log(\n                    `restarting require(${moduleIdValue}) after accelerating conditional require calls for ${acceleratedModuleIds.join()}`\n                  );\n                  this.statistics.acceleratedModules += acceleratedModuleIds.length;\n                }\n              }\n            } while (acceleratedModuleIds.length > 0);\n\n            if (effects === undefined) {\n              console.log(`delaying require(${moduleIdValue})`);\n              this.statistics.delayedModules = previousNumDelayedModules + 1;\n              // So we are about to emit a delayed require(...) call.\n              // However, before we do that, let's try to require all modules that we\n              // know this delayed require call will require.\n              // This way, we ensure that those modules will be fully initialized\n              // before the require call executes.\n              // TODO #690: More needs to be done to make the delayUnsupportedRequires\n              // feature completely safe. Open issues are:\n              // 1) Side-effects on the heap of delayed factory functions are not discovered or rejected.\n              // 2) While we do process an appropriate list of transitively required modules here,\n              //    it's likely just a subset / prefix of all transivitely required modules, as\n              //    more modules would have been required if the Introspection exception had not been thrown.\n              //    To be correct, those modules would have to be prepacked here as well.\n              //    TODO #798: Watch out for an upcoming change to the __d module declaration where the statically known\n              //    list of dependencies will be announced, so we'll no longer have to guess.\n              let nestedModulesIds = new Set();\n              for (let i = requireSequenceStart; i < this.requireSequence.length; i++) {\n                let nestedModuleId = this.requireSequence[i];\n                if (nestedModulesIds.has(nestedModuleId)) continue;\n                nestedModulesIds.add(nestedModuleId);\n                this.modules.tryInitializeModule(\n                  nestedModuleId,\n                  `initialization of module ${nestedModuleId} as it's required by module ${moduleIdValue}`\n                );\n              }\n\n              result = AbstractValue.createTemporalFromBuildFunction(realm, Value, [], ([]) =>\n                t.callExpression(t.identifier(\"require\"), [t.valueToNode(moduleIdValue)])\n              );\n            } else {\n              result = effects[0];\n              if (result instanceof Value) {\n                realm.applyEffects(effects, `initialization of module ${moduleIdValue}`);\n                this.modules.recordModuleInitialized(moduleIdValue, result);\n              } else if (result instanceof PossiblyNormalCompletion) {\n                let warning = new CompilerDiagnostic(\n                  \"Module import may fail with an exception\",\n                  result.location,\n                  \"PP0018\",\n                  \"Warning\"\n                );\n                realm.handleError(warning);\n                result = result.value;\n                realm.applyEffects(effects, `initialization of module ${moduleIdValue}`);\n                this.modules.recordModuleInitialized(moduleIdValue, result);\n              }\n            }\n          } finally {\n            let popped = this.requireStack.pop();\n            invariant(popped === moduleIdValue);\n            let message = \"\";\n            if (result instanceof ThrowCompletion) message = \" threw an error\";\n            this.log(`<require(${moduleIdValue})${message}`);\n          }\n          if (result instanceof Completion) throw result;\n          return result;\n        });\n      }\n    } else if (F === this.modules.getDefine()) {\n      if (this.evaluateForEffectsNesting !== 0)\n        this.modules.logger.logError(F, \"Defining a module in nested partial evaluation is not supported.\");\n      let factoryFunction = argumentsList[0];\n      if (factoryFunction instanceof FunctionValue) this.modules.factoryFunctions.add(factoryFunction);\n      else this.modules.logger.logError(factoryFunction, \"First argument to define function is not a function value.\");\n      let moduleId = argumentsList[1];\n      if (moduleId instanceof NumberValue || moduleId instanceof StringValue)\n        this.modules.moduleIds.add(moduleId.value);\n      else\n        this.modules.logger.logError(moduleId, \"Second argument to define function is not a number or string value.\");\n    }\n    return undefined;\n  }\n}\n\nexport class Modules {\n  constructor(\n    realm: Realm,\n    logger: Logger,\n    statistics: SerializerStatistics,\n    logModules: boolean,\n    delayUnsupportedRequires: boolean\n  ) {\n    this.realm = realm;\n    this.logger = logger;\n    this._require = realm.intrinsics.undefined;\n    this._define = realm.intrinsics.undefined;\n    this.factoryFunctions = new Set();\n    this.moduleIds = new Set();\n    this.initializedModules = new Map();\n    realm.tracers.push((this.moduleTracer = new ModuleTracer(this, statistics, logModules)));\n    this.delayUnsupportedRequires = delayUnsupportedRequires;\n    this.disallowDelayingRequiresOverride = false;\n  }\n\n  realm: Realm;\n  logger: Logger;\n  _require: Value;\n  _define: Value;\n  factoryFunctions: Set<FunctionValue>;\n  moduleIds: Set<number | string>;\n  initializedModules: Map<number | string, Value>;\n  active: boolean;\n  delayUnsupportedRequires: boolean;\n  disallowDelayingRequiresOverride: boolean;\n  moduleTracer: ModuleTracer;\n\n  resolveInitializedModules(): void {\n    this.initializedModules.clear();\n    let globalInitializedModulesMap = this._getGlobalProperty(\"__initializedModules\");\n    invariant(globalInitializedModulesMap instanceof ObjectValue);\n    for (let moduleId of globalInitializedModulesMap.properties.keys()) {\n      let property = globalInitializedModulesMap.properties.get(moduleId);\n      invariant(property);\n      let moduleValue = property.descriptor && property.descriptor.value;\n      if (moduleValue instanceof Value) this.initializedModules.set(moduleId, moduleValue);\n    }\n  }\n\n  _getGlobalProperty(name: string): Value {\n    if (this.active) return this.realm.intrinsics.undefined;\n    this.active = true;\n    try {\n      let realm = this.realm;\n      return this.logger.tryQuery(() => Get(realm, realm.$GlobalObject, name), realm.intrinsics.undefined, false);\n    } finally {\n      this.active = false;\n    }\n  }\n\n  getRequire(): Value {\n    if (!(this._require instanceof FunctionValue)) this._require = this._getGlobalProperty(\"require\");\n    return this._require;\n  }\n\n  getDefine(): Value {\n    if (!(this._define instanceof FunctionValue)) this._define = this._getGlobalProperty(\"__d\");\n    return this._define;\n  }\n\n  getIsRequire(\n    formalParameters: Array<BabelNodeLVal>,\n    functions: Array<FunctionValue>\n  ): (scope: any, node: BabelNodeCallExpression) => boolean {\n    let realm = this.realm;\n    let logger = this.logger;\n    let modules = this;\n    return function(scope: any, node: BabelNodeCallExpression) {\n      if (!t.isIdentifier(node.callee) || node.arguments.length !== 1 || !node.arguments[0]) return false;\n      let argument = node.arguments[0];\n      if (!t.isNumericLiteral(argument) && !t.isStringLiteral(argument)) return false;\n\n      invariant(node.callee);\n      let innerName = ((node.callee: any): BabelNodeIdentifier).name;\n\n      for (let f of functions) {\n        let scopedBinding = scope.getBinding(innerName);\n        if (scopedBinding) {\n          if (modules.factoryFunctions.has(f) && formalParameters[1] === scopedBinding.path.node) {\n            invariant(scopedBinding.kind === \"param\");\n            continue;\n          }\n          // The name binds to some local entity, but nothing we'd know what exactly it is\n          return false;\n        }\n\n        let doesNotMatter = true;\n        let reference = logger.tryQuery(\n          () => Environment.ResolveBinding(realm, innerName, doesNotMatter, f.$Environment),\n          undefined,\n          false\n        );\n        if (reference === undefined) {\n          // We couldn't resolve as we came across some behavior that we cannot deal with abstractly\n          return false;\n        }\n        if (Environment.IsUnresolvableReference(realm, reference)) return false;\n        let referencedBase = reference.base;\n        let referencedName: string = (reference.referencedName: any);\n        if (typeof referencedName !== \"string\") return false;\n        let value;\n        if (reference.base instanceof GlobalEnvironmentRecord) {\n          value = logger.tryQuery(() => Get(realm, realm.$GlobalObject, innerName), realm.intrinsics.undefined, false);\n        } else {\n          invariant(referencedBase instanceof DeclarativeEnvironmentRecord);\n          let binding = referencedBase.bindings[referencedName];\n          if (!binding.initialized) return false;\n          value = binding.value;\n        }\n        if (value !== modules.getRequire()) return false;\n      }\n\n      return true;\n    };\n  }\n\n  recordModuleInitialized(moduleId: number | string, value: Value) {\n    this.realm.assignToGlobal(\n      t.memberExpression(\n        t.memberExpression(t.identifier(\"global\"), t.identifier(\"__initializedModules\")),\n        t.identifier(\"\" + moduleId)\n      ),\n      value\n    );\n  }\n\n  tryInitializeModule(moduleId: number | string, message: string): void | Effects {\n    let realm = this.realm;\n    let previousDisallowDelayingRequiresOverride = this.disallowDelayingRequiresOverride;\n    this.disallowDelayingRequiresOverride = true;\n    return downgradeErrorsToWarnings(realm, () => {\n      try {\n        let node = t.callExpression(t.identifier(\"require\"), [t.valueToNode(moduleId)]);\n\n        let effects = realm.evaluateNodeForEffectsInGlobalEnv(node);\n        realm.applyEffects(effects, message);\n        return effects;\n      } catch (err) {\n        if (err instanceof FatalError) return undefined;\n        else throw err;\n      } finally {\n        this.disallowDelayingRequiresOverride = previousDisallowDelayingRequiresOverride;\n      }\n    });\n  }\n\n  initializeMoreModules() {\n    // partially evaluate all factory methods by calling require\n    let count = 0;\n    for (let moduleId of this.moduleIds) {\n      if (this.initializedModules.has(moduleId)) continue;\n      let effects = this.tryInitializeModule(moduleId, `Speculative initialization of module ${moduleId}`);\n      if (effects === undefined) continue;\n      let result = effects[0];\n      if (!(result instanceof Value)) continue; // module might throw\n      count++;\n      this.initializedModules.set(moduleId, result);\n    }\n    if (count > 0) console.log(`=== speculatively initialized ${count} additional modules`);\n  }\n\n  isModuleInitialized(moduleId: number | string): void | Value {\n    let realm = this.realm;\n    let oldReadOnly = realm.setReadOnly(true);\n    let oldDisallowDelayingRequiresOverride = this.disallowDelayingRequiresOverride;\n    this.disallowDelayingRequiresOverride = true;\n    try {\n      let node = t.callExpression(t.identifier(\"require\"), [t.valueToNode(moduleId)]);\n\n      let [compl, generator, bindings, properties, createdObjects] = realm.evaluateNodeForEffectsInGlobalEnv(node);\n      // for lint unused\n      invariant(bindings);\n\n      if (compl instanceof AbruptCompletion) return undefined;\n      invariant(compl instanceof Value);\n\n      if (!generator.empty() || (compl instanceof ObjectValue && createdObjects.has(compl))) return undefined;\n      // Check for escaping property assignments, if none escape, we got an existing object\n      let escapes = false;\n      for (let [binding] of properties) {\n        let object = binding.object;\n        invariant(object instanceof ObjectValue);\n        if (!createdObjects.has(object)) escapes = true;\n      }\n      if (escapes) return undefined;\n\n      return compl;\n    } catch (err) {\n      if (err instanceof FatalError) return undefined;\n      throw err;\n    } finally {\n      realm.setReadOnly(oldReadOnly);\n      this.disallowDelayingRequiresOverride = oldDisallowDelayingRequiresOverride;\n    }\n  }\n}\n"]}