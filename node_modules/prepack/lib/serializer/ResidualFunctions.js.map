{"version":3,"sources":["../../src/serializer/ResidualFunctions.js"],"names":["t","ResidualFunctions","realm","statistics","modules","requireReturns","locationService","prelude","initializerNameGenerator","factoryNameGenerator","scopeNameGenerator","residualFunctionInfos","residualFunctionInstances","additionalFunctionValueInfos","additionalFunctionValueNestedFunctions","functionPrototypes","Map","firstFunctionUsages","functions","functionInstances","residualFunctionInitializers","referentializer","values","instance","undefined","has","functionValue","addFunctionInstance","push","code","$ECMAScriptCode","constructor","prototypeId","set","val","bodyReference","funcBody","instances","shouldInlineFunction","shouldInline","start","end","bodySize","functionInfo","get","usesArguments","length","rewrittenAdditionalFunctions","find","factoryFunctionInfos","functionBody","factoryId","suffix","__originalName","_shouldUseFactoryFunction","_hasRewrittenFunctionInstance","identifier","generate","getLocation","functionUniqueTag","uniqueTag","scrubFunctionInitializers","functionBodies","additionalFunctionPreludes","getFunctionBody","b","globalPrelude","getPrelude","additionalFunction","containingAdditionalFunction","requireStatistics","replaced","count","functionEntries","Array","from","entries","unstrictFunctionBodies","strictFunctionBodies","funcNodes","referentialize","unbound","defineFunction","funcId","funcNode","body","isFunctionExpression","isCallExpression","variableDeclaration","variableDeclarator","id","memberExpression","funcValue","funcInfo","modifiedBindings","residualBinding","scope","referentialized","decl","name","numericLiteral","init","getReferentializedScopeInitialization","prototype","apply","newValue","additionalValueSerialized","binding_reference","serializedValue","isLVal","expressionStatement","assignmentExpression","additionalFunctionInfo","params","$FormalParameters","rewrittenBody","blockStatement","funcParams","slice","functionExpression","$Strict","_generateFactoryFunctionInfos","modified","usesThis","normalInstances","additionalFunctionNestedInstances","naiveProcessInstances","functionClones","instancesToSplice","residualFunctionBindings","scopeInstances","cloneDeep","scopeInitialization","concat","file","program","isRequire","getIsRequire","factoryInfo","factoryNames","sameResidualBindings","isDifferent","lastBinding","firstBinding","factoryParams","key","factoryNode","factoryDeclaration","map","insertionPoint","functionId","flatArgs","firstUsage","hasInitializerStatement","isNotEarlierThan","callArgs","thisExpression","flatArg","param","type","callee","childBody","returnStatement","callExpression","referentializationState","keys","referentializationScope","unshift","createCaptureScopeAccessFunction","createCapturedScopesArrayInitialization","additionalBody","reverse","splice","index","initializerStatement","getInitializerStatement"],"mappings":"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","file":"ResidualFunctions.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { FatalError } from \"../errors.js\";\nimport { Realm } from \"../realm.js\";\nimport { FunctionValue, type ECMAScriptSourceFunctionValue } from \"../values/index.js\";\nimport * as t from \"babel-types\";\nimport type {\n  BabelNodeExpression,\n  BabelNodeStatement,\n  BabelNodeIdentifier,\n  BabelNodeBlockStatement,\n  BabelNodeLVal,\n  BabelNodeSpreadElement,\n  BabelNodeFunctionExpression,\n} from \"babel-types\";\nimport type { FunctionBodyAstNode } from \"../types.js\";\nimport type { NameGenerator } from \"../utils/generator.js\";\nimport traverse from \"babel-traverse\";\nimport invariant from \"../invariant.js\";\nimport type { FunctionInfo, FactoryFunctionInfo, FunctionInstance, AdditionalFunctionInfo } from \"./types.js\";\nimport { BodyReference, AreSameResidualBinding, SerializerStatistics } from \"./types.js\";\nimport { ClosureRefReplacer } from \"./visitors.js\";\nimport { Modules } from \"./modules.js\";\nimport { ResidualFunctionInitializers } from \"./ResidualFunctionInitializers.js\";\nimport { nullExpression } from \"../utils/internalizer.js\";\nimport type { LocationService } from \"./types.js\";\nimport { Referentializer } from \"./Referentializer.js\";\nimport { getOrDefault } from \"./utils.js\";\n\ntype ResidualFunctionsResult = {\n  unstrictFunctionBodies: Array<BabelNodeFunctionExpression>,\n  strictFunctionBodies: Array<BabelNodeFunctionExpression>,\n  requireStatistics: { replaced: number, count: number },\n};\n\nexport class ResidualFunctions {\n  constructor(\n    realm: Realm,\n    statistics: SerializerStatistics,\n    modules: Modules,\n    requireReturns: Map<number | string, BabelNodeExpression>,\n    locationService: LocationService,\n    prelude: Array<BabelNodeStatement>,\n    initializerNameGenerator: NameGenerator,\n    factoryNameGenerator: NameGenerator,\n    scopeNameGenerator: NameGenerator,\n    residualFunctionInfos: Map<BabelNodeBlockStatement, FunctionInfo>,\n    residualFunctionInstances: Map<FunctionValue, FunctionInstance>,\n    additionalFunctionValueInfos: Map<FunctionValue, AdditionalFunctionInfo>,\n    additionalFunctionValueNestedFunctions: Set<FunctionValue>\n  ) {\n    this.realm = realm;\n    this.statistics = statistics;\n    this.modules = modules;\n    this.requireReturns = requireReturns;\n    this.locationService = locationService;\n    this.prelude = prelude;\n    this.factoryNameGenerator = factoryNameGenerator;\n    this.functionPrototypes = new Map();\n    this.firstFunctionUsages = new Map();\n    this.functions = new Map();\n    this.functionInstances = [];\n    this.residualFunctionInitializers = new ResidualFunctionInitializers(\n      locationService,\n      prelude,\n      initializerNameGenerator\n    );\n    this.residualFunctionInfos = residualFunctionInfos;\n    this.residualFunctionInstances = residualFunctionInstances;\n    this.additionalFunctionValueInfos = additionalFunctionValueInfos;\n    this.referentializer = new Referentializer(scopeNameGenerator, statistics);\n    for (let instance of residualFunctionInstances.values()) {\n      invariant(instance !== undefined);\n      if (!additionalFunctionValueInfos.has(instance.functionValue)) this.addFunctionInstance(instance);\n    }\n    this.additionalFunctionValueNestedFunctions = additionalFunctionValueNestedFunctions;\n  }\n\n  realm: Realm;\n  modules: Modules;\n  statistics: SerializerStatistics;\n  requireReturns: Map<number | string, BabelNodeExpression>;\n  locationService: LocationService;\n  prelude: Array<BabelNodeStatement>;\n  factoryNameGenerator: NameGenerator;\n  functionPrototypes: Map<FunctionValue, BabelNodeIdentifier>;\n  firstFunctionUsages: Map<FunctionValue, BodyReference>;\n  functions: Map<BabelNodeBlockStatement, Array<FunctionInstance>>;\n  functionInstances: Array<FunctionInstance>;\n  residualFunctionInitializers: ResidualFunctionInitializers;\n  residualFunctionInfos: Map<BabelNodeBlockStatement, FunctionInfo>;\n  residualFunctionInstances: Map<FunctionValue, FunctionInstance>;\n  additionalFunctionValueInfos: Map<FunctionValue, AdditionalFunctionInfo>;\n  additionalFunctionValueNestedFunctions: Set<FunctionValue>;\n  referentializer: Referentializer;\n\n  addFunctionInstance(instance: FunctionInstance) {\n    this.functionInstances.push(instance);\n    let code = instance.functionValue.$ECMAScriptCode;\n    invariant(code != null);\n    getOrDefault(this.functions, code, () => []).push(instance);\n  }\n\n  setFunctionPrototype(constructor: FunctionValue, prototypeId: BabelNodeIdentifier) {\n    this.functionPrototypes.set(constructor, prototypeId);\n  }\n\n  addFunctionUsage(val: FunctionValue, bodyReference: BodyReference) {\n    if (!this.firstFunctionUsages.has(val)) this.firstFunctionUsages.set(val, bodyReference);\n  }\n\n  _shouldUseFactoryFunction(funcBody: BabelNodeBlockStatement, instances: Array<FunctionInstance>) {\n    function shouldInlineFunction(): boolean {\n      let shouldInline = true;\n      if (funcBody.start && funcBody.end) {\n        let bodySize = funcBody.end - funcBody.start;\n        shouldInline = bodySize <= 30;\n      }\n      return shouldInline;\n    }\n    let functionInfo = this.residualFunctionInfos.get(funcBody);\n    invariant(functionInfo);\n    let { usesArguments } = functionInfo;\n    return !shouldInlineFunction() && instances.length > 1 && !usesArguments;\n  }\n\n  // Note: this function takes linear time. Please do not call it inside loop.\n  _hasRewrittenFunctionInstance(\n    rewrittenAdditionalFunctions: Map<FunctionValue, Array<BabelNodeStatement>>,\n    instances: Array<FunctionInstance>\n  ): boolean {\n    return instances.find(instance => rewrittenAdditionalFunctions.has(instance.functionValue)) !== undefined;\n  }\n\n  _generateFactoryFunctionInfos(\n    rewrittenAdditionalFunctions: Map<FunctionValue, Array<BabelNodeStatement>>\n  ): Map<number, FactoryFunctionInfo> {\n    const factoryFunctionInfos = new Map();\n    for (const [functionBody, instances] of this.functions) {\n      invariant(instances.length > 0);\n\n      let factoryId;\n      const suffix = instances[0].functionValue.__originalName || \"\";\n      if (this._shouldUseFactoryFunction(functionBody, instances)) {\n        // Rewritten function should never use factory function.\n        invariant(!this._hasRewrittenFunctionInstance(rewrittenAdditionalFunctions, instances));\n        factoryId = t.identifier(this.factoryNameGenerator.generate(suffix));\n      } else {\n        // For inline function body case, use the first function as the factory function.\n        factoryId = this.locationService.getLocation(instances[0].functionValue);\n      }\n\n      const functionUniqueTag = ((functionBody: any): FunctionBodyAstNode).uniqueTag;\n      invariant(functionUniqueTag);\n\n      const functionInfo = this.residualFunctionInfos.get(functionBody);\n      invariant(functionInfo);\n      factoryFunctionInfos.set(functionUniqueTag, { factoryId, functionInfo });\n    }\n    return factoryFunctionInfos;\n  }\n\n  spliceFunctions(\n    rewrittenAdditionalFunctions: Map<FunctionValue, Array<BabelNodeStatement>>\n  ): ResidualFunctionsResult {\n    this.residualFunctionInitializers.scrubFunctionInitializers();\n\n    let functionBodies = new Map();\n    // these need to get spliced in at the end\n    let additionalFunctionPreludes = new Map();\n    function getFunctionBody(instance: FunctionInstance): Array<BabelNodeStatement> {\n      let b = functionBodies.get(instance);\n      if (b === undefined) functionBodies.set(instance, (b = []));\n      return b;\n    }\n    let globalPrelude = this.prelude;\n    function getPrelude(instance: FunctionInstance): Array<BabelNodeStatement> {\n      let additionalFunction = instance.containingAdditionalFunction;\n      let b;\n      if (additionalFunction) {\n        b = additionalFunctionPreludes.get(additionalFunction);\n        if (b === undefined) additionalFunctionPreludes.set(additionalFunction, (b = []));\n      } else {\n        b = globalPrelude;\n      }\n      return b;\n    }\n\n    let requireStatistics = { replaced: 0, count: 0 };\n\n    let functionEntries: Array<[BabelNodeBlockStatement, Array<FunctionInstance>]> = Array.from(\n      this.functions.entries()\n    );\n    this.statistics.functions = functionEntries.length;\n    let unstrictFunctionBodies = [];\n    let strictFunctionBodies = [];\n    let funcNodes: Map<FunctionValue, BabelNodeFunctionExpression> = new Map();\n\n    for (let [funcBody, instances] of functionEntries) {\n      let functionInfo = this.residualFunctionInfos.get(funcBody);\n      invariant(functionInfo);\n      this.referentializer.referentialize(\n        functionInfo.unbound,\n        instances,\n        instance => !rewrittenAdditionalFunctions.has(instance.functionValue)\n      );\n    }\n\n    let defineFunction = (instance, funcId, funcNode) => {\n      let { functionValue } = instance;\n      let body;\n      if (t.isFunctionExpression(funcNode)) {\n        funcNodes.set(functionValue, ((funcNode: any): BabelNodeFunctionExpression));\n        body = getPrelude(instance);\n      } else {\n        invariant(t.isCallExpression(funcNode)); // .bind call\n        body = getFunctionBody(instance);\n      }\n      body.push(t.variableDeclaration(\"var\", [t.variableDeclarator(funcId, funcNode)]));\n      let prototypeId = this.functionPrototypes.get(functionValue);\n      if (prototypeId !== undefined) {\n        let id = this.locationService.getLocation(functionValue);\n        invariant(id !== undefined);\n        body.push(\n          t.variableDeclaration(\"var\", [\n            t.variableDeclarator(prototypeId, t.memberExpression(id, t.identifier(\"prototype\"))),\n          ])\n        );\n      }\n    };\n\n    // Emit code for ModifiedBindings for additional functions\n    for (let [funcValue, funcInfo] of this.additionalFunctionValueInfos) {\n      for (let [, residualBinding] of funcInfo.modifiedBindings) {\n        let scope = residualBinding.scope;\n\n        // TODO #989: This should probably be an invariant once captures work properly\n        // Currently we don't referentialize bindings in additional functions (but we\n        // do for bindings nested in additional functions)\n        if (!residualBinding.referentialized) continue;\n\n        // Find the proper prelude to emit to (global vs additional function's prelude)\n        let prelude = additionalFunctionPreludes.get(funcValue);\n        if (prelude === undefined) additionalFunctionPreludes.set(funcValue, (prelude = []));\n\n        // binding has been referentialized, so setup the scope to be able to\n        // access bindings from other __captured_scopes initializers\n        if (scope && scope.containingAdditionalFunction !== funcValue) {\n          let decl = t.variableDeclaration(\"var\", [\n            t.variableDeclarator(t.identifier(scope.name), t.numericLiteral(scope.id)),\n          ]);\n          let init = this.referentializer.getReferentializedScopeInitialization(scope);\n          prelude.push(decl);\n          // flow forces me to do this\n          Array.prototype.push.apply(prelude, init);\n        }\n\n        let newValue = residualBinding.additionalValueSerialized;\n        invariant(newValue);\n        let binding_reference = ((residualBinding.serializedValue: any): BabelNodeLVal);\n        invariant(binding_reference);\n        invariant(t.isLVal(binding_reference), \"Referentialized values are always LVals\");\n        // This mutation is safe because it should always be either a global identifier (for global bindings)\n        // or an accessor to a referentialized value.\n        prelude.push(t.expressionStatement(t.assignmentExpression(\"=\", binding_reference, newValue)));\n      }\n    }\n\n    // Process Additional Functions\n    for (let [funcValue, additionalFunctionInfo] of this.additionalFunctionValueInfos.entries()) {\n      let { instance } = additionalFunctionInfo;\n      let functionValue = ((funcValue: any): ECMAScriptSourceFunctionValue);\n      let params = functionValue.$FormalParameters;\n      invariant(params !== undefined);\n\n      let rewrittenBody = rewrittenAdditionalFunctions.get(funcValue);\n      invariant(rewrittenBody);\n\n      // rewritten functions shouldn't have references fixed up because the body,\n      // consists of serialized code. For simplicity we emit their instances in a naive way\n      let functionBody = t.blockStatement(rewrittenBody);\n\n      let id = this.locationService.getLocation(funcValue);\n      invariant(id !== undefined);\n      let funcParams = params.slice();\n      let funcNode = t.functionExpression(null, funcParams, functionBody);\n\n      if (funcValue.$Strict) {\n        strictFunctionBodies.push(funcNode);\n      } else {\n        unstrictFunctionBodies.push(funcNode);\n      }\n\n      defineFunction(instance, id, funcNode);\n    }\n\n    // Process normal functions\n    const factoryFunctionInfos = this._generateFactoryFunctionInfos(rewrittenAdditionalFunctions);\n    for (let [funcBody, instances] of functionEntries) {\n      let functionInfo = this.residualFunctionInfos.get(funcBody);\n      invariant(functionInfo);\n      let { unbound, modified, usesThis } = functionInfo;\n      let params = instances[0].functionValue.$FormalParameters;\n      invariant(params !== undefined);\n\n      // Split instances into normal or nested in an additional function\n      let normalInstances = [];\n      let additionalFunctionNestedInstances = [];\n      for (let instance of instances) {\n        if (this.additionalFunctionValueNestedFunctions.has(instance.functionValue))\n          additionalFunctionNestedInstances.push(instance);\n        else normalInstances.push(instance);\n      }\n\n      let naiveProcessInstances = instancesToSplice => {\n        this.statistics.functionClones += instancesToSplice.length - 1;\n\n        for (let instance of instancesToSplice) {\n          let { functionValue, residualFunctionBindings, scopeInstances } = instance;\n          let id = this.locationService.getLocation(functionValue);\n          invariant(id !== undefined);\n          let funcParams = params.slice();\n          let funcNode = t.functionExpression(\n            null,\n            funcParams,\n            ((t.cloneDeep(funcBody): any): BabelNodeBlockStatement)\n          );\n          let scopeInitialization = [];\n          for (let scope of scopeInstances) {\n            scopeInitialization.push(\n              t.variableDeclaration(\"var\", [t.variableDeclarator(t.identifier(scope.name), t.numericLiteral(scope.id))])\n            );\n            scopeInitialization = scopeInitialization.concat(\n              this.referentializer.getReferentializedScopeInitialization(scope)\n            );\n          }\n          funcNode.body.body = scopeInitialization.concat(funcNode.body.body);\n\n          traverse(t.file(t.program([t.expressionStatement(funcNode)])), ClosureRefReplacer, null, {\n            residualFunctionBindings,\n            modified,\n            requireReturns: this.requireReturns,\n            requireStatistics,\n            isRequire: this.modules.getIsRequire(funcParams, [functionValue]),\n            factoryFunctionInfos,\n          });\n\n          if (functionValue.$Strict) {\n            strictFunctionBodies.push(funcNode);\n          } else {\n            unstrictFunctionBodies.push(funcNode);\n          }\n\n          defineFunction(instance, id, funcNode);\n        }\n      };\n\n      if (additionalFunctionNestedInstances.length > 0) naiveProcessInstances(additionalFunctionNestedInstances);\n      if (!this._shouldUseFactoryFunction(funcBody, normalInstances)) {\n        naiveProcessInstances(normalInstances);\n      } else if (normalInstances.length > 0) {\n        const functionUniqueTag = ((funcBody: any): FunctionBodyAstNode).uniqueTag;\n        invariant(functionUniqueTag);\n        const factoryInfo = factoryFunctionInfos.get(functionUniqueTag);\n        invariant(factoryInfo);\n        const { factoryId } = factoryInfo;\n\n        // filter included variables to only include those that are different\n        let factoryNames: Array<string> = [];\n        let sameResidualBindings = new Map();\n        for (let name of unbound) {\n          let isDifferent = false;\n          let lastBinding;\n\n          let firstBinding = normalInstances[0].residualFunctionBindings.get(name);\n          invariant(firstBinding);\n          if (firstBinding.modified) {\n            // Must modify for traversal\n            sameResidualBindings.set(name, firstBinding);\n            continue;\n          }\n\n          for (let { residualFunctionBindings } of normalInstances) {\n            let residualBinding = residualFunctionBindings.get(name);\n\n            invariant(residualBinding);\n            invariant(!residualBinding.modified);\n            if (!lastBinding) {\n              lastBinding = residualBinding;\n            } else if (!AreSameResidualBinding(this.realm, residualBinding, lastBinding)) {\n              isDifferent = true;\n              break;\n            }\n          }\n\n          if (isDifferent) {\n            factoryNames.push(name);\n          } else {\n            invariant(lastBinding);\n            sameResidualBindings.set(name, lastBinding);\n          }\n        }\n\n        let factoryParams: Array<BabelNodeLVal> = [];\n        for (let key of factoryNames) {\n          factoryParams.push(t.identifier(key));\n        }\n\n        let scopeInitialization = [];\n        for (let scope of normalInstances[0].scopeInstances) {\n          factoryParams.push(t.identifier(scope.name));\n          scopeInitialization = scopeInitialization.concat(\n            this.referentializer.getReferentializedScopeInitialization(scope)\n          );\n        }\n\n        factoryParams = factoryParams.concat(params).slice();\n\n        // The Replacer below mutates the AST while the original AST may still be referenced\n        // by another outer residual function so let's clone the original AST to avoid modifying it.\n        let factoryNode = t.functionExpression(\n          null,\n          factoryParams,\n          ((t.cloneDeep(funcBody): any): BabelNodeBlockStatement)\n        );\n\n        if (normalInstances[0].functionValue.$Strict) {\n          strictFunctionBodies.push(factoryNode);\n        } else {\n          unstrictFunctionBodies.push(factoryNode);\n        }\n\n        factoryNode.body.body = scopeInitialization.concat(factoryNode.body.body);\n\n        // factory functions do not depend on any nested generator scope, so they go to the prelude\n        let factoryDeclaration = t.variableDeclaration(\"var\", [t.variableDeclarator(factoryId, factoryNode)]);\n        this.prelude.push(factoryDeclaration);\n\n        traverse(t.file(t.program([t.expressionStatement(factoryNode)])), ClosureRefReplacer, null, {\n          residualFunctionBindings: sameResidualBindings,\n          modified,\n          requireReturns: this.requireReturns,\n          requireStatistics,\n          isRequire: this.modules.getIsRequire(factoryParams, normalInstances.map(instance => instance.functionValue)),\n          factoryFunctionInfos,\n        });\n\n        for (let instance of normalInstances) {\n          let { functionValue, residualFunctionBindings, insertionPoint } = instance;\n          let functionId = this.locationService.getLocation(functionValue);\n          invariant(functionId !== undefined);\n          let flatArgs: Array<BabelNodeExpression> = factoryNames.map(name => {\n            let residualBinding = residualFunctionBindings.get(name);\n            invariant(residualBinding);\n            let serializedValue = residualBinding.serializedValue;\n            invariant(serializedValue);\n            return serializedValue;\n          });\n          for (let { id } of instance.scopeInstances) {\n            flatArgs.push(t.numericLiteral(id));\n          }\n          let funcNode;\n          let firstUsage = this.firstFunctionUsages.get(functionValue);\n          invariant(insertionPoint !== undefined);\n          if (\n            // The same free variables in shared instances may refer to objects with different initialization values\n            // so a stub forward function is needed during delay initializations.\n            this.residualFunctionInitializers.hasInitializerStatement(functionValue) ||\n            usesThis ||\n            (firstUsage !== undefined && !firstUsage.isNotEarlierThan(insertionPoint)) ||\n            this.functionPrototypes.get(functionValue) !== undefined\n          ) {\n            let callArgs: Array<BabelNodeExpression | BabelNodeSpreadElement> = [t.thisExpression()];\n            for (let flatArg of flatArgs) callArgs.push(flatArg);\n            for (let param of params) {\n              if (param.type !== \"Identifier\") {\n                throw new FatalError(\"TODO: do not know how to deal with non-Identifier parameters\");\n              }\n              callArgs.push(((param: any): BabelNodeIdentifier));\n            }\n\n            let callee = t.memberExpression(factoryId, t.identifier(\"call\"));\n\n            let childBody = t.blockStatement([t.returnStatement(t.callExpression(callee, callArgs))]);\n\n            funcNode = t.functionExpression(null, params, childBody);\n            if (functionValue.$Strict) {\n              strictFunctionBodies.push(funcNode);\n            } else {\n              unstrictFunctionBodies.push(funcNode);\n            }\n          } else {\n            funcNode = t.callExpression(\n              t.memberExpression(factoryId, t.identifier(\"bind\")),\n              [nullExpression].concat(flatArgs)\n            );\n          }\n\n          defineFunction(instance, functionId, funcNode);\n        }\n      }\n    }\n\n    for (let referentializationScope of this.referentializer.referentializationState.keys()) {\n      let prelude = this.prelude;\n      // Get the prelude for this additional function value\n      if (referentializationScope !== \"GLOBAL\") {\n        let additionalFunction = referentializationScope;\n        prelude = additionalFunctionPreludes.get(additionalFunction);\n        if (!prelude) {\n          prelude = [];\n          additionalFunctionPreludes.set(additionalFunction, prelude);\n        }\n      }\n      prelude.unshift(this.referentializer.createCaptureScopeAccessFunction(referentializationScope));\n      prelude.unshift(this.referentializer.createCapturedScopesArrayInitialization(referentializationScope));\n    }\n\n    for (let [additionalFunction, body] of additionalFunctionPreludes.entries()) {\n      invariant(additionalFunction);\n      let prelude = ((body: any): Array<BabelNodeStatement>);\n      let additionalBody = rewrittenAdditionalFunctions.get(additionalFunction);\n      invariant(additionalBody);\n      additionalBody.unshift(...prelude);\n    }\n\n    for (let instance of this.functionInstances.reverse()) {\n      let functionBody = functionBodies.get(instance);\n      if (functionBody !== undefined) {\n        let insertionPoint = instance.insertionPoint;\n        invariant(insertionPoint instanceof BodyReference);\n        // v8 seems to do something clever with array splicing, so this potentially\n        // expensive operations seems to be actually cheap.\n        Array.prototype.splice.apply(\n          insertionPoint.body.entries,\n          ([insertionPoint.index, 0]: Array<any>).concat((functionBody: Array<any>))\n        );\n      }\n    }\n\n    // Inject initializer code for indexed vars into functions (for delay initializations)\n    for (let [functionValue, funcNode] of funcNodes) {\n      let initializerStatement = this.residualFunctionInitializers.getInitializerStatement(functionValue);\n      if (initializerStatement !== undefined) {\n        invariant(t.isFunctionExpression(funcNode));\n        let blockStatement: BabelNodeBlockStatement = ((funcNode: any): BabelNodeFunctionExpression).body;\n        blockStatement.body.unshift(initializerStatement);\n      }\n    }\n\n    return { unstrictFunctionBodies, strictFunctionBodies, requireStatistics };\n  }\n}\n"]}