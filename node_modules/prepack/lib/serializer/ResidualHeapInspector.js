"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ResidualHeapInspector = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright (c) 2017-present, Facebook, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * This source code is licensed under the BSD-style license found in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * LICENSE file in the root directory of this source tree. An additional grant
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * of patent rights can be found in the PATENTS file in the same directory.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _realm = require("../realm.js");

var _index = require("../methods/index.js");

var _index2 = require("../values/index.js");

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _logger = require("./logger.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ResidualHeapInspector = exports.ResidualHeapInspector = function () {
  function ResidualHeapInspector(realm, logger) {
    _classCallCheck(this, ResidualHeapInspector);

    this.realm = realm;
    this.logger = logger;
    this.ignoredProperties = new Map();
  }

  _createClass(ResidualHeapInspector, [{
    key: "canIgnoreProperty",


    // Object properties which have the default value can be ignored by the serializer.
    value: function canIgnoreProperty(val, key) {
      var set = this.ignoredProperties.get(val);
      if (!set) {
        this.ignoredProperties.set(val, set = this._getIgnoredProperties(val));
      }
      return set.has(key);
    }
  }, {
    key: "_getIgnoredProperties",
    value: function _getIgnoredProperties(val) {
      var set = new Set();
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = val.properties[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _ref = _step.value;

          var _ref2 = _slicedToArray(_ref, 2);

          var key = _ref2[0];
          var propertyBinding = _ref2[1];

          (0, _invariant2.default)(propertyBinding);
          var desc = propertyBinding.descriptor;
          if (desc === undefined) continue; //deleted
          if (this._canIgnoreProperty(val, key, desc)) set.add(key);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return set;
    }
  }, {
    key: "_canIgnoreProperty",
    value: function _canIgnoreProperty(val, key, desc) {
      if ((0, _index.IsArray)(this.realm, val)) {
        if (key === "length" && desc.writable && !desc.enumerable && !desc.configurable) {
          // length property has the correct descriptor values
          return true;
        }
      } else if (val instanceof _index2.FunctionValue) {
        if (key === "length") {
          if (desc.value === undefined) {
            this.logger.logError(val, "Functions with length accessor properties are not supported in residual heap.");
            // Rationale: .bind() would call the accessor, which might throw, mutate state, or do whatever...
          }
          // length property will be inferred already by the amount of parameters
          return !desc.writable && !desc.enumerable && desc.configurable && val.hasDefaultLength();
        }

        if (key === "name") {
          // TODO #474: Make sure that we retain original function names. Or set name property.
          // Or ensure that nothing references the name property.
          // NOTE: with some old runtimes notably JSC, function names are not configurable
          // For now don't ignore the property if it is different from the function name.
          // I.e. if it was set explicitly in the code, retain it.
          if (desc.value !== undefined && !this.realm.isCompatibleWith(this.realm.MOBILE_JSC_VERSION) && (desc.value instanceof _index2.AbstractValue || val.__originalName && val.__originalName !== "" && desc.value.value !== val.__originalName)) return false;
          return true;
        }

        // Properties `caller` and `arguments` are added to normal functions in non-strict mode to prevent TypeErrors.
        // Because they are autogenerated, they should be ignored.
        if (key === "arguments" || key === "caller") {
          (0, _invariant2.default)(val instanceof _index2.ECMAScriptSourceFunctionValue);
          if (!val.$Strict && desc.writable && !desc.enumerable && desc.configurable && desc.value instanceof _index2.UndefinedValue && val.$FunctionKind === "normal") return true;
        }

        // ignore the `prototype` property when it's the right one
        if (key === "prototype") {
          if (!desc.configurable && !desc.enumerable && desc.writable && desc.value instanceof _index2.ObjectValue && desc.value.originalConstructor === val) {
            return true;
          }
        }
      } else {
        var kind = val.getKind();
        switch (kind) {
          case "RegExp":
            if (key === "lastIndex" && desc.writable && !desc.enumerable && !desc.configurable) {
              // length property has the correct descriptor values
              var v = desc.value;
              return v instanceof _index2.NumberValue && v.value === 0;
            }
            break;
          default:
            break;
        }
      }

      if (key === "constructor") {
        if (desc.configurable && !desc.enumerable && desc.writable && desc.value === val.originalConstructor) return true;
      }

      return false;
    }
  }, {
    key: "isDefaultPrototype",
    value: function isDefaultPrototype(prototype) {
      if (prototype.symbols.size !== 0 || prototype.$Prototype !== this.realm.intrinsics.ObjectPrototype || !prototype.getExtensible()) return false;
      var foundConstructor = false;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = prototype.properties.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var name = _step2.value;

          if (name === "constructor" && ResidualHeapInspector.getPropertyValue(prototype, name) === prototype.originalConstructor) foundConstructor = true;else return false;
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return foundConstructor;
    }
  }], [{
    key: "isLeaf",
    value: function isLeaf(val) {
      if (val instanceof _index2.SymbolValue) {
        return false;
      }

      if (val instanceof _index2.AbstractValue && val.hasIdentifier()) {
        return true;
      }

      if (val.isIntrinsic()) {
        return false;
      }

      return val instanceof _index2.PrimitiveValue;
    }
  }, {
    key: "getPropertyValue",
    value: function getPropertyValue(val, name) {
      var prototypeBinding = val.properties.get(name);
      if (prototypeBinding === undefined) return undefined;
      var prototypeDesc = prototypeBinding.descriptor;
      if (prototypeDesc === undefined) return undefined;
      (0, _invariant2.default)(prototypeDesc.value === undefined || prototypeDesc.value instanceof _index2.Value);
      return prototypeDesc.value;
    }
  }]);

  return ResidualHeapInspector;
}();
//# sourceMappingURL=ResidualHeapInspector.js.map