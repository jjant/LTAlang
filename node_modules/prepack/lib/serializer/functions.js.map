{"version":3,"sources":["../../src/serializer/functions.js"],"names":["t","Functions","realm","functions","moduleTracer","writeEffects","Map","functionExpressions","calls","fname","fun","fnameAst","expression","e","evaluateNodeForEffectsInGlobalEnv","undefined","ex","error","handleError","set","call","callExpression","push","globalKey","recordedAdditionalFunctions","globalRecordedAdditionalFunctionsMap","modules","logger","tryQuery","$GlobalObject","intrinsics","getOwnPropertyKeysArray","funcId","property","properties","get","funcValue","descriptor","value","statistics","react","recordedReactRootComponents","__generateAdditionalFunctions","componentType","reconciler","result","render","prototype","renderMethod","memberExpression","identifier","_generateAdditionalFunctionCallsFromInput","concat","_generateAdditionalFunctionCallsFromDirective","conflicts","fun1","call1","funcLength","getLength","e1","fun1Name","intrinsicName","location","call2","reportWriteConflicts","size","values","diagnostic","pbs","reportConflict","writtenObjects","Set","forEach","val","key","m","add","object","oldReportObjectGetOwnProperties","reportObjectGetOwnProperties","ob","currentLocation","has","oldReportPropertyAccess","reportPropertyAccess","pb"],"mappings":"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","file":"functions.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { BabelNodeCallExpression, BabelNodeSourceLocation } from \"babel-types\";\nimport { Completion, ThrowCompletion } from \"../completions.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport invariant from \"../invariant.js\";\nimport { type Effects, type PropertyBindings, Realm } from \"../realm.js\";\nimport type { PropertyBinding } from \"../types.js\";\nimport { ignoreErrorsIn } from \"../utils/errors.js\";\nimport {\n  AbstractObjectValue,\n  FunctionValue,\n  ObjectValue,\n  AbstractValue,\n  ECMAScriptSourceFunctionValue,\n} from \"../values/index.js\";\nimport { Get } from \"../methods/index.js\";\nimport { ModuleTracer } from \"./modules.js\";\nimport buildTemplate from \"babel-template\";\nimport { ReactStatistics, type ReactSerializerState } from \"./types\";\nimport { Reconciler } from \"../react/reconcilation.js\";\nimport { valueIsClassComponent } from \"../react/utils.js\";\nimport * as t from \"babel-types\";\n\nexport class Functions {\n  constructor(realm: Realm, functions: ?Array<string>, moduleTracer: ModuleTracer) {\n    this.realm = realm;\n    this.functions = functions;\n    this.moduleTracer = moduleTracer;\n    this.writeEffects = new Map();\n    this.functionExpressions = new Map();\n  }\n\n  realm: Realm;\n  functions: ?Array<string>;\n  // maps back from FunctionValue to the expression string\n  functionExpressions: Map<FunctionValue, string>;\n  moduleTracer: ModuleTracer;\n  writeEffects: Map<FunctionValue, Effects>;\n\n  _generateAdditionalFunctionCallsFromInput(): Array<[FunctionValue, BabelNodeCallExpression]> {\n    // lookup functions\n    let calls = [];\n    for (let fname of this.functions || []) {\n      let fun;\n      let fnameAst = buildTemplate(fname)({}).expression;\n      if (fnameAst) {\n        try {\n          let e = ignoreErrorsIn(this.realm, () => this.realm.evaluateNodeForEffectsInGlobalEnv(fnameAst));\n          fun = e ? e[0] : undefined;\n        } catch (ex) {\n          if (!(ex instanceof ThrowCompletion)) throw ex;\n        }\n      }\n      if (!(fun instanceof FunctionValue)) {\n        let error = new CompilerDiagnostic(\n          `Additional function ${fname} not defined in the global environment`,\n          null,\n          \"PP1001\",\n          \"FatalError\"\n        );\n        this.realm.handleError(error);\n        throw new FatalError();\n      }\n      this.functionExpressions.set(fun, fname);\n      let call = t.callExpression(fnameAst, []);\n      calls.push([fun, call]);\n    }\n    return calls;\n  }\n\n  // __reactComponentRoots\n\n  __generateAdditionalFunctions(globalKey: string) {\n    let recordedAdditionalFunctions: Map<FunctionValue, string> = new Map();\n    let realm = this.realm;\n    let globalRecordedAdditionalFunctionsMap = this.moduleTracer.modules.logger.tryQuery(\n      () => Get(realm, realm.$GlobalObject, globalKey),\n      realm.intrinsics.undefined,\n      false\n    );\n    invariant(globalRecordedAdditionalFunctionsMap instanceof ObjectValue);\n    for (let funcId of globalRecordedAdditionalFunctionsMap.getOwnPropertyKeysArray()) {\n      let property = globalRecordedAdditionalFunctionsMap.properties.get(funcId);\n      if (property) {\n        let funcValue = property.descriptor && property.descriptor.value;\n        if (!(funcValue instanceof FunctionValue)) {\n          invariant(funcValue instanceof AbstractValue);\n          realm.handleError(\n            new CompilerDiagnostic(\n              `Additional Function Value ${funcId} is an AbstractValue which is not allowed`,\n              undefined,\n              \"PP0001\",\n              \"FatalError\"\n            )\n          );\n          throw new FatalError(\"Additional Function values cannot be AbstractValues\");\n        }\n        recordedAdditionalFunctions.set(funcValue, funcId);\n      }\n    }\n    return recordedAdditionalFunctions;\n  }\n\n  checkReactRootComponents(statistics: ReactStatistics, react: ReactSerializerState): void {\n    let recordedReactRootComponents = this.__generateAdditionalFunctions(\"__reactComponentRoots\");\n\n    // Get write effects of the components\n    for (let [componentType] of recordedReactRootComponents) {\n      let reconciler = new Reconciler(this.realm, this.moduleTracer, statistics, react);\n      invariant(\n        componentType instanceof ECMAScriptSourceFunctionValue,\n        \"only ECMAScriptSourceFunctionValue function values are supported as React root components\"\n      );\n      let result = reconciler.render(componentType);\n      if (valueIsClassComponent(this.realm, componentType)) {\n        let prototype = Get(this.realm, componentType, \"prototype\");\n        invariant(prototype instanceof ObjectValue);\n        let renderMethod = Get(this.realm, prototype, \"render\");\n        invariant(renderMethod instanceof ECMAScriptSourceFunctionValue);\n        this.writeEffects.set(renderMethod, result);\n      } else {\n        this.writeEffects.set(componentType, result);\n      }\n    }\n  }\n\n  _generateAdditionalFunctionCallsFromDirective(): Array<[FunctionValue, BabelNodeCallExpression]> {\n    let recordedAdditionalFunctions = this.__generateAdditionalFunctions(\"__additionalFunctions\");\n\n    // The additional functions we registered at runtime are recorded at:\n    // global.__additionalFunctions.id\n    let calls = [];\n    for (let [funcValue, funcId] of recordedAdditionalFunctions) {\n      // TODO #987: Make Additional Functions work with arguments\n      calls.push([\n        funcValue,\n        t.callExpression(\n          t.memberExpression(\n            t.memberExpression(t.identifier(\"global\"), t.identifier(\"__additionalFunctions\")),\n            t.identifier(funcId)\n          ),\n          []\n        ),\n      ]);\n    }\n    return calls;\n  }\n\n  checkThatFunctionsAreIndependent() {\n    let calls = this._generateAdditionalFunctionCallsFromInput().concat(\n      this._generateAdditionalFunctionCallsFromDirective()\n    );\n\n    // Get write effects of the functions\n    for (let [funcValue, call] of calls) {\n      // This may throw a FatalError if there is an unrecoverable error in the called function\n      // When that happens we cannot prepack the bundle.\n      // There may also be warnings reported for errors that happen inside imported modules that can be postponed.\n\n      let e = this.realm.evaluateNodeForEffectsInGlobalEnv(call, this.moduleTracer);\n      this.writeEffects.set(funcValue, e);\n    }\n\n    // check that functions are independent\n    let conflicts: Map<BabelNodeSourceLocation, CompilerDiagnostic> = new Map();\n    for (let [fun1, call1] of calls) {\n      // Also do argument validation here\n      let funcLength = fun1.getLength();\n      if (funcLength && funcLength > 0) {\n        // TODO #987: Make Additional Functions work with arguments\n        throw new FatalError(\"TODO: implement arguments to additional functions\");\n      }\n      let e1 = this.writeEffects.get(fun1);\n      invariant(e1 !== undefined);\n      let fun1Name = this.functionExpressions.get(fun1) || fun1.intrinsicName || \"unknown\";\n      if (e1[0] instanceof Completion) {\n        let error = new CompilerDiagnostic(\n          `Additional function ${fun1Name} may terminate abruptly`,\n          e1[0].location,\n          \"PP1002\",\n          \"FatalError\"\n        );\n        this.realm.handleError(error);\n        throw new FatalError();\n      }\n      for (let [, call2] of calls) {\n        if (call1 === call2) continue;\n        this.reportWriteConflicts(fun1Name, conflicts, e1[3], call1, call2);\n      }\n    }\n    if (conflicts.size > 0) {\n      for (let diagnostic of conflicts.values()) this.realm.handleError(diagnostic);\n      throw new FatalError();\n    }\n  }\n\n  getAdditionalFunctionValuesToEffects(): Map<FunctionValue, Effects> {\n    return this.writeEffects;\n  }\n\n  reportWriteConflicts(\n    fname: string,\n    conflicts: Map<BabelNodeSourceLocation, CompilerDiagnostic>,\n    pbs: PropertyBindings,\n    call1: BabelNodeCallExpression,\n    call2: BabelNodeCallExpression\n  ) {\n    let reportConflict = (location: BabelNodeSourceLocation) => {\n      let error = new CompilerDiagnostic(\n        `Property access conflicts with write in additional function ${fname}`,\n        location,\n        \"PP1003\",\n        \"FatalError\"\n      );\n      conflicts.set(location, error);\n    };\n    let writtenObjects: Set<ObjectValue | AbstractObjectValue> = new Set();\n    pbs.forEach((val, key, m) => {\n      writtenObjects.add(key.object);\n    });\n    let oldReportObjectGetOwnProperties = this.realm.reportObjectGetOwnProperties;\n    this.realm.reportObjectGetOwnProperties = (ob: ObjectValue) => {\n      let location = this.realm.currentLocation;\n      invariant(location);\n      if (writtenObjects.has(ob) && !conflicts.has(location)) reportConflict(location);\n    };\n    let oldReportPropertyAccess = this.realm.reportPropertyAccess;\n    this.realm.reportPropertyAccess = (pb: PropertyBinding) => {\n      let location = this.realm.currentLocation;\n      if (!location) return; // happens only when accessing an additional function property\n      if (pbs.has(pb) && !conflicts.has(location)) reportConflict(location);\n    };\n    try {\n      ignoreErrorsIn(this.realm, () => this.realm.evaluateNodeForEffectsInGlobalEnv(call2, this.moduleTracer));\n    } finally {\n      this.realm.reportPropertyAccess = oldReportPropertyAccess;\n      this.realm.reportObjectGetOwnProperties = oldReportObjectGetOwnProperties;\n    }\n  }\n}\n"]}