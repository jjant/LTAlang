{"version":3,"sources":["../../src/serializer/types.js"],"names":["AreSameResidualBinding","realm","x","y","serializedValue","value","BodyReference","body","index","other","TimingStatistics","totalTime","globalCodeTime","initializeMoreModulesTime","deepTraversalTime","referenceCountsTime","serializePassTime","ReactStatistics","optimizedTrees","inlinedComponents","SerializerStatistics","objects","objectProperties","functions","functionClones","referentialized","valueIds","valuesInlined","delayedValues","acceleratedModules","delayedModules","console","log"],"mappings":";;;;;;;qjBAAA;;;;;;;;;QAwFgBA,sB,GAAAA,sB;;AA7EhB;;AACA;;AAGA;;AACA;;AACA;;;;;;;;AAIA;AAmEO,SAASA,sBAAT,CAAgCC,KAAhC,EAA8CC,CAA9C,EAA0EC,CAA1E,EAAsG;AAC3G,MAAID,EAAEE,eAAF,KAAsBD,EAAEC,eAA5B,EAA6C,OAAO,IAAP;AAC7C,MAAIF,EAAEG,KAAF,IAAWH,EAAEG,KAAF,KAAYF,EAAEE,KAA7B,EAAoC,OAAO,IAAP;AACpC,MAAIH,EAAEG,KAAF,oCAAoCF,EAAEE,KAAF,gCAAxC,EAA0E;AACxE,WAAO,yBAAUJ,KAAV,EAAiBC,EAAEG,KAAnB,EAA0BF,EAAEE,KAA5B,CAAP;AACD;AACD,SAAO,KAAP;AACD;;IAEYC,a,WAAAA,a;AACX,yBAAYC,IAAZ,EAAkCC,KAAlC,EAAiD;AAAA;;AAC/C,6BAAUA,SAAS,CAAnB;AACA,SAAKD,IAAL,GAAYA,IAAZ;AACA,SAAKC,KAAL,GAAaA,KAAb;AACD;;;;qCACgBC,K,EAA+B;AAC9C,aAAO,KAAKF,IAAL,KAAcE,MAAMF,IAApB,IAA4B,KAAKC,KAAL,IAAcC,MAAMD,KAAvD;AACD;;;;;;IAKUE,gB,WAAAA,gB,GACX,4BAAc;AAAA;;AACZ,OAAKC,SAAL,GAAiB,CAAjB;AACA,OAAKC,cAAL,GAAsB,CAAtB;AACA,OAAKC,yBAAL,GAAiC,CAAjC;AACA,OAAKC,iBAAL,GAAyB,CAAzB;AACA,OAAKC,mBAAL,GAA2B,CAA3B;AACA,OAAKC,iBAAL,GAAyB,CAAzB;AACD,C;;IASUC,e,WAAAA,e,GACX,2BAAc;AAAA;;AACZ,OAAKC,cAAL,GAAsB,CAAtB;AACA,OAAKC,iBAAL,GAAyB,CAAzB;AACD,C;;IAKUC,oB,WAAAA,oB;AACX,kCAAc;AAAA;;AACZ,SAAKC,OAAL,GAAe,CAAf;AACA,SAAKC,gBAAL,GAAwB,CAAxB;AACA,SAAKC,SAAL,GAAiB,CAAjB;AACA,SAAKC,cAAL,GAAsB,CAAtB;AACA,SAAKC,eAAL,GAAuB,CAAvB;AACA,SAAKC,QAAL,GAAgB,CAAhB;AACA,SAAKC,aAAL,GAAqB,CAArB;AACA,SAAKC,aAAL,GAAqB,CAArB;AACA,SAAKC,kBAAL,GAA0B,CAA1B;AACA,SAAKC,cAAL,GAAsB,CAAtB;AACD;;;;0BAYK;AACJC,cAAQC,GAAR;AACAD,cAAQC,GAAR,CAAe,KAAKX,OAApB,sBAA4C,KAAKC,gBAAjD;AACAS,cAAQC,GAAR,CACK,KAAKT,SADV,wBACsC,KAAKC,cAD3C,2CAC+F,KAC1FC,eAFL;AAIAM,cAAQC,GAAR,CACK,KAAKN,QADV,mBACgC,KAAKE,aADrC,0CACuF,KAClFD,aAFL;AAIAI,cAAQC,GAAR,CAAe,KAAKH,kBAApB,yBAA0D,KAAKC,cAA/D;AACD","file":"types.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { DeclarativeEnvironmentRecord, type Binding } from \"../environment.js\";\nimport { ConcreteValue, Value } from \"../values/index.js\";\nimport type { ECMAScriptSourceFunctionValue, FunctionValue } from \"../values/index.js\";\nimport type { BabelNodeExpression, BabelNodeStatement } from \"babel-types\";\nimport { SameValue } from \"../methods/abstract.js\";\nimport { Realm } from \"../realm.js\";\nimport invariant from \"../invariant.js\";\n\nexport type TryQuery<T> = (f: () => T, defaultValue: T, logFailures: boolean) => T;\n\n// TODO: add type for additional functions.\nexport type SerializedBodyType =\n  | \"MainGenerator\"\n  | \"Generator\"\n  | \"DelayInitializations\"\n  | \"ConditionalAssignmentBranch\"\n  | \"LazyObjectInitializer\";\n\nexport type SerializedBody = {\n  type: SerializedBodyType,\n  entries: Array<BabelNodeStatement>,\n};\n\nexport type AdditionalFunctionInfo = {\n  functionValue: FunctionValue,\n  captures: Set<string>,\n  // TODO: use for storing modified residual function bindings (captured by other functions)\n  modifiedBindings: Map<Binding, ResidualFunctionBinding>,\n  instance: FunctionInstance,\n};\n\nexport type FunctionInstance = {\n  residualFunctionBindings: Map<string, ResidualFunctionBinding>,\n  functionValue: ECMAScriptSourceFunctionValue,\n  insertionPoint?: BodyReference,\n  // Additional function that the function instance was declared inside of (if any)\n  containingAdditionalFunction?: FunctionValue,\n  scopeInstances: Set<ScopeBinding>,\n};\n\nexport type FunctionInfo = {\n  unbound: Set<string>,\n  modified: Set<string>,\n  usesArguments: boolean,\n  usesThis: boolean,\n};\n\nexport type FactoryFunctionInfo = { factoryId: BabelNodeIdentifier, functionInfo: FunctionInfo };\n\nexport type ResidualFunctionBinding = {\n  value: void | Value,\n  modified: boolean,\n  // void means a global binding\n  declarativeEnvironmentRecord: null | DeclarativeEnvironmentRecord,\n  // The serializedValue is only not yet present during the initialization of a binding that involves recursive dependencies.\n  serializedValue?: void | BabelNodeExpression,\n  referentialized?: boolean,\n  scope?: ScopeBinding,\n  // If the binding is only accessed by an additional function or nested values\n  // this field contains that additional function. (Determines what initializer\n  // to put the binding in -- global or additional function)\n  referencedOnlyFromAdditionalFunctions?: FunctionValue,\n  // If the binding is overwritten by an additional function, these contain the\n  // new values\n  // TODO #1087: make this a map and support arbitrary binding modifications\n  additionalFunctionOverridesValue?: true,\n  additionalValueSerialized?: BabelNodeExpression,\n};\n\nexport type ScopeBinding = {\n  name: string,\n  id: number,\n  initializationValues: Array<BabelNodeExpression>,\n  capturedScope?: string,\n  containingAdditionalFunction: void | FunctionValue,\n};\n\nexport function AreSameResidualBinding(realm: Realm, x: ResidualFunctionBinding, y: ResidualFunctionBinding) {\n  if (x.serializedValue === y.serializedValue) return true;\n  if (x.value && x.value === y.value) return true;\n  if (x.value instanceof ConcreteValue && y.value instanceof ConcreteValue) {\n    return SameValue(realm, x.value, y.value);\n  }\n  return false;\n}\n\nexport class BodyReference {\n  constructor(body: SerializedBody, index: number) {\n    invariant(index >= 0);\n    this.body = body;\n    this.index = index;\n  }\n  isNotEarlierThan(other: BodyReference): boolean {\n    return this.body === other.body && this.index >= other.index;\n  }\n  body: SerializedBody;\n  index: number;\n}\n\nexport class TimingStatistics {\n  constructor() {\n    this.totalTime = 0;\n    this.globalCodeTime = 0;\n    this.initializeMoreModulesTime = 0;\n    this.deepTraversalTime = 0;\n    this.referenceCountsTime = 0;\n    this.serializePassTime = 0;\n  }\n  totalTime: number;\n  globalCodeTime: number;\n  initializeMoreModulesTime: number;\n  deepTraversalTime: number;\n  referenceCountsTime: number;\n  serializePassTime: number;\n}\n\nexport class ReactStatistics {\n  constructor() {\n    this.optimizedTrees = 0;\n    this.inlinedComponents = 0;\n  }\n  optimizedTrees: number;\n  inlinedComponents: number;\n}\n\nexport class SerializerStatistics {\n  constructor() {\n    this.objects = 0;\n    this.objectProperties = 0;\n    this.functions = 0;\n    this.functionClones = 0;\n    this.referentialized = 0;\n    this.valueIds = 0;\n    this.valuesInlined = 0;\n    this.delayedValues = 0;\n    this.acceleratedModules = 0;\n    this.delayedModules = 0;\n  }\n  objects: number;\n  objectProperties: number;\n  functions: number;\n  functionClones: number;\n  referentialized: number;\n  valueIds: number;\n  valuesInlined: number;\n  delayedValues: number;\n  acceleratedModules: number;\n  delayedModules: number;\n\n  log() {\n    console.log(`=== serialization statistics`);\n    console.log(`${this.objects} objects with ${this.objectProperties} properties`);\n    console.log(\n      `${this.functions} functions plus ${this.functionClones} clones due to captured variables; ${this\n        .referentialized} captured mutable variables`\n    );\n    console.log(\n      `${this.valueIds} eager and ${this.delayedValues} delayed value ids generated, and ${this\n        .valuesInlined} values inlined`\n    );\n    console.log(`${this.acceleratedModules} accelerated and ${this.delayedModules} delayed modules.`);\n  }\n}\n\nexport type LocationService = {\n  getLocation: Value => void | BabelNodeIdentifier,\n  createLocation: () => BabelNodeIdentifier,\n};\n\nexport type ReactSerializerState = {\n  usedReactElementKeys: Set<string>,\n};\n"]}