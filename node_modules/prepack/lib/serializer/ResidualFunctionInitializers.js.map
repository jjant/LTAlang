{"version":3,"sources":["../../src/serializer/ResidualFunctionInitializers.js"],"names":["t","ResidualFunctionInitializers","locationService","prelude","initializerNameGenerator","functionInitializerInfos","Map","initializers","sharedInitializers","functionValues","val","length","infos","functionValue","info","get","undefined","set","ownId","size","toString","initializerIds","Set","push","id","map","sort","join","add","initializer","order","values","body","type","entries","delete","initializedValues","initializationStatements","isIfStatement","location","value","mightBeUndefined","getLocation","createLocation","unshift","expressionStatement","assignmentExpression","ifStatement","binaryExpression","blockStatement","nameGenerator","initializerInfo","ownInitializer","initializerId","i","j","concat","ast","_conditionalInitialization","count","file","program","identifier","generate","functionDeclaration","callExpression"],"mappings":"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","file":"ResidualFunctionInitializers.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { FunctionValue, Value } from \"../values/index.js\";\nimport * as t from \"babel-types\";\nimport type { BabelNodeStatement } from \"babel-types\";\nimport { NameGenerator } from \"../utils/generator.js\";\nimport traverseFast from \"../utils/traverse-fast.js\";\nimport invariant from \"../invariant.js\";\nimport { voidExpression, nullExpression } from \"../utils/internalizer.js\";\nimport type { LocationService, SerializedBody } from \"./types.js\";\nimport { factorifyObjects } from \"./factorify.js\";\n\n// This class manages information about values\n// which are only referenced by residual functions,\n// and it provides the ability to generate initialization code for those values that\n// can be placed into the residual functions.\nexport class ResidualFunctionInitializers {\n  constructor(\n    locationService: LocationService,\n    prelude: Array<BabelNodeStatement>,\n    initializerNameGenerator: NameGenerator\n  ) {\n    this.functionInitializerInfos = new Map();\n    this.initializers = new Map();\n    this.sharedInitializers = new Map();\n    this.locationService = locationService;\n    this.initializerNameGenerator = initializerNameGenerator;\n    this.prelude = prelude;\n  }\n\n  functionInitializerInfos: Map<FunctionValue, { ownId: string, initializerIds: Set<string> }>;\n  initializers: Map<string, { id: string, order: number, body: SerializedBody, values: Array<Value> }>;\n  sharedInitializers: Map<string, BabelNodeStatement>;\n  locationService: LocationService;\n  prelude: Array<BabelNodeStatement>;\n  initializerNameGenerator: NameGenerator;\n\n  registerValueOnlyReferencedByResidualFunctions(functionValues: Array<FunctionValue>, val: Value): SerializedBody {\n    invariant(functionValues.length >= 1);\n    let infos = [];\n    for (let functionValue of functionValues) {\n      let info = this.functionInitializerInfos.get(functionValue);\n      if (info === undefined)\n        this.functionInitializerInfos.set(\n          functionValue,\n          (info = { ownId: this.functionInitializerInfos.size.toString(), initializerIds: new Set() })\n        );\n      infos.push(info);\n    }\n    let id = infos.map(info => info.ownId).sort().join();\n    for (let info of infos) info.initializerIds.add(id);\n    let initializer = this.initializers.get(id);\n    if (initializer === undefined)\n      this.initializers.set(\n        id,\n        (initializer = { id, order: infos.length, values: [], body: { type: \"DelayInitializations\", entries: [] } })\n      );\n    initializer.values.push(val);\n    return initializer.body;\n  }\n\n  scrubFunctionInitializers() {\n    // Deleting trivial entries in order to avoid creating empty initialization functions that serve no purpose.\n    for (let initializer of this.initializers.values())\n      if (initializer.body.entries.length === 0) this.initializers.delete(initializer.id);\n    for (let [functionValue, info] of this.functionInitializerInfos) {\n      for (let id of info.initializerIds) {\n        let initializer = this.initializers.get(id);\n        if (initializer === undefined) {\n          info.initializerIds.delete(id);\n        }\n      }\n      if (info.initializerIds.size === 0) this.functionInitializerInfos.delete(functionValue);\n    }\n  }\n\n  _conditionalInitialization(\n    initializedValues: Array<Value>,\n    initializationStatements: Array<BabelNodeStatement>\n  ): BabelNodeStatement {\n    if (initializationStatements.length === 1 && t.isIfStatement(initializationStatements[0])) {\n      return initializationStatements[0];\n    }\n\n    // We have some initialization code, and it should only get executed once,\n    // so we are going to guard it.\n    // First, let's see if one of the initialized values is guaranteed to not\n    // be undefined after initialization. In that case, we can use that state-change\n    // to figure out if initialization needs to run.\n    let location;\n    for (let value of initializedValues) {\n      if (!value.mightBeUndefined()) {\n        location = this.locationService.getLocation(value);\n        if (location !== undefined) break;\n      }\n    }\n    if (location === undefined) {\n      // Second, if we didn't find a non-undefined value, let's make one up.\n      // It will transition from `undefined` to `null`.\n      location = this.locationService.createLocation();\n      initializationStatements.unshift(t.expressionStatement(t.assignmentExpression(\"=\", location, nullExpression)));\n    }\n    return t.ifStatement(\n      t.binaryExpression(\"===\", location, voidExpression),\n      t.blockStatement(initializationStatements)\n    );\n  }\n\n  hasInitializerStatement(functionValue: FunctionValue): boolean {\n    return !!this.functionInitializerInfos.get(functionValue);\n  }\n\n  factorifyInitializers(nameGenerator: NameGenerator) {\n    for (const initializer of this.initializers.values()) {\n      factorifyObjects(initializer.body.entries, nameGenerator);\n    }\n  }\n\n  getInitializerStatement(functionValue: FunctionValue): void | BabelNodeStatement {\n    let initializerInfo = this.functionInitializerInfos.get(functionValue);\n    if (initializerInfo === undefined) return undefined;\n\n    invariant(initializerInfo.initializerIds.size > 0);\n    let ownInitializer = this.initializers.get(initializerInfo.ownId);\n    let initializedValues;\n    let initializationStatements = [];\n    let initializers = [];\n    for (let initializerId of initializerInfo.initializerIds) {\n      let initializer = this.initializers.get(initializerId);\n      invariant(initializer !== undefined);\n      invariant(initializer.body.entries.length > 0);\n      initializers.push(initializer);\n    }\n    // Sorting initializers by the number of scopes they are required by.\n    // Note that the scope sets form a lattice, and this sorting effectively\n    // ensures that value initializers that depend on other value initializers\n    // get called in the right order.\n    initializers.sort((i, j) => j.order - i.order);\n    for (let initializer of initializers) {\n      if (initializerInfo.initializerIds.size === 1 || initializer === ownInitializer) {\n        initializedValues = initializer.values;\n      }\n      if (initializer === ownInitializer) {\n        initializationStatements = initializationStatements.concat(initializer.body.entries);\n      } else {\n        let ast = this.sharedInitializers.get(initializer.id);\n        if (ast === undefined) {\n          ast = this._conditionalInitialization(initializer.values, initializer.body.entries);\n          // We inline compact initializers, as calling a function would introduce too much\n          // overhead. To determine if an initializer is compact, we count the number of\n          // nodes in the AST, and check if it exceeds a certain threshold.\n          // TODO #885: Study in more detail which threshold is the best compromise in terms of\n          // code size and performance.\n          let count = 0;\n          traverseFast(t.file(t.program([ast])), node => {\n            count++;\n            return false;\n          });\n          if (count > 24) {\n            let id = t.identifier(this.initializerNameGenerator.generate());\n            this.prelude.push(t.functionDeclaration(id, [], t.blockStatement([ast])));\n            ast = t.expressionStatement(t.callExpression(id, []));\n          }\n          this.sharedInitializers.set(initializer.id, ast);\n        }\n        initializationStatements.push(ast);\n      }\n    }\n\n    return this._conditionalInitialization(initializedValues || [], initializationStatements);\n  }\n}\n"]}