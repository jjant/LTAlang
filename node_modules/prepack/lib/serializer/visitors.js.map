{"version":3,"sources":["../../src/serializer/visitors.js"],"names":["t","markVisited","node","data","_renamedOnce","shouldVisit","replaceName","path","residualFunctionBinding","name","scope","hasBinding","serializedValue","type","replaceWith","getLiteralTruthiness","isBooleanLiteral","isNumericLiteral","isStringLiteral","known","value","isFunctionExpression","isArrowFunctionExpression","isRegExpLiteral","isClassExpression","superClass","body","length","isObjectExpression","properties","isArrayExpression","elements","isNullLiteral","canShareFunctionBody","duplicateFunctionInfo","functionInfo","unbound","modified","usesThis","size","ClosureRefReplacer","ReferencedIdentifier","state","ignorePath","residualFunctionBindings","get","CallExpression","requireReturns","isRequire","requireStatistics","count","has","callee","moduleId","arguments","new_node","undefined","replaced","ids","getBindingIdentifierPaths","nestedPath","FunctionExpression","isProgram","parentPath","functionExpression","functionTag","uniqueTag","factoryFunctionInfos","factoryId","callExpression","memberExpression","identifier","IfStatement","exit","testTruthiness","test","consequent","alternate","remove","ConditionalExpression","LogicalExpression","leftTruthiness","left","operator","right","WhileStatement","visitName","add","parent","isLabeledStatement","isBreakStatement","isContinueStatement","ClosureRefVisitor","innerName","usesArguments","ThisExpression","getBindingIdentifiers"],"mappings":"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","file":"visitors.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { Realm } from \"../realm.js\";\nimport { FunctionValue } from \"../values/index.js\";\nimport * as t from \"babel-types\";\nimport { convertExpressionToJSXIdentifier } from \"../react/jsx\";\nimport type { BabelNodeExpression, BabelNodeCallExpression, BabelNodeFunctionExpression } from \"babel-types\";\nimport type { BabelTraversePath } from \"babel-traverse\";\nimport type { FunctionBodyAstNode } from \"../types.js\";\nimport type { TryQuery, FunctionInfo, FactoryFunctionInfo, ResidualFunctionBinding } from \"./types.js\";\nimport { nullExpression } from \"../utils/internalizer.js\";\n\nexport type ClosureRefVisitorState = {\n  tryQuery: TryQuery<*>,\n  val: FunctionValue,\n  functionInfo: FunctionInfo,\n  realm: Realm,\n};\n\nexport type ClosureRefReplacerState = {\n  residualFunctionBindings: Map<string, ResidualFunctionBinding>,\n  modified: Set<string>,\n  requireReturns: Map<number | string, BabelNodeExpression>,\n  requireStatistics: { replaced: 0, count: 0 },\n  isRequire: void | ((scope: any, node: BabelNodeCallExpression) => boolean),\n  factoryFunctionInfos: Map<number, FactoryFunctionInfo>,\n};\n\nfunction markVisited(node, data) {\n  (node: any)._renamedOnce = data;\n}\n\nfunction shouldVisit(node, data) {\n  return (node: any)._renamedOnce !== data;\n}\n\n// replaceWith causes the node to be re-analysed, so to prevent double replacement\n// we add this property on the node to mark it such that it does not get replaced\n// again on this pass\n// TODO: Make this work when replacing with arbitrary BabelNodeExpressions. Currently\n//       if the node that we're substituting contains identifiers as children,\n//       they will be visited again and possibly transformed.\n//       If necessary we could implement this by following node.parentPath and checking\n//       if any parent nodes are marked visited, but that seem unnecessary right now.let closureRefReplacer = {\nfunction replaceName(path, residualFunctionBinding, name, data) {\n  if (path.scope.hasBinding(name, /*noGlobals*/ true)) return;\n\n  if (residualFunctionBinding && shouldVisit(path.node, data)) {\n    markVisited(residualFunctionBinding.serializedValue, data);\n    let serializedValue = residualFunctionBinding.serializedValue;\n\n    if (path.node.type === \"JSXIdentifier\" || path.node.type === \"JSXMemberIdentifier\") {\n      path.replaceWith(convertExpressionToJSXIdentifier((serializedValue: any), true));\n    } else {\n      path.replaceWith(serializedValue);\n    }\n  }\n}\n\nfunction getLiteralTruthiness(node): { known: boolean, value?: boolean } {\n  // In the return value, 'known' is true only if this is a literal of known truthiness and with no side effects; if 'known' is true, 'value' is its truthiness.\n  if (t.isBooleanLiteral(node) || t.isNumericLiteral(node) || t.isStringLiteral(node)) {\n    return { known: true, value: !!node.value };\n  }\n  if (\n    t.isFunctionExpression(node) ||\n    t.isArrowFunctionExpression(node) ||\n    t.isRegExpLiteral(node) ||\n    (t.isClassExpression(node) && node.superClass === null && node.body.body.length === 0) ||\n    (t.isObjectExpression(node) && node.properties.length === 0) ||\n    (t.isArrayExpression(node) && node.elements.length === 0)\n  ) {\n    return { known: true, value: true };\n  }\n  if (t.isNullLiteral(node)) {\n    return { known: true, value: false };\n  }\n  return { known: false };\n}\n\nfunction canShareFunctionBody(duplicateFunctionInfo: FactoryFunctionInfo): boolean {\n  // Only share function when:\n  // 1. it does not access any free variables.\n  // 2. it does not use \"this\".\n  const { unbound, modified, usesThis } = duplicateFunctionInfo.functionInfo;\n  return unbound.size === 0 && modified.size === 0 && !usesThis;\n}\n\nexport let ClosureRefReplacer = {\n  ReferencedIdentifier(path: BabelTraversePath, state: ClosureRefReplacerState) {\n    if (ignorePath(path)) return;\n\n    let residualFunctionBindings = state.residualFunctionBindings;\n    let name = path.node.name;\n    let residualFunctionBinding = residualFunctionBindings.get(name);\n    if (residualFunctionBinding) replaceName(path, residualFunctionBinding, name, residualFunctionBindings);\n  },\n\n  CallExpression(path: BabelTraversePath, state: ClosureRefReplacerState) {\n    // Here we apply the require optimization by replacing require calls with their\n    // corresponding initialized modules.\n    let requireReturns = state.requireReturns;\n    if (!state.isRequire || !state.isRequire(path.scope, path.node)) return;\n    state.requireStatistics.count++;\n    if (state.modified.has(path.node.callee.name)) return;\n\n    let moduleId = \"\" + path.node.arguments[0].value;\n    let new_node = requireReturns.get(moduleId);\n    if (new_node !== undefined) {\n      markVisited(new_node, state.residualFunctionBindings);\n      path.replaceWith(new_node);\n      state.requireStatistics.replaced++;\n    }\n  },\n\n  \"AssignmentExpression|UpdateExpression\"(path: BabelTraversePath, state: ClosureRefReplacerState) {\n    let residualFunctionBindings = state.residualFunctionBindings;\n    let ids = path.getBindingIdentifierPaths();\n    for (let name in ids) {\n      let residualFunctionBinding = residualFunctionBindings.get(name);\n      if (residualFunctionBinding) {\n        let nestedPath = ids[name];\n        replaceName(nestedPath, residualFunctionBinding, name, residualFunctionBindings);\n      }\n    }\n  },\n\n  // TODO: handle FunctionDeclaration.\n  // Replace \"function () {}\" ==> \"factory_id.bind(null)\".\n  FunctionExpression(path: BabelTraversePath, state: ClosureRefReplacerState) {\n    if (t.isProgram(path.parentPath.parentPath.node)) {\n      // Our goal is replacing duplicate nested function so skip root residual function itself.\n      // This assumes the root function is wrapped with: t.file(t.program([t.expressionStatement(rootFunction).\n      return;\n    }\n\n    const functionExpression: BabelNodeFunctionExpression = path.node;\n    const functionTag = ((functionExpression.body: any): FunctionBodyAstNode).uniqueTag;\n    if (!functionTag) {\n      // Un-interpreted nested function.\n      return;\n    }\n    const duplicateFunctionInfo = state.factoryFunctionInfos.get(functionTag);\n    if (duplicateFunctionInfo && canShareFunctionBody(duplicateFunctionInfo)) {\n      const { factoryId } = duplicateFunctionInfo;\n      path.replaceWith(t.callExpression(t.memberExpression(factoryId, t.identifier(\"bind\")), [nullExpression]));\n    }\n  },\n\n  // A few very simple dead code elimination helpers. Eventually these should be subsumed by the partial evaluators.\n  IfStatement: {\n    exit: function(path: BabelTraversePath, state: ClosureRefReplacerState) {\n      let node = path.node;\n      let testTruthiness = getLiteralTruthiness(node.test);\n      if (testTruthiness.known) {\n        if (testTruthiness.value) {\n          // Strictly speaking this is not safe: Annex B.3.4 allows FunctionDeclarations as the body of IfStatements in sloppy mode,\n          // which have weird hoisting behavior: `console.log(typeof f); if (true) function f(){} console.log(typeof f)` will print 'undefined', 'function', but\n          // `console.log(typeof f); function f(){} console.log(typeof f)` will print 'function', 'function'.\n          // However, Babylon can't parse these, so it doesn't come up.\n          path.replaceWith(node.consequent);\n        } else {\n          if (node.alternate !== null) {\n            path.replaceWith(node.alternate);\n          } else {\n            path.remove();\n          }\n        }\n      }\n    },\n  },\n\n  ConditionalExpression: {\n    exit: function(path: BabelTraversePath, state: ClosureRefReplacerState) {\n      let node = path.node;\n      let testTruthiness = getLiteralTruthiness(node.test);\n      if (testTruthiness.known) {\n        path.replaceWith(testTruthiness.value ? node.consequent : node.alternate);\n      }\n    },\n  },\n\n  LogicalExpression: {\n    exit: function(path: BabelTraversePath, state: ClosureRefReplacerState) {\n      let node = path.node;\n      let leftTruthiness = getLiteralTruthiness(node.left);\n      if (node.operator === \"&&\" && leftTruthiness.known) {\n        path.replaceWith(leftTruthiness.value ? node.right : node.left);\n      } else if (node.operator === \"||\" && leftTruthiness.known) {\n        path.replaceWith(leftTruthiness.value ? node.left : node.right);\n      }\n    },\n  },\n\n  WhileStatement: {\n    exit: function(path: BabelTraversePath, state: ClosureRefReplacerState) {\n      let node = path.node;\n      let testTruthiness = getLiteralTruthiness(node.test);\n      if (testTruthiness.known && !testTruthiness.value) {\n        path.remove();\n      }\n    },\n  },\n};\n\nfunction visitName(path, state, name, modified) {\n  // Is the name bound to some local identifier? If so, we don't need to do anything\n  if (path.scope.hasBinding(name, /*noGlobals*/ true)) return;\n\n  // Otherwise, let's record that there's an unbound identifier\n  state.functionInfo.unbound.add(name);\n  if (modified) state.functionInfo.modified.add(name);\n}\n\nfunction ignorePath(path: BabelTraversePath) {\n  let parent = path.parent;\n  return t.isLabeledStatement(parent) || t.isBreakStatement(parent) || t.isContinueStatement(parent);\n}\n\n// TODO #886: doesn't check that `arguments` and `this` is in top function\nexport let ClosureRefVisitor = {\n  ReferencedIdentifier(path: BabelTraversePath, state: ClosureRefVisitorState) {\n    if (ignorePath(path)) return;\n\n    let innerName = path.node.name;\n    if (innerName === \"arguments\") {\n      state.functionInfo.usesArguments = true;\n      return;\n    }\n    visitName(path, state, innerName, false);\n  },\n\n  ThisExpression(path: BabelTraversePath, state: ClosureRefVisitorState) {\n    state.functionInfo.usesThis = true;\n  },\n\n  \"AssignmentExpression|UpdateExpression\"(path: BabelTraversePath, state: ClosureRefVisitorState) {\n    for (let name in path.getBindingIdentifiers()) {\n      visitName(path, state, name, true);\n    }\n  },\n};\n"]}