"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Functions = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright (c) 2017-present, Facebook, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * This source code is licensed under the BSD-style license found in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * LICENSE file in the root directory of this source tree. An additional grant
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * of patent rights can be found in the PATENTS file in the same directory.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _completions = require("../completions.js");

var _errors = require("../errors.js");

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _realm = require("../realm.js");

var _errors2 = require("../utils/errors.js");

var _index = require("../values/index.js");

var _index2 = require("../methods/index.js");

var _modules = require("./modules.js");

var _babelTemplate = require("babel-template");

var _babelTemplate2 = _interopRequireDefault(_babelTemplate);

var _types = require("./types");

var _reconcilation = require("../react/reconcilation.js");

var _utils = require("../react/utils.js");

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Functions = exports.Functions = function () {
  function Functions(realm, functions, moduleTracer) {
    _classCallCheck(this, Functions);

    this.realm = realm;
    this.functions = functions;
    this.moduleTracer = moduleTracer;
    this.writeEffects = new Map();
    this.functionExpressions = new Map();
  }
  // maps back from FunctionValue to the expression string


  _createClass(Functions, [{
    key: "_generateAdditionalFunctionCallsFromInput",
    value: function _generateAdditionalFunctionCallsFromInput() {
      var _this = this;

      // lookup functions
      var calls = [];

      var _loop = function _loop(fname) {
        var fun = void 0;
        var fnameAst = (0, _babelTemplate2.default)(fname)({}).expression;
        if (fnameAst) {
          try {
            var e = (0, _errors2.ignoreErrorsIn)(_this.realm, function () {
              return _this.realm.evaluateNodeForEffectsInGlobalEnv(fnameAst);
            });
            fun = e ? e[0] : undefined;
          } catch (ex) {
            if (!(ex instanceof _completions.ThrowCompletion)) throw ex;
          }
        }
        if (!(fun instanceof _index.FunctionValue)) {
          var error = new _errors.CompilerDiagnostic("Additional function " + fname + " not defined in the global environment", null, "PP1001", "FatalError");
          _this.realm.handleError(error);
          throw new _errors.FatalError();
        }
        _this.functionExpressions.set(fun, fname);
        var call = t.callExpression(fnameAst, []);
        calls.push([fun, call]);
      };

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (this.functions || [])[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var fname = _step.value;

          _loop(fname);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return calls;
    }

    // __reactComponentRoots

  }, {
    key: "__generateAdditionalFunctions",
    value: function __generateAdditionalFunctions(globalKey) {
      var recordedAdditionalFunctions = new Map();
      var realm = this.realm;
      var globalRecordedAdditionalFunctionsMap = this.moduleTracer.modules.logger.tryQuery(function () {
        return (0, _index2.Get)(realm, realm.$GlobalObject, globalKey);
      }, realm.intrinsics.undefined, false);
      (0, _invariant2.default)(globalRecordedAdditionalFunctionsMap instanceof _index.ObjectValue);
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = globalRecordedAdditionalFunctionsMap.getOwnPropertyKeysArray()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var funcId = _step2.value;

          var property = globalRecordedAdditionalFunctionsMap.properties.get(funcId);
          if (property) {
            var funcValue = property.descriptor && property.descriptor.value;
            if (!(funcValue instanceof _index.FunctionValue)) {
              (0, _invariant2.default)(funcValue instanceof _index.AbstractValue);
              realm.handleError(new _errors.CompilerDiagnostic("Additional Function Value " + funcId + " is an AbstractValue which is not allowed", undefined, "PP0001", "FatalError"));
              throw new _errors.FatalError("Additional Function values cannot be AbstractValues");
            }
            recordedAdditionalFunctions.set(funcValue, funcId);
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return recordedAdditionalFunctions;
    }
  }, {
    key: "checkReactRootComponents",
    value: function checkReactRootComponents(statistics, react) {
      var recordedReactRootComponents = this.__generateAdditionalFunctions("__reactComponentRoots");

      // Get write effects of the components
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = recordedReactRootComponents[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var _ref = _step3.value;

          var _ref2 = _slicedToArray(_ref, 1);

          var componentType = _ref2[0];

          var reconciler = new _reconcilation.Reconciler(this.realm, this.moduleTracer, statistics, react);
          (0, _invariant2.default)(componentType instanceof _index.ECMAScriptSourceFunctionValue, "only ECMAScriptSourceFunctionValue function values are supported as React root components");
          var result = reconciler.render(componentType);
          if ((0, _utils.valueIsClassComponent)(this.realm, componentType)) {
            var prototype = (0, _index2.Get)(this.realm, componentType, "prototype");
            (0, _invariant2.default)(prototype instanceof _index.ObjectValue);
            var renderMethod = (0, _index2.Get)(this.realm, prototype, "render");
            (0, _invariant2.default)(renderMethod instanceof _index.ECMAScriptSourceFunctionValue);
            this.writeEffects.set(renderMethod, result);
          } else {
            this.writeEffects.set(componentType, result);
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }
  }, {
    key: "_generateAdditionalFunctionCallsFromDirective",
    value: function _generateAdditionalFunctionCallsFromDirective() {
      var recordedAdditionalFunctions = this.__generateAdditionalFunctions("__additionalFunctions");

      // The additional functions we registered at runtime are recorded at:
      // global.__additionalFunctions.id
      var calls = [];
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = recordedAdditionalFunctions[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var _ref3 = _step4.value;

          var _ref4 = _slicedToArray(_ref3, 2);

          var funcValue = _ref4[0];
          var funcId = _ref4[1];

          // TODO #987: Make Additional Functions work with arguments
          calls.push([funcValue, t.callExpression(t.memberExpression(t.memberExpression(t.identifier("global"), t.identifier("__additionalFunctions")), t.identifier(funcId)), [])]);
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      return calls;
    }
  }, {
    key: "checkThatFunctionsAreIndependent",
    value: function checkThatFunctionsAreIndependent() {
      var calls = this._generateAdditionalFunctionCallsFromInput().concat(this._generateAdditionalFunctionCallsFromDirective());

      // Get write effects of the functions
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = calls[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var _ref5 = _step5.value;

          var _ref6 = _slicedToArray(_ref5, 2);

          var funcValue = _ref6[0];
          var call = _ref6[1];

          // This may throw a FatalError if there is an unrecoverable error in the called function
          // When that happens we cannot prepack the bundle.
          // There may also be warnings reported for errors that happen inside imported modules that can be postponed.

          var e = this.realm.evaluateNodeForEffectsInGlobalEnv(call, this.moduleTracer);
          this.writeEffects.set(funcValue, e);
        }

        // check that functions are independent
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      var conflicts = new Map();
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = calls[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var _ref7 = _step6.value;

          var _ref8 = _slicedToArray(_ref7, 2);

          var fun1 = _ref8[0];
          var call1 = _ref8[1];

          // Also do argument validation here
          var funcLength = fun1.getLength();
          if (funcLength && funcLength > 0) {
            // TODO #987: Make Additional Functions work with arguments
            throw new _errors.FatalError("TODO: implement arguments to additional functions");
          }
          var e1 = this.writeEffects.get(fun1);
          (0, _invariant2.default)(e1 !== undefined);
          var fun1Name = this.functionExpressions.get(fun1) || fun1.intrinsicName || "unknown";
          if (e1[0] instanceof _completions.Completion) {
            var error = new _errors.CompilerDiagnostic("Additional function " + fun1Name + " may terminate abruptly", e1[0].location, "PP1002", "FatalError");
            this.realm.handleError(error);
            throw new _errors.FatalError();
          }
          var _iteratorNormalCompletion8 = true;
          var _didIteratorError8 = false;
          var _iteratorError8 = undefined;

          try {
            for (var _iterator8 = calls[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
              var _ref9 = _step8.value;

              var _ref10 = _slicedToArray(_ref9, 2);

              var call2 = _ref10[1];

              if (call1 === call2) continue;
              this.reportWriteConflicts(fun1Name, conflicts, e1[3], call1, call2);
            }
          } catch (err) {
            _didIteratorError8 = true;
            _iteratorError8 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion8 && _iterator8.return) {
                _iterator8.return();
              }
            } finally {
              if (_didIteratorError8) {
                throw _iteratorError8;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6.return) {
            _iterator6.return();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }

      if (conflicts.size > 0) {
        var _iteratorNormalCompletion7 = true;
        var _didIteratorError7 = false;
        var _iteratorError7 = undefined;

        try {
          for (var _iterator7 = conflicts.values()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
            var diagnostic = _step7.value;
            this.realm.handleError(diagnostic);
          }
        } catch (err) {
          _didIteratorError7 = true;
          _iteratorError7 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion7 && _iterator7.return) {
              _iterator7.return();
            }
          } finally {
            if (_didIteratorError7) {
              throw _iteratorError7;
            }
          }
        }

        throw new _errors.FatalError();
      }
    }
  }, {
    key: "getAdditionalFunctionValuesToEffects",
    value: function getAdditionalFunctionValuesToEffects() {
      return this.writeEffects;
    }
  }, {
    key: "reportWriteConflicts",
    value: function reportWriteConflicts(fname, conflicts, pbs, call1, call2) {
      var _this2 = this;

      var reportConflict = function reportConflict(location) {
        var error = new _errors.CompilerDiagnostic("Property access conflicts with write in additional function " + fname, location, "PP1003", "FatalError");
        conflicts.set(location, error);
      };
      var writtenObjects = new Set();
      pbs.forEach(function (val, key, m) {
        writtenObjects.add(key.object);
      });
      var oldReportObjectGetOwnProperties = this.realm.reportObjectGetOwnProperties;
      this.realm.reportObjectGetOwnProperties = function (ob) {
        var location = _this2.realm.currentLocation;
        (0, _invariant2.default)(location);
        if (writtenObjects.has(ob) && !conflicts.has(location)) reportConflict(location);
      };
      var oldReportPropertyAccess = this.realm.reportPropertyAccess;
      this.realm.reportPropertyAccess = function (pb) {
        var location = _this2.realm.currentLocation;
        if (!location) return; // happens only when accessing an additional function property
        if (pbs.has(pb) && !conflicts.has(location)) reportConflict(location);
      };
      try {
        (0, _errors2.ignoreErrorsIn)(this.realm, function () {
          return _this2.realm.evaluateNodeForEffectsInGlobalEnv(call2, _this2.moduleTracer);
        });
      } finally {
        this.realm.reportPropertyAccess = oldReportPropertyAccess;
        this.realm.reportObjectGetOwnProperties = oldReportObjectGetOwnProperties;
      }
    }
  }]);

  return Functions;
}();
//# sourceMappingURL=functions.js.map