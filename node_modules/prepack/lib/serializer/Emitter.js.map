{"version":3,"sources":["../../src/serializer/Emitter.js"],"names":["Emitter","residualFunctions","mainBody","type","entries","_waitingForValues","Map","_waitingForBodies","_body","_declaredAbstractValues","_residualFunctions","_activeStack","_activeValues","Set","_activeBodies","_finalized","dependency","targetBody","push","has","add","includes","oldBody","statement","_processCurrentBody","lastDependency","pop","delete","_processValue","_isEmittingActiveGenerator","lastBody","length","size","body","a","get","undefined","shift","dependencies","func","emitNowOrAfterWaitingForDependencies","value","currentBody","_isGeneratorBody","_emitAfterWaitingForGeneratorBody","bodyStack","activeBody","slice","reverse","find","Array","isArray","values","delayReason","getReasonToWaitForDependencies","val","$BoundTargetFunction","$BoundThis","$BoundArguments","arg","addFunctionUsage","getBodyReference","hasIdentifier","valSerializeBodyStack","valActiveAncestorBody","_getFirstAncestorGeneratorWithActiveBody","indexOf","args","$ProxyTarget","$ProxyHandler","$Description","kind","getKind","proto","$Prototype","$DateValue","condition","_shouldEmitWithoutWaiting","beginEmitting","endEmitting","_emitAfterWaitingForValue","reason","set","b","emitAfterWaiting","_cloneGeneratorStack"],"mappings":"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","file":"Emitter.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport {\n  BoundFunctionValue,\n  ProxyValue,\n  AbstractValue,\n  FunctionValue,\n  Value,\n  ObjectValue,\n  SymbolValue,\n} from \"../values/index.js\";\nimport type { BabelNodeStatement } from \"babel-types\";\nimport type { SerializedBody } from \"./types.js\";\nimport { Generator } from \"../utils/generator.js\";\nimport invariant from \"../invariant.js\";\nimport { BodyReference } from \"./types.js\";\nimport { ResidualFunctions } from \"./ResidualFunctions.js\";\n\n// The emitter keeps track of a stack of what's currently being emitted.\n// There are two kinds of interesting dependencies the emitter is dealing with:\n// 1. Value dependencies:\n//    If an emission task depends on the result of another emission task which\n//    is still currently being emitted, then the emission task must be performed later,\n//    once the dependency is available.\n//    To this end, the emitter maintains the `_activeValues` and `_waitingForValues` datastructures.\n// 2. Generator dependencies:\n//    For each generator, there's a corresponding \"body\", i.e. a stream of babel statements\n//    that the emitter is appending to.\n//    There's always a \"current\" body that is currently being emitted to.\n//    There's also a distinguished `mainBody` to which all statements get directly or indirectly appended.\n//    If there are multiple generators/bodies involved, then they form a stack.\n//    Nested bodies are usually composed into an instruction emitted to the outer body.\n//    For example, two nested generators may yield the then and else-branch of an `if` statement.\n//    When an emission is supposed to target a body that is the current body, i.e. when it sits\n//    lower on the stack, then the emission task gets delayed until the next emission task on\n//    the lower body entry is finished.\n//    To this end, the emitter maintains the `_activeBodies` and `_waitingForBodies` datastructures.\nexport class Emitter {\n  constructor(residualFunctions: ResidualFunctions) {\n    let mainBody = { type: \"MainGenerator\", entries: [] };\n    this._waitingForValues = new Map();\n    this._waitingForBodies = new Map();\n    this._body = mainBody;\n    this._declaredAbstractValues = new Map();\n    this._residualFunctions = residualFunctions;\n    this._activeStack = [];\n    this._activeValues = new Set();\n    this._activeBodies = [mainBody];\n    this._finalized = false;\n  }\n\n  _finalized: boolean;\n  _activeStack: Array<string | Generator | Value>;\n  _activeValues: Set<Value>;\n  _activeBodies: Array<SerializedBody>;\n  _residualFunctions: ResidualFunctions;\n  _waitingForValues: Map<Value, Array<{ body: SerializedBody, dependencies: Array<Value>, func: () => void }>>;\n  _waitingForBodies: Map<SerializedBody, Array<{ dependencies: Array<Value>, func: () => void }>>;\n  _declaredAbstractValues: Map<AbstractValue, Array<SerializedBody>>;\n  _body: SerializedBody;\n\n  beginEmitting(dependency: string | Generator | Value, targetBody: SerializedBody) {\n    invariant(!this._finalized);\n    this._activeStack.push(dependency);\n    if (dependency instanceof Value) {\n      invariant(!this._activeValues.has(dependency));\n      this._activeValues.add(dependency);\n    } else if (dependency instanceof Generator) {\n      invariant(!this._activeBodies.includes(targetBody));\n      this._activeBodies.push(targetBody);\n    }\n    let oldBody = this._body;\n    this._body = targetBody;\n    return oldBody;\n  }\n  emit(statement: BabelNodeStatement) {\n    invariant(!this._finalized);\n    this._body.entries.push(statement);\n    this._processCurrentBody();\n  }\n  endEmitting(dependency: string | Generator | Value, oldBody: SerializedBody) {\n    invariant(!this._finalized);\n    let lastDependency = this._activeStack.pop();\n    invariant(dependency === lastDependency);\n    if (dependency instanceof Value) {\n      invariant(this._activeValues.has(dependency));\n      this._activeValues.delete(dependency);\n      this._processValue(dependency);\n    } else if (dependency instanceof Generator) {\n      invariant(this._isEmittingActiveGenerator());\n      this._activeBodies.pop();\n    }\n    let lastBody = this._body;\n    this._body = oldBody;\n    return lastBody;\n  }\n  finalize() {\n    invariant(!this._finalized);\n    invariant(this._activeBodies.length === 1);\n    invariant(this._activeBodies[0] === this._body);\n    this._processCurrentBody();\n    this._activeBodies.pop();\n    this._finalized = true;\n    invariant(this._waitingForBodies.size === 0);\n    invariant(this._waitingForValues.size === 0);\n    invariant(this._activeStack.length === 0);\n    invariant(this._activeValues.size === 0);\n    invariant(this._activeBodies.length === 0);\n  }\n  /**\n   * Emitter is emitting in two modes:\n   * 1. Emitting to entries in current active generator\n   * 2. Emitting to body of another scope(generator or residual function)\n   * This function checks the first condition above.\n   */\n  _isEmittingActiveGenerator(): boolean {\n    invariant(this._activeBodies.length > 0);\n    return this._activeBodies[this._activeBodies.length - 1] === this._body;\n  }\n  _isGeneratorBody(body: SerializedBody): boolean {\n    return body.type === \"MainGenerator\" || body.type === \"Generator\";\n  }\n  _processCurrentBody() {\n    if (!this._isEmittingActiveGenerator()) {\n      return;\n    }\n    let a = this._waitingForBodies.get(this._body);\n    if (a === undefined) return;\n    while (a.length > 0) {\n      let { dependencies, func } = a.shift();\n      this.emitNowOrAfterWaitingForDependencies(dependencies, func);\n    }\n    this._waitingForBodies.delete(this._body);\n  }\n  _processValue(value: Value) {\n    let a = this._waitingForValues.get(value);\n    if (a === undefined) return;\n    let currentBody = this._body;\n    while (a.length > 0) {\n      let { body, dependencies, func } = a.shift();\n      // If body is not generator body no need to wait for it.\n      if (this._isGeneratorBody(body) && body !== currentBody) {\n        this._emitAfterWaitingForGeneratorBody(body, dependencies, func);\n      } else {\n        this.emitNowOrAfterWaitingForDependencies(dependencies, func, body);\n      }\n    }\n    this._waitingForValues.delete(value);\n  }\n\n  // Find the first ancestor in input generator body stack that is in current active stack.\n  // It can always find one because the bottom one in the stack is the main generator.\n  _getFirstAncestorGeneratorWithActiveBody(bodyStack: Array<SerializedBody>): SerializedBody {\n    const activeBody = bodyStack.slice().reverse().find(body => this._activeBodies.includes(body));\n    invariant(activeBody);\n    return activeBody;\n  }\n\n  // Serialization of a statement related to a value MUST be delayed if\n  // the creation of the value's identity requires the availability of either:\n  // 1. a time-dependent value that is declared by some generator entry\n  //    that has not yet been processed\n  //    (tracked by `_declaredAbstractValues`), or\n  // 2. a value that is also currently being serialized\n  //    (tracked by `_activeValues`).\n  // 3. a generator body that is higher(near top) in generator body stack.\n  //    (tracked by `_activeBodies`)\n  getReasonToWaitForDependencies(dependencies: Value | Array<Value>): void | Value | SerializedBody {\n    invariant(!this._finalized);\n    if (Array.isArray(dependencies)) {\n      let values = ((dependencies: any): Array<Value>);\n      for (let value of values) {\n        let delayReason = this.getReasonToWaitForDependencies(value);\n        if (delayReason) return delayReason;\n      }\n      return undefined;\n    }\n\n    let val = ((dependencies: any): Value);\n    if (this._activeValues.has(val)) return val;\n\n    let delayReason;\n    if (val instanceof BoundFunctionValue) {\n      delayReason = this.getReasonToWaitForDependencies(val.$BoundTargetFunction);\n      if (delayReason) return delayReason;\n      delayReason = this.getReasonToWaitForDependencies(val.$BoundThis);\n      if (delayReason) return delayReason;\n      for (let arg of val.$BoundArguments) {\n        delayReason = this.getReasonToWaitForDependencies(arg);\n        if (delayReason) return delayReason;\n      }\n    } else if (val instanceof FunctionValue) {\n      this._residualFunctions.addFunctionUsage(val, this.getBodyReference());\n      return undefined;\n    } else if (val instanceof AbstractValue) {\n      if (val.hasIdentifier()) {\n        const valSerializeBodyStack = this._declaredAbstractValues.get(val);\n        if (!valSerializeBodyStack) {\n          // Hasn't been serialized yet.\n          return val;\n        } else {\n          // The dependency has already been serialized(declared). But we may still have to wait for\n          // current generator body to be available, under following conditions:\n          // 1. Currently emitting in generator body. -- and\n          // 2. Not emitting in current active generator.(otherwise no need to wait) -- and\n          // 3. Dependency's active ancestor generator body is higher(near top) in generator stack than current body.\n          const valActiveAncestorBody = this._getFirstAncestorGeneratorWithActiveBody(valSerializeBodyStack);\n          invariant(this._activeBodies.includes(valActiveAncestorBody));\n\n          if (this._isGeneratorBody(this._body)) {\n            invariant(this._activeBodies.includes(this._body));\n            if (\n              !this._isEmittingActiveGenerator() &&\n              this._activeBodies.indexOf(valActiveAncestorBody) > this._activeBodies.indexOf(this._body)\n            ) {\n              return this._body;\n            }\n          }\n        }\n      }\n      for (let arg of val.args) {\n        delayReason = this.getReasonToWaitForDependencies(arg);\n        if (delayReason) return delayReason;\n      }\n    } else if (val instanceof ProxyValue) {\n      delayReason = this.getReasonToWaitForDependencies(val.$ProxyTarget);\n      if (delayReason) return delayReason;\n      delayReason = this.getReasonToWaitForDependencies(val.$ProxyHandler);\n      if (delayReason) return delayReason;\n    } else if (val instanceof SymbolValue) {\n      if (val.$Description instanceof Value) {\n        delayReason = this.getReasonToWaitForDependencies(val.$Description);\n        if (delayReason) return delayReason;\n      }\n    } else if (val instanceof ObjectValue) {\n      let kind = val.getKind();\n      switch (kind) {\n        case \"Object\":\n          let proto = val.$Prototype;\n          if (proto instanceof ObjectValue) {\n            delayReason = this.getReasonToWaitForDependencies(val.$Prototype);\n            if (delayReason) return delayReason;\n          }\n          break;\n        case \"Date\":\n          invariant(val.$DateValue !== undefined);\n          delayReason = this.getReasonToWaitForDependencies(val.$DateValue);\n          if (delayReason) return delayReason;\n          break;\n        default:\n          break;\n      }\n    }\n\n    return undefined;\n  }\n  // Wait for a known-to-be active value if a condition is met.\n  getReasonToWaitForActiveValue(value: Value, condition: boolean): void | Value {\n    invariant(!this._finalized);\n    invariant(this._activeValues.has(value));\n    return condition ? value : undefined;\n  }\n  _shouldEmitWithoutWaiting(delayReason: void | Value | SerializedBody, targetBody?: SerializedBody): boolean {\n    /**\n     * We can directly emit without waiting if:\n     * 1. No delayReason\n     * 2. delayReason is a generator body while the target body we are not emitting into is not a generator body.\n     */\n    return (\n      !delayReason ||\n      (!(delayReason instanceof Value) &&\n        this._isGeneratorBody(delayReason) &&\n        targetBody !== undefined &&\n        !this._isGeneratorBody(targetBody))\n    );\n  }\n  emitAfterWaiting(\n    delayReason: void | Value | SerializedBody,\n    dependencies: Array<Value>,\n    func: () => void,\n    targetBody?: SerializedBody\n  ) {\n    if (this._shouldEmitWithoutWaiting(delayReason, targetBody)) {\n      if (targetBody === undefined || targetBody === this._body) {\n        // Emit into current body.\n        func();\n      } else {\n        invariant(!this._isGeneratorBody(targetBody));\n        const oldBody = this.beginEmitting(targetBody.type, targetBody);\n        func();\n        this.endEmitting(targetBody.type, oldBody);\n      }\n    } else {\n      invariant(delayReason !== undefined);\n      if (delayReason instanceof Value) {\n        this._emitAfterWaitingForValue(\n          delayReason,\n          dependencies,\n          targetBody === undefined ? this._body : targetBody,\n          func\n        );\n      } else if (this._isGeneratorBody(delayReason)) {\n        // delayReason is a generator body.\n        this._emitAfterWaitingForGeneratorBody(delayReason, dependencies, func);\n      } else {\n        // Unknown delay reason.\n        invariant(false);\n      }\n    }\n  }\n  _emitAfterWaitingForValue(reason: Value, dependencies: Array<Value>, targetBody: SerializedBody, func: () => void) {\n    invariant(!this._finalized);\n    invariant(\n      !(reason instanceof AbstractValue && this._declaredAbstractValues.has(reason)) || this._activeValues.has(reason)\n    );\n    let a = this._waitingForValues.get(reason);\n    if (a === undefined) this._waitingForValues.set(reason, (a = []));\n    a.push({ body: targetBody, dependencies, func });\n  }\n  _emitAfterWaitingForGeneratorBody(reason: SerializedBody, dependencies: Array<Value>, func: () => void) {\n    invariant(this._isGeneratorBody(reason));\n    invariant(!this._finalized);\n    invariant(this._activeBodies.includes(reason));\n    let b = this._waitingForBodies.get(reason);\n    if (b === undefined) this._waitingForBodies.set(reason, (b = []));\n    b.push({ dependencies, func });\n  }\n  emitNowOrAfterWaitingForDependencies(dependencies: Array<Value>, func: () => void, targetBody?: SerializedBody) {\n    invariant(!this._finalized);\n    this.emitAfterWaiting(this.getReasonToWaitForDependencies(dependencies), dependencies, func, targetBody);\n  }\n  _cloneGeneratorStack() {\n    return this._activeBodies.slice();\n  }\n  declare(value: AbstractValue) {\n    invariant(!this._finalized);\n    invariant(!this._activeValues.has(value));\n    invariant(value.hasIdentifier());\n    invariant(this._isEmittingActiveGenerator());\n    this._declaredAbstractValues.set(value, this._cloneGeneratorStack());\n    this._processValue(value);\n  }\n  hasBeenDeclared(value: AbstractValue) {\n    invariant(!this._finalized);\n    return this._declaredAbstractValues.has(value);\n  }\n  getBody(): SerializedBody {\n    return this._body;\n  }\n  getBodyReference() {\n    invariant(!this._finalized);\n    return new BodyReference(this._body, this._body.entries.length);\n  }\n}\n"]}