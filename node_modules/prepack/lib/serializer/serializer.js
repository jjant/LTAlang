"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Serializer = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright (c) 2017-present, Facebook, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * This source code is licensed under the BSD-style license found in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * LICENSE file in the root directory of this source tree. An additional grant
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * of patent rights can be found in the PATENTS file in the same directory.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _realm = require("../realm.js");

var _errors = require("../errors.js");

var _completions = require("../completions.js");

var _generator = require("../utils/generator.js");

var _babelGenerator = require("babel-generator");

var _babelGenerator2 = _interopRequireDefault(_babelGenerator);

var _traverseFast = require("../utils/traverse-fast.js");

var _traverseFast2 = _interopRequireDefault(_traverseFast);

var _utils = require("../flow/utils.js");

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _types = require("./types.js");

var _functions = require("./functions.js");

var _logger = require("./logger.js");

var _modules = require("./modules.js");

var _LoggingTracer = require("./LoggingTracer.js");

var _ResidualHeapVisitor = require("./ResidualHeapVisitor.js");

var _ResidualHeapSerializer = require("./ResidualHeapSerializer.js");

var _ResidualHeapValueIdentifiers = require("./ResidualHeapValueIdentifiers.js");

var _LazyObjectsSerializer = require("./LazyObjectsSerializer.js");

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Serializer = exports.Serializer = function () {
  function Serializer(realm) {
    var serializerOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Serializer);

    (0, _invariant2.default)(realm.useAbstractInterpretation);
    // Start tracking mutations
    realm.generator = new _generator.Generator(realm);

    this.realm = realm;
    this.logger = new _logger.Logger(this.realm, !!serializerOptions.internalDebug);
    this.statistics = new _types.SerializerStatistics();
    this.modules = new _modules.Modules(this.realm, this.logger, this.statistics, !!serializerOptions.logModules, !!serializerOptions.delayUnsupportedRequires);
    this.functions = new _functions.Functions(this.realm, serializerOptions.additionalFunctions, this.modules.moduleTracer);
    if (serializerOptions.trace) this.realm.tracers.push(new _LoggingTracer.LoggingTracer(this.realm));

    this.options = serializerOptions;
    this.react = {
      usedReactElementKeys: new Set()
    };
  }

  _createClass(Serializer, [{
    key: "_execute",
    value: function _execute(sources) {
      var sourceMaps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var realm = this.realm;

      var _realm$$GlobalEnv$exe = realm.$GlobalEnv.executeSources(sources, "script", function (ast) {
        var realmPreludeGenerator = realm.preludeGenerator;
        (0, _invariant2.default)(realmPreludeGenerator);
        var forbiddenNames = realmPreludeGenerator.nameGenerator.forbiddenNames;
        (0, _traverseFast2.default)(ast, function (node) {
          if (!t.isIdentifier(node)) return false;

          forbiddenNames.add(node.name);
          return true;
        });
      }),
          _realm$$GlobalEnv$exe2 = _slicedToArray(_realm$$GlobalEnv$exe, 2),
          res = _realm$$GlobalEnv$exe2[0],
          code = _realm$$GlobalEnv$exe2[1];

      if (res instanceof _completions.AbruptCompletion) {
        var context = new _realm.ExecutionContext();
        realm.pushContext(context);
        try {
          this.logger.logCompletion(res);
        } finally {
          realm.popContext(context);
        }
        var diagnostic = new _errors.CompilerDiagnostic("Global code may end abruptly", res.location, "PP0016", "FatalError");
        realm.handleError(diagnostic);
        throw new _errors.FatalError();
      }
      return code;
    }
  }, {
    key: "init",
    value: function init(sources) {
      var sourceMaps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      // Phase 1: Let's interpret.
      var timingStats = this.options.profile ? new _types.TimingStatistics() : undefined;
      if (timingStats !== undefined) {
        timingStats.totalTime = Date.now();
        timingStats.globalCodeTime = Date.now();
      }
      var code = this._execute(sources);
      if (timingStats !== undefined) timingStats.globalCodeTime = Date.now() - timingStats.globalCodeTime;
      if (this.logger.hasErrors()) return undefined;
      this.modules.resolveInitializedModules();
      this.functions.checkThatFunctionsAreIndependent();
      var reactStatistics = null;
      if (this.realm.react.enabled) {
        reactStatistics = new _types.ReactStatistics();
        this.functions.checkReactRootComponents(reactStatistics, this.react);
      }

      if (this.options.initializeMoreModules) {
        if (timingStats !== undefined) timingStats.initializeMoreModulesTime = Date.now();
        this.modules.initializeMoreModules();
        if (this.logger.hasErrors()) return undefined;
        if (timingStats !== undefined) timingStats.initializeMoreModulesTime = Date.now() - timingStats.initializeMoreModulesTime;
      }

      var additionalFunctionValuesAndEffects = this.functions.getAdditionalFunctionValuesToEffects();
      //Deep traversal of the heap to identify the necessary scope of residual functions
      if (timingStats !== undefined) timingStats.deepTraversalTime = Date.now();
      var residualHeapVisitor = new _ResidualHeapVisitor.ResidualHeapVisitor(this.realm, this.logger, this.modules, additionalFunctionValuesAndEffects);
      residualHeapVisitor.visitRoots();
      if (this.logger.hasErrors()) return undefined;
      if (timingStats !== undefined) timingStats.deepTraversalTime = Date.now() - timingStats.deepTraversalTime;

      // Phase 2: Let's serialize the heap and generate code.
      // Serialize for the first time in order to gather reference counts
      var residualHeapValueIdentifiers = new _ResidualHeapValueIdentifiers.ResidualHeapValueIdentifiers();

      if (this.options.inlineExpressions) {
        if (timingStats !== undefined) timingStats.referenceCountsTime = Date.now();
        residualHeapValueIdentifiers.initPass1();
        new _ResidualHeapSerializer.ResidualHeapSerializer(this.realm, this.logger, this.modules, residualHeapValueIdentifiers, residualHeapVisitor.inspector, residualHeapVisitor.values, residualHeapVisitor.functionInstances, residualHeapVisitor.functionInfos, this.options, residualHeapVisitor.referencedDeclaredValues, additionalFunctionValuesAndEffects, residualHeapVisitor.additionalFunctionValueInfos, this.statistics, this.react).serialize();
        if (this.logger.hasErrors()) return undefined;
        if (timingStats !== undefined) timingStats.referenceCountsTime = Date.now() - timingStats.referenceCountsTime;
        residualHeapValueIdentifiers.initPass2();
      }

      // Serialize for a second time, using reference counts to minimize number of generated identifiers
      if (timingStats !== undefined) timingStats.serializePassTime = Date.now();
      var TargetSerializer = this.options.lazyObjectsRuntime != null ? _LazyObjectsSerializer.LazyObjectsSerializer : _ResidualHeapSerializer.ResidualHeapSerializer;
      var residualHeapSerializer = new TargetSerializer(this.realm, this.logger, this.modules, residualHeapValueIdentifiers, residualHeapVisitor.inspector, residualHeapVisitor.values, residualHeapVisitor.functionInstances, residualHeapVisitor.functionInfos, this.options, residualHeapVisitor.referencedDeclaredValues, additionalFunctionValuesAndEffects, residualHeapVisitor.additionalFunctionValueInfos, this.statistics, this.react);

      var ast = residualHeapSerializer.serialize();
      if (this.realm.react.enabled && this.realm.react.flowRequired) {
        (0, _utils.stripFlowTypeAnnotations)(ast);
      }
      var generated = (0, _babelGenerator2.default)(ast, { sourceMaps: sourceMaps }, code);
      if (timingStats !== undefined) {
        timingStats.serializePassTime = Date.now() - timingStats.serializePassTime;
        timingStats.totalTime = Date.now() - timingStats.totalTime;
      }
      (0, _invariant2.default)(!this.logger.hasErrors());
      if (this.options.logStatistics) residualHeapSerializer.statistics.log();
      return {
        code: generated.code,
        map: generated.map,
        reactStatistics: reactStatistics,
        statistics: residualHeapSerializer.statistics,
        timingStats: timingStats
      };
    }
  }]);

  return Serializer;
}();
//# sourceMappingURL=serializer.js.map