"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ResidualHeapVisitor = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright (c) 2017-present, Facebook, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * This source code is licensed under the BSD-style license found in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * LICENSE file in the root directory of this source tree. An additional grant
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * of patent rights can be found in the PATENTS file in the same directory.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _environment = require("../environment.js");

var _errors = require("../errors.js");

var _realm = require("../realm.js");

var _index = require("../methods/index.js");

var _index2 = require("../values/index.js");

var _Error = require("../intrinsics/ecma262/Error.js");

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

var _generator = require("../utils/generator.js");

var _babelTraverse = require("babel-traverse");

var _babelTraverse2 = _interopRequireDefault(_babelTraverse);

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _visitors = require("./visitors.js");

var _logger = require("./logger.js");

var _modules = require("./modules.js");

var _ResidualHeapInspector = require("./ResidualHeapInspector.js");

var _utils = require("./utils.js");

var _singletons = require("../singletons.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* This class visits all values that are reachable in the residual heap.
   In particular, this "filters out" values that are...
   - captured by a DeclarativeEnvironmentRecord, but not actually used by any closure.
   - Unmodified prototype objects
   TODO #680: Figure out minimal set of values that need to be kept alive for WeakSet and WeakMap instances.
*/
var ResidualHeapVisitor = exports.ResidualHeapVisitor = function () {
  function ResidualHeapVisitor(realm, logger, modules, additionalFunctionValuesAndEffects) {
    _classCallCheck(this, ResidualHeapVisitor);

    (0, _invariant2.default)(realm.useAbstractInterpretation);
    this.realm = realm;
    this.logger = logger;
    this.modules = modules;

    this.declarativeEnvironmentRecordsBindings = new Map();
    this.globalBindings = new Map();
    this.functionInfos = new Map();
    this.functionInstances = new Map();
    this.values = new Map();
    var generator = this.realm.generator;
    (0, _invariant2.default)(generator);
    this.scope = this.commonScope = generator;
    this.inspector = new _ResidualHeapInspector.ResidualHeapInspector(realm, logger);
    this.referencedDeclaredValues = new Set();
    this.delayedVisitGeneratorEntries = [];
    this.additionalFunctionValuesAndEffects = additionalFunctionValuesAndEffects;
    this.equivalenceSet = new _index.HashSet();
    this.additionalFunctionValueInfos = new Map();
  }

  // Caches that ensure one ResidualFunctionBinding exists per (record, name) pair

  // Either the realm's generator or the FunctionValue of an additional function to serialize


  _createClass(ResidualHeapVisitor, [{
    key: "_withScope",
    value: function _withScope(scope, f) {
      var oldScope = this.scope;
      this.scope = scope;
      f();
      this.scope = oldScope;
    }
  }, {
    key: "visitObjectProperty",
    value: function visitObjectProperty(binding) {
      var desc = binding.descriptor;
      if (desc === undefined) return; //deleted
      var obj = binding.object;
      if (obj instanceof _index2.AbstractObjectValue || !this.inspector.canIgnoreProperty(obj, binding.key)) {
        this.visitDescriptor(desc);
      }
    }
  }, {
    key: "visitObjectProperties",
    value: function visitObjectProperties(obj, kind) {
      // visit properties
      if (kind !== "ReactElement") {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = obj.symbols[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _ref = _step.value;

            var _ref2 = _slicedToArray(_ref, 2);

            var symbol = _ref2[0];
            var propertyBinding = _ref2[1];

            (0, _invariant2.default)(propertyBinding);
            var desc = propertyBinding.descriptor;
            if (desc === undefined) continue; //deleted
            this.visitDescriptor(desc);
            this.visitValue(symbol);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }

      // visit properties
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = obj.properties[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _ref3 = _step2.value;

          var _ref4 = _slicedToArray(_ref3, 2);

          var propertyBindingKey = _ref4[0];
          var propertyBindingValue = _ref4[1];

          // we don't want to the $$typeof or _owner properties
          // as this is contained within the JSXElement, otherwise
          // they we be need to be emitted during serialization
          if (kind === "ReactElement" && (propertyBindingKey === "$$typeof" || propertyBindingKey === "_owner")) {
            continue;
          }
          (0, _invariant2.default)(propertyBindingValue);
          this.visitObjectProperty(propertyBindingValue);
        }

        // inject properties with computed names
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      if (obj.unknownProperty !== undefined) {
        var _desc = obj.unknownProperty.descriptor;
        if (_desc !== undefined) {
          var val = _desc.value;
          (0, _invariant2.default)(val instanceof _index2.AbstractValue);
          this.visitObjectPropertiesWithComputedNames(val);
        }
      }

      // prototype
      if (kind !== "ReactElement") {
        // we don't want to the ReactElement prototype visited
        // as this is contained within the JSXElement, otherwise
        // they we be need to be emitted during serialization
        this.visitObjectPrototype(obj);
      }
      if (obj instanceof _index2.FunctionValue) this.visitConstructorPrototype(obj);
    }
  }, {
    key: "visitObjectPrototype",
    value: function visitObjectPrototype(obj) {
      var proto = obj.$Prototype;

      var kind = obj.getKind();
      if (proto === this.realm.intrinsics[kind + "Prototype"]) return;

      this.visitValue(proto);
    }
  }, {
    key: "visitConstructorPrototype",
    value: function visitConstructorPrototype(func) {
      // If the original prototype object was mutated,
      // request its serialization here as this might be observable by
      // residual code.
      var prototype = _ResidualHeapInspector.ResidualHeapInspector.getPropertyValue(func, "prototype");
      if (prototype instanceof _index2.ObjectValue && prototype.originalConstructor === func && !this.inspector.isDefaultPrototype(prototype)) {
        this.visitValue(prototype);
      }
    }
  }, {
    key: "visitObjectPropertiesWithComputedNames",
    value: function visitObjectPropertiesWithComputedNames(absVal) {
      (0, _invariant2.default)(absVal.args.length === 3);
      var cond = absVal.args[0];
      (0, _invariant2.default)(cond instanceof _index2.AbstractValue);
      if (cond.kind === "template for property name condition") {
        var P = cond.args[0];
        (0, _invariant2.default)(P instanceof _index2.AbstractValue);
        var V = absVal.args[1];
        var earlier_props = absVal.args[2];
        if (earlier_props instanceof _index2.AbstractValue) this.visitObjectPropertiesWithComputedNames(earlier_props);
        this.visitValue(P);
        this.visitValue(V);
      } else {
        // conditional assignment
        absVal.args[0] = this.visitEquivalentValue(cond);
        var consequent = absVal.args[1];
        (0, _invariant2.default)(consequent instanceof _index2.AbstractValue);
        var alternate = absVal.args[2];
        (0, _invariant2.default)(alternate instanceof _index2.AbstractValue);
        this.visitObjectPropertiesWithComputedNames(consequent);
        this.visitObjectPropertiesWithComputedNames(alternate);
      }
    }
  }, {
    key: "visitDescriptor",
    value: function visitDescriptor(desc) {
      (0, _invariant2.default)(desc.value === undefined || desc.value instanceof _index2.Value);
      if (desc.joinCondition !== undefined) {
        desc.joinCondition = this.visitEquivalentValue(desc.joinCondition);
        if (desc.descriptor1 !== undefined) this.visitDescriptor(desc.descriptor1);
        if (desc.descriptor2 !== undefined) this.visitDescriptor(desc.descriptor2);
        return;
      }
      if (desc.value !== undefined) desc.value = this.visitEquivalentValue(desc.value);
      if (desc.get !== undefined) this.visitValue(desc.get);
      if (desc.set !== undefined) this.visitValue(desc.set);
    }
  }, {
    key: "visitDeclarativeEnvironmentRecordBinding",
    value: function visitDeclarativeEnvironmentRecordBinding(r, n) {
      var residualFunctionBindings = this.declarativeEnvironmentRecordsBindings.get(r);
      if (!residualFunctionBindings) {
        residualFunctionBindings = new Map();
        this.declarativeEnvironmentRecordsBindings.set(r, residualFunctionBindings);
      }
      var residualFunctionBinding = residualFunctionBindings.get(n);
      if (!residualFunctionBinding) {
        var realm = this.realm;
        var binding = r.bindings[n];
        (0, _invariant2.default)(!binding.deletable);
        var value = binding.initialized && binding.value || realm.intrinsics.undefined;
        residualFunctionBinding = { value: value, modified: false, declarativeEnvironmentRecord: r };
        residualFunctionBindings.set(n, residualFunctionBinding);
      }
      (0, _invariant2.default)(residualFunctionBinding.value !== undefined);
      residualFunctionBinding.value = this.visitEquivalentValue(residualFunctionBinding.value);
      return residualFunctionBinding;
    }
  }, {
    key: "visitValueArray",
    value: function visitValueArray(val) {
      this.visitObjectProperties(val);
      var realm = this.realm;
      var lenProperty = (0, _index.Get)(realm, val, "length");
      if (lenProperty instanceof _index2.AbstractValue || (0, _index.ToLength)(realm, lenProperty) !== (0, _utils.getSuggestedArrayLiteralLength)(realm, val)) {
        this.visitValue(lenProperty);
      }
    }
  }, {
    key: "visitValueMap",
    value: function visitValueMap(val) {
      var kind = val.getKind();

      var entries = void 0;
      if (kind === "Map") {
        entries = val.$MapData;
      } else {
        (0, _invariant2.default)(kind === "WeakMap");
        entries = val.$WeakMapData;
      }
      (0, _invariant2.default)(entries !== undefined);
      var len = entries.length;

      for (var i = 0; i < len; i++) {
        var _entry = entries[i];
        var key = _entry.$Key;
        var value = _entry.$Value;
        if (key === undefined || value === undefined) continue;
        this.visitValue(key);
        this.visitValue(value);
      }
    }
  }, {
    key: "visitValueSet",
    value: function visitValueSet(val) {
      var kind = val.getKind();

      var entries = void 0;
      if (kind === "Set") {
        entries = val.$SetData;
      } else {
        (0, _invariant2.default)(kind === "WeakSet");
        entries = val.$WeakSetData;
      }
      (0, _invariant2.default)(entries !== undefined);
      var len = entries.length;

      for (var i = 0; i < len; i++) {
        var _entry2 = entries[i];
        if (_entry2 === undefined) continue;
        this.visitValue(_entry2);
      }
    }
  }, {
    key: "visitValueFunction",
    value: function visitValueFunction(val) {
      var _this = this;

      this.visitObjectProperties(val);

      if (val instanceof _index2.BoundFunctionValue) {
        this.visitValue(val.$BoundTargetFunction);
        this.visitValue(val.$BoundThis);
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = val.$BoundArguments[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var boundArg = _step3.value;
            this.visitValue(boundArg);
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        return;
      }

      (0, _invariant2.default)(!(val instanceof _index2.NativeFunctionValue), "all native function values should be intrinsics");

      (0, _invariant2.default)(val instanceof _index2.ECMAScriptSourceFunctionValue);
      (0, _invariant2.default)(val.constructor === _index2.ECMAScriptSourceFunctionValue);
      var formalParameters = val.$FormalParameters;
      (0, _invariant2.default)(formalParameters != null);
      var code = val.$ECMAScriptCode;
      (0, _invariant2.default)(code != null);

      var functionInfo = this.functionInfos.get(code);

      if (!functionInfo) {
        functionInfo = {
          unbound: new Set(),
          modified: new Set(),
          usesArguments: false,
          usesThis: false
        };
        this.functionInfos.set(code, functionInfo);

        var state = {
          tryQuery: this.logger.tryQuery.bind(this.logger),
          val: val,
          functionInfo: functionInfo,
          realm: this.realm
        };

        (0, _babelTraverse2.default)(t.file(t.program([t.expressionStatement(t.functionExpression(null, formalParameters, code))])), _visitors.ClosureRefVisitor, null, state);

        if (val.isResidual && functionInfo.unbound.size) {
          if (!val.isUnsafeResidual) {
            this.logger.logError(val, "residual function " + ((0, _Error.describeLocation)(this.realm, val, undefined, code.loc) || "(unknown)") + " refers to the following identifiers defined outside of the local scope: " + Object.keys(functionInfo.unbound).join(", "));
          }
        }
      }

      var residualFunctionBindings = new Map();
      this._withScope(val, function () {
        (0, _invariant2.default)(functionInfo);

        var _loop = function _loop(innerName) {
          var residualFunctionBinding = void 0;
          var doesNotMatter = true;
          var reference = _this.logger.tryQuery(function () {
            return _singletons.Environment.ResolveBinding(_this.realm, innerName, doesNotMatter, val.$Environment);
          }, undefined, false /* The only reason `ResolveBinding` might fail is because the global object is partial. But in that case, we know that we are dealing with the common scope. */
          );
          if (reference === undefined || _singletons.Environment.IsUnresolvableReference(_this.realm, reference) || reference.base instanceof _environment.GlobalEnvironmentRecord) {
            residualFunctionBinding = _this.visitGlobalBinding(innerName);
          } else {
            (0, _invariant2.default)(!_singletons.Environment.IsUnresolvableReference(_this.realm, reference));
            var referencedBase = reference.base;
            var referencedName = reference.referencedName;
            if (typeof referencedName !== "string") {
              throw new _errors.FatalError("TODO: do not know how to visit reference with symbol");
            }
            (0, _invariant2.default)(referencedBase instanceof _environment.DeclarativeEnvironmentRecord);
            residualFunctionBinding = _this.visitDeclarativeEnvironmentRecordBinding(referencedBase, referencedName);
          }
          residualFunctionBindings.set(innerName, residualFunctionBinding);
          if (functionInfo.modified.has(innerName)) residualFunctionBinding.modified = true;
        };

        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = functionInfo.unbound[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var innerName = _step4.value;

            _loop(innerName);
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }
      });

      this.functionInstances.set(val, {
        residualFunctionBindings: residualFunctionBindings,
        functionValue: val,
        scopeInstances: new Set()
      });
    }
  }, {
    key: "visitValueObject",
    value: function visitValueObject(val) {
      var kind = val.getKind();
      this.visitObjectProperties(val, kind);

      // If this object is a prototype object that was implicitly created by the runtime
      // for a constructor, then we can obtain a reference to this object
      // in a special way that's handled alongside function serialization.
      var constructor = val.originalConstructor;
      if (constructor !== undefined) {
        this.visitValue(constructor);
        return;
      }

      switch (kind) {
        case "RegExp":
        case "Number":
        case "String":
        case "Boolean":
        case "ReactElement":
        case "ArrayBuffer":
          return;
        case "Date":
          var dateValue = val.$DateValue;
          (0, _invariant2.default)(dateValue !== undefined);
          this.visitValue(dateValue);
          return;
        case "Float32Array":
        case "Float64Array":
        case "Int8Array":
        case "Int16Array":
        case "Int32Array":
        case "Uint8Array":
        case "Uint16Array":
        case "Uint32Array":
        case "Uint8ClampedArray":
        case "DataView":
          var buf = val.$ViewedArrayBuffer;
          (0, _invariant2.default)(buf !== undefined);
          this.visitValue(buf);
          return;
        case "Map":
        case "WeakMap":
          this.visitValueMap(val);
          return;
        case "Set":
        case "WeakSet":
          this.visitValueSet(val);
          return;
        default:
          if (kind !== "Object") this.logger.logError(val, "Object of kind " + kind + " is not supported in residual heap.");
          if (this.$ParameterMap !== undefined) this.logger.logError(val, "Arguments object is not supported in residual heap.");
          return;
      }
    }
  }, {
    key: "visitValueSymbol",
    value: function visitValueSymbol(val) {
      if (val.$Description) this.visitValue(val.$Description);
    }
  }, {
    key: "visitValueProxy",
    value: function visitValueProxy(val) {
      this.visitValue(val.$ProxyTarget);
      this.visitValue(val.$ProxyHandler);
    }
  }, {
    key: "visitAbstractValue",
    value: function visitAbstractValue(val) {
      if (val.kind === "sentinel member expression") this.logger.logError(val, "expressions of type o[p] are not yet supported for partially known o and unknown p");
      for (var i = 0, n = val.args.length; i < n; i++) {
        val.args[i] = this.visitEquivalentValue(val.args[i]);
      }
    }
  }, {
    key: "_mark",
    value: function _mark(val) {
      var scopes = this.values.get(val);
      if (scopes === undefined) this.values.set(val, scopes = new Set());
      if (scopes.has(this.scope)) return false;
      scopes.add(this.scope);
      return true;
    }
  }, {
    key: "visitEquivalentValue",
    value: function visitEquivalentValue(val) {
      if (val instanceof _index2.AbstractValue) {
        var equivalentValue = this.equivalenceSet.add(val);
        if (this._mark(equivalentValue)) this.visitAbstractValue(equivalentValue);
        return equivalentValue;
      }
      this.visitValue(val);
      return val;
    }
  }, {
    key: "visitValue",
    value: function visitValue(val) {
      var _this2 = this;

      (0, _invariant2.default)(!val.refuseSerialization);
      if (val instanceof _index2.AbstractValue) {
        if (this._mark(val)) this.visitAbstractValue(val);
      } else if (val.isIntrinsic()) {
        // All intrinsic values exist from the beginning of time...
        // ...except for a few that come into existance as templates for abstract objects (TODO #882).
        if (val.isTemplate) this._mark(val);else this._withScope(this.commonScope, function () {
          _this2._mark(val);
        });
      } else if (val instanceof _index2.EmptyValue) {
        this._mark(val);
      } else if (_ResidualHeapInspector.ResidualHeapInspector.isLeaf(val)) {
        this._mark(val);
      } else if ((0, _index.IsArray)(this.realm, val)) {
        (0, _invariant2.default)(val instanceof _index2.ObjectValue);
        if (this._mark(val)) this.visitValueArray(val);
      } else if (val instanceof _index2.ProxyValue) {
        if (this._mark(val)) this.visitValueProxy(val);
      } else if (val instanceof _index2.FunctionValue) {
        // Function declarations should get hoisted in common scope so that instances only get allocated once
        this._withScope(this.commonScope, function () {
          (0, _invariant2.default)(val instanceof _index2.FunctionValue);
          if (_this2._mark(val)) _this2.visitValueFunction(val);
        });
      } else if (val instanceof _index2.SymbolValue) {
        if (this._mark(val)) this.visitValueSymbol(val);
      } else {
        (0, _invariant2.default)(val instanceof _index2.ObjectValue);

        // Prototypes are reachable via function declarations, and those get hoisted, so we need to move
        // prototype initialization to the common scope code as well.
        if (val.originalConstructor !== undefined) {
          this._withScope(this.commonScope, function () {
            (0, _invariant2.default)(val instanceof _index2.ObjectValue);
            if (_this2._mark(val)) _this2.visitValueObject(val);
          });
        } else {
          if (this._mark(val)) this.visitValueObject(val);
        }
      }
    }
  }, {
    key: "visitGlobalBinding",
    value: function visitGlobalBinding(key) {
      var binding = this.globalBindings.get(key);
      if (!binding) {
        var value = this.realm.getGlobalLetBinding(key);
        binding = { value: value, modified: true, declarativeEnvironmentRecord: null };
        this.globalBindings.set(key, binding);
      }
      if (binding.value) binding.value = this.visitEquivalentValue(binding.value);
      return binding;
    }
  }, {
    key: "createGeneratorVisitCallbacks",
    value: function createGeneratorVisitCallbacks(generator, commonScope) {
      var _this3 = this;

      return {
        visitValues: function visitValues(values) {
          for (var i = 0, n = values.length; i < n; i++) {
            values[i] = _this3.visitEquivalentValue(values[i]);
          }
        },
        visitGenerator: this.visitGenerator.bind(this),
        canSkip: function canSkip(value) {
          return !_this3.referencedDeclaredValues.has(value) && !_this3.values.has(value);
        },
        recordDeclaration: function recordDeclaration(value) {
          _this3.referencedDeclaredValues.add(value);
        },
        recordDelayedEntry: function recordDelayedEntry(entry) {
          _this3.delayedVisitGeneratorEntries.push({ commonScope: commonScope, generator: generator, entry: entry });
        }
      };
    }
  }, {
    key: "visitGenerator",
    value: function visitGenerator(generator) {
      var _this4 = this;

      this._withScope(generator, function () {
        generator.visit(_this4.createGeneratorVisitCallbacks(generator, _this4.commonScope));
      });
    }
  }, {
    key: "visitAdditionalFunctionEffects",
    value: function visitAdditionalFunctionEffects() {
      var _this5 = this;

      var _loop2 = function _loop2(functionValue, effects) {
        var _effects = _slicedToArray(effects, 5),
            result = _effects[0],
            generator = _effects[1],
            modifiedBindings = _effects[2],
            modifiedProperties = _effects[3],
            createdObjects = _effects[4];
        // Need to do this fixup because otherwise we will skip over this function's
        // generator in the _getTarget scope lookup


        generator.parent = functionValue.parent;
        functionValue.parent = generator;
        // result -- ignore TODO: return the result from the function somehow
        // Generator -- visit all entries
        // Bindings -- (modifications to named variables) only need to serialize bindings if they're
        //             captured by a residual function
        //          -- need to apply them and maybe need to revisit functions in ancestors to make sure
        //             we don't overwrite anything they capture
        //          -- TODO: deal with these properly
        // PropertyBindings -- (property modifications) visit any property bindings to pre-existing objects
        // CreatedObjects -- should take care of itself
        _this5.realm.applyEffects([result, new _generator.Generator(_this5.realm), modifiedBindings, modifiedProperties, createdObjects]);
        // Allows us to emit function declarations etc. inside of this additional
        // function instead of adding them at global scope
        _this5.commonScope = functionValue;
        var modifiedBindingInfo = new Map();
        var visitPropertiesAndBindings = function visitPropertiesAndBindings() {
          var _iteratorNormalCompletion7 = true;
          var _didIteratorError7 = false;
          var _iteratorError7 = undefined;

          try {
            for (var _iterator7 = modifiedProperties.keys()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
              var propertyBinding = _step7.value;

              var binding = propertyBinding;
              var object = binding.object;
              if (object instanceof _index2.ObjectValue && createdObjects.has(object)) continue; // Created Object's binding
              if (object.refuseSerialization) continue; // modification to internal state
              if (object.intrinsicName === "global") continue; // Avoid double-counting
              _this5.visitObjectProperty(binding);
            }
            // Handing of ModifiedBindings
          } catch (err) {
            _didIteratorError7 = true;
            _iteratorError7 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion7 && _iterator7.return) {
                _iterator7.return();
              }
            } finally {
              if (_didIteratorError7) {
                throw _iteratorError7;
              }
            }
          }

          var _iteratorNormalCompletion8 = true;
          var _didIteratorError8 = false;
          var _iteratorError8 = undefined;

          try {
            for (var _iterator8 = modifiedBindings.keys()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
              var additionalBinding = _step8.value;

              //let modifiedBinding: Binding = ((additionalBinding: any): Binding);
              var modifiedBinding = additionalBinding;
              var residualBinding = void 0;
              if (modifiedBinding.isGlobal) {
                residualBinding = _this5.globalBindings.get(modifiedBinding.name);
              } else {
                var containingEnv = modifiedBinding.environment;
                (0, _invariant2.default)(containingEnv instanceof _environment.DeclarativeEnvironmentRecord);
                var bindMap = _this5.declarativeEnvironmentRecordsBindings.get(containingEnv);
                if (bindMap) residualBinding = bindMap.get(modifiedBinding.name);
              }
              // Only visit it if there is already a binding (no binding means that
              // the additional function created the binding)
              if (residualBinding && modifiedBinding.value !== residualBinding.value) {
                var newValue = modifiedBinding.value;
                (0, _invariant2.default)(newValue);
                _this5.visitValue(newValue);
                residualBinding.modified = true;
                // This should be enforced by checkThatFunctionsAreIndependent
                (0, _invariant2.default)(!residualBinding.additionalFunctionOverridesValue, "We should only have one additional function value modifying any given residual binding");
                residualBinding.additionalFunctionOverridesValue = true;
                modifiedBindingInfo.set(modifiedBinding, residualBinding);
              }
            }
          } catch (err) {
            _didIteratorError8 = true;
            _iteratorError8 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion8 && _iterator8.return) {
                _iterator8.return();
              }
            } finally {
              if (_didIteratorError8) {
                throw _iteratorError8;
              }
            }
          }

          (0, _invariant2.default)(result instanceof _index2.Value);
          _this5.visitValue(result);
        };
        (0, _invariant2.default)(functionValue instanceof _index2.ECMAScriptSourceFunctionValue);
        var code = functionValue.$ECMAScriptCode;
        (0, _invariant2.default)(code != null);
        var functionInfo = _this5.functionInfos.get(code);
        (0, _invariant2.default)(functionInfo);
        var funcInstance = _this5.functionInstances.get(functionValue);
        (0, _invariant2.default)(funcInstance);
        _this5.additionalFunctionValueInfos.set(functionValue, {
          functionValue: functionValue,
          captures: functionInfo.unbound,
          modifiedBindings: modifiedBindingInfo,
          instance: funcInstance
        });
        _this5.visitGenerator(generator);
        _this5._withScope(generator, visitPropertiesAndBindings);
        _this5.realm.restoreBindings(modifiedBindings);
        _this5.realm.restoreProperties(modifiedProperties);
      };

      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = this.additionalFunctionValuesAndEffects.entries()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var _ref5 = _step5.value;

          var _ref6 = _slicedToArray(_ref5, 2);

          var functionValue = _ref6[0];
          var effects = _ref6[1];

          _loop2(functionValue, effects);
        }
        // Do a fixpoint over all pure generator entries to make sure that we visit
        // arguments of only BodyEntries that are required by some other residual value
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      var oldDelayedEntries = [];
      while (oldDelayedEntries.length !== this.delayedVisitGeneratorEntries.length) {
        oldDelayedEntries = this.delayedVisitGeneratorEntries;
        this.delayedVisitGeneratorEntries = [];

        var _loop3 = function _loop3(_ref7) {
          var commonScope = _ref7.commonScope,
              entryGenerator = _ref7.generator,
              entry = _ref7.entry;

          _this5.commonScope = commonScope;
          _this5._withScope(entryGenerator, function () {
            entryGenerator.visitEntry(entry, _this5.createGeneratorVisitCallbacks(entryGenerator, commonScope));
          });
        };

        var _iteratorNormalCompletion6 = true;
        var _didIteratorError6 = false;
        var _iteratorError6 = undefined;

        try {
          for (var _iterator6 = oldDelayedEntries[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
            var _ref7 = _step6.value;

            _loop3(_ref7);
          }
        } catch (err) {
          _didIteratorError6 = true;
          _iteratorError6 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion6 && _iterator6.return) {
              _iterator6.return();
            }
          } finally {
            if (_didIteratorError6) {
              throw _iteratorError6;
            }
          }
        }
      }
      return this.realm.intrinsics.undefined;
    }
  }, {
    key: "visitRoots",
    value: function visitRoots() {
      var generator = this.realm.generator;
      (0, _invariant2.default)(generator);
      this.visitGenerator(generator);
      var _iteratorNormalCompletion9 = true;
      var _didIteratorError9 = false;
      var _iteratorError9 = undefined;

      try {
        for (var _iterator9 = this.modules.initializedModules.values()[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
          var moduleValue = _step9.value;
          this.visitValue(moduleValue);
        }
      } catch (err) {
        _didIteratorError9 = true;
        _iteratorError9 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion9 && _iterator9.return) {
            _iterator9.return();
          }
        } finally {
          if (_didIteratorError9) {
            throw _iteratorError9;
          }
        }
      }

      this.realm.evaluateAndRevertInGlobalEnv(this.visitAdditionalFunctionEffects.bind(this));
    }
  }]);

  return ResidualHeapVisitor;
}();
//# sourceMappingURL=ResidualHeapVisitor.js.map