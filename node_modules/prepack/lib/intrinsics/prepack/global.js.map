{"version":3,"sources":["../../../src/intrinsics/prepack/global.js"],"names":["realm","global","$GlobalObject","$DefineOwnProperty","value","context","args","console","log","map","arg","serialize","writable","enumerable","configurable","parseTypeNameOrTemplate","typeNameOrTemplate","undefined","type","template","typeNameString","getTypeFromName","createErrorThrowCompletion","intrinsics","TypeError","throwTemplateSrc","throwTemplate","createAbstract","null","additionalValues","name","useAbstractInterpretation","result","nameString","locString","contextStack","slice","reverse","executionContext","caller","function","lexicalEnvironment","loc","locVal","kind","objectCount","createFromTemplate","intrinsicName","values","Set","makePartial","rebuildNestedProperties","length","createAbstractConcreteUnion","ObjectPrototype","additonalFunctionUid","functionValue","assignToGlobal","t","memberExpression","identifier","react","enabled","reactComponentRootUid","deriveNativeFunctionValue","unsafe","f","isTypeCompatibleWith","constructor","isResidual","isUnsafeResidual","createTemporalFromBuildFunction","concat","callExpression","nodes","generator","getIdentifier","object","makeSimple","propertyName","invariantOptions","key","propertyIdentifier","getAsPropertyNameExpression","computed","isIdentifier","condition","objectNode","valueNode","binaryExpression","invariantOptionString","valueToNode","emitInvariant","objnode","$Set","rebuildObjectProperty","$Realm","__IntrospectionError"],"mappings":"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","file":"global.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../../realm.js\";\nimport {\n  AbstractObjectValue,\n  AbstractValue,\n  BooleanValue,\n  ConcreteValue,\n  FunctionValue,\n  NativeFunctionValue,\n  ObjectValue,\n  StringValue,\n  UndefinedValue,\n  Value,\n  ECMAScriptSourceFunctionValue,\n} from \"../../values/index.js\";\nimport { ToStringPartial } from \"../../methods/index.js\";\nimport { ValuesDomain } from \"../../domains/index.js\";\nimport buildExpressionTemplate from \"../../utils/builder.js\";\nimport * as t from \"babel-types\";\nimport type { BabelNodeExpression, BabelNodeSpreadElement } from \"babel-types\";\nimport invariant from \"../../invariant.js\";\nimport { describeLocation } from \"../ecma262/Error.js\";\n\nexport default function(realm: Realm): void {\n  let global = realm.$GlobalObject;\n\n  global.$DefineOwnProperty(\"dump\", {\n    value: new NativeFunctionValue(realm, \"global.dump\", \"dump\", 0, (context, args) => {\n      console.log(\"dump\", args.map(arg => arg.serialize()));\n      return context;\n    }),\n    writable: true,\n    enumerable: false,\n    configurable: true,\n  });\n\n  function parseTypeNameOrTemplate(typeNameOrTemplate): { type: typeof Value, template: void | ObjectValue } {\n    if (typeNameOrTemplate === undefined || typeNameOrTemplate instanceof UndefinedValue) {\n      return { type: Value, template: undefined };\n    } else if (typeNameOrTemplate instanceof StringValue) {\n      let typeNameString = ToStringPartial(realm, typeNameOrTemplate);\n      let type = Value.getTypeFromName(typeNameString);\n      if (type === undefined) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"unknown typeNameOrTemplate\");\n      }\n      return { type, template: undefined };\n    } else if (typeNameOrTemplate instanceof FunctionValue) {\n      return { type: FunctionValue, template: typeNameOrTemplate };\n    } else if (typeNameOrTemplate instanceof ObjectValue) {\n      return { type: ObjectValue, template: typeNameOrTemplate };\n    } else {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"typeNameOrTemplate has unsupported type\");\n    }\n  }\n\n  const throwTemplateSrc = \"(function(){throw new global.Error('abstract value defined at ' + A);})()\";\n  const throwTemplate = buildExpressionTemplate(throwTemplateSrc);\n\n  // Helper function to model values that are obtained from the environment,\n  // and whose concrete values are not known at Prepack-time.\n  // __abstract(typeNameOrTemplate, name, options) creates a new abstract value\n  // where typeNameOrTemplate either either 'string', 'boolean', 'number', 'object', or an actual object defining known properties.\n  // If the abstract value gets somehow embedded in the final heap,\n  // it will be referred to by the supplied name in the generated code.\n  global.$DefineOwnProperty(\"__abstract\", {\n    value: createAbstract(),\n    writable: true,\n    enumerable: false,\n    configurable: true,\n  });\n\n  global.$DefineOwnProperty(\"__abstractOrNull\", {\n    value: createAbstract(realm.intrinsics.null),\n    writable: true,\n    enumerable: false,\n    configurable: true,\n  });\n\n  global.$DefineOwnProperty(\"__abstractOrNullOrUndefined\", {\n    value: createAbstract(realm.intrinsics.null, realm.intrinsics.undefined),\n    writable: true,\n    enumerable: false,\n    configurable: true,\n  });\n\n  global.$DefineOwnProperty(\"__abstractOrUndefined\", {\n    value: createAbstract(realm.intrinsics.undefined),\n    writable: true,\n    enumerable: false,\n    configurable: true,\n  });\n\n  function createAbstract(...additionalValues: Array<ConcreteValue>): NativeFunctionValue {\n    return new NativeFunctionValue(\n      realm,\n      \"global.__abstract\",\n      \"__abstract\",\n      0,\n      (context, [typeNameOrTemplate, name]) => {\n        if (!realm.useAbstractInterpretation) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"realm is not partial\");\n        }\n\n        let { type, template } = parseTypeNameOrTemplate(typeNameOrTemplate);\n\n        let result;\n        let nameString = name ? ToStringPartial(realm, name) : \"\";\n        if (nameString === \"\") {\n          let locString;\n          for (let executionContext of realm.contextStack.slice().reverse()) {\n            let caller = executionContext.caller;\n            locString = describeLocation(\n              realm,\n              caller ? caller.function : undefined,\n              caller ? caller.lexicalEnvironment : undefined,\n              executionContext.loc\n            );\n            if (locString !== undefined) break;\n          }\n          let locVal = new StringValue(realm, locString || \"(unknown location)\");\n          let kind = \"__abstract_\" + realm.objectCount++; // need not be an object, but must be unique\n          result = AbstractValue.createFromTemplate(realm, throwTemplate, type, [locVal], kind);\n        } else {\n          let kind = \"__abstract_\" + nameString; // assume name is unique TODO #1155: check this\n          result = AbstractValue.createFromTemplate(realm, buildExpressionTemplate(nameString), type, [], kind);\n          result.intrinsicName = nameString;\n        }\n\n        if (template) result.values = new ValuesDomain(new Set([template]));\n        if (template && !(template instanceof FunctionValue)) {\n          // why exclude functions?\n          template.makePartial();\n          if (nameString) realm.rebuildNestedProperties(result, nameString);\n        }\n\n        if (additionalValues.length > 0)\n          result = AbstractValue.createAbstractConcreteUnion(realm, result, ...additionalValues);\n        return result;\n      }\n    );\n  }\n\n  global.$DefineOwnProperty(\"__additionalFunctions\", {\n    value: new ObjectValue(realm, realm.intrinsics.ObjectPrototype, \"__additionalFunctions\", true),\n    writable: true,\n    enumerable: false,\n    configurable: true,\n  });\n\n  let additonalFunctionUid = 0;\n  // Allows dynamically registering additional functions.\n  // WARNING: these functions will get exposed at global scope and called there.\n  // NB: If we interpret one of these calls in an evaluateForEffects context\n  //     that is not subsequently applied, the function will not be registered\n  //     (because prepack won't have a correct value for the FunctionValue itself)\n  global.$DefineOwnProperty(\"__registerAdditionalFunctionToPrepack\", {\n    value: new NativeFunctionValue(\n      realm,\n      \"global.__registerAdditionalFunctionToPrepack\",\n      \"__registerAdditionalFunctionToPrepack\",\n      0,\n      (context, [functionValue]) => {\n        invariant(functionValue instanceof ECMAScriptSourceFunctionValue);\n        realm.assignToGlobal(\n          t.memberExpression(\n            t.memberExpression(t.identifier(\"global\"), t.identifier(\"__additionalFunctions\")),\n            t.identifier(\"\" + additonalFunctionUid++)\n          ),\n          functionValue\n        );\n        return realm.intrinsics.undefined;\n      }\n    ),\n    writable: true,\n    enumerable: false,\n    configurable: true,\n  });\n\n  if (realm.react.enabled) {\n    global.$DefineOwnProperty(\"__reactComponentRoots\", {\n      value: new ObjectValue(realm, realm.intrinsics.ObjectPrototype, \"__reactComponentRoots\", true),\n      writable: true,\n      enumerable: false,\n      configurable: true,\n    });\n    let reactComponentRootUid = 0;\n    // this is almost a copy of the additionalFunctions code above\n    global.$DefineOwnProperty(\"__registerReactComponentRoot\", {\n      value: new NativeFunctionValue(\n        realm,\n        \"global.__registerReactComponentRoot\",\n        \"__registerReactComponentRoot\",\n        0,\n        (context, [functionValue]) => {\n          invariant(functionValue instanceof ECMAScriptSourceFunctionValue);\n          realm.assignToGlobal(\n            t.memberExpression(\n              t.memberExpression(t.identifier(\"global\"), t.identifier(\"__reactComponentRoots\")),\n              t.identifier(\"\" + reactComponentRootUid++)\n            ),\n            functionValue\n          );\n          return realm.intrinsics.undefined;\n        }\n      ),\n      writable: true,\n      enumerable: false,\n      configurable: true,\n    });\n  }\n\n  // Maps from initialized moduleId to exports object\n  // NB: Changes to this shouldn't ever be serialized\n  global.$DefineOwnProperty(\"__initializedModules\", {\n    value: new ObjectValue(realm, realm.intrinsics.ObjectPrototype, \"__initializedModules\", true),\n    writable: true,\n    enumerable: false,\n    configurable: true,\n  });\n\n  // Helper function used to instatiate a residual function\n  function deriveNativeFunctionValue(unsafe: boolean): NativeFunctionValue {\n    return new NativeFunctionValue(\n      realm,\n      \"global.__residual\",\n      \"__residual\",\n      2,\n      (context, [typeNameOrTemplate, f, ...args]) => {\n        if (!realm.useAbstractInterpretation) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"realm is not partial\");\n        }\n\n        let { type, template } = parseTypeNameOrTemplate(typeNameOrTemplate);\n\n        if (!Value.isTypeCompatibleWith(f.constructor, FunctionValue)) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"cannot determine residual function\");\n        }\n        invariant(f instanceof FunctionValue);\n        f.isResidual = true;\n        if (unsafe) f.isUnsafeResidual = true;\n        let result = AbstractValue.createTemporalFromBuildFunction(realm, type, [f].concat(args), nodes =>\n          t.callExpression(nodes[0], ((nodes.slice(1): any): Array<BabelNodeExpression | BabelNodeSpreadElement>))\n        );\n        if (template) {\n          invariant(\n            result instanceof AbstractValue,\n            \"the nested properties should only be rebuilt for an abstract value\"\n          );\n          template.makePartial();\n          result.values = new ValuesDomain(new Set([template]));\n          invariant(realm.generator);\n          realm.rebuildNestedProperties(result, result.getIdentifier().name);\n        }\n        return result;\n      }\n    );\n  }\n\n  // Helper function that identifies a computation that must remain part of the residual program and cannot be partially evaluated,\n  // e.g. because it contains a loop over abstract values.\n  // __residual(typeNameOrTemplate, function, arg0, arg1, ...) creates a new abstract value\n  // that is computed by invoking function(arg0, arg1, ...) in the residual program and\n  // where typeNameOrTemplate either either 'string', 'boolean', 'number', 'object', or an actual object defining known properties.\n  // The function must not have side effects, and it must not access any state (besides the supplied arguments).\n  global.$DefineOwnProperty(\"__residual\", {\n    value: deriveNativeFunctionValue(false),\n    writable: true,\n    enumerable: false,\n    configurable: true,\n  });\n\n  // Helper function that identifies a variant of the residual function that has implicit dependencies. This version of residual will infer the dependencies\n  // and rewrite the function body to do the same thing as the original residual function.\n  global.$DefineOwnProperty(\"__residual_unsafe\", {\n    value: deriveNativeFunctionValue(true),\n    writable: true,\n    enumerable: false,\n    configurable: true,\n  });\n\n  // TODO #1023: Remove this property. It's just here as some existing internal test cases assume that the __annotate property is exists and is readable.\n  global.$DefineOwnProperty(\"__annotate\", {\n    value: realm.intrinsics.undefined,\n    writable: true,\n    enumerable: false,\n    configurable: true,\n  });\n\n  // Internal helper function for tests.\n  // __isAbstract(value) checks if a given value is abstract.\n  global.$DefineOwnProperty(\"__isAbstract\", {\n    value: new NativeFunctionValue(realm, \"global.__isAbstract\", \"__isAbstract\", 1, (context, [value]) => {\n      return new BooleanValue(realm, value instanceof AbstractValue);\n    }),\n    writable: true,\n    enumerable: false,\n    configurable: true,\n  });\n\n  // __makePartial(object) marks an (abstract) object as partial.\n  global.$DefineOwnProperty(\"__makePartial\", {\n    value: new NativeFunctionValue(realm, \"global.__makePartial\", \"__makePartial\", 1, (context, [object]) => {\n      // casting to any to avoid Flow bug\n      if ((object: any) instanceof AbstractObjectValue || (object: any) instanceof ObjectValue) {\n        (object: any).makePartial();\n        return object;\n      }\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not an (abstract) object\");\n    }),\n    writable: true,\n    enumerable: false,\n    configurable: true,\n  });\n\n  // __makeSimple(object) marks an (abstract) object as one that has no getters or setters.\n  global.$DefineOwnProperty(\"__makeSimple\", {\n    value: new NativeFunctionValue(realm, \"global.__makeSimple\", \"__makeSimple\", 1, (context, [object]) => {\n      // casting to any to avoid Flow bug\n      if ((object: any) instanceof AbstractObjectValue || (object: any) instanceof ObjectValue) {\n        (object: any).makeSimple();\n        return object;\n      }\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not an (abstract) object\");\n    }),\n    writable: true,\n    enumerable: false,\n    configurable: true,\n  });\n\n  // Helper function that emits a check whether a given object property has a particular value.\n  global.$DefineOwnProperty(\"__assumeDataProperty\", {\n    value: new NativeFunctionValue(\n      realm,\n      \"global.__assumeDataProperty\",\n      \"__assumeDataProperty\",\n      3,\n      (context, [object, propertyName, value, invariantOptions]) => {\n        if (!realm.useAbstractInterpretation) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"realm is not partial\");\n        }\n\n        // casting to any to avoid Flow bug \"*** Recursion limit exceeded ***\"\n        if ((object: any) instanceof AbstractObjectValue || (object: any) instanceof ObjectValue) {\n          let generator = realm.generator;\n          invariant(generator);\n\n          let key = ToStringPartial(realm, propertyName);\n          let propertyIdentifier = generator.getAsPropertyNameExpression(key);\n          let computed = !t.isIdentifier(propertyIdentifier);\n          let condition = ([objectNode, valueNode]) =>\n            t.binaryExpression(\"!==\", t.memberExpression(objectNode, propertyIdentifier, computed), valueNode);\n          if (invariantOptions) {\n            let invariantOptionString = ToStringPartial(realm, invariantOptions);\n            switch (invariantOptionString) {\n              case \"VALUE_DEFINED_INVARIANT\":\n                condition = ([objectNode, valueNode]) =>\n                  t.binaryExpression(\n                    \"===\",\n                    t.memberExpression(objectNode, propertyIdentifier, computed),\n                    t.valueToNode(undefined)\n                  );\n                break;\n              case \"SKIP_INVARIANT\":\n                condition = null;\n                break;\n              case \"FULL_INVARIANT\":\n                break;\n              default:\n                invariant(false, \"Invalid invariantOption \" + invariantOptionString);\n            }\n          }\n          if (condition)\n            generator.emitInvariant([object, value, object], condition, objnode =>\n              t.memberExpression(objnode, propertyIdentifier, computed)\n            );\n          realm.generator = undefined; // don't emit code during the following $Set call\n          // casting to due to Flow workaround above\n          (object: any).$Set(key, value, object);\n          realm.generator = generator;\n          if (object.intrinsicName) realm.rebuildObjectProperty(object, key, value, object.intrinsicName);\n          return context.$Realm.intrinsics.undefined;\n        }\n\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not an (abstract) object\");\n      }\n    ),\n    writable: true,\n    enumerable: false,\n    configurable: true,\n  });\n\n  global.$DefineOwnProperty(\"__IntrospectionError\", {\n    value: realm.intrinsics.__IntrospectionError,\n    writable: true,\n    enumerable: false,\n    configurable: true,\n  });\n}\n"]}