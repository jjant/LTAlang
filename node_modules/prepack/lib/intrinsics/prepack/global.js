"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Copyright (c) 2017-present, Facebook, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * This source code is licensed under the BSD-style license found in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * LICENSE file in the root directory of this source tree. An additional grant
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * of patent rights can be found in the PATENTS file in the same directory.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */

exports.default = function (realm) {
  var global = realm.$GlobalObject;

  global.$DefineOwnProperty("dump", {
    value: new _index.NativeFunctionValue(realm, "global.dump", "dump", 0, function (context, args) {
      console.log("dump", args.map(function (arg) {
        return arg.serialize();
      }));
      return context;
    }),
    writable: true,
    enumerable: false,
    configurable: true
  });

  function parseTypeNameOrTemplate(typeNameOrTemplate) {
    if (typeNameOrTemplate === undefined || typeNameOrTemplate instanceof _index.UndefinedValue) {
      return { type: _index.Value, template: undefined };
    } else if (typeNameOrTemplate instanceof _index.StringValue) {
      var typeNameString = (0, _index2.ToStringPartial)(realm, typeNameOrTemplate);
      var _type = _index.Value.getTypeFromName(typeNameString);
      if (_type === undefined) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "unknown typeNameOrTemplate");
      }
      return { type: _type, template: undefined };
    } else if (typeNameOrTemplate instanceof _index.FunctionValue) {
      return { type: _index.FunctionValue, template: typeNameOrTemplate };
    } else if (typeNameOrTemplate instanceof _index.ObjectValue) {
      return { type: _index.ObjectValue, template: typeNameOrTemplate };
    } else {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "typeNameOrTemplate has unsupported type");
    }
  }

  var throwTemplateSrc = "(function(){throw new global.Error('abstract value defined at ' + A);})()";
  var throwTemplate = (0, _builder2.default)(throwTemplateSrc);

  // Helper function to model values that are obtained from the environment,
  // and whose concrete values are not known at Prepack-time.
  // __abstract(typeNameOrTemplate, name, options) creates a new abstract value
  // where typeNameOrTemplate either either 'string', 'boolean', 'number', 'object', or an actual object defining known properties.
  // If the abstract value gets somehow embedded in the final heap,
  // it will be referred to by the supplied name in the generated code.
  global.$DefineOwnProperty("__abstract", {
    value: createAbstract(),
    writable: true,
    enumerable: false,
    configurable: true
  });

  global.$DefineOwnProperty("__abstractOrNull", {
    value: createAbstract(realm.intrinsics.null),
    writable: true,
    enumerable: false,
    configurable: true
  });

  global.$DefineOwnProperty("__abstractOrNullOrUndefined", {
    value: createAbstract(realm.intrinsics.null, realm.intrinsics.undefined),
    writable: true,
    enumerable: false,
    configurable: true
  });

  global.$DefineOwnProperty("__abstractOrUndefined", {
    value: createAbstract(realm.intrinsics.undefined),
    writable: true,
    enumerable: false,
    configurable: true
  });

  function createAbstract() {
    for (var _len = arguments.length, additionalValues = Array(_len), _key = 0; _key < _len; _key++) {
      additionalValues[_key] = arguments[_key];
    }

    return new _index.NativeFunctionValue(realm, "global.__abstract", "__abstract", 0, function (context, _ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          typeNameOrTemplate = _ref2[0],
          name = _ref2[1];

      if (!realm.useAbstractInterpretation) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "realm is not partial");
      }

      var _parseTypeNameOrTempl = parseTypeNameOrTemplate(typeNameOrTemplate),
          type = _parseTypeNameOrTempl.type,
          template = _parseTypeNameOrTempl.template;

      var result = void 0;
      var nameString = name ? (0, _index2.ToStringPartial)(realm, name) : "";
      if (nameString === "") {
        var locString = void 0;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = realm.contextStack.slice().reverse()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var executionContext = _step.value;

            var caller = executionContext.caller;
            locString = (0, _Error.describeLocation)(realm, caller ? caller.function : undefined, caller ? caller.lexicalEnvironment : undefined, executionContext.loc);
            if (locString !== undefined) break;
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        var locVal = new _index.StringValue(realm, locString || "(unknown location)");
        var kind = "__abstract_" + realm.objectCount++; // need not be an object, but must be unique
        result = _index.AbstractValue.createFromTemplate(realm, throwTemplate, type, [locVal], kind);
      } else {
        var _kind = "__abstract_" + nameString; // assume name is unique TODO #1155: check this
        result = _index.AbstractValue.createFromTemplate(realm, (0, _builder2.default)(nameString), type, [], _kind);
        result.intrinsicName = nameString;
      }

      if (template) result.values = new _index3.ValuesDomain(new Set([template]));
      if (template && !(template instanceof _index.FunctionValue)) {
        // why exclude functions?
        template.makePartial();
        if (nameString) realm.rebuildNestedProperties(result, nameString);
      }

      if (additionalValues.length > 0) result = _index.AbstractValue.createAbstractConcreteUnion.apply(_index.AbstractValue, [realm, result].concat(additionalValues));
      return result;
    });
  }

  global.$DefineOwnProperty("__additionalFunctions", {
    value: new _index.ObjectValue(realm, realm.intrinsics.ObjectPrototype, "__additionalFunctions", true),
    writable: true,
    enumerable: false,
    configurable: true
  });

  var additonalFunctionUid = 0;
  // Allows dynamically registering additional functions.
  // WARNING: these functions will get exposed at global scope and called there.
  // NB: If we interpret one of these calls in an evaluateForEffects context
  //     that is not subsequently applied, the function will not be registered
  //     (because prepack won't have a correct value for the FunctionValue itself)
  global.$DefineOwnProperty("__registerAdditionalFunctionToPrepack", {
    value: new _index.NativeFunctionValue(realm, "global.__registerAdditionalFunctionToPrepack", "__registerAdditionalFunctionToPrepack", 0, function (context, _ref3) {
      var _ref4 = _slicedToArray(_ref3, 1),
          functionValue = _ref4[0];

      (0, _invariant2.default)(functionValue instanceof _index.ECMAScriptSourceFunctionValue);
      realm.assignToGlobal(t.memberExpression(t.memberExpression(t.identifier("global"), t.identifier("__additionalFunctions")), t.identifier("" + additonalFunctionUid++)), functionValue);
      return realm.intrinsics.undefined;
    }),
    writable: true,
    enumerable: false,
    configurable: true
  });

  if (realm.react.enabled) {
    global.$DefineOwnProperty("__reactComponentRoots", {
      value: new _index.ObjectValue(realm, realm.intrinsics.ObjectPrototype, "__reactComponentRoots", true),
      writable: true,
      enumerable: false,
      configurable: true
    });
    var reactComponentRootUid = 0;
    // this is almost a copy of the additionalFunctions code above
    global.$DefineOwnProperty("__registerReactComponentRoot", {
      value: new _index.NativeFunctionValue(realm, "global.__registerReactComponentRoot", "__registerReactComponentRoot", 0, function (context, _ref5) {
        var _ref6 = _slicedToArray(_ref5, 1),
            functionValue = _ref6[0];

        (0, _invariant2.default)(functionValue instanceof _index.ECMAScriptSourceFunctionValue);
        realm.assignToGlobal(t.memberExpression(t.memberExpression(t.identifier("global"), t.identifier("__reactComponentRoots")), t.identifier("" + reactComponentRootUid++)), functionValue);
        return realm.intrinsics.undefined;
      }),
      writable: true,
      enumerable: false,
      configurable: true
    });
  }

  // Maps from initialized moduleId to exports object
  // NB: Changes to this shouldn't ever be serialized
  global.$DefineOwnProperty("__initializedModules", {
    value: new _index.ObjectValue(realm, realm.intrinsics.ObjectPrototype, "__initializedModules", true),
    writable: true,
    enumerable: false,
    configurable: true
  });

  // Helper function used to instatiate a residual function
  function deriveNativeFunctionValue(unsafe) {
    return new _index.NativeFunctionValue(realm, "global.__residual", "__residual", 2, function (context, _ref7) {
      var _ref8 = _toArray(_ref7),
          typeNameOrTemplate = _ref8[0],
          f = _ref8[1],
          args = _ref8.slice(2);

      if (!realm.useAbstractInterpretation) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "realm is not partial");
      }

      var _parseTypeNameOrTempl2 = parseTypeNameOrTemplate(typeNameOrTemplate),
          type = _parseTypeNameOrTempl2.type,
          template = _parseTypeNameOrTempl2.template;

      if (!_index.Value.isTypeCompatibleWith(f.constructor, _index.FunctionValue)) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "cannot determine residual function");
      }
      (0, _invariant2.default)(f instanceof _index.FunctionValue);
      f.isResidual = true;
      if (unsafe) f.isUnsafeResidual = true;
      var result = _index.AbstractValue.createTemporalFromBuildFunction(realm, type, [f].concat(args), function (nodes) {
        return t.callExpression(nodes[0], nodes.slice(1));
      });
      if (template) {
        (0, _invariant2.default)(result instanceof _index.AbstractValue, "the nested properties should only be rebuilt for an abstract value");
        template.makePartial();
        result.values = new _index3.ValuesDomain(new Set([template]));
        (0, _invariant2.default)(realm.generator);
        realm.rebuildNestedProperties(result, result.getIdentifier().name);
      }
      return result;
    });
  }

  // Helper function that identifies a computation that must remain part of the residual program and cannot be partially evaluated,
  // e.g. because it contains a loop over abstract values.
  // __residual(typeNameOrTemplate, function, arg0, arg1, ...) creates a new abstract value
  // that is computed by invoking function(arg0, arg1, ...) in the residual program and
  // where typeNameOrTemplate either either 'string', 'boolean', 'number', 'object', or an actual object defining known properties.
  // The function must not have side effects, and it must not access any state (besides the supplied arguments).
  global.$DefineOwnProperty("__residual", {
    value: deriveNativeFunctionValue(false),
    writable: true,
    enumerable: false,
    configurable: true
  });

  // Helper function that identifies a variant of the residual function that has implicit dependencies. This version of residual will infer the dependencies
  // and rewrite the function body to do the same thing as the original residual function.
  global.$DefineOwnProperty("__residual_unsafe", {
    value: deriveNativeFunctionValue(true),
    writable: true,
    enumerable: false,
    configurable: true
  });

  // TODO #1023: Remove this property. It's just here as some existing internal test cases assume that the __annotate property is exists and is readable.
  global.$DefineOwnProperty("__annotate", {
    value: realm.intrinsics.undefined,
    writable: true,
    enumerable: false,
    configurable: true
  });

  // Internal helper function for tests.
  // __isAbstract(value) checks if a given value is abstract.
  global.$DefineOwnProperty("__isAbstract", {
    value: new _index.NativeFunctionValue(realm, "global.__isAbstract", "__isAbstract", 1, function (context, _ref9) {
      var _ref10 = _slicedToArray(_ref9, 1),
          value = _ref10[0];

      return new _index.BooleanValue(realm, value instanceof _index.AbstractValue);
    }),
    writable: true,
    enumerable: false,
    configurable: true
  });

  // __makePartial(object) marks an (abstract) object as partial.
  global.$DefineOwnProperty("__makePartial", {
    value: new _index.NativeFunctionValue(realm, "global.__makePartial", "__makePartial", 1, function (context, _ref11) {
      var _ref12 = _slicedToArray(_ref11, 1),
          object = _ref12[0];

      // casting to any to avoid Flow bug
      if (object instanceof _index.AbstractObjectValue || object instanceof _index.ObjectValue) {
        object.makePartial();
        return object;
      }
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "not an (abstract) object");
    }),
    writable: true,
    enumerable: false,
    configurable: true
  });

  // __makeSimple(object) marks an (abstract) object as one that has no getters or setters.
  global.$DefineOwnProperty("__makeSimple", {
    value: new _index.NativeFunctionValue(realm, "global.__makeSimple", "__makeSimple", 1, function (context, _ref13) {
      var _ref14 = _slicedToArray(_ref13, 1),
          object = _ref14[0];

      // casting to any to avoid Flow bug
      if (object instanceof _index.AbstractObjectValue || object instanceof _index.ObjectValue) {
        object.makeSimple();
        return object;
      }
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "not an (abstract) object");
    }),
    writable: true,
    enumerable: false,
    configurable: true
  });

  // Helper function that emits a check whether a given object property has a particular value.
  global.$DefineOwnProperty("__assumeDataProperty", {
    value: new _index.NativeFunctionValue(realm, "global.__assumeDataProperty", "__assumeDataProperty", 3, function (context, _ref15) {
      var _ref16 = _slicedToArray(_ref15, 4),
          object = _ref16[0],
          propertyName = _ref16[1],
          value = _ref16[2],
          invariantOptions = _ref16[3];

      if (!realm.useAbstractInterpretation) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "realm is not partial");
      }

      // casting to any to avoid Flow bug "*** Recursion limit exceeded ***"
      if (object instanceof _index.AbstractObjectValue || object instanceof _index.ObjectValue) {
        var generator = realm.generator;
        (0, _invariant2.default)(generator);

        var key = (0, _index2.ToStringPartial)(realm, propertyName);
        var propertyIdentifier = generator.getAsPropertyNameExpression(key);
        var computed = !t.isIdentifier(propertyIdentifier);
        var condition = function condition(_ref17) {
          var _ref18 = _slicedToArray(_ref17, 2),
              objectNode = _ref18[0],
              valueNode = _ref18[1];

          return t.binaryExpression("!==", t.memberExpression(objectNode, propertyIdentifier, computed), valueNode);
        };
        if (invariantOptions) {
          var invariantOptionString = (0, _index2.ToStringPartial)(realm, invariantOptions);
          switch (invariantOptionString) {
            case "VALUE_DEFINED_INVARIANT":
              condition = function condition(_ref19) {
                var _ref20 = _slicedToArray(_ref19, 2),
                    objectNode = _ref20[0],
                    valueNode = _ref20[1];

                return t.binaryExpression("===", t.memberExpression(objectNode, propertyIdentifier, computed), t.valueToNode(undefined));
              };
              break;
            case "SKIP_INVARIANT":
              condition = null;
              break;
            case "FULL_INVARIANT":
              break;
            default:
              (0, _invariant2.default)(false, "Invalid invariantOption " + invariantOptionString);
          }
        }
        if (condition) generator.emitInvariant([object, value, object], condition, function (objnode) {
          return t.memberExpression(objnode, propertyIdentifier, computed);
        });
        realm.generator = undefined; // don't emit code during the following $Set call
        // casting to due to Flow workaround above
        object.$Set(key, value, object);
        realm.generator = generator;
        if (object.intrinsicName) realm.rebuildObjectProperty(object, key, value, object.intrinsicName);
        return context.$Realm.intrinsics.undefined;
      }

      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "not an (abstract) object");
    }),
    writable: true,
    enumerable: false,
    configurable: true
  });

  global.$DefineOwnProperty("__IntrospectionError", {
    value: realm.intrinsics.__IntrospectionError,
    writable: true,
    enumerable: false,
    configurable: true
  });
};

var _index = require("../../values/index.js");

var _index2 = require("../../methods/index.js");

var _index3 = require("../../domains/index.js");

var _builder = require("../../utils/builder.js");

var _builder2 = _interopRequireDefault(_builder);

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

var _invariant = require("../../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _Error = require("../ecma262/Error.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }
//# sourceMappingURL=global.js.map