"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Copyright (c) 2017-present, Facebook, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * This source code is licensed under the BSD-style license found in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * LICENSE file in the root directory of this source tree. An additional grant
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * of patent rights can be found in the PATENTS file in the same directory.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */

exports.default = function (realm) {
  var obj = new _index.ObjectValue(realm, realm.intrinsics.ObjectPrototype, "JSON");

  // ECMA262 24.3.3
  obj.defineNativeProperty(realm.intrinsics.SymbolToStringTag, new _index.StringValue(realm, "JSON"), { writable: false });

  // ECMA262 24.3.2
  obj.defineNativeMethod("stringify", 3, function (context, _ref3) {
    var _ref4 = _slicedToArray(_ref3, 3),
        value = _ref4[0],
        replacer = _ref4[1],
        space = _ref4[2];

    replacer = replacer.throwIfNotConcrete();
    space = space.throwIfNotConcrete();

    // 1. Let stack be a new empty List.
    var stack = [];

    // 2. Let indent be the empty String.
    var indent = "";

    // 3. Let PropertyList and ReplacerFunction be undefined.
    var PropertyList = void 0,
        ReplacerFunction = void 0;

    // 4. If Type(replacer) is Object, then
    if (replacer instanceof _index.ObjectValue) {
      // a. If IsCallable(replacer) is true, then
      if ((0, _index2.IsCallable)(realm, replacer)) {
        // i. Let ReplacerFunction be replacer.
        ReplacerFunction = replacer;
      } else {
        // b. Else,
        // i. Let isArray be ? IsArray(replacer).
        var isArray = (0, _index2.IsArray)(realm, replacer);

        // ii. If isArray is true, then
        if (isArray === true) {
          // i. Let PropertyList be a new empty List.
          PropertyList = [];

          // ii. Let len be ? ToLength(? Get(replacer, "length")).
          var len = (0, _index2.ToLength)(realm, (0, _index2.Get)(realm, replacer, "length"));

          // iii. Let k be 0.
          var k = 0;

          // iv. Repeat while k<len,

          var _loop = function _loop() {
            // 1. Let v be ? Get(replacer, ! ToString(k)).
            var v = (0, _index2.Get)(realm, replacer, new _index.StringValue(realm, k + ""));
            v = v.throwIfNotConcrete();

            // 2. Let item be undefined.
            var item = void 0;

            // 3. If Type(v) is String, let item be v.
            if (v instanceof _index.StringValue) {
              item = v;
            } else if (v instanceof _index.NumberValue) {
              // 4. Else if Type(v) is Number, let item be ! ToString(v).
              item = new _index.StringValue(realm, (0, _index2.ToString)(realm, v));
            } else if (v instanceof _index.ObjectValue) {
              // 5. Else if Type(v) is Object, then
              // a. If v has a [[StringData]] or [[NumberData]] internal slot, let item be ? ToString(v).
              if (v.$StringData || v.$NumberData) {
                item = new _index.StringValue(realm, (0, _index2.ToString)(realm, v));
              }
            }

            // 6. If item is not undefined and item is not currently an element of PropertyList, then
            if (item !== undefined && PropertyList.find(function (x) {
              return x.value === item.value;
            }) === undefined) {
              // a. Append item to the end of PropertyList.
              PropertyList.push(item);
            }

            // 7. Let k be k+1.
            k++;
          };

          while (k < len) {
            _loop();
          }
        }
      }
    }

    // 5. If Type(space) is Object, then
    if (space instanceof _index.ObjectValue) {
      // a. If space has a [[NumberData]] internal slot, then
      if (space.$NumberData) {
        // i. Let space be ? ToNumber(space).
        space = new _index.NumberValue(realm, (0, _index2.ToNumber)(realm, space));
      } else if (space.$StringData) {
        // b. Else if space has a [[StringData]] internal slot, then
        // i. Let space be ? ToString(space).
        space = new _index.StringValue(realm, (0, _index2.ToString)(realm, space));
      }
    }

    var gap = void 0;
    // 6. If Type(space) is Number, then
    if (space instanceof _index.NumberValue) {
      // a. Let space be min(10, ToInteger(space)).
      space = new _index.NumberValue(realm, Math.min(10, (0, _index2.ToInteger)(realm, space)));

      // b. Set gap to a String containing space occurrences of code unit 0x0020 (SPACE). This will be the empty String if space is less than 1.
      gap = Array(Math.max(0, space.value)).join(" ");
    } else if (space instanceof _index.StringValue) {
      // 7. Else if Type(space) is String, then
      // a. If the number of elements in space is 10 or less, set gap to space; otherwise set gap to a String consisting of the first 10 elements of space.
      gap = space.value.length <= 10 ? space.value : space.value.substring(0, 10);
    } else {
      // 8. Else,
      // a. Set gap to the empty String.
      gap = "";
    }

    // 9. Let wrapper be ObjectCreate(%ObjectPrototype%).
    var wrapper = (0, _index2.ObjectCreate)(realm, realm.intrinsics.ObjectPrototype);

    // TODO #1012: Make result abstract if any nested element is an abstract value.
    if (value instanceof _index.AbstractValue || value instanceof _index.ObjectValue && value.isPartialObject()) {
      // Return abstract result. This enables cloning via JSON.parse(JSON.stringify(...)).
      var clonedValue = InternalJSONClone(realm, value);
      var result = _index.AbstractValue.createTemporalFromTemplate(realm, JSONStringify, _index.StringValue, [clonedValue], {
        kind: "JSON.stringify(...)"
      }, true);
      if (clonedValue instanceof _index.ObjectValue) {
        var iName = result.intrinsicName;
        (0, _invariant2.default)(iName);
        (0, _invariant2.default)(realm.generator);
        realm.rebuildNestedProperties(result, iName);
      }
      return result;
    }

    // 10. Let status be CreateDataProperty(wrapper, the empty String, value).
    var status = (0, _index2.CreateDataProperty)(realm, wrapper, "", value);

    // 11. Assert: status is true.
    (0, _invariant2.default)(status, "expected to create data property");

    // 12. Return ? SerializeJSONProperty(the empty String, wrapper).
    var str = SerializeJSONProperty(realm, realm.intrinsics.emptyString, wrapper, {
      PropertyList: PropertyList,
      ReplacerFunction: ReplacerFunction,
      stack: stack,
      indent: indent,
      gap: gap
    });
    if (str === undefined) {
      return realm.intrinsics.undefined;
    } else {
      return new _index.StringValue(realm, str);
    }
  });

  // ECMA262 24.3.1
  obj.defineNativeMethod("parse", 2, function (context, _ref5) {
    var _ref6 = _slicedToArray(_ref5, 2),
        text = _ref6[0],
        reviver = _ref6[1];

    var unfiltered = void 0;
    if (text instanceof _index.AbstractValue && text.kind === "JSON.stringify(...)") {
      // Enable cloning via JSON.parse(JSON.stringify(...)).
      var gen = realm.preludeGenerator;
      (0, _invariant2.default)(gen); // text is abstract, so we are doing abstract interpretation
      var args = gen.derivedIds.get(text.intrinsicName);
      (0, _invariant2.default)(args && args[0] instanceof _index.Value); // since text.kind === "JSON.stringify(...)"
      var inputClone = args[0]; // A temporal copy of the object that was the argument to stringify
      // Clone it so that every call to parse produces a different instance from stringify's clone
      var parseResult = void 0; // A clone of inputClone, because every call to parse produces a new object
      if (inputClone instanceof _index.ObjectValue) {
        parseResult = InternalCloneObject(realm, inputClone);
      } else {
        (0, _invariant2.default)(inputClone instanceof _index.AbstractObjectValue);
        parseResult = InternalCloneObject(realm, inputClone.getTemplate());
      }
      (0, _invariant2.default)(parseResult.isPartialObject()); // Because stringify ensures it
      parseResult.makeSimple(); // because the result of JSON.parse is always simple
      // Force evaluation of the parse call
      unfiltered = _index.AbstractValue.createTemporalFromTemplate(realm, JSONParse, _index.ObjectValue, [text], {
        kind: "JSON.parse(...)"
      });
      unfiltered.values = new _index3.ValuesDomain(new Set([parseResult]));
      (0, _invariant2.default)(unfiltered.intrinsicName);
      (0, _invariant2.default)(realm.generator);
      realm.rebuildNestedProperties(unfiltered, unfiltered.intrinsicName);
    } else {
      // 1. Let JText be ? ToString(text).
      var JText = (0, _index2.ToStringPartial)(realm, text);

      // 2. Parse JText interpreted as UTF-16 encoded Unicode points (6.1.4) as a JSON text as specified in ECMA-404. Throw a SyntaxError exception if JText is not a valid JSON text as defined in that specification.
      // 3. Let scriptText be the result of concatenating "(", JText, and ");".
      // 4. Let completion be the result of parsing and evaluating scriptText as if it was the source text of an ECMAScript Script, but using the alternative definition of DoubleStringCharacter provided below. The extended PropertyDefinitionEvaluation semantics defined in B.3.1 must not be used during the evaluation.
      // 5. Let unfiltered be completion.[[Value]].
      try {
        unfiltered = (0, _nativeToInterp2.default)(realm, JSON.parse(JText));
      } catch (err) {
        if (err instanceof SyntaxError) {
          throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, err.message);
        } else {
          throw err;
        }
      }

      // 6. Assert: unfiltered will be either a primitive value or an object that is defined by either an ArrayLiteral or an ObjectLiteral.
      (0, _invariant2.default)((0, _index2.HasSomeCompatibleType)(unfiltered, _index.PrimitiveValue, _index.ObjectValue, _index.ArrayValue), "expected primitive, object or array");
    }

    // 7. If IsCallable(reviver) is true, then
    if ((0, _index2.IsCallable)(realm, reviver)) {
      // a. Let root be ObjectCreate(%ObjectPrototype%).
      var root = (0, _index2.ObjectCreate)(realm, realm.intrinsics.ObjectPrototype);

      // b. Let rootName be the empty String.
      var rootName = "";

      // c. Let status be CreateDataProperty(root, rootName, unfiltered).
      var status = (0, _index2.CreateDataProperty)(realm, root, rootName, unfiltered);

      // d. Assert: status is true.
      (0, _invariant2.default)(status, "expected to create data property");

      // e. Return ? InternalizeJSONProperty(root, rootName).
      return (0, _json.InternalizeJSONProperty)(realm, reviver, root, rootName);
    } else {
      // 8. Else,
      // a. Return unfiltered.
      return unfiltered;
    }
  });

  return obj;
};

var _index = require("../../values/index.js");

var _index2 = require("../../methods/index.js");

var _json = require("../../methods/json.js");

var _index3 = require("../../domains/index.js");

var _errors = require("../../errors.js");

var _singletons = require("../../singletons.js");

var _nativeToInterp = require("../../utils/native-to-interp.js");

var _nativeToInterp2 = _interopRequireDefault(_nativeToInterp);

var _invariant = require("../../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _builder = require("../../utils/builder.js");

var _builder2 = _interopRequireDefault(_builder);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function SerializeJSONArray(realm, value, context) {
  // 1. If stack contains value, throw a TypeError exception because the structure is cyclical.
  if (context.stack.indexOf(value) >= 0) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "cyclical error");
  }

  // 2. Append value to stack.
  context.stack.push(value);

  // 3. Let stepback be indent.
  var stepback = context.indent;

  // 4. Let indent be the concatenation of indent and gap.
  context.indent += context.gap;

  // 5. Let partial be a new empty List.
  var partial = [];

  // 6. Let len be ? ToLength(? Get(value, "length")).
  var len = (0, _index2.ToLength)(realm, (0, _index2.Get)(realm, value, "length"));

  // 7. Let index be 0.
  var index = 0;

  // 8. Repeat while index < len
  while (index < len) {
    // a. Let strP be ? SerializeJSONProperty(! ToString(index), value).
    var strP = SerializeJSONProperty(realm, new _index.StringValue(realm, index + ""), value, context);

    // b. If strP is undefined, then
    if (strP === undefined) {
      // i. Append "null" to partial.
      partial.push("null");
    } else {
      // c. Else,
      // i. Append strP to partial.
      partial.push(strP);
    }

    // d. Increment index by 1.
    index++;
  }

  // 9. If partial is empty, then
  var final = "";
  if (!partial.length) {
    // a. Let final be "[]".
    final = "[]";
  } else {
    // 10. Else,
    // a. If gap is the empty String, then
    if (!context.gap) {
      // i. Let properties be a String formed by concatenating all the element Strings of partial with each adjacent pair of Strings separated with code unit 0x002C (COMMA). A comma is not inserted either before the first String or after the last String.
      var properties = partial.join(",");

      // ii. Let final be the result of concatenating "[", properties, and "]".
      final = "[" + properties + "]";
    } else {
      // b. Else,
      // i. Let separator be the result of concatenating code unit 0x002C (COMMA), code unit 0x000A (LINE FEED), and indent.
      // ii. Let properties be a String formed by concatenating all the element Strings of partial with each adjacent pair of Strings separated with separator. The separator String is not inserted either before the first String or after the last String.
      // iii. Let final be the result of concatenating "[", code unit 0x000A (LINE FEED), indent, properties, code unit 0x000A (LINE FEED), stepback, and "]".
    }
  }

  // 11. Remove the last element of stack.
  context.stack.pop();

  // 12. Let indent be stepback.
  context.indent = stepback;

  // 13. Return final.
  return final;
}

function QuoteJSONString(realm, value) {
  return JSON.stringify(value.value);
}

function SerializeJSONObject(realm, value, context) {
  // 1. If stack contains value, throw a TypeError exception because the structure is cyclical.
  if (context.stack.indexOf(value) >= 0) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "cyclical error");
  }

  // 2. Append value to stack.
  context.stack.push(value);

  // 3. Let stepback be indent.
  var stepback = context.indent;

  // 4. Let indent be the concatenation of indent and gap.
  context.indent += context.gap;

  // 5. If PropertyList is not undefined, then
  var K = void 0;
  if (context.PropertyList !== undefined) {
    // a. Let K be PropertyList.
    K = context.PropertyList;
  } else {
    // 6. Else,
    // a. Let K be ? EnumerableOwnProperties(value, "key").
    K = (0, _index2.EnumerableOwnProperties)(realm, value, "key");
  }

  // 7. Let partial be a new empty List.
  var partial = [];

  // 8. For each element P of K,
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = K[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var P = _step.value;

      (0, _invariant2.default)(P instanceof _index.StringValue);

      // a. Let strP be ? SerializeJSONProperty(P, value).
      var strP = SerializeJSONProperty(realm, P, value, context);

      // b. If strP is not undefined, then
      if (strP !== undefined) {
        // i. Let member be QuoteJSONString(P).
        var member = QuoteJSONString(realm, P);

        // ii. Let member be the concatenation of member and the string ":".
        member += ":";

        // iii. If gap is not the empty String, then
        if (context.gap) {
          // 1. Let member be the concatenation of member and code unit 0x0020 (SPACE).
          member += " ";
        }

        // iv. Let member be the concatenation of member and strP.
        member += strP;

        // v. Append member to partial.
        partial.push(member);
      }
    }

    // 9. If partial is empty, then
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var final = "";
  if (!partial.length) {
    // a. Let final be "{}".
    final = "{}";
  } else {
    // 10. Else,
    // a. If gap is the empty String, then
    if (!context.gap) {
      // i. Let properties be a String formed by concatenating all the element Strings of partial with each adjacent pair of Strings separated with code unit 0x002C (COMMA). A comma is not inserted either before the first String or after the last String.
      var properties = partial.join(",");

      // ii. Let final be the result of concatenating "{", properties, and "}".
      final = "{" + properties + "}";
    } else {
      // b. Else gap is not the empty String,
      // i. Let separator be the result of concatenating code unit 0x002C (COMMA), code unit 0x000A (LINE FEED), and indent.
      // ii. Let properties be a String formed by concatenating all the element Strings of partial with each adjacent pair of Strings separated with separator. The separator String is not inserted either before the first String or after the last String.
      // iii. Let final be the result of concatenating "{", code unit 0x000A (LINE FEED), indent, properties, code unit 0x000A (LINE FEED), stepback, and "}".
    }
  }

  // 11. Remove the last element of stack.
  context.stack.pop();

  // 12. Let indent be stepback.
  context.indent = stepback;

  // 13. Return final.
  return final;
}

function SerializeJSONProperty(realm, key, holder, context) {
  // 1. Let value be ? Get(holder, key).
  var value = (0, _index2.Get)(realm, holder, key).throwIfNotConcrete();

  // 2. If Type(value) is Object, then
  if (value instanceof _index.ObjectValue) {
    // a. Let toJSON be ? Get(value, "toJSON").
    var toJSON = (0, _index2.Get)(realm, value, "toJSON");

    // b. If IsCallable(toJSON) is true, then
    if ((0, _index2.IsCallable)(realm, toJSON)) {
      // i. Let value be ? Call(toJSON, value, « key »).
      value = (0, _index2.Call)(realm, toJSON, value, [key]);
    }
  }

  // 3. If ReplacerFunction is not undefined, then
  if (context.ReplacerFunction) {
    // a. Let value be ? Call(ReplacerFunction, holder, « key, value »).
    value = (0, _index2.Call)(realm, context.ReplacerFunction, holder, [key, value]);
  }

  // 4. If Type(value) is Object, then
  if (value instanceof _index.ObjectValue) {
    // a. If value has a [[NumberData]] internal slot, then
    if (value.$NumberData) {
      // b. Let value be ? ToNumber(value).
      value = new _index.NumberValue(realm, (0, _index2.ToNumber)(realm, value));
    } else if (value.$StringData) {
      // c. Else if value has a [[StringData]] internal slot, then
      // d. Let value be ? ToString(value).
      value = new _index.StringValue(realm, (0, _index2.ToString)(realm, value));
    } else if (value.$BooleanData) {
      // e. Else if value has a [[BooleanData]] internal slot, then
      // f. Let value be the value of the [[BooleanData]] internal slot of value.
      value = value.$BooleanData;
    }
  }

  // 5. If value is null, return "null".
  if (value instanceof _index.NullValue) return "null";

  // 6. If value is true, return "true".
  if (value instanceof _index.BooleanValue && value.value) return "true";

  // 7. If value is false, return "false".
  if (value instanceof _index.BooleanValue && !value.value) return "false";

  // 8. If Type(value) is String, return QuoteJSONString(value).
  if (value instanceof _index.StringValue) return QuoteJSONString(realm, value);

  // 9. If Type(value) is Number, then
  if (value instanceof _index.NumberValue) {
    // a. If value is finite, return ! ToString(value).
    if (isFinite(value.value)) {
      return (0, _index2.ToString)(realm, value);
    } else {
      // b. Else, return "null".
      return "null";
    }
  }

  // 10. If Type(value) is Object and IsCallable(value) is false, then
  if (value instanceof _index.ObjectValue && !(0, _index2.IsCallable)(realm, value)) {
    // a. Let isArray be ? IsArray(value).
    var isArray = (0, _index2.IsArray)(realm, value);

    // b. If isArray is true, return ? SerializeJSONArray(value).
    if (isArray) {
      return SerializeJSONArray(realm, value, context);
    } else {
      // c. Else, return ? SerializeJSONObject(value).
      return SerializeJSONObject(realm, value, context);
    }
  }

  // 1. Return undefined.
  return undefined;
}

function InternalCloneObject(realm, val) {
  var clone = (0, _index2.ObjectCreate)(realm, realm.intrinsics.ObjectPrototype);
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = val.properties[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _ref = _step2.value;

      var _ref2 = _slicedToArray(_ref, 2);

      var key = _ref2[0];
      var binding = _ref2[1];

      if (binding === undefined || binding.descriptor === undefined) continue; // deleted
      (0, _invariant2.default)(binding.descriptor !== undefined);
      var value = binding.descriptor.value;
      _singletons.Properties.ThrowIfMightHaveBeenDeleted(value);
      if (value === undefined) {
        _index.AbstractValue.reportIntrospectionError(val, key); // cannot handle accessors
        throw new _errors.FatalError();
      }
      (0, _invariant2.default)(value instanceof _index.Value);
      (0, _index2.CreateDataProperty)(realm, clone, key, InternalJSONClone(realm, value));
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  if (val.isPartialObject()) clone.makePartial();
  if (val.isSimpleObject()) clone.makeSimple();
  clone.isTemplate = true; // because this object doesn't exist ahead of time, and the visitor would otherwise declare it in the common scope
  return clone;
}

var JSONStringifyStr = "global.JSON.stringify(A)";
var JSONStringify = (0, _builder2.default)(JSONStringifyStr);
var JSONParseStr = "global.JSON.parse(A)";
var JSONParse = (0, _builder2.default)(JSONParseStr);

function InternalJSONClone(realm, val) {
  if (val instanceof _index.AbstractValue) {
    if (val instanceof _index.AbstractObjectValue) {
      var strVal = _index.AbstractValue.createFromTemplate(realm, JSONStringify, _index.StringValue, [val], JSONStringifyStr);
      var obVal = _index.AbstractValue.createFromTemplate(realm, JSONParse, _index.ObjectValue, [strVal], JSONParseStr);
      obVal.values = new _index3.ValuesDomain(new Set([InternalCloneObject(realm, val.getTemplate())]));
      return obVal;
    }
    // TODO #1010: NaN and Infinity must be mapped to null.
    return val;
  }
  if (val instanceof _index.NumberValue && !isFinite(val.value) || val instanceof _index.UndefinedValue || val instanceof _index.NullValue) {
    return realm.intrinsics.null;
  }
  if (val instanceof _index.PrimitiveValue) {
    return val;
  }
  if (val instanceof _index.ObjectValue) {
    var clonedObj = void 0;
    var isArray = (0, _index2.IsArray)(realm, val);
    if (isArray === true) {
      clonedObj = (0, _index2.ObjectCreate)(realm, realm.intrinsics.ArrayPrototype);
      var I = 0;
      var len = (0, _index2.ToLength)(realm, (0, _index2.Get)(realm, val, "length"));
      while (I < len) {
        var P = (0, _index2.ToString)(realm, new _index.NumberValue(realm, I));
        var newElement = (0, _index2.Get)(realm, val, P);
        if (!(newElement instanceof _index.UndefinedValue)) {
          // TODO #1011: An abstract value that ultimately yields undefined should still be skipped
          (0, _index2.CreateDataProperty)(realm, clonedObj, P, InternalJSONClone(realm, newElement));
        }
        I += 1;
      }
    } else {
      clonedObj = (0, _index2.ObjectCreate)(realm, realm.intrinsics.ObjectPrototype);
      var valIsPartial = false;
      if (val.isPartialObject()) {
        valIsPartial = true;
        val.makeNotPartial();
      }
      var keys = (0, _index2.EnumerableOwnProperties)(realm, val, "key");
      if (valIsPartial) val.makePartial();
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = keys[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var _P = _step3.value;

          (0, _invariant2.default)(_P instanceof _index.StringValue);
          var _newElement = (0, _index2.Get)(realm, val, _P);
          if (!(_newElement instanceof _index.UndefinedValue)) {
            // TODO #1011: An abstract value that ultimately yields undefined should still be skipped
            (0, _index2.CreateDataProperty)(realm, clonedObj, _P, InternalJSONClone(realm, _newElement));
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }
    if (val.isPartialObject()) clonedObj.makePartial();
    clonedObj.makeSimple(); // The result of a JSON clone is always simple
    return clonedObj;
  }
  (0, _invariant2.default)(false);
}
//# sourceMappingURL=JSON.js.map