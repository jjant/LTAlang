{"version":3,"sources":["../../../src/intrinsics/ecma262/JSON.js"],"names":["realm","obj","intrinsics","ObjectPrototype","defineNativeProperty","SymbolToStringTag","writable","defineNativeMethod","context","value","replacer","space","throwIfNotConcrete","stack","indent","PropertyList","ReplacerFunction","isArray","len","k","v","item","$StringData","$NumberData","undefined","find","x","push","gap","Math","min","Array","max","join","length","substring","wrapper","isPartialObject","clonedValue","InternalJSONClone","result","createTemporalFromTemplate","JSONStringify","kind","iName","intrinsicName","generator","rebuildNestedProperties","status","str","SerializeJSONProperty","emptyString","text","reviver","unfiltered","gen","preludeGenerator","args","derivedIds","get","inputClone","parseResult","InternalCloneObject","getTemplate","makeSimple","JSONParse","values","Set","JText","JSON","parse","err","SyntaxError","createErrorThrowCompletion","message","root","rootName","SerializeJSONArray","indexOf","TypeError","stepback","partial","index","strP","final","properties","pop","QuoteJSONString","stringify","SerializeJSONObject","K","P","member","key","holder","toJSON","$BooleanData","isFinite","val","clone","binding","descriptor","ThrowIfMightHaveBeenDeleted","reportIntrospectionError","makePartial","isSimpleObject","isTemplate","JSONStringifyStr","JSONParseStr","strVal","createFromTemplate","obVal","null","clonedObj","ArrayPrototype","I","newElement","valIsPartial","makeNotPartial","keys"],"mappings":"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","file":"JSON.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../../realm.js\";\nimport {\n  AbstractObjectValue,\n  AbstractValue,\n  ArrayValue,\n  BooleanValue,\n  NullValue,\n  NumberValue,\n  ObjectValue,\n  PrimitiveValue,\n  StringValue,\n  UndefinedValue,\n  Value,\n} from \"../../values/index.js\";\nimport {\n  Call,\n  CreateDataProperty,\n  EnumerableOwnProperties,\n  Get,\n  HasSomeCompatibleType,\n  IsArray,\n  IsCallable,\n  ObjectCreate,\n  ToInteger,\n  ToLength,\n  ToNumber,\n  ToString,\n  ToStringPartial,\n} from \"../../methods/index.js\";\nimport { InternalizeJSONProperty } from \"../../methods/json.js\";\nimport { ValuesDomain } from \"../../domains/index.js\";\nimport { FatalError } from \"../../errors.js\";\nimport { Properties } from \"../../singletons.js\";\nimport nativeToInterp from \"../../utils/native-to-interp.js\";\nimport invariant from \"../../invariant.js\";\nimport buildExpressionTemplate from \"../../utils/builder.js\";\n\ntype Context = {\n  PropertyList?: Array<StringValue>,\n  ReplacerFunction?: ObjectValue,\n  stack: Array<ObjectValue>,\n  indent: string,\n  gap: string,\n};\n\nfunction SerializeJSONArray(realm: Realm, value: ObjectValue, context: Context): string {\n  // 1. If stack contains value, throw a TypeError exception because the structure is cyclical.\n  if (context.stack.indexOf(value) >= 0) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"cyclical error\");\n  }\n\n  // 2. Append value to stack.\n  context.stack.push(value);\n\n  // 3. Let stepback be indent.\n  let stepback = context.indent;\n\n  // 4. Let indent be the concatenation of indent and gap.\n  context.indent += context.gap;\n\n  // 5. Let partial be a new empty List.\n  let partial = [];\n\n  // 6. Let len be ? ToLength(? Get(value, \"length\")).\n  let len = ToLength(realm, Get(realm, value, \"length\"));\n\n  // 7. Let index be 0.\n  let index = 0;\n\n  // 8. Repeat while index < len\n  while (index < len) {\n    // a. Let strP be ? SerializeJSONProperty(! ToString(index), value).\n    let strP = SerializeJSONProperty(realm, new StringValue(realm, index + \"\"), value, context);\n\n    // b. If strP is undefined, then\n    if (strP === undefined) {\n      // i. Append \"null\" to partial.\n      partial.push(\"null\");\n    } else {\n      // c. Else,\n      // i. Append strP to partial.\n      partial.push(strP);\n    }\n\n    // d. Increment index by 1.\n    index++;\n  }\n\n  // 9. If partial is empty, then\n  let final = \"\";\n  if (!partial.length) {\n    // a. Let final be \"[]\".\n    final = \"[]\";\n  } else {\n    // 10. Else,\n    // a. If gap is the empty String, then\n    if (!context.gap) {\n      // i. Let properties be a String formed by concatenating all the element Strings of partial with each adjacent pair of Strings separated with code unit 0x002C (COMMA). A comma is not inserted either before the first String or after the last String.\n      let properties = partial.join(\",\");\n\n      // ii. Let final be the result of concatenating \"[\", properties, and \"]\".\n      final = `[${properties}]`;\n    } else {\n      // b. Else,\n      // i. Let separator be the result of concatenating code unit 0x002C (COMMA), code unit 0x000A (LINE FEED), and indent.\n      // ii. Let properties be a String formed by concatenating all the element Strings of partial with each adjacent pair of Strings separated with separator. The separator String is not inserted either before the first String or after the last String.\n      // iii. Let final be the result of concatenating \"[\", code unit 0x000A (LINE FEED), indent, properties, code unit 0x000A (LINE FEED), stepback, and \"]\".\n    }\n  }\n\n  // 11. Remove the last element of stack.\n  context.stack.pop();\n\n  // 12. Let indent be stepback.\n  context.indent = stepback;\n\n  // 13. Return final.\n  return final;\n}\n\nfunction QuoteJSONString(realm: Realm, value: StringValue): string {\n  return JSON.stringify(value.value);\n}\n\nfunction SerializeJSONObject(realm: Realm, value: ObjectValue, context: Context): string {\n  // 1. If stack contains value, throw a TypeError exception because the structure is cyclical.\n  if (context.stack.indexOf(value) >= 0) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"cyclical error\");\n  }\n\n  // 2. Append value to stack.\n  context.stack.push(value);\n\n  // 3. Let stepback be indent.\n  let stepback = context.indent;\n\n  // 4. Let indent be the concatenation of indent and gap.\n  context.indent += context.gap;\n\n  // 5. If PropertyList is not undefined, then\n  let K;\n  if (context.PropertyList !== undefined) {\n    // a. Let K be PropertyList.\n    K = context.PropertyList;\n  } else {\n    // 6. Else,\n    // a. Let K be ? EnumerableOwnProperties(value, \"key\").\n    K = EnumerableOwnProperties(realm, value, \"key\");\n  }\n\n  // 7. Let partial be a new empty List.\n  let partial = [];\n\n  // 8. For each element P of K,\n  for (let P of K) {\n    invariant(P instanceof StringValue);\n\n    // a. Let strP be ? SerializeJSONProperty(P, value).\n    let strP = SerializeJSONProperty(realm, P, value, context);\n\n    // b. If strP is not undefined, then\n    if (strP !== undefined) {\n      // i. Let member be QuoteJSONString(P).\n      let member = QuoteJSONString(realm, P);\n\n      // ii. Let member be the concatenation of member and the string \":\".\n      member += \":\";\n\n      // iii. If gap is not the empty String, then\n      if (context.gap) {\n        // 1. Let member be the concatenation of member and code unit 0x0020 (SPACE).\n        member += \" \";\n      }\n\n      // iv. Let member be the concatenation of member and strP.\n      member += strP;\n\n      // v. Append member to partial.\n      partial.push(member);\n    }\n  }\n\n  // 9. If partial is empty, then\n  let final: string = \"\";\n  if (!partial.length) {\n    // a. Let final be \"{}\".\n    final = \"{}\";\n  } else {\n    // 10. Else,\n    // a. If gap is the empty String, then\n    if (!context.gap) {\n      // i. Let properties be a String formed by concatenating all the element Strings of partial with each adjacent pair of Strings separated with code unit 0x002C (COMMA). A comma is not inserted either before the first String or after the last String.\n      let properties = partial.join(\",\");\n\n      // ii. Let final be the result of concatenating \"{\", properties, and \"}\".\n      final = `{${properties}}`;\n    } else {\n      // b. Else gap is not the empty String,\n      // i. Let separator be the result of concatenating code unit 0x002C (COMMA), code unit 0x000A (LINE FEED), and indent.\n      // ii. Let properties be a String formed by concatenating all the element Strings of partial with each adjacent pair of Strings separated with separator. The separator String is not inserted either before the first String or after the last String.\n      // iii. Let final be the result of concatenating \"{\", code unit 0x000A (LINE FEED), indent, properties, code unit 0x000A (LINE FEED), stepback, and \"}\".\n    }\n  }\n\n  // 11. Remove the last element of stack.\n  context.stack.pop();\n\n  // 12. Let indent be stepback.\n  context.indent = stepback;\n\n  // 13. Return final.\n  return final;\n}\n\nfunction SerializeJSONProperty(realm: Realm, key: StringValue, holder: ObjectValue, context: Context): void | string {\n  // 1. Let value be ? Get(holder, key).\n  let value = Get(realm, holder, key).throwIfNotConcrete();\n\n  // 2. If Type(value) is Object, then\n  if (value instanceof ObjectValue) {\n    // a. Let toJSON be ? Get(value, \"toJSON\").\n    let toJSON = Get(realm, value, \"toJSON\");\n\n    // b. If IsCallable(toJSON) is true, then\n    if (IsCallable(realm, toJSON)) {\n      // i. Let value be ? Call(toJSON, value, « key »).\n      value = Call(realm, toJSON, value, [key]);\n    }\n  }\n\n  // 3. If ReplacerFunction is not undefined, then\n  if (context.ReplacerFunction) {\n    // a. Let value be ? Call(ReplacerFunction, holder, « key, value »).\n    value = Call(realm, context.ReplacerFunction, holder, [key, value]);\n  }\n\n  // 4. If Type(value) is Object, then\n  if (value instanceof ObjectValue) {\n    // a. If value has a [[NumberData]] internal slot, then\n    if (value.$NumberData) {\n      // b. Let value be ? ToNumber(value).\n      value = new NumberValue(realm, ToNumber(realm, value));\n    } else if (value.$StringData) {\n      // c. Else if value has a [[StringData]] internal slot, then\n      // d. Let value be ? ToString(value).\n      value = new StringValue(realm, ToString(realm, value));\n    } else if (value.$BooleanData) {\n      // e. Else if value has a [[BooleanData]] internal slot, then\n      // f. Let value be the value of the [[BooleanData]] internal slot of value.\n      value = value.$BooleanData;\n    }\n  }\n\n  // 5. If value is null, return \"null\".\n  if (value instanceof NullValue) return \"null\";\n\n  // 6. If value is true, return \"true\".\n  if (value instanceof BooleanValue && value.value) return \"true\";\n\n  // 7. If value is false, return \"false\".\n  if (value instanceof BooleanValue && !value.value) return \"false\";\n\n  // 8. If Type(value) is String, return QuoteJSONString(value).\n  if (value instanceof StringValue) return QuoteJSONString(realm, value);\n\n  // 9. If Type(value) is Number, then\n  if (value instanceof NumberValue) {\n    // a. If value is finite, return ! ToString(value).\n    if (isFinite(value.value)) {\n      return ToString(realm, value);\n    } else {\n      // b. Else, return \"null\".\n      return \"null\";\n    }\n  }\n\n  // 10. If Type(value) is Object and IsCallable(value) is false, then\n  if (value instanceof ObjectValue && !IsCallable(realm, value)) {\n    // a. Let isArray be ? IsArray(value).\n    let isArray = IsArray(realm, value);\n\n    // b. If isArray is true, return ? SerializeJSONArray(value).\n    if (isArray) {\n      return SerializeJSONArray(realm, value, context);\n    } else {\n      // c. Else, return ? SerializeJSONObject(value).\n      return SerializeJSONObject(realm, value, context);\n    }\n  }\n\n  // 1. Return undefined.\n  return undefined;\n}\n\nfunction InternalCloneObject(realm: Realm, val: ObjectValue): ObjectValue {\n  let clone = ObjectCreate(realm, realm.intrinsics.ObjectPrototype);\n  for (let [key, binding] of val.properties) {\n    if (binding === undefined || binding.descriptor === undefined) continue; // deleted\n    invariant(binding.descriptor !== undefined);\n    let value = binding.descriptor.value;\n    Properties.ThrowIfMightHaveBeenDeleted(value);\n    if (value === undefined) {\n      AbstractValue.reportIntrospectionError(val, key); // cannot handle accessors\n      throw new FatalError();\n    }\n    invariant(value instanceof Value);\n    CreateDataProperty(realm, clone, key, InternalJSONClone(realm, value));\n  }\n  if (val.isPartialObject()) clone.makePartial();\n  if (val.isSimpleObject()) clone.makeSimple();\n  clone.isTemplate = true; // because this object doesn't exist ahead of time, and the visitor would otherwise declare it in the common scope\n  return clone;\n}\n\nconst JSONStringifyStr = \"global.JSON.stringify(A)\";\nconst JSONStringify = buildExpressionTemplate(JSONStringifyStr);\nconst JSONParseStr = \"global.JSON.parse(A)\";\nconst JSONParse = buildExpressionTemplate(JSONParseStr);\n\nfunction InternalJSONClone(realm: Realm, val: Value): Value {\n  if (val instanceof AbstractValue) {\n    if (val instanceof AbstractObjectValue) {\n      let strVal = AbstractValue.createFromTemplate(realm, JSONStringify, StringValue, [val], JSONStringifyStr);\n      let obVal = AbstractValue.createFromTemplate(realm, JSONParse, ObjectValue, [strVal], JSONParseStr);\n      obVal.values = new ValuesDomain(new Set([InternalCloneObject(realm, val.getTemplate())]));\n      return obVal;\n    }\n    // TODO #1010: NaN and Infinity must be mapped to null.\n    return val;\n  }\n  if (\n    (val instanceof NumberValue && !isFinite(val.value)) ||\n    val instanceof UndefinedValue ||\n    val instanceof NullValue\n  ) {\n    return realm.intrinsics.null;\n  }\n  if (val instanceof PrimitiveValue) {\n    return val;\n  }\n  if (val instanceof ObjectValue) {\n    let clonedObj;\n    let isArray = IsArray(realm, val);\n    if (isArray === true) {\n      clonedObj = ObjectCreate(realm, realm.intrinsics.ArrayPrototype);\n      let I = 0;\n      let len = ToLength(realm, Get(realm, val, \"length\"));\n      while (I < len) {\n        let P = ToString(realm, new NumberValue(realm, I));\n        let newElement = Get(realm, val, P);\n        if (!(newElement instanceof UndefinedValue)) {\n          // TODO #1011: An abstract value that ultimately yields undefined should still be skipped\n          CreateDataProperty(realm, clonedObj, P, InternalJSONClone(realm, newElement));\n        }\n        I += 1;\n      }\n    } else {\n      clonedObj = ObjectCreate(realm, realm.intrinsics.ObjectPrototype);\n      let valIsPartial = false;\n      if (val.isPartialObject()) {\n        valIsPartial = true;\n        val.makeNotPartial();\n      }\n      let keys = EnumerableOwnProperties(realm, val, \"key\");\n      if (valIsPartial) val.makePartial();\n      for (let P of keys) {\n        invariant(P instanceof StringValue);\n        let newElement = Get(realm, val, P);\n        if (!(newElement instanceof UndefinedValue)) {\n          // TODO #1011: An abstract value that ultimately yields undefined should still be skipped\n          CreateDataProperty(realm, clonedObj, P, InternalJSONClone(realm, newElement));\n        }\n      }\n    }\n    if (val.isPartialObject()) clonedObj.makePartial();\n    clonedObj.makeSimple(); // The result of a JSON clone is always simple\n    return clonedObj;\n  }\n  invariant(false);\n}\n\nexport default function(realm: Realm): ObjectValue {\n  let obj = new ObjectValue(realm, realm.intrinsics.ObjectPrototype, \"JSON\");\n\n  // ECMA262 24.3.3\n  obj.defineNativeProperty(realm.intrinsics.SymbolToStringTag, new StringValue(realm, \"JSON\"), { writable: false });\n\n  // ECMA262 24.3.2\n  obj.defineNativeMethod(\"stringify\", 3, (context, [value, replacer, space]) => {\n    replacer = replacer.throwIfNotConcrete();\n    space = space.throwIfNotConcrete();\n\n    // 1. Let stack be a new empty List.\n    let stack = [];\n\n    // 2. Let indent be the empty String.\n    let indent = \"\";\n\n    // 3. Let PropertyList and ReplacerFunction be undefined.\n    let PropertyList, ReplacerFunction;\n\n    // 4. If Type(replacer) is Object, then\n    if (replacer instanceof ObjectValue) {\n      // a. If IsCallable(replacer) is true, then\n      if (IsCallable(realm, replacer)) {\n        // i. Let ReplacerFunction be replacer.\n        ReplacerFunction = replacer;\n      } else {\n        // b. Else,\n        // i. Let isArray be ? IsArray(replacer).\n        let isArray = IsArray(realm, replacer);\n\n        // ii. If isArray is true, then\n        if (isArray === true) {\n          // i. Let PropertyList be a new empty List.\n          PropertyList = [];\n\n          // ii. Let len be ? ToLength(? Get(replacer, \"length\")).\n          let len = ToLength(realm, Get(realm, replacer, \"length\"));\n\n          // iii. Let k be 0.\n          let k = 0;\n\n          // iv. Repeat while k<len,\n          while (k < len) {\n            // 1. Let v be ? Get(replacer, ! ToString(k)).\n            let v = Get(realm, replacer, new StringValue(realm, k + \"\"));\n            v = v.throwIfNotConcrete();\n\n            // 2. Let item be undefined.\n            let item;\n\n            // 3. If Type(v) is String, let item be v.\n            if (v instanceof StringValue) {\n              item = v;\n            } else if (v instanceof NumberValue) {\n              // 4. Else if Type(v) is Number, let item be ! ToString(v).\n              item = new StringValue(realm, ToString(realm, v));\n            } else if (v instanceof ObjectValue) {\n              // 5. Else if Type(v) is Object, then\n              // a. If v has a [[StringData]] or [[NumberData]] internal slot, let item be ? ToString(v).\n              if (v.$StringData || v.$NumberData) {\n                item = new StringValue(realm, ToString(realm, v));\n              }\n            }\n\n            // 6. If item is not undefined and item is not currently an element of PropertyList, then\n            if (item !== undefined && PropertyList.find(x => x.value === item.value) === undefined) {\n              // a. Append item to the end of PropertyList.\n              PropertyList.push(item);\n            }\n\n            // 7. Let k be k+1.\n            k++;\n          }\n        }\n      }\n    }\n\n    // 5. If Type(space) is Object, then\n    if (space instanceof ObjectValue) {\n      // a. If space has a [[NumberData]] internal slot, then\n      if (space.$NumberData) {\n        // i. Let space be ? ToNumber(space).\n        space = new NumberValue(realm, ToNumber(realm, space));\n      } else if (space.$StringData) {\n        // b. Else if space has a [[StringData]] internal slot, then\n        // i. Let space be ? ToString(space).\n        space = new StringValue(realm, ToString(realm, space));\n      }\n    }\n\n    let gap;\n    // 6. If Type(space) is Number, then\n    if (space instanceof NumberValue) {\n      // a. Let space be min(10, ToInteger(space)).\n      space = new NumberValue(realm, Math.min(10, ToInteger(realm, space)));\n\n      // b. Set gap to a String containing space occurrences of code unit 0x0020 (SPACE). This will be the empty String if space is less than 1.\n      gap = Array(Math.max(0, space.value)).join(\" \");\n    } else if (space instanceof StringValue) {\n      // 7. Else if Type(space) is String, then\n      // a. If the number of elements in space is 10 or less, set gap to space; otherwise set gap to a String consisting of the first 10 elements of space.\n      gap = space.value.length <= 10 ? space.value : space.value.substring(0, 10);\n    } else {\n      // 8. Else,\n      // a. Set gap to the empty String.\n      gap = \"\";\n    }\n\n    // 9. Let wrapper be ObjectCreate(%ObjectPrototype%).\n    let wrapper = ObjectCreate(realm, realm.intrinsics.ObjectPrototype);\n\n    // TODO #1012: Make result abstract if any nested element is an abstract value.\n    if (value instanceof AbstractValue || (value instanceof ObjectValue && value.isPartialObject())) {\n      // Return abstract result. This enables cloning via JSON.parse(JSON.stringify(...)).\n      let clonedValue = InternalJSONClone(realm, value);\n      let result = AbstractValue.createTemporalFromTemplate(\n        realm,\n        JSONStringify,\n        StringValue,\n        [clonedValue],\n        {\n          kind: \"JSON.stringify(...)\",\n        },\n        true\n      );\n      if (clonedValue instanceof ObjectValue) {\n        let iName = result.intrinsicName;\n        invariant(iName);\n        invariant(realm.generator);\n        realm.rebuildNestedProperties(result, iName);\n      }\n      return result;\n    }\n\n    // 10. Let status be CreateDataProperty(wrapper, the empty String, value).\n    let status = CreateDataProperty(realm, wrapper, \"\", value);\n\n    // 11. Assert: status is true.\n    invariant(status, \"expected to create data property\");\n\n    // 12. Return ? SerializeJSONProperty(the empty String, wrapper).\n    let str = SerializeJSONProperty(realm, realm.intrinsics.emptyString, wrapper, {\n      PropertyList,\n      ReplacerFunction,\n      stack,\n      indent,\n      gap,\n    });\n    if (str === undefined) {\n      return realm.intrinsics.undefined;\n    } else {\n      return new StringValue(realm, str);\n    }\n  });\n\n  // ECMA262 24.3.1\n  obj.defineNativeMethod(\"parse\", 2, (context, [text, reviver]) => {\n    let unfiltered;\n    if (text instanceof AbstractValue && text.kind === \"JSON.stringify(...)\") {\n      // Enable cloning via JSON.parse(JSON.stringify(...)).\n      let gen = realm.preludeGenerator;\n      invariant(gen); // text is abstract, so we are doing abstract interpretation\n      let args = gen.derivedIds.get(text.intrinsicName);\n      invariant(args && args[0] instanceof Value); // since text.kind === \"JSON.stringify(...)\"\n      let inputClone = args[0]; // A temporal copy of the object that was the argument to stringify\n      // Clone it so that every call to parse produces a different instance from stringify's clone\n      let parseResult; // A clone of inputClone, because every call to parse produces a new object\n      if (inputClone instanceof ObjectValue) {\n        parseResult = InternalCloneObject(realm, inputClone);\n      } else {\n        invariant(inputClone instanceof AbstractObjectValue);\n        parseResult = InternalCloneObject(realm, inputClone.getTemplate());\n      }\n      invariant(parseResult.isPartialObject()); // Because stringify ensures it\n      parseResult.makeSimple(); // because the result of JSON.parse is always simple\n      // Force evaluation of the parse call\n      unfiltered = AbstractValue.createTemporalFromTemplate(realm, JSONParse, ObjectValue, [text], {\n        kind: \"JSON.parse(...)\",\n      });\n      unfiltered.values = new ValuesDomain(new Set([parseResult]));\n      invariant(unfiltered.intrinsicName);\n      invariant(realm.generator);\n      realm.rebuildNestedProperties(unfiltered, unfiltered.intrinsicName);\n    } else {\n      // 1. Let JText be ? ToString(text).\n      let JText = ToStringPartial(realm, text);\n\n      // 2. Parse JText interpreted as UTF-16 encoded Unicode points (6.1.4) as a JSON text as specified in ECMA-404. Throw a SyntaxError exception if JText is not a valid JSON text as defined in that specification.\n      // 3. Let scriptText be the result of concatenating \"(\", JText, and \");\".\n      // 4. Let completion be the result of parsing and evaluating scriptText as if it was the source text of an ECMAScript Script, but using the alternative definition of DoubleStringCharacter provided below. The extended PropertyDefinitionEvaluation semantics defined in B.3.1 must not be used during the evaluation.\n      // 5. Let unfiltered be completion.[[Value]].\n      try {\n        unfiltered = nativeToInterp(realm, JSON.parse(JText));\n      } catch (err) {\n        if (err instanceof SyntaxError) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, err.message);\n        } else {\n          throw err;\n        }\n      }\n\n      // 6. Assert: unfiltered will be either a primitive value or an object that is defined by either an ArrayLiteral or an ObjectLiteral.\n      invariant(\n        HasSomeCompatibleType(unfiltered, PrimitiveValue, ObjectValue, ArrayValue),\n        \"expected primitive, object or array\"\n      );\n    }\n\n    // 7. If IsCallable(reviver) is true, then\n    if (IsCallable(realm, reviver)) {\n      // a. Let root be ObjectCreate(%ObjectPrototype%).\n      let root = ObjectCreate(realm, realm.intrinsics.ObjectPrototype);\n\n      // b. Let rootName be the empty String.\n      let rootName = \"\";\n\n      // c. Let status be CreateDataProperty(root, rootName, unfiltered).\n      let status = CreateDataProperty(realm, root, rootName, unfiltered);\n\n      // d. Assert: status is true.\n      invariant(status, \"expected to create data property\");\n\n      // e. Return ? InternalizeJSONProperty(root, rootName).\n      return InternalizeJSONProperty(realm, reviver, root, rootName);\n    } else {\n      // 8. Else,\n      // a. Return unfiltered.\n      return unfiltered;\n    }\n  });\n\n  return obj;\n}\n"]}