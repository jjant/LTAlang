{"version":3,"sources":["../../../src/intrinsics/ecma262/TypedArrayPrototype.js"],"names":["realm","obj","defineNativeGetter","O","context","throwIfNotConcrete","createErrorThrowCompletion","intrinsics","TypeError","$ViewedArrayBuffer","buffer","zero","size","$ByteLength","offset","$ByteOffset","defineNativeMethod","target","start","end","len","$ArrayLength","relativeTarget","to","Math","max","min","relativeStart","from","relativeEnd","final","count","direction","fromKey","toKey","fromPresent","fromVal","Set","DeletePropertyOrThrow","callbackfn","thisArg","T","undefined","k","Pk","kPresent","kValue","testResult","false","true","value","kept","captured","selected","push","A","n","e","predicate","searchElement","fromIndex","elementK","Object","is","same","separator","sep","emptyString","element0","R","S","element","next","length","mappedValue","initialValue","accumulator","middle","floor","lower","upper","upperP","lowerP","lowerExists","lowerValue","upperExists","upperValue","overloaded","$TypedArrayName","array","targetOffset","RangeError","targetBuffer","targetLength","targetName","targetElementSize","targetType","targetByteOffset","src","srcLength","targetByteIndex","limit","kNumber","typedArray","srcBuffer","srcName","srcType","srcElementSize","srcByteOffset","srcByteIndex","ArrayBuffer","elementSize","comparefn","SortCompare","x","y","mightBeUndefined","v","isNaN","comparefn_","result_","numb","arr","j","val","sort","begin","relativeBegin","beginIndex","endIndex","newLength","constructorName","beginByteOffset","argumentsList","firstElement","nextElement","defineNativeProperty","ArrayProto_toString","TypedArrayProto_values","SymbolIterator","SymbolToStringTag","name","build","type","$Prototype","TypedArrayPrototype","defineNativeConstant"],"mappings":"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","file":"TypedArrayPrototype.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../../realm.js\";\nimport type { ElementType } from \"../../types.js\";\nimport { ElementSize } from \"../../types.js\";\nimport { ObjectValue, StringValue, NumberValue, UndefinedValue, NullValue } from \"../../values/index.js\";\nimport {\n  ToInteger,\n  ToString,\n  ToStringPartial,\n  ToBooleanPartial,\n  ToObject,\n  ToObjectPartial,\n  ToLength,\n  ToNumber,\n} from \"../../methods/to.js\";\nimport { Call, Invoke } from \"../../methods/call.js\";\nimport { Get } from \"../../methods/get.js\";\nimport { HasProperty, HasSomeCompatibleType } from \"../../methods/has.js\";\nimport { IsDetachedBuffer, IsCallable } from \"../../methods/is.js\";\nimport {\n  ArrayElementSize,\n  ArrayElementType,\n  ValidateTypedArray,\n  TypedArraySpeciesCreate,\n  IntegerIndexedElementSet,\n  IntegerIndexedElementGet,\n} from \"../../methods/typedarray.js\";\nimport { CreateArrayIterator } from \"../../methods/create.js\";\nimport { SetValueInBuffer, GetValueFromBuffer, CloneArrayBuffer } from \"../../methods/arraybuffer.js\";\nimport { SameValue, SameValueZeroPartial, StrictEqualityComparisonPartial } from \"../../methods/abstract.js\";\nimport { Properties } from \"../../singletons.js\";\nimport invariant from \"../../invariant.js\";\n\nexport default function(realm: Realm, obj: ObjectValue): void {\n  // ECMA262 22.2.3.1\n  obj.defineNativeGetter(\"buffer\", context => {\n    // 1. Let O be the this value.\n    let O = context.throwIfNotConcrete();\n\n    // 2. If Type(O) is not Object, return undefined.\n    if (!(O instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(O) is not Object\");\n    }\n\n    // 3. If O does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.\n    if (!(\"$TypedArrayName\" in O)) {\n      throw realm.createErrorThrowCompletion(\n        realm.intrinsics.TypeError,\n        \"O does not have a [[TypedArrayName]] internal slot\"\n      );\n    }\n\n    // 4. Assert: O has a [[ViewedArrayBuffer]] internal slot.\n    invariant(O.$ViewedArrayBuffer, \"O has a [[ViewedArrayBuffer]]\");\n\n    // 5. Let buffer be O.[[ViewedArrayBuffer]].\n    let buffer = O.$ViewedArrayBuffer;\n\n    // 6. Return buffer.\n    return buffer;\n  });\n\n  // ECMA262 22.2.3.2\n  obj.defineNativeGetter(\"byteLength\", context => {\n    // 1. Let O be the this value.\n    let O = context.throwIfNotConcrete();\n\n    // 2. If Type(O) is not Object, throw a TypeError exception.\n    if (!(O instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(O) is not Object\");\n    }\n\n    // 3. If O does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.\n    if (!(\"$TypedArrayName\" in O)) {\n      throw realm.createErrorThrowCompletion(\n        realm.intrinsics.TypeError,\n        \"O does not have a [[TypedArrayName]] internal slot\"\n      );\n    }\n\n    // 4. Assert: O has [[ViewedArrayBuffer]] and [[ArrayLength]] internal slots.\n    invariant(O.$ViewedArrayBuffer, \"O has a [[ViewedArrayBuffer]] internal slot\");\n\n    // 5. Let buffer be O.[[ViewedArrayBuffer]].\n    let buffer = O.$ViewedArrayBuffer;\n    invariant(buffer);\n\n    // 6. If IsDetachedBuffer(buffer) is true, return 0.\n    if (IsDetachedBuffer(realm, buffer) === true) return realm.intrinsics.zero;\n\n    // 7. Let size be O.[[ByteLength]].\n    let size = O.$ByteLength;\n    invariant(typeof size === \"number\");\n\n    // 8. Return size.\n    return new NumberValue(realm, size);\n  });\n\n  // ECMA262 22.2.3.3\n  obj.defineNativeGetter(\"byteOffset\", context => {\n    // 1. Let O be the this value.\n    let O = context.throwIfNotConcrete();\n\n    // 2. If Type(O) is not Object, throw a TypeError exception.\n    if (!(O instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(O) is not Object\");\n    }\n\n    // 3. If O does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.\n    if (!(\"$TypedArrayName\" in O)) {\n      throw realm.createErrorThrowCompletion(\n        realm.intrinsics.TypeError,\n        \"O does not have a [[TypedArrayName]] internal slot\"\n      );\n    }\n\n    // 4. Assert: O has [[ViewedArrayBuffer]] and [[ArrayLength]] internal slots.\n    invariant(O.$ViewedArrayBuffer, \"O has a [[ViewedArrayBuffer]] internal slot\");\n\n    // 5. Let buffer be O.[[ViewedArrayBuffer]].\n    let buffer = O.$ViewedArrayBuffer;\n    invariant(buffer);\n\n    // 6. If IsDetachedBuffer(buffer) is true, return 0.\n    if (IsDetachedBuffer(realm, buffer) === true) return realm.intrinsics.zero;\n\n    // 7. Let offset be O.[[ByteOffset]].\n    let offset = O.$ByteOffset;\n    invariant(typeof offset === \"number\");\n\n    // 8. Return offset.\n    return new NumberValue(realm, offset);\n  });\n\n  // ECMA262 22.2.3.5\n  obj.defineNativeMethod(\"copyWithin\", 2, (context, [target, start, end]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = ToObject(realm, context.throwIfNotConcrete());\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. Let relativeTarget be ? ToInteger(target).\n    let relativeTarget = ToInteger(realm, target);\n\n    // 5. If relativeTarget < 0, let to be max((len + relativeTarget), 0); else let to be min(relativeTarget, len).\n    let to = relativeTarget < 0 ? Math.max(len + relativeTarget, 0) : Math.min(relativeTarget, len);\n\n    // 6. Let relativeStart be ? ToInteger(start).\n    let relativeStart = ToInteger(realm, start);\n\n    // 7. If relativeStart < 0, let from be max((len + relativeStart), 0); else let from be min(relativeStart, len).\n    let from = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);\n\n    // 8. If end is undefined, let relativeEnd be len; else let relativeEnd be ? ToInteger(end).\n    let relativeEnd = !end || end instanceof UndefinedValue ? len : ToInteger(realm, end.throwIfNotConcrete());\n\n    // 9. If relativeEnd < 0, let final be max((len + relativeEnd), 0); else let final be min(relativeEnd, len).\n    let final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);\n\n    // 10. Let count be min(final-from, len-to).\n    let count = Math.min(final - from, len - to);\n\n    let direction;\n    // 11. If from<to and to<from+count, then\n    if (from < to && to < from + count) {\n      // a. Let direction be -1.\n      direction = -1;\n\n      // b. Let from be from + count - 1.\n      from = from + count - 1;\n\n      // c. Let to be to + count - 1.\n      to = to + count - 1;\n    } else {\n      // 12. Else,\n      // a. Let direction be 1.\n      direction = 1;\n    }\n\n    // 13. Repeat, while count > 0\n    while (count > 0) {\n      // a. Let fromKey be ! ToString(from).\n      let fromKey = ToString(realm, new NumberValue(realm, from));\n\n      // b. Let toKey be ! ToString(to).\n      let toKey = ToString(realm, new NumberValue(realm, to));\n\n      // c. Let fromPresent be ? HasProperty(O, fromKey).\n      let fromPresent = HasProperty(realm, O, fromKey);\n\n      // d. If fromPresent is true, then\n      if (fromPresent === true) {\n        // i. Let fromVal be ? Get(O, fromKey).\n        let fromVal = Get(realm, O, fromKey);\n        // ii. Perform ? Set(O, toKey, fromVal, true).\n        Properties.Set(realm, O, toKey, fromVal, true);\n      } else {\n        // e. Else fromPresent is false,\n        // i. Perform ? DeletePropertyOrThrow(O, toKey).\n        Properties.DeletePropertyOrThrow(realm, O, toKey);\n      }\n\n      // f. Let from be from + direction.\n      from = from + direction;\n\n      // g. Let to be to + direction.\n      to = to + direction;\n\n      // h. Let count be count - 1.\n      count = count - 1;\n    }\n\n    // 14. Return O.\n    return O;\n  });\n\n  // ECMA262 22.2.3.6\n  obj.defineNativeMethod(\"entries\", 0, context => {\n    // 1. Let O be the this value.\n    let O = context;\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n    invariant(O instanceof ObjectValue);\n\n    // 3. Return CreateArrayIterator(O, \"key+value\").\n    return CreateArrayIterator(realm, O, \"key+value\");\n  });\n\n  // ECMA262 22.2.3.7\n  obj.defineNativeMethod(\"every\", 1, (context, [callbackfn, thisArg]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = ToObject(realm, context.throwIfNotConcrete());\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.\n    if (!IsCallable(realm, callbackfn)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not a function\");\n    }\n\n    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.\n    let T = thisArg || realm.intrinsics.undefined;\n\n    // 6. Let k be 0.\n    let k = 0;\n\n    // 7. Repeat, while k < len\n    while (k < len) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = new StringValue(realm, k + \"\");\n\n      // b. Let kPresent be ? HasProperty(O, Pk).\n      let kPresent = HasProperty(realm, O, Pk);\n\n      // c. If kPresent is true, then\n      if (kPresent) {\n        // i. Let kValue be ? Get(O, Pk).\n        let kValue = Get(realm, O, Pk);\n\n        // ii. Let testResult be ToBoolean(? Call(callbackfn, T, « kValue, k, O »)).\n        let testResult = ToBooleanPartial(realm, Call(realm, callbackfn, T, [kValue, new NumberValue(realm, k), O]));\n\n        // iii. If testResult is false, return false.\n        if (!testResult) return realm.intrinsics.false;\n      }\n\n      // d. Increase k by 1.\n      k++;\n    }\n\n    // 8. Return true.\n    return realm.intrinsics.true;\n  });\n\n  // ECMA262 22.2.3.8\n  obj.defineNativeMethod(\"fill\", 1, (context, [value, start, end]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = ToObject(realm, context.throwIfNotConcrete());\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. Let relativeStart be ? ToInteger(start).\n    let relativeStart = ToInteger(realm, start || realm.intrinsics.undefined);\n\n    // 5. If relativeStart < 0, let k be max((len + relativeStart), 0); else let k be min(relativeStart, len).\n    let k = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);\n\n    // 6. If end is undefined, let relativeEnd be len; else let relativeEnd be ? ToInteger(end).\n    let relativeEnd = !end || end instanceof UndefinedValue ? len : ToInteger(realm, end.throwIfNotConcrete());\n\n    // 7. If relativeEnd < 0, let final be max((len + relativeEnd), 0); else let final be min(relativeEnd, len).\n    let final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);\n\n    // 8. Repeat, while k < final\n    while (k < final) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = new StringValue(realm, k + \"\");\n\n      // b. Perform ? Set(O, Pk, value, true).\n      Properties.Set(realm, O, Pk, value, true);\n\n      // c. Increase k by 1.\n      k++;\n    }\n\n    // 9. Return O.\n    return O;\n  });\n\n  // ECMA262 22.2.3.9\n  obj.defineNativeMethod(\"filter\", 1, (context, [callbackfn, thisArg]) => {\n    // 1. Let O be the this value.\n    let O = context;\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n    invariant(O instanceof ObjectValue);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.\n    if (IsCallable(realm, callbackfn) === false) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsCallable(callbackfn) is false\");\n    }\n\n    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.\n    let T = thisArg ? thisArg : realm.intrinsics.undefined;\n\n    // 6. Let kept be a new empty List.\n    let kept = [];\n\n    // 7. Let k be 0.\n    let k = 0;\n\n    // 8. Let captured be 0.\n    let captured = 0;\n\n    // 9. Repeat, while k < len\n    while (k < len) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = ToString(realm, new NumberValue(realm, k));\n\n      // b. Let kValue be ? Get(O, Pk).\n      let kValue = Get(realm, O, Pk);\n\n      // c. Let selected be ToBoolean(? Call(callbackfn, T, « kValue, k, O »)).\n      let selected = ToBooleanPartial(realm, Call(realm, callbackfn, T, [kValue, new NumberValue(realm, k), O]));\n\n      // d. If selected is true, then\n      if (selected === true) {\n        // i. Append kValue to the end of kept.\n        kept.push(kValue);\n\n        // ii. Increase captured by 1.\n        captured += 1;\n      }\n\n      // e. Increase k by 1.\n      k += 1;\n    }\n\n    // 10. Let A be ? TypedArraySpeciesCreate(O, « captured »).\n    let A = TypedArraySpeciesCreate(realm, O, [new NumberValue(realm, captured)]);\n\n    // 11. Let n be 0.\n    let n = 0;\n\n    // 12. For each element e of kept\n    for (let e of kept) {\n      // a. Perform ! Set(A, ! ToString(n), e, true).\n      Properties.Set(realm, A, new StringValue(realm, ToString(realm, new NumberValue(realm, n))), e, true);\n\n      // b. Increment n by 1.\n      n = n + 1;\n    }\n\n    // 13. Return A.\n    return A;\n  });\n\n  // ECMA262 22.2.3.10\n  obj.defineNativeMethod(\"find\", 1, (context, [predicate, thisArg]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = ToObject(realm, context.throwIfNotConcrete());\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. If IsCallable(predicate) is false, throw a TypeError exception.\n    if (!IsCallable(realm, predicate)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not a function\");\n    }\n\n    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.\n    let T = thisArg || realm.intrinsics.undefined;\n\n    // 6. Let k be 0.\n    let k = 0;\n\n    // 7. Repeat, while k < len\n    while (k < len) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = new StringValue(realm, k + \"\");\n\n      // b. Let kValue be ? Get(O, Pk).\n      let kValue = Get(realm, O, Pk);\n\n      // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).\n      let testResult = ToBooleanPartial(realm, Call(realm, predicate, T, [kValue, new NumberValue(realm, k), O]));\n\n      // d. If testResult is true, return kValue.\n      if (testResult) return kValue;\n\n      // e. Increase k by 1.\n      k++;\n    }\n\n    // 8. Return undefined.\n    return realm.intrinsics.undefined;\n  });\n\n  // ECMA262 22.2.3.11\n  obj.defineNativeMethod(\"findIndex\", 1, (context, [predicate, thisArg]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = ToObject(realm, context.throwIfNotConcrete());\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. If IsCallable(predicate) is false, throw a TypeError exception.\n    if (IsCallable(realm, predicate) === false) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not a function\");\n    }\n\n    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.\n    let T = thisArg ? thisArg : realm.intrinsics.undefined;\n\n    // 6. Let k be 0.\n    let k = 0;\n\n    // 7. Repeat, while k < len\n    while (k < len) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = ToString(realm, new NumberValue(realm, k));\n\n      // b. Let kValue be ? Get(O, Pk).\n      let kValue = Get(realm, O, new StringValue(realm, Pk));\n\n      // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).\n      let testResult = ToBooleanPartial(realm, Call(realm, predicate, T, [kValue, new NumberValue(realm, k), O]));\n\n      // d. If testResult is true, return k.\n      if (testResult === true) return new NumberValue(realm, k);\n\n      // e. Increase k by 1.\n      k = k + 1;\n    }\n\n    // 8. Return -1.\n    return new NumberValue(realm, -1);\n  });\n\n  // ECMA262 22.2.3.12\n  obj.defineNativeMethod(\"forEach\", 1, (context, [callbackfn, thisArg]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = ToObject(realm, context.throwIfNotConcrete());\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.\n    if (!IsCallable(realm, callbackfn)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not a function\");\n    }\n\n    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.\n    let T = thisArg || realm.intrinsics.undefined;\n\n    // 6. Let k be 0.\n    let k = 0;\n\n    // 7. Repeat, while k < len\n    while (k < len) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = new StringValue(realm, k + \"\");\n\n      // b. Let kPresent be ? HasProperty(O, Pk).\n      let kPresent = HasProperty(realm, O, Pk);\n\n      // c. If kPresent is true, then\n      if (kPresent) {\n        // i. Let kValue be ? Get(O, Pk).\n        let kValue = Get(realm, O, Pk);\n\n        // ii. Perform ? Call(callbackfn, T, « kValue, k, O »).\n        Call(realm, callbackfn, T, [kValue, new NumberValue(realm, k), O]);\n      }\n\n      // d. Increase k by 1.\n      k++;\n    }\n\n    // 8. Return undefined.\n    return realm.intrinsics.undefined;\n  });\n\n  // ECMA262 22.2.3.14\n  obj.defineNativeMethod(\"includes\", 1, (context, [searchElement, fromIndex]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = ToObject(realm, context.throwIfNotConcrete());\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. If len is 0, return false.\n    if (len === 0) return realm.intrinsics.false;\n\n    // 5. Let n be ? ToInteger(fromIndex). (If fromIndex is undefined, this step produces the value 0.)\n    let n = ToInteger(realm, fromIndex || realm.intrinsics.undefined);\n\n    let k;\n    // 6. If n ≥ 0, then\n    if (n >= 0) {\n      // a. Let k be n.\n      k = n;\n    } else {\n      // 7. Else n < 0,\n      // a. Let k be len + n.\n      k = len + n;\n      // b. If k < 0, let k be 0.\n      if (k < 0) k = 0;\n    }\n\n    // 8. Repeat, while k < len\n    while (k < len) {\n      // a. Let elementK be the result of ? Get(O, ! ToString(k)).\n      let elementK = Get(realm, O, ToString(realm, new NumberValue(realm, k)));\n\n      // b. If SameValueZero(searchElement, elementK) is true, return true.\n      if (SameValueZeroPartial(realm, searchElement, elementK) === true) return realm.intrinsics.true;\n\n      // c. Increase k by 1.\n      k = k + 1;\n    }\n\n    // 9. Return false.\n    return realm.intrinsics.false;\n  });\n\n  // ECMA262 22.2.3.14\n  obj.defineNativeMethod(\"indexOf\", 1, (context, [searchElement, fromIndex]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = ToObject(realm, context.throwIfNotConcrete());\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. If len is 0, return -1.\n    if (len === 0) return new NumberValue(realm, -1);\n\n    // 5. Let n be ? ToInteger(fromIndex). (If fromIndex is undefined, this step produces the value 0.)\n    let n = fromIndex ? ToInteger(realm, fromIndex) : 0;\n\n    // 6. If n ≥ len, return -1.\n    if (n >= len) return new NumberValue(realm, -1);\n\n    // 7. If n ≥ 0, then\n    let k;\n    if (n >= 0) {\n      // a. If n is -0, let k be +0; else let k be n.\n      k = Object.is(n, -0) ? +0 : n;\n    } else {\n      // 8. Else n < 0,\n      // a. Let k be len + n.\n      k = len + n;\n\n      // b. If k < 0, let k be 0.\n      if (k < 0) k = 0;\n    }\n\n    // 9. Repeat, while k < len\n    while (k < len) {\n      // a. Let kPresent be ? HasProperty(O, ! ToString(k)).\n      let kPresent = HasProperty(realm, O, k + \"\");\n\n      // b. If kPresent is true, then\n      if (kPresent === true) {\n        // i. Let elementK be ? Get(O, ! ToString(k)).\n        let elementK = Get(realm, O, k + \"\");\n\n        // ii. Let same be the result of performing Strict Equality Comparison searchElement === elementK.\n        let same = StrictEqualityComparisonPartial(realm, searchElement, elementK);\n\n        // iii. If same is true, return k.\n        if (same) return new NumberValue(realm, k);\n      }\n\n      // c. Increase k by 1.\n      k++;\n    }\n\n    // 10. Return -1.\n    return new NumberValue(realm, -1);\n  });\n\n  // ECMA262 22.2.3.15\n  obj.defineNativeMethod(\"join\", 1, (context, [separator]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = ToObject(realm, context.throwIfNotConcrete());\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. If separator is undefined, let separator be the single-element String \",\".\n    if (!separator || separator instanceof UndefinedValue) separator = new StringValue(realm, \",\");\n\n    // 5. Let sep be ? ToString(separator).\n    let sep = ToStringPartial(realm, separator);\n\n    // 6. If len is zero, return the empty String.\n    if (len === 0) return realm.intrinsics.emptyString;\n\n    // 7. Let element0 be Get(O, \"0\").\n    let element0 = Get(realm, O, \"0\");\n\n    // 8. If element0 is undefined or null, let R be the empty String; otherwise, let R be ? ToString(element0).\n    let R: ?string;\n    if (HasSomeCompatibleType(element0, UndefinedValue, NullValue)) {\n      R = \"\";\n    } else {\n      R = ToStringPartial(realm, element0);\n    }\n\n    // 9. Let k be 1.\n    let k = 1;\n\n    // 10. Repeat, while k < len\n    while (k < len) {\n      // a. Let S be the String value produced by concatenating R and sep.\n      let S: string = R + sep;\n\n      // b. Let element be ? Get(O, ! ToString(k)).\n      let element = Get(realm, O, new StringValue(realm, k + \"\"));\n\n      // c. If element is undefined or null, let next be the empty String; otherwise, let next be ? ToString(element).\n      let next: ?string;\n      if (HasSomeCompatibleType(element, UndefinedValue, NullValue)) {\n        next = \"\";\n      } else {\n        next = ToStringPartial(realm, element);\n      }\n\n      // d. Let R be a String value produced by concatenating S and next.\n      R = S + next;\n\n      // e. Increase k by 1.\n      k++;\n    }\n\n    // 11. Return R.\n    return new StringValue(realm, R + \"\");\n  });\n\n  // ECMA262 22.2.3.16\n  obj.defineNativeMethod(\"keys\", 0, context => {\n    // 1. Let O be the this value.\n    let O = context;\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n    invariant(O instanceof ObjectValue);\n\n    // 3. Return CreateArrayIterator(O, \"key\").\n    return CreateArrayIterator(realm, O, \"key\");\n  });\n\n  // ECMA262 22.2.3.17\n  obj.defineNativeMethod(\"lastIndexOf\", 1, (context, [searchElement, fromIndex]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = ToObject(realm, context.throwIfNotConcrete());\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. If len is 0, return -1.\n    if (len === 0) return new NumberValue(realm, -1);\n\n    // 5. If argument fromIndex was passed, let n be ? ToInteger(fromIndex); else let n be len-1.\n    let n = fromIndex ? ToInteger(realm, fromIndex) : len - 1;\n\n    // 6. If n ≥ 0, then\n    let k;\n    if (n >= 0) {\n      // a. If n is -0, let k be +0; else let k be min(n, len - 1).\n      k = Object.is(n, -0) ? +0 : Math.min(n, len - 1);\n    } else {\n      // 7. Else n < 0,\n      // a. Let k be len + n.\n      k = len + n;\n    }\n\n    // 8. Repeat, while k ≥ 0\n    while (k >= 0) {\n      // a. Let kPresent be ? HasProperty(O, ! ToString(k)).\n      let kPresent = HasProperty(realm, O, new StringValue(realm, k + \"\"));\n\n      // b. If kPresent is true, then\n      if (kPresent) {\n        // i. Let elementK be ? Get(O, ! ToString(k)).\n        let elementK = Get(realm, O, new StringValue(realm, k + \"\"));\n\n        // ii. Let same be the result of performing Strict Equality Comparison searchElement === elementK.\n        let same = StrictEqualityComparisonPartial(realm, searchElement, elementK);\n\n        // iii. If same is true, return k.\n        if (same) return new NumberValue(realm, k);\n      }\n\n      // c. Decrease k by 1.\n      k--;\n    }\n\n    // 9. Return -1.\n    return new NumberValue(realm, -1);\n  });\n\n  // ECMA262 22.2.3.18\n  obj.defineNativeGetter(\"length\", context => {\n    // 1. Let O be the this value.\n    let O = context.throwIfNotConcrete();\n\n    // 2. If Type(O) is not Object, throw a TypeError exception.\n    if (!(O instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(O) is not Object\");\n    }\n\n    // 3. If O does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.\n    if (!(\"$TypedArrayName\" in O)) {\n      throw realm.createErrorThrowCompletion(\n        realm.intrinsics.TypeError,\n        \"O does not have a [[TypedArrayName]] internal slot\"\n      );\n    }\n\n    // 4. Assert: O has [[ViewedArrayBuffer]] and [[ArrayLength]] internal slots.\n    invariant(O.$ViewedArrayBuffer, \"O has a [[ViewedArrayBuffer]] internal slot\");\n\n    // 5. Let buffer be O.[[ViewedArrayBuffer]].\n    let buffer = O.$ViewedArrayBuffer;\n    invariant(buffer);\n\n    // 6. If IsDetachedBuffer(buffer) is true, return 0.\n    if (IsDetachedBuffer(realm, buffer) === true) return realm.intrinsics.zero;\n\n    // 7. Let length be O.[[ArrayLength]].\n    let length = O.$ArrayLength;\n    invariant(typeof length === \"number\");\n\n    // 8. Return length.\n    return new NumberValue(realm, length);\n  });\n\n  // ECMA262 22.2.3.19\n  obj.defineNativeMethod(\"map\", 1, (context, [callbackfn, thisArg]) => {\n    // 1. Let O be the this value.\n    let O = context;\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n    invariant(O instanceof ObjectValue);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.\n    if (IsCallable(realm, callbackfn) === false) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsCallable(callbackfn) is false\");\n    }\n\n    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.\n    let T = thisArg ? thisArg : realm.intrinsics.undefined;\n\n    // 6. Let A be ? TypedArraySpeciesCreate(O, « len »).\n    let A = TypedArraySpeciesCreate(realm, O, [new NumberValue(realm, len)]);\n\n    // 7. Let k be 0.\n    let k = 0;\n\n    // 8. Repeat, while k < len\n    while (k < len) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = ToString(realm, new NumberValue(realm, k));\n\n      // b. Let kValue be ? Get(O, Pk).\n      let kValue = Get(realm, O, Pk);\n\n      // c. Let mappedValue be ? Call(callbackfn, T, « kValue, k, O »).\n      let mappedValue = Call(realm, callbackfn, T, [kValue, new NumberValue(realm, k), O]);\n\n      // d. Perform ? Set(A, Pk, mappedValue, true).\n      Properties.Set(realm, A, Pk, mappedValue, true);\n\n      // e. Increase k by 1.\n      k = k + 1;\n    }\n\n    // 9. Return A.\n    return A;\n  });\n\n  // ECMA262 22.2.3.20\n  obj.defineNativeMethod(\"reduce\", 1, (context, [callbackfn, initialValue]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = ToObject(realm, context.throwIfNotConcrete());\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.\n    if (!IsCallable(realm, callbackfn)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not a function\");\n    }\n\n    // 5. If len is 0 and initialValue is not present, throw a TypeError exception.\n    if (len === 0 && !initialValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Array.prototype\");\n    }\n\n    // 6. Let k be 0.\n    let k = 0;\n\n    // 7. If initialValue is present, then\n    let accumulator;\n    if (initialValue) {\n      // a. Set accumulator to initialValue.\n      accumulator = initialValue;\n    } else {\n      // 8. Else initialValue is not present,\n      // a. Let kPresent be false.\n      let kPresent = false;\n\n      // b. Repeat, while kPresent is false and k < len\n      while (kPresent === false && k < len) {\n        // i. Let Pk be ! ToString(k).\n        let Pk = new StringValue(realm, k + \"\");\n\n        // ii. Let kPresent be ? HasProperty(O, Pk).\n        kPresent = HasProperty(realm, O, Pk);\n\n        // iv. If kPresent is true, then\n        if (kPresent) {\n          // 1. Let accumulator be ? Get(O, Pk).\n          accumulator = Get(realm, O, Pk);\n        }\n\n        // v. Increase k by 1.\n        k++;\n      }\n\n      // c. If kPresent is false, throw a TypeError exception.\n      if (!kPresent) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"kPresent is false\");\n      }\n\n      invariant(accumulator);\n    }\n\n    // 9. Repeat, while k < len\n    while (k < len) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = new StringValue(realm, k + \"\");\n\n      // b. Let kPresent be ? HasProperty(O, Pk).\n      let kPresent = HasProperty(realm, O, Pk);\n\n      // c. If kPresent is true, then\n      if (kPresent) {\n        // i. Let kValue be ? Get(O, Pk).\n        let kValue = Get(realm, O, Pk);\n\n        // ii. Let accumulator be ? Call(callbackfn, undefined, « accumulator, kValue, k, O »).\n        accumulator = Call(realm, callbackfn, realm.intrinsics.undefined, [\n          accumulator,\n          kValue,\n          new NumberValue(realm, k),\n          O,\n        ]);\n      }\n\n      // d. Increase k by 1.\n      k++;\n    }\n\n    // 10. Return accumulator.\n    return accumulator;\n  });\n\n  // ECMA262 22.2.3.21\n  obj.defineNativeMethod(\"reduceRight\", 1, (context, [callbackfn, initialValue]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = ToObject(realm, context.throwIfNotConcrete());\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.\n    if (!IsCallable(realm, callbackfn)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not a function\");\n    }\n\n    // 5. If len is 0 and initialValue is not present, throw a TypeError exception.\n    if (len === 0 && !initialValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Array.prototype\");\n    }\n\n    // 6. Let k be len-1.\n    let k = len - 1;\n\n    // 7. If initialValue is present, then\n    let accumulator;\n    if (initialValue) {\n      // 1. Set accumulator to initialValue.\n      accumulator = initialValue;\n    } else {\n      // 8. Else initialValue is not present,\n      // a. Let kPresent be false.\n      let kPresent = false;\n\n      // b. Repeat, while kPresent is false and k ≥ 0\n      while (!kPresent && k >= 0) {\n        // i. Let Pk be ! ToString(k).\n        let Pk = new StringValue(realm, k + \"\");\n\n        // ii. Let kPresent be ? HasProperty(O, Pk).\n        kPresent = HasProperty(realm, O, Pk);\n\n        // iii. If kPresent is true, then\n        if (kPresent) {\n          // 1. Let accumulator be ? Get(O, Pk).\n          accumulator = Get(realm, O, Pk);\n        }\n\n        // iv. Decrease k by 1.\n        k--;\n      }\n\n      // c. If kPresent is false, throw a TypeError exception.\n      if (!kPresent || !accumulator) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Array.prototype\");\n      }\n    }\n\n    // 9. Repeat, while k ≥ 0\n    while (k >= 0) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = new StringValue(realm, k + \"\");\n\n      // b. Let kPresent be ? HasProperty(O, Pk).\n      let kPresent = HasProperty(realm, O, Pk);\n\n      // c. If kPresent is true, then\n      if (kPresent) {\n        // i. Let kValue be ? Get(O, Pk).\n        let kValue = Get(realm, O, Pk);\n\n        // ii. Let accumulator be ? Call(callbackfn, undefined, « accumulator, kValue, k, O »).\n        accumulator = Call(realm, callbackfn, realm.intrinsics.undefined, [\n          accumulator,\n          kValue,\n          new NumberValue(realm, k),\n          O,\n        ]);\n      }\n\n      // d. Decrease k by 1.\n      k--;\n    }\n\n    // 10. Return accumulator.\n    return accumulator;\n  });\n\n  // ECMA262 22.2.3.21\n  obj.defineNativeMethod(\"reverse\", 0, context => {\n    // 1. Let O be ? ToObject(this value).\n    let O = ToObject(realm, context.throwIfNotConcrete());\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. Let middle be floor(len/2).\n    let middle = Math.floor(len / 2);\n\n    // 5. Let lower be 0.\n    let lower = 0;\n\n    // 6. Repeat, while lower ≠ middle\n    while (lower !== middle) {\n      // a. Let upper be len - lower - 1.\n      let upper = len - lower - 1;\n\n      // b. Let upperP be ! ToString(upper).\n      let upperP = new StringValue(realm, upper + \"\");\n\n      // c. Let lowerP be ! ToString(lower).\n      let lowerP = new StringValue(realm, lower + \"\");\n\n      // d. Let lowerExists be ? HasProperty(O, lowerP).\n      let lowerExists = HasProperty(realm, O, lowerP);\n\n      // e. If lowerExists is true, then\n      let lowerValue;\n      if (lowerExists) {\n        // i. Let lowerValue be ? Get(O, lowerP).\n        lowerValue = Get(realm, O, lowerP);\n      }\n\n      // f. Let upperExists be ? HasProperty(O, upperP).\n      let upperExists = HasProperty(realm, O, upperP);\n\n      // g. If upperExists is true, then\n      let upperValue;\n      if (upperExists) {\n        // i. Let upperValue be ? Get(O, upperP).\n        upperValue = Get(realm, O, upperP);\n      }\n\n      // h. If lowerExists is true and upperExists is true, then\n      if (lowerExists && upperExists) {\n        invariant(lowerValue, \"expected lower value to exist\");\n        invariant(upperValue, \"expected upper value to exist\");\n\n        // i. Perform ? Set(O, lowerP, upperValue, true).\n        Properties.Set(realm, O, lowerP, upperValue, true);\n\n        // ii. Perform ? Set(O, upperP, lowerValue, true).\n        Properties.Set(realm, O, upperP, lowerValue, true);\n      } else if (!lowerExists && upperExists) {\n        // i. Else if lowerExists is false and upperExists is true, then\n        invariant(upperValue, \"expected upper value to exist\");\n\n        // i. Perform ? Set(O, lowerP, upperValue, true).\n        Properties.Set(realm, O, lowerP, upperValue, true);\n\n        // ii. Perform ? DeletePropertyOrThrow(O, upperP).\n        Properties.DeletePropertyOrThrow(realm, O, upperP);\n      } else if (lowerExists && !upperExists) {\n        // j. Else if lowerExists is true and upperExists is false, then\n        invariant(lowerValue, \"expected lower value to exist\");\n\n        // i. Perform ? DeletePropertyOrThrow(O, lowerP).\n        Properties.DeletePropertyOrThrow(realm, O, lowerP);\n\n        // ii. Perform ? Set(O, upperP, lowerValue, true).\n        Properties.Set(realm, O, upperP, lowerValue, true);\n      } else {\n        // k. Else both lowerExists and upperExists are false,\n        // i. No action is required.\n      }\n\n      // l. Increase lower by 1.\n      lower++;\n    }\n\n    // 7. Return O.\n    return O;\n  });\n\n  // ECMA262 22.2.3.23\n  obj.defineNativeMethod(\"set\", 1, (context, [overloaded, offset]) => {\n    if (!overloaded.$TypedArrayName) {\n      let array = overloaded;\n\n      // 1. Assert: array is any ECMAScript language value other than an Object with a [[TypedArrayName]] internal slot. If it is such an Object, the definition in 22.2.3.23.2 applies.\n      invariant(!(overloaded instanceof ObjectValue && overloaded.$TypedArrayName));\n\n      // 2. Let target be the this value.\n      let target = context.throwIfNotConcrete();\n\n      // 3. If Type(target) is not Object, throw a TypeError exception.\n      if (!(target instanceof ObjectValue)) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(target) is not Object\");\n      }\n\n      // 4. If target does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.\n      if (typeof target.$TypedArrayName !== \"string\") {\n        throw realm.createErrorThrowCompletion(\n          realm.intrinsics.TypeError,\n          \"target does not have a [[TypedArrayName]] internal slot\"\n        );\n      }\n\n      // 5. Assert: target has a [[ViewedArrayBuffer]] internal slot.\n      invariant(target.$ViewedArrayBuffer, \"target has a [[ViewedArrayBuffer]] internal slot\");\n\n      // 6. Let targetOffset be ? ToInteger(offset).\n      let targetOffset = ToInteger(realm, offset || realm.intrinsics.undefined);\n\n      // 7. If targetOffset < 0, throw a RangeError exception.\n      if (targetOffset < 0) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"targetOffset < 0\");\n      }\n\n      // 8. Let targetBuffer be target.[[ViewedArrayBuffer]].\n      let targetBuffer = target.$ViewedArrayBuffer;\n      invariant(targetBuffer instanceof ObjectValue);\n\n      // 9. If IsDetachedBuffer(targetBuffer) is true, throw a TypeError exception.\n      if (IsDetachedBuffer(realm, targetBuffer) === true) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsDetachedBuffer(targetBuffer) is true\");\n      }\n\n      // 10. Let targetLength be target.[[ArrayLength]].\n      let targetLength = target.$ArrayLength;\n      invariant(typeof targetLength === \"number\");\n\n      // 11. Let targetName be the String value of target.[[TypedArrayName]].\n      let targetName = target.$TypedArrayName;\n      invariant(typeof targetName === \"string\");\n\n      // 12. Let targetElementSize be the Number value of the Element Size value specified in Table 50 for targetName.\n      let targetElementSize = ArrayElementSize[targetName];\n\n      // 13. Let targetType be the String value of the Element Type value in Table 50 for targetName.\n      let targetType = ArrayElementType[targetName];\n\n      // 14. Let targetByteOffset be target.[[ByteOffset]].\n      let targetByteOffset = target.$ByteOffset;\n      invariant(typeof targetByteOffset === \"number\");\n\n      // 15. Let src be ? ToObject(array).\n      let src = ToObjectPartial(realm, array);\n\n      // 16. Let srcLength be ? ToLength(? Get(src, \"length\")).\n      let srcLength = ToLength(realm, Get(realm, src, \"length\"));\n\n      // 17. If srcLength + targetOffset > targetLength, throw a RangeError exception.\n      if (srcLength + targetOffset > targetLength) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"srcLength + targetOffset > targetLength\");\n      }\n\n      // 18. Let targetByteIndex be targetOffset × targetElementSize + targetByteOffset.\n      let targetByteIndex = targetOffset * targetElementSize + targetByteOffset;\n\n      // 19. Let k be 0.\n      let k = 0;\n\n      // 20. Let limit be targetByteIndex + targetElementSize × srcLength.\n      let limit = targetByteIndex + targetElementSize * srcLength;\n\n      // 21. Repeat, while targetByteIndex < limit\n      while (targetByteIndex < limit) {\n        // a. Let Pk be ! ToString(k).\n        let Pk = ToString(realm, new NumberValue(realm, k));\n\n        // b. Let kNumber be ? ToNumber(? Get(src, Pk)).\n        let kNumber = ToNumber(realm, Get(realm, src, Pk));\n\n        // c. If IsDetachedBuffer(targetBuffer) is true, throw a TypeError exception.\n        if (IsDetachedBuffer(realm, targetBuffer) === true) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsDetachedBuffer(targetBuffer) is true\");\n        }\n\n        // d. Perform SetValueInBuffer(targetBuffer, targetByteIndex, targetType, kNumber).\n        SetValueInBuffer(realm, targetBuffer, targetByteIndex, targetType, kNumber);\n\n        // e. Set k to k + 1.\n        k = k + 1;\n\n        // f. Set targetByteIndex to targetByteIndex + targetElementSize.\n        targetByteIndex = targetByteIndex + targetElementSize;\n      }\n\n      // 22. Return undefined.\n      return realm.intrinsics.undefined;\n    } else {\n      let typedArray = overloaded;\n\n      // 1. Assert: typedArray has a [[TypedArrayName]] internal slot. If it does not, the definition in 22.2.3.23.1 applies.\n      invariant(typedArray instanceof ObjectValue && typedArray.$TypedArrayName);\n\n      // 2. Let target be the this value.\n      let target = context.throwIfNotConcrete();\n\n      // 3. If Type(target) is not Object, throw a TypeError exception.\n      if (!(target instanceof ObjectValue)) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(target) is not Object\");\n      }\n\n      // 4. If target does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.\n      if (typeof target.$TypedArrayName !== \"string\") {\n        throw realm.createErrorThrowCompletion(\n          realm.intrinsics.TypeError,\n          \"target does not have a [[TypedArrayName]] internal slot\"\n        );\n      }\n\n      // 5. Assert: target has a [[ViewedArrayBuffer]] internal slot.\n      invariant(target.$ViewedArrayBuffer);\n\n      // 6. Let targetOffset be ? ToInteger(offset).\n      let targetOffset = ToInteger(realm, offset || realm.intrinsics.undefined);\n\n      // 7. If targetOffset < 0, throw a RangeError exception.\n      if (targetOffset < 0) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"targetOffset < 0\");\n      }\n\n      // 8. Let targetBuffer be target.[[ViewedArrayBuffer]].\n      let targetBuffer = target.$ViewedArrayBuffer;\n      invariant(targetBuffer instanceof ObjectValue);\n\n      // 9. If IsDetachedBuffer(targetBuffer) is true, throw a TypeError exception.\n      if (IsDetachedBuffer(realm, targetBuffer) === true) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsDetachedBuffer(targetBuffer) is true\");\n      }\n\n      // 10. Let targetLength be target.[[ArrayLength]].\n      let targetLength = target.$ArrayLength;\n      invariant(typeof targetLength === \"number\");\n\n      // 11. Let srcBuffer be typedArray.[[ViewedArrayBuffer]].\n      let srcBuffer = typedArray.$ViewedArrayBuffer;\n      invariant(srcBuffer);\n\n      // 12. If IsDetachedBuffer(srcBuffer) is true, throw a TypeError exception.\n      if (IsDetachedBuffer(realm, srcBuffer) === true) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsDetachedBuffer(srcBuffer) is true\");\n      }\n\n      // 13. Let targetName be the String value of target.[[TypedArrayName]].\n      let targetName = target.$TypedArrayName;\n      invariant(typeof targetName === \"string\");\n\n      // 14. Let targetType be the String value of the Element Type value in Table 50 for targetName.\n      let targetType = ArrayElementType[targetName];\n\n      // 15. Let targetElementSize be the Number value of the Element Size value specified in Table 50 for targetName.\n      let targetElementSize = ArrayElementSize[targetName];\n\n      // 16. Let targetByteOffset be target.[[ByteOffset]].\n      let targetByteOffset = target.$ByteOffset;\n      invariant(typeof targetByteOffset === \"number\");\n\n      // 17. Let srcName be the String value of typedArray.[[TypedArrayName]].\n      let srcName = typedArray.$TypedArrayName;\n      invariant(typeof srcName === \"string\");\n\n      // 18. Let srcType be the String value of the Element Type value in Table 50 for srcName.\n      let srcType = ArrayElementType[srcName];\n\n      // 19. Let srcElementSize be the Number value of the Element Size value specified in Table 50 for srcName.\n      let srcElementSize = ArrayElementSize[srcName];\n\n      // 20. Let srcLength be typedArray.[[ArrayLength]].\n      let srcLength = typedArray.$ArrayLength;\n      invariant(typeof srcLength === \"number\");\n\n      // 21. Let srcByteOffset be typedArray.[[ByteOffset]].\n      let srcByteOffset = typedArray.$ByteOffset;\n      invariant(typeof srcByteOffset === \"number\");\n\n      // 22. If srcLength + targetOffset > targetLength, throw a RangeError exception.\n      if (srcLength + targetOffset > targetLength) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"srcLength + targetOffset > targetLength\");\n      }\n\n      let srcByteIndex;\n      // 23. If SameValue(srcBuffer, targetBuffer) is true, then\n      if (SameValue(realm, srcBuffer, targetBuffer) === true) {\n        // a. Let srcBuffer be ? CloneArrayBuffer(targetBuffer, srcByteOffset, %ArrayBuffer%).\n        srcBuffer = CloneArrayBuffer(realm, targetBuffer, srcByteOffset, realm.intrinsics.ArrayBuffer);\n\n        // b. NOTE: %ArrayBuffer% is used to clone srcBuffer because is it known to not have any observable side-effects.\n\n        // c. Let srcByteIndex be 0.\n        srcByteIndex = 0;\n      } else {\n        // 24. Else, let srcByteIndex be srcByteOffset.\n        srcByteIndex = srcByteOffset;\n      }\n\n      // 25. Let targetByteIndex be targetOffset × targetElementSize + targetByteOffset.\n      let targetByteIndex = targetOffset * targetElementSize + targetByteOffset;\n\n      // 26. Let limit be targetByteIndex + targetElementSize × srcLength.\n      let limit = targetByteIndex + targetElementSize * srcLength;\n\n      // 27. If SameValue(srcType, targetType) is true, then\n      if (srcType === targetType) {\n        // a. NOTE: If srcType and targetType are the same, the transfer must be performed in a manner that preserves the bit-level encoding of the source data.\n\n        // b. Repeat, while targetByteIndex < limit\n        while (targetByteIndex < limit) {\n          // i. Let value be GetValueFromBuffer(srcBuffer, srcByteIndex, \"Uint8\").\n          let value = GetValueFromBuffer(realm, srcBuffer, srcByteIndex, \"Uint8\");\n\n          // ii. Perform SetValueInBuffer(targetBuffer, targetByteIndex, \"Uint8\", value).\n          SetValueInBuffer(realm, targetBuffer, targetByteIndex, \"Uint8\", value.value);\n\n          // iii. Set srcByteIndex to srcByteIndex + 1.\n          srcByteIndex += 1;\n\n          // iv. Set targetByteIndex to targetByteIndex + 1.\n          targetByteIndex += 1;\n        }\n      } else {\n        // 28. Else,\n        // a. Repeat, while targetByteIndex < limit\n        while (targetByteIndex < limit) {\n          // i. Let value be GetValueFromBuffer(srcBuffer, srcByteIndex, srcType).\n          let value = GetValueFromBuffer(realm, srcBuffer, srcByteIndex, srcType);\n\n          // ii. Perform SetValueInBuffer(targetBuffer, targetByteIndex, targetType, value).\n          SetValueInBuffer(realm, targetBuffer, targetByteIndex, targetType, value.value);\n\n          // iii. Set srcByteIndex to srcByteIndex + srcElementSize.\n          srcByteIndex = srcByteIndex + srcElementSize;\n\n          // iv. Set targetByteIndex to targetByteIndex + targetElementSize.\n          targetByteIndex = targetByteIndex + targetElementSize;\n        }\n      }\n\n      // 29. Return undefined.\n      return realm.intrinsics.undefined;\n    }\n  });\n\n  // ECMA262 22.2.3.24\n  obj.defineNativeMethod(\"slice\", 2, (context, [start, end]) => {\n    // 1. Let O be the this value.\n    let O = context;\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n    invariant(O instanceof ObjectValue);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. Let relativeStart be ? ToInteger(start).\n    let relativeStart = ToInteger(realm, start);\n\n    // 5. If relativeStart < 0, let k be max((len + relativeStart), 0); else let k be min(relativeStart, len).\n    let k = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);\n\n    // 6. If end is undefined, let relativeEnd be len; else let relativeEnd be ? ToInteger(end).\n    let relativeEnd = !end || end instanceof UndefinedValue ? len : ToInteger(realm, end.throwIfNotConcrete());\n\n    // 7. If relativeEnd < 0, let final be max((len + relativeEnd), 0); else let final be min(relativeEnd, len).\n    let final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);\n\n    // 8. Let count be max(final - k, 0).\n    let count = Math.max(final - k, 0);\n\n    // 9. Let A be ? TypedArraySpeciesCreate(O, « count »).\n    let A = TypedArraySpeciesCreate(realm, O, [new NumberValue(realm, count)]);\n\n    // 10. Let srcName be the String value of O.[[TypedArrayName]].\n    let srcName = O.$TypedArrayName;\n    invariant(typeof srcName === \"string\");\n\n    // 11. Let srcType be the String value of the Element Type value in Table 50 for srcName.\n    let srcType = ArrayElementType[srcName];\n\n    // 12. Let targetName be the String value of A.[[TypedArrayName]].\n    let targetName = A.$TypedArrayName;\n    invariant(typeof targetName === \"string\");\n\n    // 13. Let targetType be the String value of the Element Type value in Table 50 for targetName.\n    let targetType = ArrayElementType[targetName];\n\n    // 14. If SameValue(srcType, targetType) is false, then\n    if (srcType !== targetType) {\n      // a. Let n be 0.\n      let n = 0;\n\n      // b. Repeat, while k < final\n      while (k < final) {\n        // i. Let Pk be ! ToString(k).\n        let Pk = ToString(realm, new NumberValue(realm, k));\n\n        // ii. Let kValue be ? Get(O, Pk).\n        let kValue = Get(realm, O, Pk);\n\n        // iii. Perform ! Set(A, ! ToString(n), kValue).\n        Properties.Set(realm, A, ToString(realm, new NumberValue(realm, n)), kValue, true);\n\n        // iv. Increase k by 1.\n        k += 1;\n\n        // v. Increase n by 1.\n        n += 1;\n      }\n    } else if (count > 0) {\n      // 15. Else if count > 0, then\n      // a. Let srcBuffer be O.[[ViewedArrayBuffer]].\n      let srcBuffer = O.$ViewedArrayBuffer;\n      invariant(srcBuffer);\n\n      // b. If IsDetachedBuffer(srcBuffer) is true, throw a TypeError exception.\n      if (IsDetachedBuffer(realm, srcBuffer) === true) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsDetachedBuffer(srcBuffer) is true\");\n      }\n\n      // c. Let targetBuffer be A.[[ViewedArrayBuffer]].\n      let targetBuffer = A.$ViewedArrayBuffer;\n      invariant(targetBuffer instanceof ObjectValue);\n\n      // d. Let elementSize be the Number value of the Element Size value specified in Table 50 for srcType.\n      let elementSize = ElementSize[srcType];\n\n      // e. NOTE: If srcType and targetType are the same, the transfer must be performed in a manner that preserves the bit-level encoding of the source data.\n\n      // f. Let srcByteOffset be O.[[ByteOffset]].\n      let srcByteOffset = O.$ByteOffset;\n      invariant(typeof srcByteOffset === \"number\");\n\n      // g. Let targetByteIndex be A.[[ByteOffset]].\n      let targetByteIndex = A.$ByteOffset;\n      invariant(typeof targetByteIndex === \"number\");\n\n      // h. Let srcByteIndex be (k × elementSize) + srcByteOffset.\n      let srcByteIndex = k * elementSize + srcByteOffset;\n\n      // i. Let limit be targetByteIndex + count × elementSize.\n      let limit = targetByteIndex + count * elementSize;\n\n      // j. Repeat, while targetByteIndex < limit\n      while (targetByteIndex < limit) {\n        // i. Let value be GetValueFromBuffer(srcBuffer, srcByteIndex, \"Uint8\").\n        let value = GetValueFromBuffer(realm, srcBuffer, srcByteIndex, \"Uint8\");\n\n        // ii. Perform SetValueInBuffer(targetBuffer, targetByteIndex, \"Uint8\", value).\n        SetValueInBuffer(realm, targetBuffer, targetByteIndex, \"Uint8\", value.value);\n\n        // iii. Increase srcByteIndex by 1.\n        srcByteIndex += 1;\n\n        // iv. Increase targetByteIndex by 1.\n        targetByteIndex += 1;\n      }\n    }\n\n    // 16. Return A.\n    return A;\n  });\n\n  // ECMA262 22.2.3.25\n  obj.defineNativeMethod(\"some\", 1, (context, [callbackfn, thisArg]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = ToObject(realm, context.throwIfNotConcrete());\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.\n    if (!IsCallable(realm, callbackfn)) {\n      throw realm.createErrorThrowCompletion(\n        realm.intrinsics.TypeError,\n        \"callback passed to Array.prototype.some isn't callable\"\n      );\n    }\n\n    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.\n    let T = thisArg || realm.intrinsics.undefined;\n\n    // 6. Let k be 0.\n    let k = 0;\n\n    // 7. Repeat, while k < len\n    while (k < len) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = new StringValue(realm, k + \"\");\n\n      // b. Let kPresent be ? HasProperty(O, Pk).\n      let kPresent = HasProperty(realm, O, Pk);\n\n      // c. If kPresent is true, then\n      if (kPresent) {\n        // i. Let kValue be ? Get(O, Pk).\n        let kValue = Get(realm, O, Pk);\n\n        // ii. Let testResult be ToBoolean(? Call(callbackfn, T, « kValue, k, O »)).\n        let testResult = ToBooleanPartial(realm, Call(realm, callbackfn, T, [kValue, new NumberValue(realm, k), O]));\n\n        // iii. If testResult is true, return true.\n        if (testResult) return realm.intrinsics.true;\n      }\n\n      // d. Increase k by 1.\n      k++;\n    }\n\n    // 8. Return false.\n    return realm.intrinsics.false;\n  });\n\n  // ECMA262 22.2.3.26\n  obj.defineNativeMethod(\"sort\", 1, (context, [comparefn]) => {\n    // 1. Let obj be the this value.\n    let O = ToObject(realm, context.throwIfNotConcrete());\n\n    // 2. Let buffer be ? ValidateTypedArray(obj).\n    let buffer = ValidateTypedArray(realm, O);\n\n    // 3. Let len be the value of obj's [[ArrayLength]] internal slot.\n    let len = O.$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 22.2.3.26 Runtime Semantics: SortCompare( x, y )#\n    let SortCompare = (x, y) => {\n      // 1. Assert: Both Type(x) and Type(y) is Number.\n      invariant(x instanceof NumberValue);\n      invariant(y instanceof NumberValue);\n\n      // 2. If the argument comparefn is not undefined, then\n      if (!comparefn.mightBeUndefined()) {\n        // a. Let v be ? Call(comparefn, undefined, « x, y »).\n        let v = Call(realm, comparefn, realm.intrinsics.undefined, [x, y]);\n\n        // b. If IsDetachedBuffer(buffer) is true, throw a TypeError exception.\n        if (IsDetachedBuffer(realm, buffer) === true)\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"array buffer has been detached\");\n\n        // c. If v is NaN, return +0.\n        if (v instanceof NumberValue && isNaN(v.value)) return realm.intrinsics.zero;\n\n        // d. Return v.\n        return v;\n      }\n      comparefn.throwIfNotConcrete();\n\n      // If x and y are both NaN, return +0.\n      // If x is NaN, return 1.\n      if (isNaN(x.value)) {\n        if (isNaN(y.value)) return realm.intrinsics.zero;\n        return new NumberValue(realm, 1);\n      }\n\n      // If y is NaN, return -1.\n      if (isNaN(y.value)) return new NumberValue(realm, -1);\n\n      // If x < y, return -1.\n      if (x.value < y.value) return new NumberValue(realm, -1);\n\n      // If x > y, return 1.\n      if (x.value > y.value) return new NumberValue(realm, +1);\n\n      // If x is -0 and y is +0, return -1.\n      if (Object.is(x.value, -0) && Object.is(y.value, +0)) return new NumberValue(realm, -1);\n\n      // If x is +0 and y is -0, return 1.\n      if (Object.is(x.value, +0) && Object.is(y.value, -0)) return new NumberValue(realm, 1);\n\n      // Return +0.\n      return realm.intrinsics.zero;\n    };\n\n    //1. Perform an implementation-dependent sequence of calls to the [[Get]] and [[Set]] internal methods of obj, to the DeletePropertyOrThrow and HasOwnProperty abstract operation with obj as the first argument, and to SortCompare (described below), such that:\n    //   The property key argument for each call to [[Get]], [[Set]], HasOwnProperty, or DeletePropertyOrThrow is the string representation of a nonnegative integer less than len.\n\n    // We leverage the underlying implementation sort by copying the element in a temp. array, sorting it, and\n    // transfering back the value inside the our array.\n\n    // We need to adapt the comparefn function to match the expected types\n    let comparefn_ = (x, y) => {\n      invariant(x instanceof NumberValue, \"Unexpected type\");\n      invariant(y instanceof NumberValue, \"Unexpected type\");\n\n      let result_ = SortCompare(x, y);\n      let numb = ToNumber(realm, result_);\n      return numb;\n    };\n\n    let arr = [];\n    for (let j = 0; j < len; j++) {\n      let val = IntegerIndexedElementGet(realm, O, j);\n      arr[j] = val;\n    }\n\n    arr.sort(comparefn_);\n\n    //Apply the permutation back to the original array.\n    for (let j = 0; j < len; j++) {\n      IntegerIndexedElementSet(realm, O, j, arr[j]);\n    }\n\n    // 2. Return obj;\n    return context;\n  });\n\n  // ECMA262 22.2.3.27\n  obj.defineNativeMethod(\"subarray\", 2, (context, [begin, end]) => {\n    // 1. Let O be the this value.\n    let O = context.throwIfNotConcrete();\n\n    // 2. If Type(O) is not Object, throw a TypeError exception.\n    if (!(O instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(O) is not Object\");\n    }\n\n    // 3. If O does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.\n    if (!(\"$TypedArrayName\" in O)) {\n      throw realm.createErrorThrowCompletion(\n        realm.intrinsics.TypeError,\n        \"O does not have a [[TypedArrayName]] internal slot\"\n      );\n    }\n\n    // 4. Assert: O has a [[ViewedArrayBuffer]] internal slot.\n    invariant(O.$ViewedArrayBuffer, \"O has a [[ViewedArrayBuffer]] internal slot\");\n\n    // 5. Let buffer be O.[[ViewedArrayBuffer]].\n    let buffer = O.$ViewedArrayBuffer;\n    invariant(buffer);\n\n    // 6. Let srcLength be O.[[ArrayLength]].\n    let srcLength = O.$ArrayLength;\n    invariant(typeof srcLength === \"number\");\n\n    // 7. Let relativeBegin be ? ToInteger(begin).\n    let relativeBegin = ToInteger(realm, begin);\n\n    // 8. If relativeBegin < 0, let beginIndex be max((srcLength + relativeBegin), 0); else let beginIndex be min(relativeBegin, srcLength).\n    let beginIndex = relativeBegin < 0 ? Math.max(srcLength + relativeBegin, 0) : Math.min(relativeBegin, srcLength);\n\n    // 9. If end is undefined, let relativeEnd be srcLength; else, let relativeEnd be ? ToInteger(end).\n    let relativeEnd = !end || end instanceof UndefinedValue ? srcLength : ToInteger(realm, end.throwIfNotConcrete());\n\n    // 10. If relativeEnd < 0, let endIndex be max((srcLength + relativeEnd), 0); else let endIndex be min(relativeEnd, srcLength).\n    let endIndex = relativeEnd < 0 ? Math.max(srcLength + relativeEnd, 0) : Math.min(relativeEnd, srcLength);\n\n    // 11. Let newLength be max(endIndex - beginIndex, 0).\n    let newLength = Math.max(endIndex - beginIndex, 0);\n\n    // 12. Let constructorName be the String value of O.[[TypedArrayName]].\n    let constructorName = O.$TypedArrayName;\n    invariant(typeof constructorName === \"string\");\n\n    // 13. Let elementSize be the Number value of the Element Size value specified in Table 50 for constructorName.\n    let elementSize = ArrayElementSize[constructorName];\n\n    // 14. Let srcByteOffset be O.[[ByteOffset]].\n    let srcByteOffset = O.$ByteOffset;\n    invariant(typeof srcByteOffset === \"number\");\n\n    // 15. Let beginByteOffset be srcByteOffset + beginIndex × elementSize.\n    let beginByteOffset = srcByteOffset + beginIndex * elementSize;\n\n    // 16. Let argumentsList be « buffer, beginByteOffset, newLength ».\n    let argumentsList = [buffer, new NumberValue(realm, beginByteOffset), new NumberValue(realm, newLength)];\n\n    // 17. Return ? TypedArraySpeciesCreate(O, argumentsList).\n    return TypedArraySpeciesCreate(realm, O, argumentsList);\n  });\n\n  // ECMA262 22.2.3.28\n  obj.defineNativeMethod(\"toLocaleString\", 0, context => {\n    // 1. Let array be ? ToObject(this value).\n    let array = ToObject(realm, context.throwIfNotConcrete());\n\n    // 2. Perform ? ValidateTypedArray(array).\n    ValidateTypedArray(realm, array);\n\n    // 3. Let len be array.[[ArrayLength]].\n    let len = array.$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. Let separator be the String value for the list-separator String appropriate for the host environment's current locale (this is derived in an implementation-defined way).\n    let separator = \",\";\n\n    // 5. If len is zero, return the empty String.\n    if (len === 0) return realm.intrinsics.emptyString;\n\n    // 6. Let firstElement be ? Get(array, \"0\").\n    let firstElement = Get(realm, array, \"0\");\n\n    // 7. If firstElement is undefined or null, then\n    let R: ?string;\n    if (HasSomeCompatibleType(firstElement, UndefinedValue, NullValue)) {\n      // a. Let R be the empty String.\n      R = \"\";\n    } else {\n      // 8. Else,\n      // a. Let R be ? ToString(? Invoke(firstElement, \"toLocaleString\")).\n      R = ToStringPartial(realm, Invoke(realm, firstElement, \"toLocaleString\"));\n    }\n\n    // 9. Let k be 1.\n    let k = 1;\n\n    // 10. Repeat, while k < len\n    while (k < len) {\n      // a. Let S be a String value produced by concatenating R and separator.\n      let S: string = R + separator;\n\n      // b. Let nextElement be ? Get(array, ! ToString(k)).\n      let nextElement = Get(realm, array, new StringValue(realm, k + \"\"));\n\n      // c. If nextElement is undefined or null, then\n      if (HasSomeCompatibleType(nextElement, UndefinedValue, NullValue)) {\n        // i. Let R be the empty String.\n        R = \"\";\n      } else {\n        // d. Else,\n        // i. Let R be ? ToString(? Invoke(nextElement, \"toLocaleString\")).\n        R = ToStringPartial(realm, Invoke(realm, nextElement, \"toLocaleString\"));\n      }\n\n      // e. Let R be a String value produced by concatenating S and R.\n      R = S + R;\n\n      // f. Increase k by 1.\n      k++;\n    }\n\n    // 11. Return R.\n    return new StringValue(realm, R);\n  });\n\n  // ECMA262 22.2.3.29\n  obj.defineNativeProperty(\"toString\", realm.intrinsics.ArrayProto_toString);\n\n  // ECMA262 22.2.3.30\n  obj.defineNativeProperty(\"values\", realm.intrinsics.TypedArrayProto_values);\n\n  // ECMA262 22.2.3.31\n  obj.defineNativeProperty(realm.intrinsics.SymbolIterator, realm.intrinsics.TypedArrayProto_values);\n\n  // ECMA262 22.2.3.32\n  obj.defineNativeGetter(realm.intrinsics.SymbolToStringTag, context => {\n    // 1. Let O be the this value.\n    let O = context.throwIfNotConcrete();\n\n    // 2. If Type(O) is not Object, return undefined.\n    if (!(O instanceof ObjectValue)) return realm.intrinsics.undefined;\n\n    // 3. If O does not have a [[TypedArrayName]] internal slot, return undefined.\n    if (!(\"$TypedArrayName\" in O)) return realm.intrinsics.undefined;\n\n    // 4. Let name be O.[[TypedArrayName]].\n    let name = O.$TypedArrayName;\n\n    // 5. Assert: name is a String value.\n    invariant(typeof name === \"string\", \"name is a String value\");\n\n    // 6. Return name.\n    return new StringValue(realm, name);\n  });\n}\n\nexport function build(realm: Realm, obj: ObjectValue, type: ElementType): void {\n  // ECMA262 22.2.6\n  obj.$Prototype = realm.intrinsics.TypedArrayPrototype;\n\n  // ECMA262 22.2.6.1\n  obj.defineNativeConstant(\"BYTES_PER_ELEMENT\", new NumberValue(realm, ElementSize[type]));\n}\n"]}