"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Copyright (c) 2017-present, Facebook, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * This source code is licensed under the BSD-style license found in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * LICENSE file in the root directory of this source tree. An additional grant
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * of patent rights can be found in the PATENTS file in the same directory.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */

exports.default = function (realm) {
  // ECMA262 19.4.1.1
  var func = new _index.NativeFunctionValue(realm, "Symbol", "Symbol", 0, function (context, _ref, argCount, NewTarget) {
    var _ref2 = _slicedToArray(_ref, 1),
        description = _ref2[0];

    // 1. If NewTarget is not undefined, throw a TypeError exception.
    if (NewTarget) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    }

    // 2. If description is undefined, let descString be undefined.
    var descString = void 0;
    if (!description || description instanceof _index.UndefinedValue) {
      descString = undefined;
    } else if (description instanceof _index.AbstractValue) {
      descString = description;
    } else {
      // 3. Else, let descString be ? ToString(description).
      descString = (0, _index2.ToStringPartial)(realm, description);
      descString = new _index.StringValue(realm, descString);
    }
    // 4. Return a new unique Symbol value whose [[Description]] value is descString.
    return new _index.SymbolValue(realm, descString);
  });

  // ECMA262 19.4.2.1
  func.defineNativeMethod("for", 1, function (context, _ref3) {
    var _ref4 = _slicedToArray(_ref3, 1),
        key = _ref4[0];

    // 1. Let stringKey be ? ToString(key).
    var stringKey = (0, _index2.ToStringPartial)(realm, key);
    stringKey = new _index.StringValue(realm, stringKey);

    // 2. For each element e of the GlobalSymbolRegistry List,
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = realm.globalSymbolRegistry[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var e = _step.value;

        // a. If SameValue(e.[[Key]], stringKey) is true, return e.[[Symbol]].
        if (e.$Key === stringKey.value) {
          return e.$Symbol;
        }
      }

      // 3. Assert: GlobalSymbolRegistry does not currently contain an entry for stringKey.

      // 4. Let newSymbol be a new unique Symbol value whose [[Description]] value is stringKey.
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    var newSymbol = new _index.SymbolValue(realm, stringKey);

    // 5. Append the Record { [[Key]]: stringKey, [[Symbol]]: newSymbol } to the GlobalSymbolRegistry List.
    realm.globalSymbolRegistry.push({ $Key: stringKey.value, $Symbol: newSymbol });

    // 6. Return newSymbol.
    return newSymbol;
  });

  // ECMA262 19.4.2.2
  func.defineNativeMethod("keyFor", 1, function (context, _ref5) {
    var _ref6 = _slicedToArray(_ref5, 1),
        sym = _ref6[0];

    // 1. If Type(sym) is not Symbol, throw a TypeError exception.
    if (!(sym instanceof _index.SymbolValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(sym) is not Symbol");
    }

    // 2. For each element e of the GlobalSymbolRegistry List (see 19.4.2.1),
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = realm.globalSymbolRegistry[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var e = _step2.value;

        // a. If SameValue(e.[[Symbol]], sym) is true, return e.[[Key]].
        if ((0, _abstract.SameValue)(realm, e.$Symbol, sym) === true) {
          return new _index.StringValue(realm, e.$Key);
        }
      }

      // 3. Assert: GlobalSymbolRegistry does not currently contain an entry for sym.

      // 4. Return undefined.
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    return realm.intrinsics.undefined;
  });

  // ECMA262 19.4.2.3
  func.defineNativeConstant("isConcatSpreadable", realm.intrinsics.SymbolIsConcatSpreadable);

  // ECMA262 19.4.2.10
  func.defineNativeConstant("species", realm.intrinsics.SymbolSpecies);

  // ECMA262 19.4.2.8
  func.defineNativeConstant("replace", realm.intrinsics.SymbolReplace);

  // ECMA262 19.4.2.4
  func.defineNativeConstant("iterator", realm.intrinsics.SymbolIterator);

  // ECMA262 19.4.2.2
  func.defineNativeConstant("hasInstance", realm.intrinsics.SymbolHasInstance);

  // ECMA262 19.4.2.12
  func.defineNativeConstant("toPrimitive", realm.intrinsics.SymbolToPrimitive);

  // ECMA262 19.4.2.13
  func.defineNativeConstant("toStringTag", realm.intrinsics.SymbolToStringTag);

  // ECMA262 19.4.2.14
  func.defineNativeConstant("unscopables", realm.intrinsics.SymbolUnscopables);

  // ECMA262 19.4.2.6
  func.defineNativeConstant("match", realm.intrinsics.SymbolMatch);

  // ECMA262 19.4.2.11
  func.defineNativeConstant("split", realm.intrinsics.SymbolSplit);

  // ECMA262 19.4.2.9
  func.defineNativeConstant("search", realm.intrinsics.SymbolSearch);

  return func;
};

var _index = require("../../values/index.js");

var _index2 = require("../../methods/index.js");

var _abstract = require("../../methods/abstract.js");
//# sourceMappingURL=Symbol.js.map