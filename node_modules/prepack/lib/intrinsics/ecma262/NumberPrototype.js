"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Copyright (c) 2017-present, Facebook, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * This source code is licensed under the BSD-style license found in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * LICENSE file in the root directory of this source tree. An additional grant
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * of patent rights can be found in the PATENTS file in the same directory.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */

exports.default = function (realm, obj) {
  // ECMA262 20.1.3
  obj.$NumberData = realm.intrinsics.zero;

  // ECMA262 20.1.3.2
  obj.defineNativeMethod("toExponential", 1, function (context, _ref) {
    var _ref2 = _slicedToArray(_ref, 1),
        fractionDigits = _ref2[0];

    // 1. Let x be ? thisNumberValue(this value).
    var x = (0, _index2.thisNumberValue)(realm, context).value;

    // 2. Let f be ? ToInteger(fractionDigits).
    fractionDigits = fractionDigits.throwIfNotConcrete();
    var f = (0, _index2.ToInteger)(realm, fractionDigits);

    // 3. Assert: f is 0, when fractionDigits is undefined.
    (0, _invariant2.default)(f === 0 || !(fractionDigits instanceof _index.UndefinedValue));

    // 4. If x is NaN, return the String "NaN".
    if (isNaN(x)) return new _index.StringValue(realm, "NaN");

    // 5. Let s be the empty String.
    var s = "";

    // 6. If x < 0, then
    if (x < 0) {
      // 6a. Let s be "-".
      s = "-";

      // 6b. Let x be -x.
      x = -x;
    }

    // 7. If x = +∞, then
    if (x === +Infinity) {
      // 7a. Return the concatenation of the Strings s and "Infinity".
      return new _index.StringValue(realm, s + "Infinity");
    }

    // 8. If f < 0 or f > 20, throw a RangeError exception. However, an implementation is permitted to extend the behaviour of toExponential for values of f less than 0 or greater than 20. In this case toExponential would not necessarily throw RangeError for such values.
    if (f < 0 || f > 20) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, "f < 0 || f > 20");
    }

    var positiveResultString = x.toExponential(fractionDigits instanceof _index.UndefinedValue ? undefined : f);
    return new _index.StringValue(realm, s + positiveResultString);
  });

  // ECMA262 20.1.3.3
  obj.defineNativeMethod("toFixed", 1, function (context, _ref3) {
    var _ref4 = _slicedToArray(_ref3, 1),
        fractionDigits = _ref4[0];

    // 1. Let f be ToInteger(fractionDigits). (If fractionDigits is undefined, this step produces the value 0).
    var f = (0, _index2.ToInteger)(realm, fractionDigits);

    // 2. If f < 0 or f > 20, throw a RangeError exception.
    if (f < 0 || f > 20) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, "f < 0 || f > 20");
    }

    // 3. Let x be this Number value.
    var x = (0, _index2.thisNumberValue)(realm, context).value;

    // 4. If x is NaN, return the String "NaN".
    if (isNaN(x)) return new _index.StringValue(realm, "NaN");

    return new _index.StringValue(realm, x.toFixed(f));
  });

  var toLocaleStringSrc = "(A).toLocaleString()";
  var toLocaleString = (0, _builder2.default)(toLocaleStringSrc);

  // ECMA262 20.1.3.4
  obj.defineNativeMethod("toLocaleString", 0, function (context) {
    var x = (0, _index2.thisNumberValue)(realm, context);
    if (realm.useAbstractInterpretation) {
      // The locale is environment-dependent and may also be time-dependent
      // so do this at runtime and at this point in time
      return _index.AbstractValue.createTemporalFromTemplate(realm, toLocaleString, _index.StringValue, [x]);
    } else {
      return new _index.StringValue(realm, x.toLocaleString());
    }
  });

  // ECMA262 20.1.3.5
  obj.defineNativeMethod("toPrecision", 1, function (context, _ref5) {
    var _ref6 = _slicedToArray(_ref5, 1),
        precision = _ref6[0];

    // 1. Let x be ? thisNumberValue(this value).
    var num = (0, _index2.thisNumberValue)(realm, context);
    // 2. If precision is undefined, return ! ToString(x).
    if (precision instanceof _index.UndefinedValue) {
      return new _index.StringValue(realm, (0, _index2.ToString)(realm, num));
    }
    // 3. Let p be ? ToInteger(precision).
    var p = (0, _index2.ToInteger)(realm, precision.throwIfNotConcrete());
    // 4. If x is NaN, return the String "NaN".
    var x = num.value;
    if (isNaN(x)) {
      return new _index.StringValue(realm, "NaN");
    }
    // 5. Let s be the empty String.
    var s = "";
    // 6. If x < 0, then
    if (x < 0) {
      // a. Let s be code unit 0x002D (HYPHEN-MINUS).
      s = "-";
      // b. Let x be -x.
      x = -x;
    }
    // 7. If x = +∞, then
    if (x === +Infinity) {
      // a. Return the String that is the concatenation of s and "Infinity".
      return new _index.StringValue(realm, s + "Infinity");
    }
    // 8. If p < 1 or p > 21, throw a RangeError exception.
    // However, an implementation is permitted to extend the behaviour of
    // toPrecision for values of p less than 1 or greater than 21.
    // In this case toPrecision would not necessarily throw RangeError for such
    // values.
    if (p < 1 || p > 21) {
      // for simplicity, throw the error
      throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, "p should be in between 1 and 21 inclusive");
    }
    return new _index.StringValue(realm, s + x.toPrecision(p));
  });

  var tsTemplateSrc = "(A).toString()";
  var tsTemplate = (0, _builder2.default)(tsTemplateSrc);

  // ECMA262 20.1.3.6
  obj.defineNativeMethod("toString", 1, function (context, _ref7) {
    var _ref8 = _slicedToArray(_ref7, 1),
        radix = _ref8[0];

    if (radix instanceof _index.UndefinedValue) {
      var target = context instanceof _index.ObjectValue ? context.$NumberData : context;
      if (target instanceof _index.AbstractValue && target.getType() === _index.NumberValue) {
        return _index.AbstractValue.createFromTemplate(realm, tsTemplate, _index.StringValue, [target], tsTemplateSrc);
      }
    }
    // 1. Let x be ? thisNumberValue(this value).
    var x = (0, _index2.thisNumberValue)(realm, context);

    // 2. If radix is not present, let radixNumber be 10.
    // 3. Else if radix is undefined, let radixNumber be 10.
    var radixNumber = void 0;
    if (!radix || radix instanceof _index.UndefinedValue) {
      radixNumber = 10;
    } else {
      // 4. Else let radixNumber be ? ToInteger(radix).
      radixNumber = (0, _index2.ToInteger)(realm, radix.throwIfNotConcrete());
    }

    // 5. If radixNumber < 2 or radixNumber > 36, throw a RangeError exception.
    if (radixNumber < 2 || radixNumber > 36) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    }

    // 6. If radixNumber = 10, return ! ToString(x).
    if (radixNumber === 10) return new _index.StringValue(realm, (0, _index2.ToString)(realm, x));

    // 7. Return the String representation of this Number value using the radix specified by radixNumber.
    //    Letters a-z are used for digits with values 10 through 35. The precise algorithm is
    //    implementation-dependent, however the algorithm should be a generalization of that specified in
    //    7.1.12.1.
    return new _index.StringValue(realm, x.value.toString(radixNumber));
  });

  // ECMA262 20.1.3.7
  obj.defineNativeMethod("valueOf", 0, function (context) {
    // 1. Return ? thisNumberValue(this value).
    return (0, _index2.thisNumberValue)(realm, context);
  });
};

var _index = require("../../values/index.js");

var _index2 = require("../../methods/index.js");

var _invariant = require("../../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _builder = require("../../utils/builder.js");

var _builder2 = _interopRequireDefault(_builder);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
//# sourceMappingURL=NumberPrototype.js.map