"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Copyright (c) 2017-present, Facebook, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * This source code is licensed under the BSD-style license found in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * LICENSE file in the root directory of this source tree. An additional grant
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * of patent rights can be found in the PATENTS file in the same directory.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */

exports.default = function (realm) {
  // ECMA262 19.1.1.1
  var func = new _index.NativeFunctionValue(realm, "Object", "Object", 1, function (context, _ref, argCount, NewTarget) {
    var _ref2 = _slicedToArray(_ref, 1),
        value = _ref2[0];

    // 1. If NewTarget is neither undefined nor the active function, then
    if (NewTarget && NewTarget !== func) {
      // a. Return ? OrdinaryCreateFromConstructor(NewTarget, "%ObjectPrototype%").
      return (0, _index2.OrdinaryCreateFromConstructor)(realm, NewTarget, "ObjectPrototype");
    }

    // 2. If value is null, undefined or not supplied, return ObjectCreate(%ObjectPrototype%).
    if ((0, _index2.HasSomeCompatibleType)(value, _index.NullValue, _index.UndefinedValue)) {
      return (0, _index2.ObjectCreate)(realm, realm.intrinsics.ObjectPrototype);
    }

    // 3. Return ToObject(value).
    return (0, _index2.ToObjectPartial)(realm, value);
  });

  // ECMA262 19.1.2.1
  func.defineNativeMethod("assign", 2, function (context, _ref3) {
    var _ref4 = _toArray(_ref3),
        target = _ref4[0],
        sources = _ref4.slice(1);

    // 1. Let to be ? ToObject(target).
    var to = (0, _index2.ToObjectPartial)(realm, target);
    var to_must_be_partial = false;

    // 2. If only one argument was passed, return to.
    if (!sources.length) return to;

    // 3. Let sources be the List of argument values starting with the second argument.
    sources;

    // 4. For each element nextSource of sources, in ascending index order,
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = sources[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var nextSource = _step.value;

        var keys = void 0,
            frm = void 0;

        // a. If nextSource is undefined or null, let keys be a new empty List.
        if ((0, _index2.HasSomeCompatibleType)(nextSource, _index.NullValue, _index.UndefinedValue)) {
          continue;
        } else {
          // b. Else,
          // i. Let from be ToObject(nextSource).
          frm = (0, _index2.ToObjectPartial)(realm, nextSource);
          var frm_was_partial = frm.isPartialObject();
          if (frm_was_partial) {
            to_must_be_partial = true;
            frm.makeNotPartial();
          }

          // ii. Let keys be ? from.[[OwnPropertyKeys]]().
          keys = frm.$OwnPropertyKeys();
          if (frm_was_partial) frm.makePartial();
        }
        if (to_must_be_partial) {
          // Only OK if to is an empty object because nextSource might have
          // properties at runtime that will overwrite current properties in to.
          // For now, just throw if this happens.
          var to_keys = to.$OwnPropertyKeys();
          if (to_keys.length !== 0) {
            _index.AbstractValue.reportIntrospectionError(nextSource);
            throw new _errors.FatalError();
          }
        }

        (0, _invariant2.default)(frm, "from required");
        (0, _invariant2.default)(keys, "keys required");

        // c. Repeat for each element nextKey of keys in List order,
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = keys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var nextKey = _step2.value;

            // i. Let desc be ? from.[[GetOwnProperty]](nextKey).
            var desc = frm.$GetOwnProperty(nextKey);

            // ii. If desc is not undefined and desc.[[Enumerable]] is true, then
            if (desc && desc.enumerable) {
              _singletons.Properties.ThrowIfMightHaveBeenDeleted(desc.value);

              // 1. Let propValue be ? Get(from, nextKey).
              var propValue = (0, _index2.Get)(realm, frm, nextKey);

              // 2. Perform ? Set(to, nextKey, propValue, true).
              _singletons.Properties.Set(realm, to, nextKey, propValue, true);
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }

      // 5. Return to.
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    if (to_must_be_partial) to.makePartial();
    return to;
  });

  // ECMA262 19.1.2.2
  func.defineNativeMethod("create", 2, function (context, _ref5) {
    var _ref6 = _slicedToArray(_ref5, 2),
        O = _ref6[0],
        Properties = _ref6[1];

    // 1. If Type(O) is neither Object nor Null, throw a TypeError exception.
    if (!(0, _index2.HasSomeCompatibleType)(O, _index.ObjectValue, _index.NullValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    }

    // 2. Let obj be ObjectCreate(O).
    var obj = (0, _index2.ObjectCreate)(realm, O.throwIfNotConcrete());

    // 3. If Properties is not undefined, then
    if (!Properties.mightBeUndefined()) {
      // a. Return ? ObjectDefineProperties(obj, Properties).
      return _singletons.Properties.ObjectDefineProperties(realm, obj, Properties);
    }
    Properties.throwIfNotConcrete();

    // 4. Return obj.
    return obj;
  });

  // ECMA262 19.1.2.3
  func.defineNativeMethod("defineProperties", 2, function (context, _ref7) {
    var _ref8 = _slicedToArray(_ref7, 2),
        O = _ref8[0],
        Properties = _ref8[1];

    // 1. Return ? ObjectDefineProperties(O, Properties).
    return _singletons.Properties.ObjectDefineProperties(realm, O, Properties);
  });

  // ECMA262 19.1.2.4
  func.defineNativeMethod("defineProperty", 3, function (context, _ref9) {
    var _ref10 = _slicedToArray(_ref9, 3),
        O = _ref10[0],
        P = _ref10[1],
        Attributes = _ref10[2];

    // 1. If Type(O) is not Object, throw a TypeError exception.
    if (!O.mightBeObject()) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    }
    O = O.throwIfNotObject();

    // 2. Let key be ? ToPropertyKey(P).
    var key = (0, _index2.ToPropertyKey)(realm, P.throwIfNotConcrete());

    // 3. Let desc be ? ToPropertyDescriptor(Attributes).
    var desc = (0, _index2.ToPropertyDescriptor)(realm, Attributes);

    // 4. Perform ? DefinePropertyOrThrow(O, key, desc).
    _singletons.Properties.DefinePropertyOrThrow(realm, O, key, desc);

    // 4. Return O.
    return O;
  });

  // ECMA262 19.1.2.5
  func.defineNativeMethod("freeze", 1, function (context, _ref11) {
    var _ref12 = _slicedToArray(_ref11, 1),
        O = _ref12[0];

    // 1. If Type(O) is not Object, return O.
    if (!O.mightBeObject()) return O;

    // 2. Let status be ? SetIntegrityLevel(O, "frozen").
    O = O.throwIfNotConcreteObject();
    var status = (0, _index2.SetIntegrityLevel)(realm, O, "frozen");

    // 3. If status is false, throw a TypeError exception.
    if (status === false) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    }

    // 4. Return O.
    return O;
  });

  // ECMA262 19.1.2.6
  func.defineNativeMethod("getOwnPropertyDescriptor", 2, function (context, _ref13) {
    var _ref14 = _slicedToArray(_ref13, 2),
        O = _ref14[0],
        P = _ref14[1];

    // 1. Let obj be ? ToObject(O).
    var obj = (0, _index2.ToObjectPartial)(realm, O);

    // 2. Let key be ? ToPropertyKey(P).
    var key = (0, _index2.ToPropertyKey)(realm, P.throwIfNotConcrete());

    // 3. Let desc be ? obj.[[GetOwnProperty]](key).
    var desc = obj.$GetOwnProperty(key);

    // 4. Return FromPropertyDescriptor(desc).
    return _singletons.Properties.FromPropertyDescriptor(realm, desc);
  });

  // ECMA262 19.1.2.7
  func.defineNativeMethod("getOwnPropertyNames", 1, function (context, _ref15) {
    var _ref16 = _slicedToArray(_ref15, 1),
        O = _ref16[0];

    // 1. Return ? GetOwnPropertyKeys(O, String).
    return (0, _index2.GetOwnPropertyKeys)(realm, O, _index.StringValue);
  });

  // ECMA262 19.1.2.8
  func.defineNativeMethod("getOwnPropertyDescriptors", 1, function (context, _ref17) {
    var _ref18 = _slicedToArray(_ref17, 1),
        O = _ref18[0];

    // 1. Let obj be ? ToObject(O).
    var obj = (0, _index2.ToObject)(realm, O.throwIfNotConcrete());

    // 2. Let ownKeys be ? obj.[[OwnPropertyKeys]]().
    var ownKeys = obj.$OwnPropertyKeys();

    // 3. Let descriptors be ! ObjectCreate(%ObjectPrototype%).
    var descriptors = (0, _index2.ObjectCreate)(realm, realm.intrinsics.ObjectPrototype);

    // 4. Repeat, for each element key of ownKeys in List order,
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = ownKeys[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var key = _step3.value;

        // a. Let desc be ? obj.[[GetOwnProperty]](key).
        var desc = obj.$GetOwnProperty(key);
        if (desc !== undefined) _singletons.Properties.ThrowIfMightHaveBeenDeleted(desc.value);

        // b. Let descriptor be ! FromPropertyDescriptor(desc).
        var descriptor = _singletons.Properties.FromPropertyDescriptor(realm, desc);

        // c. If descriptor is not undefined, perform ! CreateDataProperty(descriptors, key, descriptor).
        if (!(descriptor instanceof _index.UndefinedValue)) (0, _index2.CreateDataProperty)(realm, descriptors, key, descriptor);
      }

      // 5. Return descriptors.
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return) {
          _iterator3.return();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    return descriptors;
  });

  // ECMA262 19.1.2.9
  func.defineNativeMethod("getOwnPropertySymbols", 1, function (context, _ref19) {
    var _ref20 = _slicedToArray(_ref19, 1),
        O = _ref20[0];

    // Return ? GetOwnPropertyKeys(O, Symbol).
    return (0, _index2.GetOwnPropertyKeys)(realm, O, _index.SymbolValue);
  });

  // ECMA262 19.1.2.10
  func.defineNativeMethod("getPrototypeOf", 1, function (context, _ref21) {
    var _ref22 = _slicedToArray(_ref21, 1),
        O = _ref22[0];

    // 1. Let obj be ? ToObject(O).
    var obj = (0, _index2.ToObject)(realm, O.throwIfNotConcrete());

    // 2. Return ? obj.[[GetPrototypeOf]]().
    return obj.$GetPrototypeOf();
  });

  // ECMA262 19.1.2.11
  func.defineNativeMethod("is", 2, function (context, _ref23) {
    var _ref24 = _slicedToArray(_ref23, 2),
        value1 = _ref24[0],
        value2 = _ref24[1];

    // 1. Return SameValue(value1, value2).
    return new _index.BooleanValue(realm, (0, _index2.SameValuePartial)(realm, value1, value2));
  });

  // ECMA262 19.1.2.12
  func.defineNativeMethod("isExtensible", 1, function (context, _ref25) {
    var _ref26 = _slicedToArray(_ref25, 1),
        O = _ref26[0];

    // 1. If Type(O) is not Object, return false.
    if (!O.mightBeObject()) return realm.intrinsics.false;
    O = O.throwIfNotObject();

    // 2. Return ? IsExtensible(O).
    return new _index.BooleanValue(realm, (0, _index2.IsExtensible)(realm, O));
  });

  // ECMA262 19.1.2.13
  func.defineNativeMethod("isFrozen", 1, function (context, _ref27) {
    var _ref28 = _slicedToArray(_ref27, 1),
        O = _ref28[0];

    // 1. If Type(O) is not Object, return true.
    if (!O.mightBeObject()) return realm.intrinsics.true;

    // 2. Return ? TestIntegrityLevel(O, "frozen").
    O = O.throwIfNotConcreteObject();
    return new _index.BooleanValue(realm, (0, _index2.TestIntegrityLevel)(realm, O, "frozen"));
  });

  // ECMA262 19.1.2.14
  func.defineNativeMethod("isSealed", 1, function (context, _ref29) {
    var _ref30 = _slicedToArray(_ref29, 1),
        O = _ref30[0];

    // 1. If Type(O) is not Object, return true.
    if (!O.mightBeObject()) return realm.intrinsics.true;

    // 2. Return ? TestIntegrityLevel(O, "sealed").
    O = O.throwIfNotConcreteObject();
    return new _index.BooleanValue(realm, (0, _index2.TestIntegrityLevel)(realm, O, "sealed"));
  });

  // ECMA262 19.1.2.15
  func.defineNativeMethod("keys", 1, function (context, _ref31) {
    var _ref32 = _slicedToArray(_ref31, 1),
        O = _ref32[0];

    // 1. Let obj be ? ToObject(O).
    var obj = (0, _index2.ToObject)(realm, O.throwIfNotConcrete());

    // 2. Let nameList be ? EnumerableOwnProperties(obj, "key").
    var nameList = (0, _index2.EnumerableOwnProperties)(realm, obj, "key");

    // 3. Return CreateArrayFromList(nameList).
    return (0, _index2.CreateArrayFromList)(realm, nameList);
  });

  // ECMA262 9.1.2.16
  func.defineNativeMethod("values", 1, function (context, _ref33) {
    var _ref34 = _slicedToArray(_ref33, 1),
        O = _ref34[0];

    // 1. Let obj be ? ToObject(O).
    var obj = (0, _index2.ToObject)(realm, O.throwIfNotConcrete());

    // 2. Let nameList be ? EnumerableOwnProperties(obj, "value").
    var nameList = (0, _index2.EnumerableOwnProperties)(realm, obj, "value");

    // 3. Return CreateArrayFromList(nameList).
    return (0, _index2.CreateArrayFromList)(realm, nameList);
  });

  // ECMA262 19.1.2.17
  func.defineNativeMethod("entries", 1, function (context, _ref35) {
    var _ref36 = _slicedToArray(_ref35, 1),
        O = _ref36[0];

    // 1. Let obj be ? ToObject(O).
    var obj = (0, _index2.ToObject)(realm, O.throwIfNotConcrete());

    // 2. Let nameList be ? EnumerableOwnProperties(obj, "key+value").
    var nameList = (0, _index2.EnumerableOwnProperties)(realm, obj, "key+value");

    // 3. Return CreateArrayFromList(nameList).
    return (0, _index2.CreateArrayFromList)(realm, nameList);
  });

  // ECMA262 19.1.2.18
  func.defineNativeMethod("preventExtensions", 1, function (context, _ref37) {
    var _ref38 = _slicedToArray(_ref37, 1),
        O = _ref38[0];

    // 1. If Type(O) is not Object, return O.
    if (!O.mightBeObject()) return O;

    // 2. Let status be ? O.[[PreventExtensions]]().
    O = O.throwIfNotConcreteObject();
    var status = O.$PreventExtensions();

    // 3. If status is false, throw a TypeError exception.
    if (status === false) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    }

    // 4. Return O.
    return O;
  });

  // ECMA262 19.1.2.19
  func.defineNativeMethod("seal", 1, function (context, _ref39) {
    var _ref40 = _slicedToArray(_ref39, 1),
        O = _ref40[0];

    // 1. If Type(O) is not Object, return O.
    if (!O.mightBeObject()) return O;

    // 2. Let status be ? SetIntegrityLevel(O, "sealed").
    O = O.throwIfNotConcreteObject();
    var status = (0, _index2.SetIntegrityLevel)(realm, O, "sealed");

    // 3. If status is false, throw a TypeError exception.
    if (status === false) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    }

    // 4. Return O.
    return O;
  });

  // ECMA262 19.1.2.20
  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION)) func.defineNativeMethod("setPrototypeOf", 2, function (context, _ref41) {
    var _ref42 = _slicedToArray(_ref41, 2),
        O = _ref42[0],
        proto = _ref42[1];

    // 1. Let O be ? RequireObjectCoercible(O).
    O = (0, _index2.RequireObjectCoercible)(realm, O);

    // 2. If Type(proto) is neither Object nor Null, throw a TypeError exception.
    if (!(0, _index2.HasSomeCompatibleType)(proto, _index.ObjectValue, _index.NullValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    }

    // 3. If Type(O) is not Object, return O.
    O = O.throwIfNotConcrete();
    if (!(O instanceof _index.ObjectValue)) return O;

    // 4. Let status be ? O.[[SetPrototypeOf]](proto).
    var status = O.$SetPrototypeOf(proto);

    // 5. If status is false, throw a TypeError exception.
    if (status === false) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    }

    // 6. Return O.
    return O;
  });

  return func;
};

var _errors = require("../../errors.js");

var _realm = require("../../realm.js");

var _index = require("../../values/index.js");

var _index2 = require("../../methods/index.js");

var _singletons = require("../../singletons.js");

var _invariant = require("../../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }
//# sourceMappingURL=Object.js.map