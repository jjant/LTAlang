{"version":3,"sources":["../../../src/intrinsics/ecma262/DataView.js"],"names":["realm","func","context","argCount","NewTarget","buffer","byteOffset","byteLength","createErrorThrowCompletion","intrinsics","TypeError","throwIfNotConcrete","offset","bufferByteLength","$ArrayBufferByteLength","RangeError","viewByteLength","O","$DataView","undefined","$ViewedArrayBuffer","$ByteLength","$ByteOffset"],"mappings":";;;;;;ypBAAA;;;;;;;;;kBAgBe,UAASA,KAAT,EAA4C;AACzD;AACA,MAAIC,OAAO,gCACTD,KADS,EAET,UAFS,EAGT,UAHS,EAIT,CAJS,EAKT,UAACE,OAAD,QAA4CC,QAA5C,EAAsDC,SAAtD,EAAoE;AAAA;AAAA,QAAzDC,MAAyD;AAAA,QAAjDC,UAAiD;AAAA,QAArCC,UAAqC;;AAClE;AACA,QAAI,CAACH,SAAL,EAAgB;AACd,YAAMJ,MAAMQ,0BAAN,CAAiCR,MAAMS,UAAN,CAAiBC,SAAlD,CAAN;AACD;;AAEDL,aAASA,OAAOM,kBAAP,EAAT;AACA;AACA,QAAI,EAAEN,qCAAF,CAAJ,EAAsC;AACpC,YAAML,MAAMQ,0BAAN,CAAiCR,MAAMS,UAAN,CAAiBC,SAAlD,CAAN;AACD;;AAED;AACA,QAAI,EAAE,sBAAsBL,MAAxB,CAAJ,EAAqC;AACnC,YAAML,MAAMQ,0BAAN,CAAiCR,MAAMS,UAAN,CAAiBC,SAAlD,CAAN;AACD;;AAED;AACA,QAAIE,SAAS,2BAAeZ,KAAf,EAAsBM,UAAtB,CAAb;;AAEA;AACA,QAAI,6BAAiBN,KAAjB,EAAwBK,MAAxB,CAAJ,EAAqC;AACnC,YAAML,MAAMQ,0BAAN,CAAiCR,MAAMS,UAAN,CAAiBC,SAAlD,CAAN;AACD;;AAED;AACA,QAAIG,mBAAmBR,OAAOS,sBAA9B;AACA,6BAAU,OAAOD,gBAAP,KAA4B,QAAtC;;AAEA;AACA,QAAID,SAASC,gBAAb,EAA+B;AAC7B,YAAMb,MAAMQ,0BAAN,CAAiCR,MAAMS,UAAN,CAAiBM,UAAlD,CAAN;AACD;;AAED;AACA,QAAIC,uBAAJ;AACA,QAAI,CAACT,UAAD,IAAeA,4CAAnB,EAAyD;AACvD;AACAS,uBAAiBH,mBAAmBD,MAApC;AACD,KAHD,MAGO;AACL;AACA;AACAI,uBAAiB,2BAAehB,KAAf,EAAsBO,UAAtB,CAAjB;;AAEA;AACA,UAAIK,SAASI,cAAT,GAA0BH,gBAA9B,EAAgD;AAC9C,cAAMb,MAAMQ,0BAAN,CAAiCR,MAAMS,UAAN,CAAiBM,UAAlD,CAAN;AACD;AACF;;AAED;AACA,QAAIE,IAAI,0CAA8BjB,KAA9B,EAAqCI,SAArC,EAAgD,mBAAhD,EAAqE;AAC3Ec,iBAAWC,SADgE;AAE3EC,0BAAoBD,SAFuD;AAG3EE,mBAAaF,SAH8D;AAI3EG,mBAAaH;AAJ8D,KAArE,CAAR;;AAOA;AACAF,MAAEC,SAAF,GAAc,IAAd;;AAEA;AACAD,MAAEG,kBAAF,GAAuBf,MAAvB;;AAEA;AACAY,MAAEI,WAAF,GAAgBL,cAAhB;;AAEA;AACAC,MAAEK,WAAF,GAAgBV,MAAhB;;AAEA;AACA,WAAOK,CAAP;AACD,GA7EQ,CAAX;;AAgFA,SAAOhB,IAAP;AACD,C;;AAvFD;;AACA;;AACA","file":"DataView.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../../realm.js\";\nimport { ToIndexPartial, OrdinaryCreateFromConstructor, IsDetachedBuffer } from \"../../methods/index.js\";\nimport { NativeFunctionValue, ObjectValue, UndefinedValue } from \"../../values/index.js\";\nimport invariant from \"../../invariant.js\";\n\nexport default function(realm: Realm): NativeFunctionValue {\n  // ECMA262 24.2.2.1\n  let func = new NativeFunctionValue(\n    realm,\n    \"DataView\",\n    \"DataView\",\n    3,\n    (context, [buffer, byteOffset, byteLength], argCount, NewTarget) => {\n      // 1. If NewTarget is undefined, throw a TypeError exception.\n      if (!NewTarget) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n\n      buffer = buffer.throwIfNotConcrete();\n      // 2. If Type(buffer) is not Object, throw a TypeError exception.\n      if (!(buffer instanceof ObjectValue)) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n\n      // 3. If buffer does not have an [[ArrayBufferData]] internal slot, throw a TypeError exception.\n      if (!(\"$ArrayBufferData\" in buffer)) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n\n      // 4. Let offset be ? ToIndex(byteOffset).\n      let offset = ToIndexPartial(realm, byteOffset);\n\n      // 5. If IsDetachedBuffer(buffer) is true, throw a TypeError exception.\n      if (IsDetachedBuffer(realm, buffer)) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n\n      // 6. Let bufferByteLength be the value of buffer's [[ArrayBufferByteLength]] internal slot.\n      let bufferByteLength = buffer.$ArrayBufferByteLength;\n      invariant(typeof bufferByteLength === \"number\");\n\n      // 7. If offset > bufferByteLength, throw a RangeError exception.\n      if (offset > bufferByteLength) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError);\n      }\n\n      // 8. If byteLength is undefined, then\n      let viewByteLength;\n      if (!byteLength || byteLength instanceof UndefinedValue) {\n        // a. Let viewByteLength be bufferByteLength - offset.\n        viewByteLength = bufferByteLength - offset;\n      } else {\n        // 9. Else,\n        // a. Let viewByteLength be ? ToIndex(byteLength).\n        viewByteLength = ToIndexPartial(realm, byteLength);\n\n        // b. If offset+viewByteLength > bufferByteLength, throw a RangeError exception.\n        if (offset + viewByteLength > bufferByteLength) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError);\n        }\n      }\n\n      // 10. Let O be ? OrdinaryCreateFromConstructor(NewTarget, \"%DataViewPrototype%\", « [[DataView]], [[ViewedArrayBuffer]], [[ByteLength]], [[ByteOffset]] »).\n      let O = OrdinaryCreateFromConstructor(realm, NewTarget, \"DataViewPrototype\", {\n        $DataView: undefined,\n        $ViewedArrayBuffer: undefined,\n        $ByteLength: undefined,\n        $ByteOffset: undefined,\n      });\n\n      // 11. Set O's [[DataView]] internal slot to true.\n      O.$DataView = true;\n\n      // 12. Set O's [[ViewedArrayBuffer]] internal slot to buffer.\n      O.$ViewedArrayBuffer = buffer;\n\n      // 13. Set O's [[ByteLength]] internal slot to viewByteLength.\n      O.$ByteLength = viewByteLength;\n\n      // 14. Set O's [[ByteOffset]] internal slot to offset.\n      O.$ByteOffset = offset;\n\n      // 15. Return O.\n      return O;\n    }\n  );\n\n  return func;\n}\n"]}