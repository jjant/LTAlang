{"version":3,"sources":["../../../src/intrinsics/ecma262/RegExpPrototype.js"],"names":["realm","obj","defineNativeMethod","context","string","R","throwIfNotConcrete","createErrorThrowCompletion","intrinsics","TypeError","$RegExpMatcher","undefined","S","defineNativeGetter","result","global","ignoreCase","multiline","unicode","sticky","InternalHasFlag","SymbolMatch","rx","fullUnicode","Set","zero","A","n","null","matchStr","status","thisIndex","nextIndex","SymbolReplace","replaceValue","lengthS","length","functionalReplace","results","done","push","accumulatedResult","nextSourcePosition","nCaptures","Math","max","matched","matchLength","position","min","captures","capN","mightBeUndefined","replacement","replacerArgs","capture","concat","replValue","value","substr","SymbolSearch","previousLastIndex","$OriginalSource","RegExpPrototype","$OriginalFlags","src","flags","SymbolSplit","limit","C","RegExp","unicodeMatching","indexOf","newFlags","splitter","lengthA","lim","pow","size","p","z","q","e","T","numberOfCaptures","i","nextCapture","match","pattern","flag","true","false"],"mappings":";;;;;;ypBAAA;;;;;;;;;kBAmEe,UAASA,KAAT,EAAuBC,GAAvB,EAA+C;AAC5D;AACAA,MAAIC,kBAAJ,CAAuB,MAAvB,EAA+B,CAA/B,EAAkC,UAACC,OAAD,QAAuB;AAAA;AAAA,QAAZC,MAAY;;AACvD;AACA,QAAIC,IAAIF,QAAQG,kBAAR,EAAR;;AAEA;AACA,QAAI,EAAED,+BAAF,CAAJ,EAAiC;AAC/B,YAAML,MAAMO,0BAAN,CAAiCP,MAAMQ,UAAN,CAAiBC,SAAlD,EAA6D,0BAA7D,CAAN;AACD;;AAED;AACA,QAAIJ,EAAEK,cAAF,KAAqBC,SAAzB,EAAoC;AAClC,YAAMX,MAAMO,0BAAN,CACJP,MAAMQ,UAAN,CAAiBC,SADb,EAEJ,mDAFI,CAAN;AAID;;AAED;AACA,QAAIG,IAAI,yBAAgBZ,KAAhB,EAAuBI,MAAvB,CAAR;;AAEA;AACA,WAAO,+BAAkBJ,KAAlB,EAAyBK,CAAzB,EAA4BO,CAA5B,CAAP;AACD,GAtBD;;AAwBA;AACAX,MAAIY,kBAAJ,CAAuB,OAAvB,EAAgC,mBAAW;AACzC;AACA,QAAIR,IAAIF,QAAQG,kBAAR,EAAR;;AAEA;AACA,QAAI,EAAED,+BAAF,CAAJ,EAAiC;AAC/B,YAAML,MAAMO,0BAAN,CAAiCP,MAAMQ,UAAN,CAAiBC,SAAlD,EAA6D,0BAA7D,CAAN;AACD;;AAED;AACA,QAAIK,SAAS,EAAb;;AAEA;AACA,QAAIC,SAAS,0BAAiBf,KAAjB,EAAwB,cAAIA,KAAJ,EAAWK,CAAX,EAAc,QAAd,CAAxB,CAAb;;AAEA;AACA,QAAIU,MAAJ,EAAYD,UAAU,GAAV;;AAEZ;AACA,QAAIE,aAAa,0BAAiBhB,KAAjB,EAAwB,cAAIA,KAAJ,EAAWK,CAAX,EAAc,YAAd,CAAxB,CAAjB;;AAEA;AACA,QAAIW,UAAJ,EAAgBF,UAAU,GAAV;;AAEhB;AACA,QAAIG,YAAY,0BAAiBjB,KAAjB,EAAwB,cAAIA,KAAJ,EAAWK,CAAX,EAAc,WAAd,CAAxB,CAAhB;;AAEA;AACA,QAAIY,SAAJ,EAAeH,UAAU,GAAV;;AAEf;AACA,QAAII,UAAU,0BAAiBlB,KAAjB,EAAwB,cAAIA,KAAJ,EAAWK,CAAX,EAAc,SAAd,CAAxB,CAAd;;AAEA;AACA,QAAIa,OAAJ,EAAaJ,UAAU,GAAV;;AAEb;AACA,QAAIK,SAAS,0BAAiBnB,KAAjB,EAAwB,cAAIA,KAAJ,EAAWK,CAAX,EAAc,QAAd,CAAxB,CAAb;;AAEA;AACA,QAAIc,MAAJ,EAAYL,UAAU,GAAV;;AAEZ;AACA,WAAO,uBAAgBd,KAAhB,EAAuBc,MAAvB,CAAP;AACD,GA5CD;;AA8CA;AACAb,MAAIY,kBAAJ,CAAuB,QAAvB,EAAiC,mBAAW;AAC1C,WAAOO,gBAAgBpB,KAAhB,EAAuBG,OAAvB,EAAgC,GAAhC,CAAP;AACD,GAFD;;AAIA;AACAF,MAAIY,kBAAJ,CAAuB,YAAvB,EAAqC,mBAAW;AAC9C,WAAOO,gBAAgBpB,KAAhB,EAAuBG,OAAvB,EAAgC,GAAhC,CAAP;AACD,GAFD;;AAIA;AACAF,MAAIC,kBAAJ,CAAuBF,MAAMQ,UAAN,CAAiBa,WAAxC,EAAqD,CAArD,EAAwD,UAAClB,OAAD,SAAuB;AAAA;AAAA,QAAZC,MAAY;;AAC7E;AACA,QAAIkB,KAAKnB,QAAQG,kBAAR,EAAT;;AAEA;AACA,QAAI,EAAEgB,gCAAF,CAAJ,EAAkC;AAChC,YAAMtB,MAAMO,0BAAN,CAAiCP,MAAMQ,UAAN,CAAiBC,SAAlD,EAA6D,0BAA7D,CAAN;AACD;;AAED;AACA,QAAIG,IAAI,yBAAgBZ,KAAhB,EAAuBI,MAAvB,CAAR;;AAEA;AACA,QAAIW,SAAS,0BAAiBf,KAAjB,EAAwB,cAAIA,KAAJ,EAAWsB,EAAX,EAAe,QAAf,CAAxB,CAAb;;AAEA;AACA,QAAIP,WAAW,KAAf,EAAsB;AACpB;AACA,aAAO,wBAAWf,KAAX,EAAkBsB,EAAlB,EAAsBV,CAAtB,CAAP;AACD,KAHD,MAGO;AACL;AACA;AACA,UAAIW,cAAc,0BAAiBvB,KAAjB,EAAwB,cAAIA,KAAJ,EAAWsB,EAAX,EAAe,SAAf,CAAxB,CAAlB;;AAEA;AACA,6BAAWE,GAAX,CAAexB,KAAf,EAAsBsB,EAAtB,EAA0B,WAA1B,EAAuCtB,MAAMQ,UAAN,CAAiBiB,IAAxD,EAA8D,IAA9D;;AAEA;AACA,UAAIC,IAAI,yBAAY1B,KAAZ,EAAmB,CAAnB,CAAR;;AAEA;AACA,UAAI2B,IAAI,CAAR;;AAEA;AACA,aAAO,IAAP,EAAa;AACX;AACA,YAAIb,SAAS,wBAAWd,KAAX,EAAkBsB,EAAlB,EAAsBV,CAAtB,CAAb;;AAEA;AACA,YAAIE,kCAAJ,EAAiC;AAC/B;AACA,cAAIa,MAAM,CAAV,EAAa;AACX,mBAAO3B,MAAMQ,UAAN,CAAiBoB,IAAxB;AACD,WAFD,MAEO;AACL;AACA,mBAAOF,CAAP;AACD;AACF,SARD,MAQO;AACL;AACA;AACA,cAAIG,WAAW,yBAAgB7B,KAAhB,EAAuB,cAAIA,KAAJ,EAAWc,MAAX,EAAmB,GAAnB,CAAvB,CAAf;;AAEA;AACA,cAAIgB,SAAS,gCACX9B,KADW,EAEX0B,CAFW,EAGX,kBAAS1B,KAAT,EAAgB,uBAAgBA,KAAhB,EAAuB2B,CAAvB,CAAhB,CAHW,EAIX,uBAAgB3B,KAAhB,EAAuB6B,QAAvB,CAJW,CAAb;;AAOA;AACA,mCAAUC,WAAW,IAArB,EAA2B,gBAA3B;;AAEA;AACA,cAAID,aAAa,EAAjB,EAAqB;AACnB;AACA,gBAAIE,YAAY,kBAAS/B,KAAT,EAAgB,cAAIA,KAAJ,EAAWsB,EAAX,EAAe,WAAf,CAAhB,CAAhB;;AAEA;AACA,gBAAIU,YAAY,gCAAmBhC,KAAnB,EAA0BY,CAA1B,EAA6BmB,SAA7B,EAAwCR,WAAxC,CAAhB;;AAEA;AACA,mCAAWC,GAAX,CAAexB,KAAf,EAAsBsB,EAAtB,EAA0B,WAA1B,EAAuC,uBAAgBtB,KAAhB,EAAuBgC,SAAvB,CAAvC,EAA0E,IAA1E;AACD;;AAED;AACAL,eAAK,CAAL;AACD;AACF;;AAED,+BAAU,KAAV;AACD;AACF,GAlFD;;AAoFA;AACA1B,MAAIY,kBAAJ,CAAuB,WAAvB,EAAoC,mBAAW;AAC7C,WAAOO,gBAAgBpB,KAAhB,EAAuBG,OAAvB,EAAgC,GAAhC,CAAP;AACD,GAFD;;AAIA;AACAF,MAAIC,kBAAJ,CAAuBF,MAAMQ,UAAN,CAAiByB,aAAxC,EAAuD,CAAvD,EAA0D,UAAC9B,OAAD,SAAqC;AAAA;AAAA,QAA1BC,MAA0B;AAAA,QAAlB8B,YAAkB;;AAC7F;AACA,QAAIZ,KAAKnB,QAAQG,kBAAR,EAAT;;AAEA;AACA,QAAI,EAAEgB,gCAAF,CAAJ,EAAkC;AAChC,YAAMtB,MAAMO,0BAAN,CAAiCP,MAAMQ,UAAN,CAAiBC,SAAlD,EAA6D,0BAA7D,CAAN;AACD;;AAED;AACA,QAAIG,IAAI,yBAAgBZ,KAAhB,EAAuBI,MAAvB,CAAR;;AAEA;AACA,QAAI+B,UAAUvB,EAAEwB,MAAhB;;AAEA;AACA,QAAIC,oBAAoB,oBAAWrC,KAAX,EAAkBkC,YAAlB,CAAxB;;AAEA;AACA,QAAIG,sBAAsB,KAA1B,EAAiC;AAC/B;AACAH,qBAAe,uBAAgBlC,KAAhB,EAAuB,yBAAgBA,KAAhB,EAAuBkC,YAAvB,CAAvB,CAAf;AACD;;AAED;AACA,QAAInB,SAAS,0BAAiBf,KAAjB,EAAwB,cAAIA,KAAJ,EAAWsB,EAAX,EAAe,QAAf,CAAxB,CAAb;;AAEA,QAAIC,oBAAJ;AACA;AACA,QAAIR,WAAW,IAAf,EAAqB;AACnB;AACAQ,oBAAc,0BAAiBvB,KAAjB,EAAwB,cAAIA,KAAJ,EAAWsB,EAAX,EAAe,SAAf,CAAxB,CAAd;;AAEA;AACA,6BAAWE,GAAX,CAAexB,KAAf,EAAsBsB,EAAtB,EAA0B,WAA1B,EAAuCtB,MAAMQ,UAAN,CAAiBiB,IAAxD,EAA8D,IAA9D;AACD;;AAED;AACA,QAAIa,UAAU,EAAd;;AAEA;AACA,QAAIC,OAAO,KAAX;;AAEA;AACA,WAAOA,SAAS,KAAhB,EAAuB;AACrB;AACA,UAAIzB,SAAS,wBAAWd,KAAX,EAAkBsB,EAAlB,EAAsBV,CAAtB,CAAb;;AAEA;AACA,UAAIE,kCAAJ,EAAiC;AAC/ByB,eAAO,IAAP;AACD,OAFD,MAEO;AACL;AACA;AACAD,gBAAQE,IAAR,CAAa1B,MAAb;;AAEA;AACA,YAAIC,WAAW,KAAf,EAAsB;AACpBwB,iBAAO,IAAP;AACD,SAFD,MAEO;AACL;AACA,mCAAUhB,gBAAgBZ,SAA1B;;AAEA;AACA,cAAIkB,WAAW,yBAAgB7B,KAAhB,EAAuB,cAAIA,KAAJ,EAAWc,MAAX,EAAmB,GAAnB,CAAvB,CAAf;;AAEA;AACA,cAAIe,aAAa,EAAjB,EAAqB;AACnB;AACA,gBAAIE,YAAY,kBAAS/B,KAAT,EAAgB,cAAIA,KAAJ,EAAWsB,EAAX,EAAe,WAAf,CAAhB,CAAhB;;AAEA;AACA,gBAAIU,YAAY,gCAAmBhC,KAAnB,EAA0BY,CAA1B,EAA6BmB,SAA7B,EAAwCR,WAAxC,CAAhB;;AAEA;AACA,mCAAWC,GAAX,CAAexB,KAAf,EAAsBsB,EAAtB,EAA0B,WAA1B,EAAuC,uBAAgBtB,KAAhB,EAAuBgC,SAAvB,CAAvC,EAA0E,IAA1E;AACD;AACF;AACF;AACF;;AAED;AACA,QAAIS,oBAAoB,EAAxB;;AAEA;AACA,QAAIC,qBAAqB,CAAzB;;AAEA;AAvF6F;AAAA;AAAA;;AAAA;AAwF7F,2BAAmBJ,OAAnB,8HAA4B;AAAA,YAAnBxB,OAAmB;;AAC1B;AACA,YAAI6B,YAAY,kBAAS3C,KAAT,EAAgB,cAAIA,KAAJ,EAAWc,OAAX,EAAmB,QAAnB,CAAhB,CAAhB;;AAEA;AACA6B,oBAAYC,KAAKC,GAAL,CAASF,YAAY,CAArB,EAAwB,CAAxB,CAAZ;;AAEA;AACA,YAAIG,UAAU,yBAAgB9C,KAAhB,EAAuB,cAAIA,KAAJ,EAAWc,OAAX,EAAmB,GAAnB,CAAvB,CAAd;;AAEA;AACA,YAAIiC,cAAcD,QAAQV,MAA1B;;AAEA;AACA,YAAIY,WAAW,mBAAUhD,KAAV,EAAiB,cAAIA,KAAJ,EAAWc,OAAX,EAAmB,OAAnB,CAAjB,CAAf;;AAEA;AACAkC,mBAAWJ,KAAKC,GAAL,CAASD,KAAKK,GAAL,CAASD,QAAT,EAAmBb,OAAnB,CAAT,EAAsC,CAAtC,CAAX;;AAEA;AACA,YAAIR,IAAI,CAAR;;AAEA;AACA,YAAIuB,WAAW,EAAf;;AAEA;AACA,eAAOvB,KAAKgB,SAAZ,EAAuB;AACrB;AACA,cAAIQ,OAAO,cAAInD,KAAJ,EAAWc,OAAX,EAAmB,kBAASd,KAAT,EAAgB,uBAAgBA,KAAhB,EAAuB2B,CAAvB,CAAhB,CAAnB,CAAX;;AAEA;AACA,cAAI,CAACwB,KAAKC,gBAAL,EAAL,EAA8B;AAC5B;AACAD,mBAAO,yBAAgBnD,KAAhB,EAAuBmD,IAAvB,CAAP;AACD,WAHD,MAGO;AACLA,iBAAK7C,kBAAL;AACA6C,mBAAOxC,SAAP;AACD;;AAED;AACAuC,mBAASV,IAAT,CAAcW,IAAd;;AAEA;AACAxB,cAAIA,IAAI,CAAR;AACD;;AAED,YAAI0B,oBAAJ;AACA;AACA,YAAIhB,iBAAJ,EAAuB;AACrB;AACA,cAAIiB,eAAe,CAAC,uBAAgBtD,KAAhB,EAAuB8C,OAAvB,CAAD,CAAnB;;AAEA;AAJqB;AAAA;AAAA;;AAAA;AAKrB,kCAAoBI,QAApB,mIAA8B;AAAA,kBAArBK,OAAqB;;AAC5BD,2BAAad,IAAb,CAAkBe,YAAY5C,SAAZ,GAAwBX,MAAMQ,UAAN,CAAiBG,SAAzC,GAAqD,uBAAgBX,KAAhB,EAAuBuD,OAAvB,CAAvE;AACD;;AAED;AATqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAUrBD,yBAAeA,aAAaE,MAAb,CAAoB,CAAC,uBAAgBxD,KAAhB,EAAuBgD,QAAvB,CAAD,EAAmC,uBAAgBhD,KAAhB,EAAuBY,CAAvB,CAAnC,CAApB,CAAf;;AAEA;AACA,cAAI6C,YAAY,gBAAKzD,KAAL,EAAYkC,YAAZ,EAA0BlC,MAAMQ,UAAN,CAAiBG,SAA3C,EAAsD2C,YAAtD,CAAhB;;AAEA;AACAD,wBAAc,yBAAgBrD,KAAhB,EAAuByD,SAAvB,CAAd;AACD,SAjBD,MAiBO;AACL;AACA,mCAAUvB,0CAAV;AACA;AACAmB,wBAAc,0BAAgBrD,KAAhB,EAAuB8C,OAAvB,EAAgClC,CAAhC,EAAmCoC,QAAnC,EAA6CE,QAA7C,EAAuDhB,aAAawB,KAApE,CAAd;AACD;;AAED;AACA,YAAIV,YAAYN,kBAAhB,EAAoC;AAClC;AACA;AACAD,8BACEA,oBAAoB7B,EAAE+C,MAAF,CAASjB,kBAAT,EAA6BM,WAAWN,kBAAxC,CAApB,GAAkFW,WADpF;;AAGA;AACAX,+BAAqBM,WAAWD,WAAhC;AACD;AACF;AACD;AA3K6F;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA4K7F,QAAIL,sBAAsBP,OAA1B,EAAmC,OAAO,uBAAgBnC,KAAhB,EAAuByC,iBAAvB,CAAP;;AAEnC;AACA,WAAO,uBAAgBzC,KAAhB,EAAuByC,oBAAoB7B,EAAE+C,MAAF,CAASjB,kBAAT,CAA3C,CAAP;AACD,GAhLD;;AAkLA;AACAzC,MAAIC,kBAAJ,CAAuBF,MAAMQ,UAAN,CAAiBoD,YAAxC,EAAsD,CAAtD,EAAyD,UAACzD,OAAD,SAAuB;AAAA;AAAA,QAAZC,MAAY;;AAC9E;AACA,QAAIkB,KAAKnB,QAAQG,kBAAR,EAAT;;AAEA;AACA,QAAI,EAAEgB,gCAAF,CAAJ,EAAkC;AAChC,YAAMtB,MAAMO,0BAAN,CAAiCP,MAAMQ,UAAN,CAAiBC,SAAlD,EAA6D,0BAA7D,CAAN;AACD;;AAED;AACA,QAAIG,IAAI,yBAAgBZ,KAAhB,EAAuBI,MAAvB,CAAR;;AAEA;AACA,QAAIyD,oBAAoB,cAAI7D,KAAJ,EAAWsB,EAAX,EAAe,WAAf,CAAxB;;AAEA;AACA,2BAAWE,GAAX,CAAexB,KAAf,EAAsBsB,EAAtB,EAA0B,WAA1B,EAAuCtB,MAAMQ,UAAN,CAAiBiB,IAAxD,EAA8D,IAA9D;;AAEA;AACA,QAAIX,SAAS,wBAAWd,KAAX,EAAkBsB,EAAlB,EAAsBV,CAAtB,CAAb;;AAEA;AACA,2BAAWY,GAAX,CAAexB,KAAf,EAAsBsB,EAAtB,EAA0B,WAA1B,EAAuCuC,iBAAvC,EAA0D,IAA1D;;AAEA;AACA,QAAI/C,kCAAJ,EAAiC,OAAO,uBAAgBd,KAAhB,EAAuB,CAAC,CAAxB,CAAP;;AAEjC;AACA,WAAO,cAAIA,KAAJ,EAAWc,MAAX,EAAmB,OAAnB,CAAP;AACD,GA7BD;;AA+BA;AACAb,MAAIY,kBAAJ,CAAuB,QAAvB,EAAiC,mBAAW;AAC1C;AACA,QAAIR,IAAIF,QAAQG,kBAAR,EAAR;;AAEA;AACA,QAAI,EAAED,+BAAF,CAAJ,EAAiC;AAC/B,YAAML,MAAMO,0BAAN,CAAiCP,MAAMQ,UAAN,CAAiBC,SAAlD,EAA6D,0BAA7D,CAAN;AACD;;AAED;AACA,QAAI,OAAOJ,EAAEyD,eAAT,KAA6B,QAAjC,EAA2C;AACzC;AACA,UAAI,yBAAU9D,KAAV,EAAiBK,CAAjB,EAAoBL,MAAMQ,UAAN,CAAiBuD,eAArC,CAAJ,EAA2D;AACzD,eAAO,uBAAgB/D,KAAhB,EAAuB,MAAvB,CAAP;AACD,OAFD,MAEO;AACL;AACA,cAAMA,MAAMO,0BAAN,CACJP,MAAMQ,UAAN,CAAiBC,SADb,EAEJ,qDAFI,CAAN;AAID;AACF;;AAED;AACA,6BAAUJ,EAAE2D,cAAF,KAAqBrD,SAA/B,EAA0C,0CAA1C;;AAEA;AACA,QAAIsD,MAAM5D,EAAEyD,eAAZ;AACA,6BAAU,OAAOG,GAAP,KAAe,QAAzB;;AAEA;AACA,QAAIC,QAAQ7D,EAAE2D,cAAd;AACA,6BAAU,OAAOE,KAAP,KAAiB,QAA3B;;AAEA;AACA,WAAO,uBAAgBlE,KAAhB,EAAuB,iCAAoBA,KAApB,EAA2BiE,GAA3B,EAAgCC,KAAhC,CAAvB,CAAP;AACD,GApCD;;AAsCA;AACAjE,MAAIC,kBAAJ,CAAuBF,MAAMQ,UAAN,CAAiB2D,WAAxC,EAAqD,CAArD,EAAwD,UAAChE,OAAD,SAA8B;AAAA;AAAA,QAAnBC,MAAmB;AAAA,QAAXgE,KAAW;;AACpF;AACA,QAAI9C,KAAKnB,QAAQG,kBAAR,EAAT;;AAEA;AACA,QAAI,EAAEgB,gCAAF,CAAJ,EAAkC;AAChC,YAAMtB,MAAMO,0BAAN,CAAiCP,MAAMQ,UAAN,CAAiBC,SAAlD,EAA6D,2BAA7D,CAAN;AACD;;AAED;AACA,QAAIG,IAAI,yBAAgBZ,KAAhB,EAAuBI,MAAvB,CAAR;;AAEA;AACA,QAAIiE,IAAI,mCAAmBrE,KAAnB,EAA0BsB,EAA1B,EAA8BtB,MAAMQ,UAAN,CAAiB8D,MAA/C,CAAR;;AAEA;AACA,QAAIJ,QAAQ,yBAAgBlE,KAAhB,EAAuB,cAAIA,KAAJ,EAAWsB,EAAX,EAAe,OAAf,CAAvB,CAAZ;;AAEA,QAAIiD,wBAAJ;AACA;AACA,QAAIL,MAAMM,OAAN,CAAc,GAAd,KAAsB,CAA1B,EAA6B;AAC3BD,wBAAkB,IAAlB;AACD,KAFD,MAEO;AACL;AACAA,wBAAkB,KAAlB;AACD;;AAED,QAAIE,iBAAJ;AACA;AACA,QAAIP,MAAMM,OAAN,CAAc,GAAd,KAAsB,CAA1B,EAA6B;AAC3BC,iBAAWP,KAAX;AACD,KAFD,MAEO;AACL;AACAO,iBAAWP,QAAQ,GAAnB;AACD;;AAED;AACA,QAAIQ,WAAW,0BAAU1E,KAAV,EAAiBqE,CAAjB,EAAoB,CAAC/C,EAAD,EAAK,uBAAgBtB,KAAhB,EAAuByE,QAAvB,CAAL,CAApB,CAAf;;AAEA;AACA,QAAI/C,IAAI,yBAAY1B,KAAZ,EAAmB,CAAnB,CAAR;;AAEA;AACA,QAAI2E,UAAU,CAAd;;AAEA;AACA,QAAIC,MAAMR,yCAAkCxB,KAAKiC,GAAL,CAAS,CAAT,EAAY,EAAZ,IAAkB,CAApD,GAAwD,kBAAS7E,KAAT,EAAgBoE,MAAM9D,kBAAN,EAAhB,CAAlE;;AAEA;AACA,QAAIwE,OAAOlE,EAAEwB,MAAb;;AAEA;AACA,QAAI2C,IAAI,CAAR;;AAEA;AACA,QAAIH,QAAQ,CAAZ,EAAe,OAAOlD,CAAP;;AAEf;AACA,QAAIoD,SAAS,CAAb,EAAgB;AACd;AACA,UAAIE,IAAI,wBAAWhF,KAAX,EAAkB0E,QAAlB,EAA4B9D,CAA5B,CAAR;;AAEA;AACA,UAAI,EAAEoE,6BAAF,CAAJ,EAA+B,OAAOtD,CAAP;;AAE/B;AACA,sCAAmB1B,KAAnB,EAA0B0B,CAA1B,EAA6B,GAA7B,EAAkC,uBAAgB1B,KAAhB,EAAuBY,CAAvB,CAAlC;;AAEA;AACA,aAAOc,CAAP;AACD;;AAED;AACA,QAAIuD,IAAIF,CAAR;;AAEA;AACA,WAAOE,IAAIH,IAAX,EAAiB;AACf;AACA,6BAAWtD,GAAX,CAAexB,KAAf,EAAsB0E,QAAtB,EAAgC,WAAhC,EAA6C,uBAAgB1E,KAAhB,EAAuBiF,CAAvB,CAA7C,EAAwE,IAAxE;;AAEA;AACA,UAAID,KAAI,wBAAWhF,KAAX,EAAkB0E,QAAlB,EAA4B9D,CAA5B,CAAR;;AAEA;AACA,UAAIoE,8BAAJ,EAA4B;AAC1BC,YAAI,gCAAmBjF,KAAnB,EAA0BY,CAA1B,EAA6BqE,CAA7B,EAAgCV,eAAhC,CAAJ;AACD,OAFD,MAEO;AACL;AACA;AACA,YAAIW,IAAI,kBAASlF,KAAT,EAAgB,cAAIA,KAAJ,EAAW0E,QAAX,EAAqB,WAArB,CAAhB,CAAR;;AAEA;AACAQ,YAAItC,KAAKK,GAAL,CAASiC,CAAT,EAAYJ,IAAZ,CAAJ;;AAEA;AACA,YAAII,MAAMH,CAAV,EAAa;AACXE,cAAI,gCAAmBjF,KAAnB,EAA0BY,CAA1B,EAA6BqE,CAA7B,EAAgCV,eAAhC,CAAJ;AACD,SAFD,MAEO;AACL;AACA;AACA,cAAIY,KAAIvE,EAAE+C,MAAF,CAASoB,CAAT,EAAYE,IAAIF,CAAhB,CAAR;;AAEA;AACA,0CAAmB/E,KAAnB,EAA0B0B,CAA1B,EAA6B,kBAAS1B,KAAT,EAAgB,uBAAgBA,KAAhB,EAAuB2E,OAAvB,CAAhB,CAA7B,EAA+E,uBAAgB3E,KAAhB,EAAuBmF,EAAvB,CAA/E;;AAEA;AACAR,oBAAUA,UAAU,CAApB;;AAEA;AACA,cAAIA,YAAYC,GAAhB,EAAqB,OAAOlD,CAAP;;AAErB;AACAqD,cAAIG,CAAJ;;AAEA;AACA,cAAIE,mBAAmB,kBAASpF,KAAT,EAAgB,cAAIA,KAAJ,EAAWgF,EAAX,EAAc,QAAd,CAAhB,CAAvB;;AAEA;AACAI,6BAAmBxC,KAAKC,GAAL,CAASuC,mBAAmB,CAA5B,EAA+B,CAA/B,CAAnB;;AAEA;AACA,cAAIC,IAAI,CAAR;;AAEA;AACA,iBAAOA,KAAKD,gBAAZ,EAA8B;AAC5B;AACA,gBAAIE,cAAc,cAAItF,KAAJ,EAAWgF,EAAX,EAAc,kBAAShF,KAAT,EAAgB,uBAAgBA,KAAhB,EAAuBqF,CAAvB,CAAhB,CAAd,CAAlB;;AAEA;AACA,4CAAmBrF,KAAnB,EAA0B0B,CAA1B,EAA6B,kBAAS1B,KAAT,EAAgB,uBAAgBA,KAAhB,EAAuB2E,OAAvB,CAAhB,CAA7B,EAA+EW,WAA/E;;AAEA;AACAD,gBAAIA,IAAI,CAAR;;AAEA;AACAV,sBAAUA,UAAU,CAApB;;AAEA;AACA,gBAAIA,YAAYC,GAAhB,EAAqB,OAAOlD,CAAP;AACtB;;AAED;AACAuD,cAAIF,CAAJ;AACD;AACF;AACF;;AAED;AACA,QAAII,IAAIvE,EAAE+C,MAAF,CAASoB,CAAT,EAAYD,OAAOC,CAAnB,CAAR;;AAEA;AACA,oCAAmB/E,KAAnB,EAA0B0B,CAA1B,EAA6B,kBAAS1B,KAAT,EAAgB,uBAAgBA,KAAhB,EAAuB2E,OAAvB,CAAhB,CAA7B,EAA+E,uBAAgB3E,KAAhB,EAAuBmF,CAAvB,CAA/E;;AAEA;AACA,WAAOzD,CAAP;AACD,GA3JD;;AA6JA;AACAzB,MAAIY,kBAAJ,CAAuB,QAAvB,EAAiC,mBAAW;AAC1C,WAAOO,gBAAgBpB,KAAhB,EAAuBG,OAAvB,EAAgC,GAAhC,CAAP;AACD,GAFD;;AAIA;AACAF,MAAIC,kBAAJ,CAAuB,MAAvB,EAA+B,CAA/B,EAAkC,UAACC,OAAD,UAAkB;AAAA;AAAA,QAAPS,CAAO;;AAClD;AACA,QAAIP,IAAIF,QAAQG,kBAAR,EAAR;;AAEA;AACA,QAAI,EAAED,+BAAF,CAAJ,EAAiC;AAC/B,YAAML,MAAMO,0BAAN,CAAiCP,MAAMQ,UAAN,CAAiBC,SAAlD,EAA6D,0BAA7D,CAAN;AACD;;AAED;AACA,QAAIL,SAAS,yBAAgBJ,KAAhB,EAAuBY,CAAvB,CAAb;;AAEA;AACA,QAAI2E,QAAQ,wBAAWvF,KAAX,EAAkBK,CAAlB,EAAqBD,MAArB,CAAZ;;AAEA;AACA,WAAO,wBAAiBJ,KAAjB,EAAwB,EAAEuF,iCAAF,IAAgC,IAAhC,GAAuC,KAA/D,CAAP;AACD,GAjBD;;AAmBA;AACAtF,MAAIC,kBAAJ,CAAuB,UAAvB,EAAmC,CAAnC,EAAsC,mBAAW;AAC/C;AACA,QAAIG,IAAIF,QAAQG,kBAAR,EAAR;;AAEA;AACA,QAAI,EAAED,+BAAF,CAAJ,EAAiC;AAC/B,YAAML,MAAMO,0BAAN,CAAiCP,MAAMQ,UAAN,CAAiBC,SAAlD,EAA6D,0BAA7D,CAAN;AACD;;AAED;AACA,QAAI+E,UAAU,yBAAgBxF,KAAhB,EAAuB,cAAIA,KAAJ,EAAWK,CAAX,EAAc,QAAd,CAAvB,CAAd;;AAEA;AACA,QAAI6D,QAAQ,yBAAgBlE,KAAhB,EAAuB,cAAIA,KAAJ,EAAWK,CAAX,EAAc,OAAd,CAAvB,CAAZ;;AAEA;AACA,QAAIS,SAAS,MAAM0E,OAAN,GAAgB,GAAhB,GAAsBtB,KAAnC;;AAEA;AACA,WAAO,uBAAgBlE,KAAhB,EAAuBc,MAAvB,CAAP;AACD,GApBD;;AAsBA;AACAb,MAAIY,kBAAJ,CAAuB,SAAvB,EAAkC,mBAAW;AAC3C,WAAOO,gBAAgBpB,KAAhB,EAAuBG,OAAvB,EAAgC,GAAhC,CAAP;AACD,GAFD;AAGD,C;;AAhrBD;;;;AACA;;AASA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;;;AAEA,SAASiB,eAAT,CAAyBpB,KAAzB,EAAuCG,OAAvC,EAAuDsF,IAAvD,EAA4E;AAC1E;AACA,MAAIpF,IAAIF,QAAQG,kBAAR,EAAR;;AAEA;AACA,MAAI,EAAED,+BAAF,CAAJ,EAAiC;AAC/B,UAAML,MAAMO,0BAAN,CAAiCP,MAAMQ,UAAN,CAAiBC,SAAlD,EAA6D,0BAA7D,CAAN;AACD;;AAED;AACA,MAAI,OAAOJ,EAAE2D,cAAT,KAA4B,QAAhC,EAA0C;AACxC;AACA,QAAI,yBAAUhE,KAAV,EAAiBK,CAAjB,EAAoBL,MAAMQ,UAAN,CAAiBuD,eAArC,CAAJ,EAA2D;AACzD,aAAO/D,MAAMQ,UAAN,CAAiBG,SAAxB;AACD,KAFD,MAEO;AACL;AACA,YAAMX,MAAMO,0BAAN,CACJP,MAAMQ,UAAN,CAAiBC,SADb,EAEJ,oDAFI,CAAN;AAID;AACF;;AAED;AACA,MAAIyD,QAAQ7D,EAAE2D,cAAd;;AAEA;AACA,MAAIE,MAAMM,OAAN,CAAciB,IAAd,KAAuB,CAA3B,EAA8B;AAC5B,WAAOzF,MAAMQ,UAAN,CAAiBkF,IAAxB;AACD;;AAED;AACA,SAAO1F,MAAMQ,UAAN,CAAiBmF,KAAxB;AACD","file":"RegExpPrototype.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../../realm.js\";\nimport invariant from \"../../invariant.js\";\nimport {\n  BooleanValue,\n  StringValue,\n  ObjectValue,\n  NullValue,\n  NumberValue,\n  UndefinedValue,\n  Value,\n} from \"../../values/index.js\";\nimport { ArrayCreate, CreateDataProperty } from \"../../methods/create.js\";\nimport { SameValue } from \"../../methods/abstract.js\";\nimport { Call } from \"../../methods/call.js\";\nimport { Construct, SpeciesConstructor } from \"../../methods/construct.js\";\nimport { Get, GetSubstitution } from \"../../methods/get.js\";\nimport { Properties } from \"../../singletons.js\";\nimport { IsCallable } from \"../../methods/is.js\";\nimport { ToString, ToStringPartial, ToBooleanPartial, ToLength, ToInteger, ToUint32 } from \"../../methods/to.js\";\nimport { RegExpBuiltinExec, RegExpExec, EscapeRegExpPattern, AdvanceStringIndex } from \"../../methods/regexp.js\";\n\nfunction InternalHasFlag(realm: Realm, context: Value, flag: string): Value {\n  // 1. Let R be the this value.\n  let R = context.throwIfNotConcrete();\n\n  // 2. If Type(R) is not Object, throw a TypeError exception.\n  if (!(R instanceof ObjectValue)) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(R) is not an object\");\n  }\n\n  // 3. If R does not have an [[OriginalFlags]] internal slot, throw a TypeError exception.\n  if (typeof R.$OriginalFlags !== \"string\") {\n    // a. If SameValue(R, %RegExpPrototype%) is true, return undefined.\n    if (SameValue(realm, R, realm.intrinsics.RegExpPrototype)) {\n      return realm.intrinsics.undefined;\n    } else {\n      // b. Otherwise, throw a TypeError exception.\n      throw realm.createErrorThrowCompletion(\n        realm.intrinsics.TypeError,\n        \"R does not have an [[OriginalFlags]] internal slot\"\n      );\n    }\n  }\n\n  // 4. Let flags be the value of R's [[OriginalFlags]] internal slot.\n  let flags = R.$OriginalFlags;\n\n  // 5. If flags contains the code unit \"g\", return true.\n  if (flags.indexOf(flag) >= 0) {\n    return realm.intrinsics.true;\n  }\n\n  // 6. Return false.\n  return realm.intrinsics.false;\n}\n\nexport default function(realm: Realm, obj: ObjectValue): void {\n  // ECMA262 21.2.5.2\n  obj.defineNativeMethod(\"exec\", 1, (context, [string]) => {\n    // 1. Let R be the this value.\n    let R = context.throwIfNotConcrete();\n\n    // 2. If Type(R) is not Object, throw a TypeError exception.\n    if (!(R instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(R) is not an object\");\n    }\n\n    // 3. If R does not have a [[RegExpMatcher]] internal slot, throw a TypeError exception.\n    if (R.$RegExpMatcher === undefined) {\n      throw realm.createErrorThrowCompletion(\n        realm.intrinsics.TypeError,\n        \"R does not have a [[RegExpMatcher]] internal slot\"\n      );\n    }\n\n    // 4. Let S be ? ToString(string).\n    let S = ToStringPartial(realm, string);\n\n    // 5. Return ? RegExpBuiltinExec(R, S).\n    return RegExpBuiltinExec(realm, R, S);\n  });\n\n  // ECMA262 21.2.5.3\n  obj.defineNativeGetter(\"flags\", context => {\n    // 1. Let R be the this value.\n    let R = context.throwIfNotConcrete();\n\n    // 2. If Type(R) is not Object, throw a TypeError exception.\n    if (!(R instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(R) is not an object\");\n    }\n\n    // 3. Let result be the empty String.\n    let result = \"\";\n\n    // 4. Let global be ToBoolean(? Get(R, \"global\")).\n    let global = ToBooleanPartial(realm, Get(realm, R, \"global\"));\n\n    // 5. If global is true, append \"g\" as the last code unit of result.\n    if (global) result += \"g\";\n\n    // 6. Let ignoreCase be ToBoolean(? Get(R, \"ignoreCase\")).\n    let ignoreCase = ToBooleanPartial(realm, Get(realm, R, \"ignoreCase\"));\n\n    // 7. If ignoreCase is true, append \"i\" as the last code unit of result.\n    if (ignoreCase) result += \"i\";\n\n    // 8. Let multiline be ToBoolean(? Get(R, \"multiline\")).\n    let multiline = ToBooleanPartial(realm, Get(realm, R, \"multiline\"));\n\n    // 9. If multiline is true, append \"m\" as the last code unit of result.\n    if (multiline) result += \"m\";\n\n    // 10. Let unicode be ToBoolean(? Get(R, \"unicode\")).\n    let unicode = ToBooleanPartial(realm, Get(realm, R, \"unicode\"));\n\n    // 11. If unicode is true, append \"u\" as the last code unit of result.\n    if (unicode) result += \"u\";\n\n    // 12. Let sticky be ToBoolean(? Get(R, \"sticky\")).\n    let sticky = ToBooleanPartial(realm, Get(realm, R, \"sticky\"));\n\n    // 13. If sticky is true, append \"y\" as the last code unit of result.\n    if (sticky) result += \"y\";\n\n    // 14. Return result.\n    return new StringValue(realm, result);\n  });\n\n  // ECMA262 21.2.5.4\n  obj.defineNativeGetter(\"global\", context => {\n    return InternalHasFlag(realm, context, \"g\");\n  });\n\n  // ECMA262 21.2.5.5\n  obj.defineNativeGetter(\"ignoreCase\", context => {\n    return InternalHasFlag(realm, context, \"i\");\n  });\n\n  // ECMA262 21.2.5.6\n  obj.defineNativeMethod(realm.intrinsics.SymbolMatch, 1, (context, [string]) => {\n    // 1. Let rx be the this value.\n    let rx = context.throwIfNotConcrete();\n\n    // 2. If Type(rx) is not Object, throw a TypeError exception.\n    if (!(rx instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(R) is not an object\");\n    }\n\n    // 3. Let S be ? ToString(string).\n    let S = ToStringPartial(realm, string);\n\n    // 4. Let global be ToBoolean(? Get(rx, \"global\")).\n    let global = ToBooleanPartial(realm, Get(realm, rx, \"global\"));\n\n    // 5. If global is false, then\n    if (global === false) {\n      // a. Return ? RegExpExec(rx, S).\n      return RegExpExec(realm, rx, S);\n    } else {\n      // 6. Else global is true,\n      // a. Let fullUnicode be ToBoolean(? Get(rx, \"unicode\")).\n      let fullUnicode = ToBooleanPartial(realm, Get(realm, rx, \"unicode\"));\n\n      // b. Perform ? Set(rx, \"lastIndex\", 0, true).\n      Properties.Set(realm, rx, \"lastIndex\", realm.intrinsics.zero, true);\n\n      // c. Let A be ArrayCreate(0).\n      let A = ArrayCreate(realm, 0);\n\n      // d. Let n be 0.\n      let n = 0;\n\n      // e. Repeat,\n      while (true) {\n        // i. Let result be ? RegExpExec(rx, S).\n        let result = RegExpExec(realm, rx, S);\n\n        // ii. If result is null, then\n        if (result instanceof NullValue) {\n          // 1. If n=0, return null.\n          if (n === 0) {\n            return realm.intrinsics.null;\n          } else {\n            // 2. Else, return A.\n            return A;\n          }\n        } else {\n          // iii. Else result is not null,\n          // 1. Let matchStr be ? ToString(? Get(result, \"0\")).\n          let matchStr = ToStringPartial(realm, Get(realm, result, \"0\"));\n\n          // 2. Let status be CreateDataProperty(A, ! ToString(n), matchStr).\n          let status = CreateDataProperty(\n            realm,\n            A,\n            ToString(realm, new NumberValue(realm, n)),\n            new StringValue(realm, matchStr)\n          );\n\n          // 3. Assert: status is true.\n          invariant(status === true, \"status is true\");\n\n          // 4. If matchStr is the empty String, then\n          if (matchStr === \"\") {\n            // a. Let thisIndex be ? ToLength(? Get(rx, \"lastIndex\")).\n            let thisIndex = ToLength(realm, Get(realm, rx, \"lastIndex\"));\n\n            // b. Let nextIndex be AdvanceStringIndex(S, thisIndex, fullUnicode).\n            let nextIndex = AdvanceStringIndex(realm, S, thisIndex, fullUnicode);\n\n            // c .Perform ? Set(rx, \"lastIndex\", nextIndex, true).\n            Properties.Set(realm, rx, \"lastIndex\", new NumberValue(realm, nextIndex), true);\n          }\n\n          // 5. Increment n.\n          n += 1;\n        }\n      }\n\n      invariant(false);\n    }\n  });\n\n  // ECMA262 21.2.5.7\n  obj.defineNativeGetter(\"multiline\", context => {\n    return InternalHasFlag(realm, context, \"m\");\n  });\n\n  // ECMA262 21.2.5.8\n  obj.defineNativeMethod(realm.intrinsics.SymbolReplace, 2, (context, [string, replaceValue]) => {\n    // 1. Let rx be the this value.\n    let rx = context.throwIfNotConcrete();\n\n    // 2. If Type(rx) is not Object, throw a TypeError exception.\n    if (!(rx instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(R) is not an object\");\n    }\n\n    // 3. Let S be ? ToString(string).\n    let S = ToStringPartial(realm, string);\n\n    // 4. Let lengthS be the number of code unit elements in S.\n    let lengthS = S.length;\n\n    // 5. Let functionalReplace be IsCallable(replaceValue).\n    let functionalReplace = IsCallable(realm, replaceValue);\n\n    // 6. If functionalReplace is false, then\n    if (functionalReplace === false) {\n      // a. Let replaceValue be ? ToString(replaceValue).\n      replaceValue = new StringValue(realm, ToStringPartial(realm, replaceValue));\n    }\n\n    // 7. Let global be ToBoolean(? Get(rx, \"global\")).\n    let global = ToBooleanPartial(realm, Get(realm, rx, \"global\"));\n\n    let fullUnicode;\n    // 8. If global is true, then\n    if (global === true) {\n      // a. Let fullUnicode be ToBoolean(? Get(rx, \"unicode\")).\n      fullUnicode = ToBooleanPartial(realm, Get(realm, rx, \"unicode\"));\n\n      // b. Perform ? Set(rx, \"lastIndex\", 0, true).\n      Properties.Set(realm, rx, \"lastIndex\", realm.intrinsics.zero, true);\n    }\n\n    // 9. Let results be a new empty List.\n    let results = [];\n\n    // 10. Let done be false.\n    let done = false;\n\n    // 11. Repeat, while done is false\n    while (done === false) {\n      // a. Let result be ? RegExpExec(rx, S).\n      let result = RegExpExec(realm, rx, S);\n\n      // b. If result is null, set done to true.\n      if (result instanceof NullValue) {\n        done = true;\n      } else {\n        // c. Else result is not null,\n        // i. Append result to the end of results.\n        results.push(result);\n\n        // ii. If global is false, set done to true.\n        if (global === false) {\n          done = true;\n        } else {\n          // iii. Else,\n          invariant(fullUnicode !== undefined);\n\n          // 1. Let matchStr be ? ToString(? Get(result, \"0\")).\n          let matchStr = ToStringPartial(realm, Get(realm, result, \"0\"));\n\n          // 2. If matchStr is the empty String, then\n          if (matchStr === \"\") {\n            // a. Let thisIndex be ? ToLength(? Get(rx, \"lastIndex\")).\n            let thisIndex = ToLength(realm, Get(realm, rx, \"lastIndex\"));\n\n            // b. Let nextIndex be AdvanceStringIndex(S, thisIndex, fullUnicode).\n            let nextIndex = AdvanceStringIndex(realm, S, thisIndex, fullUnicode);\n\n            // c. Perform ? Set(rx, \"lastIndex\", nextIndex, true).\n            Properties.Set(realm, rx, \"lastIndex\", new NumberValue(realm, nextIndex), true);\n          }\n        }\n      }\n    }\n\n    // 12. Let accumulatedResult be the empty String value.\n    let accumulatedResult = \"\";\n\n    // 13. Let nextSourcePosition be 0.\n    let nextSourcePosition = 0;\n\n    // 14. Repeat, for each result in results,\n    for (let result of results) {\n      // a. Let nCaptures be ? ToLength(? Get(result, \"length\")).\n      let nCaptures = ToLength(realm, Get(realm, result, \"length\"));\n\n      // b. Let nCaptures be max(nCaptures - 1, 0).\n      nCaptures = Math.max(nCaptures - 1, 0);\n\n      // c. Let matched be ? ToString(? Get(result, \"0\")).\n      let matched = ToStringPartial(realm, Get(realm, result, \"0\"));\n\n      // d. Let matchLength be the number of code units in matched.\n      let matchLength = matched.length;\n\n      // e. Let position be ? ToInteger(? Get(result, \"index\")).\n      let position = ToInteger(realm, Get(realm, result, \"index\"));\n\n      // f. Let position be max(min(position, lengthS), 0).\n      position = Math.max(Math.min(position, lengthS), 0);\n\n      // g. Let n be 1.\n      let n = 1;\n\n      // h. Let captures be a new empty List.\n      let captures = [];\n\n      // i. Repeat while n ≤ nCaptures\n      while (n <= nCaptures) {\n        // i. Let capN be ? Get(result, ! ToString(n)).\n        let capN = Get(realm, result, ToString(realm, new NumberValue(realm, n)));\n\n        // ii. If capN is not undefined, then\n        if (!capN.mightBeUndefined()) {\n          // 1. Let capN be ? ToString(capN).\n          capN = ToStringPartial(realm, capN);\n        } else {\n          capN.throwIfNotConcrete();\n          capN = undefined;\n        }\n\n        // iii. Append capN as the last element of captures.\n        captures.push(capN);\n\n        // iv. Let n be n+1.\n        n = n + 1;\n      }\n\n      let replacement;\n      // j. If functionalReplace is true, then\n      if (functionalReplace) {\n        // i. Let replacerArgs be « matched ».\n        let replacerArgs = [new StringValue(realm, matched)];\n\n        // ii. Append in list order the elements of captures to the end of the List replacerArgs.\n        for (let capture of captures) {\n          replacerArgs.push(capture === undefined ? realm.intrinsics.undefined : new StringValue(realm, capture));\n        }\n\n        // iii. Append position and S as the last two elements of replacerArgs.\n        replacerArgs = replacerArgs.concat([new NumberValue(realm, position), new StringValue(realm, S)]);\n\n        // iv. Let replValue be ? Call(replaceValue, undefined, replacerArgs).\n        let replValue = Call(realm, replaceValue, realm.intrinsics.undefined, replacerArgs);\n\n        // v. Let replacement be ? ToString(replValue).\n        replacement = ToStringPartial(realm, replValue);\n      } else {\n        // k. Else,\n        invariant(replaceValue instanceof StringValue);\n        // i. Let replacement be GetSubstitution(matched, S, position, captures, replaceValue).\n        replacement = GetSubstitution(realm, matched, S, position, captures, replaceValue.value);\n      }\n\n      // l. If position ≥ nextSourcePosition, then\n      if (position >= nextSourcePosition) {\n        // i. NOTE position should not normally move backwards. If it does, it is an indication of an ill-behaving RegExp subclass or use of an access triggered side-effect to change the global flag or other characteristics of rx. In such cases, the corresponding substitution is ignored.\n        // ii. Let accumulatedResult be the String formed by concatenating the code units of the current value of accumulatedResult with the substring of S consisting of the code units from nextSourcePosition (inclusive) up to position (exclusive) and with the code units of replacement.\n        accumulatedResult =\n          accumulatedResult + S.substr(nextSourcePosition, position - nextSourcePosition) + replacement;\n\n        // iii. Let nextSourcePosition be position + matchLength.\n        nextSourcePosition = position + matchLength;\n      }\n    }\n    // 15. If nextSourcePosition ≥ lengthS, return accumulatedResult.\n    if (nextSourcePosition >= lengthS) return new StringValue(realm, accumulatedResult);\n\n    // 16. Return the String formed by concatenating the code units of accumulatedResult with the substring of S consisting of the code units from nextSourcePosition (inclusive) up through the final code unit of S (inclusive).\n    return new StringValue(realm, accumulatedResult + S.substr(nextSourcePosition));\n  });\n\n  // ECMA262 21.2.5.9\n  obj.defineNativeMethod(realm.intrinsics.SymbolSearch, 1, (context, [string]) => {\n    // 1. Let rx be the this value.\n    let rx = context.throwIfNotConcrete();\n\n    // 2. If Type(rx) is not Object, throw a TypeError exception.\n    if (!(rx instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(R) is not an object\");\n    }\n\n    // 3. Let S be ? ToString(string).\n    let S = ToStringPartial(realm, string);\n\n    // 4. Let previousLastIndex be ? Get(rx, \"lastIndex\").\n    let previousLastIndex = Get(realm, rx, \"lastIndex\");\n\n    // 5. Perform ? Set(rx, \"lastIndex\", 0, true).\n    Properties.Set(realm, rx, \"lastIndex\", realm.intrinsics.zero, true);\n\n    // 6. Let result be ? RegExpExec(rx, S).\n    let result = RegExpExec(realm, rx, S);\n\n    // 7. Perform ? Set(rx, \"lastIndex\", previousLastIndex, true).\n    Properties.Set(realm, rx, \"lastIndex\", previousLastIndex, true);\n\n    // 8. If result is null, return -1.\n    if (result instanceof NullValue) return new NumberValue(realm, -1);\n\n    // 9. Return ? Get(result, \"index\").\n    return Get(realm, result, \"index\");\n  });\n\n  // ECMA262 21.2.5.10\n  obj.defineNativeGetter(\"source\", context => {\n    // 1. Let R be the this value.\n    let R = context.throwIfNotConcrete();\n\n    // 2. If Type(R) is not Object, throw a TypeError exception.\n    if (!(R instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(R) is not an object\");\n    }\n\n    // 3. If R does not have an [[OriginalSource]] internal slot, throw a TypeError exception.\n    if (typeof R.$OriginalSource !== \"string\") {\n      // a. If SameValue(R, %RegExpPrototype%) is true, return undefined.\n      if (SameValue(realm, R, realm.intrinsics.RegExpPrototype)) {\n        return new StringValue(realm, \"(?:)\");\n      } else {\n        // b. Otherwise, throw a TypeError exception.\n        throw realm.createErrorThrowCompletion(\n          realm.intrinsics.TypeError,\n          \"R does not have an [[OriginalSource]] internal slot\"\n        );\n      }\n    }\n\n    // 4. Assert: R has an [[OriginalFlags]] internal slot.\n    invariant(R.$OriginalFlags !== undefined, \"R has an [[OriginalFlags]] internal slot\");\n\n    // 5. Let src be R.[[OriginalSource]].\n    let src = R.$OriginalSource;\n    invariant(typeof src === \"string\");\n\n    // 6. Let flags be R.[[OriginalFlags]].\n    let flags = R.$OriginalFlags;\n    invariant(typeof flags === \"string\");\n\n    // 7. Return EscapeRegExpPattern(src, flags).\n    return new StringValue(realm, EscapeRegExpPattern(realm, src, flags));\n  });\n\n  // ECMA262 21.2.5.11\n  obj.defineNativeMethod(realm.intrinsics.SymbolSplit, 2, (context, [string, limit]) => {\n    // 1. Let rx be the this value.\n    let rx = context.throwIfNotConcrete();\n\n    // 2. If Type(rx) is not Object, throw a TypeError exception.\n    if (!(rx instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(rx) is not an object\");\n    }\n\n    // 3. Let S be ? ToString(string).\n    let S = ToStringPartial(realm, string);\n\n    // 4. Let C be ? SpeciesConstructor(rx, %RegExp%).\n    let C = SpeciesConstructor(realm, rx, realm.intrinsics.RegExp);\n\n    // 5. Let flags be ? ToString(? Get(rx, \"flags\")).\n    let flags = ToStringPartial(realm, Get(realm, rx, \"flags\"));\n\n    let unicodeMatching;\n    // 6. If flags contains \"u\", let unicodeMatching be true.\n    if (flags.indexOf(\"u\") >= 0) {\n      unicodeMatching = true;\n    } else {\n      // 7. Else, let unicodeMatching be false.\n      unicodeMatching = false;\n    }\n\n    let newFlags;\n    // 8. If flags contains \"y\", let newFlags be flags.\n    if (flags.indexOf(\"y\") >= 0) {\n      newFlags = flags;\n    } else {\n      // 9. Else, let newFlags be the string that is the concatenation of flags and \"y\".\n      newFlags = flags + \"y\";\n    }\n\n    // 10. Let splitter be ? Construct(C, « rx, newFlags »).\n    let splitter = Construct(realm, C, [rx, new StringValue(realm, newFlags)]);\n\n    // 11. Let A be ArrayCreate(0).\n    let A = ArrayCreate(realm, 0);\n\n    // 12. Let lengthA be 0.\n    let lengthA = 0;\n\n    // 13. If limit is undefined, let lim be 2^32-1; else let lim be ? ToUint32(limit).\n    let lim = limit instanceof UndefinedValue ? Math.pow(2, 32) - 1 : ToUint32(realm, limit.throwIfNotConcrete());\n\n    // 14. Let size be the number of elements in S.\n    let size = S.length;\n\n    // 15. Let p be 0.\n    let p = 0;\n\n    // 16. If lim = 0, return A.\n    if (lim === 0) return A;\n\n    // 17. If size = 0, then\n    if (size === 0) {\n      // a. Let z be ? RegExpExec(splitter, S).\n      let z = RegExpExec(realm, splitter, S);\n\n      // b. If z is not null, return A.\n      if (!(z instanceof NullValue)) return A;\n\n      // c. Perform ! CreateDataProperty(A, \"0\", S).\n      CreateDataProperty(realm, A, \"0\", new StringValue(realm, S));\n\n      // d Return A.\n      return A;\n    }\n\n    // 18. Let q be p.\n    let q = p;\n\n    // 19. Repeat, while q < size\n    while (q < size) {\n      // a. Perform ? Set(splitter, \"lastIndex\", q, true).\n      Properties.Set(realm, splitter, \"lastIndex\", new NumberValue(realm, q), true);\n\n      // b. Let z be ? RegExpExec(splitter, S).\n      let z = RegExpExec(realm, splitter, S);\n\n      // c. If z is null, let q be AdvanceStringIndex(S, q, unicodeMatching).\n      if (z instanceof NullValue) {\n        q = AdvanceStringIndex(realm, S, q, unicodeMatching);\n      } else {\n        // d. Else z is not null,\n        // i. Let e be ? ToLength(? Get(splitter, \"lastIndex\")).\n        let e = ToLength(realm, Get(realm, splitter, \"lastIndex\"));\n\n        // ii. Let e be min(e, size).\n        e = Math.min(e, size);\n\n        // iii. If e = p, let q be AdvanceStringIndex(S, q, unicodeMatching).\n        if (e === p) {\n          q = AdvanceStringIndex(realm, S, q, unicodeMatching);\n        } else {\n          // iv. Else e ≠ p,\n          // 1. Let T be a String value equal to the substring of S consisting of the elements at indices p (inclusive) through q (exclusive).\n          let T = S.substr(p, q - p);\n\n          // 2. Perform ! CreateDataProperty(A, ! ToString(lengthA), T).\n          CreateDataProperty(realm, A, ToString(realm, new NumberValue(realm, lengthA)), new StringValue(realm, T));\n\n          // 3. Let lengthA be lengthA + 1.\n          lengthA = lengthA + 1;\n\n          // 4. If lengthA = lim, return A.\n          if (lengthA === lim) return A;\n\n          // 5. Let p be e.\n          p = e;\n\n          // 6. Let numberOfCaptures be ? ToLength(? Get(z, \"length\")).\n          let numberOfCaptures = ToLength(realm, Get(realm, z, \"length\"));\n\n          // 7. Let numberOfCaptures be max(numberOfCaptures-1, 0).\n          numberOfCaptures = Math.max(numberOfCaptures - 1, 0);\n\n          // 8. Let i be 1.\n          let i = 1;\n\n          // 9. Repeat, while i ≤ numberOfCaptures,\n          while (i <= numberOfCaptures) {\n            // a. Let nextCapture be ? Get(z, ! ToString(i)).\n            let nextCapture = Get(realm, z, ToString(realm, new NumberValue(realm, i)));\n\n            // b. Perform ! CreateDataProperty(A, ! ToString(lengthA), nextCapture).\n            CreateDataProperty(realm, A, ToString(realm, new NumberValue(realm, lengthA)), nextCapture);\n\n            // c. Let i be i + 1.\n            i = i + 1;\n\n            // d. Let lengthA be lengthA + 1.\n            lengthA = lengthA + 1;\n\n            // e. If lengthA = lim, return A.\n            if (lengthA === lim) return A;\n          }\n\n          // 10. Let q be p.\n          q = p;\n        }\n      }\n    }\n\n    // 20. Let T be a String value equal to the substring of S consisting of the elements at indices p (inclusive) through size (exclusive).\n    let T = S.substr(p, size - p);\n\n    // 21. Perform ! CreateDataProperty(A, ! ToString(lengthA), T).\n    CreateDataProperty(realm, A, ToString(realm, new NumberValue(realm, lengthA)), new StringValue(realm, T));\n\n    // 22. Return A.\n    return A;\n  });\n\n  // ECMA262 21.2.5.12\n  obj.defineNativeGetter(\"sticky\", context => {\n    return InternalHasFlag(realm, context, \"y\");\n  });\n\n  // ECMA262 21.2.5.13\n  obj.defineNativeMethod(\"test\", 1, (context, [S]) => {\n    // 1. Let R be the this value.\n    let R = context.throwIfNotConcrete();\n\n    // 2. If Type(R) is not Object, throw a TypeError exception.\n    if (!(R instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(R) is not an object\");\n    }\n\n    // 3. Let string be ? ToString(S).\n    let string = ToStringPartial(realm, S);\n\n    // 4. Let match be ? RegExpExec(R, string).\n    let match = RegExpExec(realm, R, string);\n\n    // 5. If match is not null, return true; else return false.\n    return new BooleanValue(realm, !(match instanceof NullValue) ? true : false);\n  });\n\n  // ECMA262 21.2.5.14\n  obj.defineNativeMethod(\"toString\", 0, context => {\n    // 1. Let R be the this value.\n    let R = context.throwIfNotConcrete();\n\n    // 2. If Type(R) is not Object, throw a TypeError exception.\n    if (!(R instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(R) is not an object\");\n    }\n\n    // 3. Let pattern be ? ToString(? Get(R, \"source\")).\n    let pattern = ToStringPartial(realm, Get(realm, R, \"source\"));\n\n    // 4. Let flags be ? ToString(? Get(R, \"flags\")).\n    let flags = ToStringPartial(realm, Get(realm, R, \"flags\"));\n\n    // 5. Let result be the String value formed by concatenating \"/\", pattern, \"/\", and flags.\n    let result = \"/\" + pattern + \"/\" + flags;\n\n    // 6. Return result.\n    return new StringValue(realm, result);\n  });\n\n  // ECMA262 21.2.5.15\n  obj.defineNativeGetter(\"unicode\", context => {\n    return InternalHasFlag(realm, context, \"u\");\n  });\n}\n"]}