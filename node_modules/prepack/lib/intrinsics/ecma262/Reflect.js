"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Copyright (c) 2017-present, Facebook, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * This source code is licensed under the BSD-style license found in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * LICENSE file in the root directory of this source tree. An additional grant
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * of patent rights can be found in the PATENTS file in the same directory.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */

exports.default = function (realm) {
  var obj = new _index.ObjectValue(realm, realm.intrinsics.ObjectPrototype, "Reflect");

  // ECMA262 26.1.1
  obj.defineNativeMethod("apply", 3, function (context, _ref) {
    var _ref2 = _slicedToArray(_ref, 3),
        target = _ref2[0],
        thisArgument = _ref2[1],
        argumentsList = _ref2[2];

    // 1. If IsCallable(target) is false, throw a TypeError exception.
    if (!(0, _index2.IsCallable)(realm, target)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    }

    // 2. Let args be ? CreateListFromArrayLike(argumentsList).
    var args = (0, _index2.CreateListFromArrayLike)(realm, argumentsList);

    // TODO #1008 3. Perform PrepareForTailCall().

    // 4. Return ? Call(target, thisArgument, args).
    return (0, _index2.Call)(realm, target, thisArgument, args);
  });

  // ECMA262 26.1.2
  obj.defineNativeMethod("construct", 2, function (context, _ref3) {
    var _ref4 = _slicedToArray(_ref3, 3),
        target = _ref4[0],
        argumentsList = _ref4[1],
        newTarget = _ref4[2];

    // 1. If IsConstructor(target) is false, throw a TypeError exception.
    if (!(0, _index2.IsConstructor)(realm, target)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    }

    // 2. If newTarget is not present, let newTarget be target.
    if (!newTarget) {
      newTarget = target;
    } else if (!(0, _index2.IsConstructor)(realm, newTarget)) {
      // 3. Else if IsConstructor(newTarget) is false, throw a TypeError exception.
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    }

    // 4. Let args be ? CreateListFromArrayLike(argumentsList).
    var args = (0, _index2.CreateListFromArrayLike)(realm, argumentsList);

    // 5. Return ? Construct(target, args, newTarget).
    return (0, _index2.Construct)(realm, target, args, newTarget);
  });

  // ECMA262 26.1.3
  obj.defineNativeMethod("defineProperty", 3, function (context, _ref5) {
    var _ref6 = _slicedToArray(_ref5, 3),
        target = _ref6[0],
        propertyKey = _ref6[1],
        attributes = _ref6[2];

    target = target.throwIfNotConcrete();

    // 1. If Type(target) is not Object, throw a TypeError exception.
    if (!(target instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    }

    // 2. Let key be ? ToPropertyKey(propertyKey).
    var key = (0, _index2.ToPropertyKey)(realm, propertyKey);

    // 3. Let desc be ? ToPropertyDescriptor(attributes).
    var desc = (0, _index2.ToPropertyDescriptor)(realm, attributes);

    // 4. Return ? target.[[DefineOwnProperty]](key, desc).
    return new _index.BooleanValue(realm, target.$DefineOwnProperty(key, desc));
  });

  // ECMA262 26.1.4
  obj.defineNativeMethod("deleteProperty", 2, function (context, _ref7) {
    var _ref8 = _slicedToArray(_ref7, 2),
        target = _ref8[0],
        propertyKey = _ref8[1];

    target = target.throwIfNotConcrete();

    // 1. If Type(target) is not Object, throw a TypeError exception.
    if (!(target instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    }

    // 2. Let key be ? ToPropertyKey(propertyKey).
    var key = (0, _index2.ToPropertyKey)(realm, propertyKey);

    // 3. Return ? target.[[Delete]](key).
    return new _index.BooleanValue(realm, target.$Delete(key));
  });

  // ECMA262 26.1.5
  obj.defineNativeMethod("get", 2, function (context, _ref9) {
    var _ref10 = _slicedToArray(_ref9, 3),
        target = _ref10[0],
        propertyKey = _ref10[1],
        receiver = _ref10[2];

    target = target.throwIfNotConcrete();

    // 1. If Type(target) is not Object, throw a TypeError exception.
    if (!(target instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    }

    // 2. Let key be ? ToPropertyKey(propertyKey).
    var key = (0, _index2.ToPropertyKey)(realm, propertyKey);

    // 3. If receiver is not present, then
    if (!receiver) {
      // a. Let receiver be target.
      receiver = target;
    }

    // 4. Return ? target.[[Get]](key, receiver).
    return target.$Get(key, receiver);
  });

  // ECMA262 26.1.6
  obj.defineNativeMethod("getOwnPropertyDescriptor", 2, function (context, _ref11) {
    var _ref12 = _slicedToArray(_ref11, 2),
        target = _ref12[0],
        propertyKey = _ref12[1];

    target = target.throwIfNotConcrete();

    // 1. If Type(target) is not Object, throw a TypeError exception.
    if (!(target instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    }

    // 2. Let key be ? ToPropertyKey(propertyKey).
    var key = (0, _index2.ToPropertyKey)(realm, propertyKey);

    // 3. Let desc be ? target.[[GetOwnProperty]](key).
    var desc = target.$GetOwnProperty(key);

    // 4. Return FromPropertyDescriptor(desc).
    return _singletons.Properties.FromPropertyDescriptor(realm, desc);
  });

  // ECMA262 26.1.7
  obj.defineNativeMethod("getPrototypeOf", 1, function (context, _ref13) {
    var _ref14 = _slicedToArray(_ref13, 1),
        target = _ref14[0];

    target = target.throwIfNotConcrete();

    // 1. If Type(target) is not Object, throw a TypeError exception.
    if (!(target instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    }

    // 2. Return ? target.[[GetPrototypeOf]]().
    return target.$GetPrototypeOf();
  });

  // ECMA262 26.1.8
  obj.defineNativeMethod("has", 2, function (context, _ref15) {
    var _ref16 = _slicedToArray(_ref15, 2),
        target = _ref16[0],
        propertyKey = _ref16[1];

    // 1. If Type(target) is not Object, throw a TypeError exception.
    if (target.mightNotBeObject()) {
      if (target.mightBeObject()) target.throwIfNotConcrete();
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    }

    // 2. Let key be ? ToPropertyKey(propertyKey).
    var key = (0, _index2.ToPropertyKey)(realm, propertyKey);

    // 3. Return ? target.[[HasProperty]](key).
    return new _index.BooleanValue(realm, target.$HasProperty(key));
  });

  // ECMA262 26.1.9
  obj.defineNativeMethod("isExtensible", 1, function (context, _ref17) {
    var _ref18 = _slicedToArray(_ref17, 1),
        target = _ref18[0];

    target = target.throwIfNotConcrete();

    // 1. If Type(target) is not Object, throw a TypeError exception.
    if (!(target instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    }

    // 2. Return ? target.[[IsExtensible]]().
    return new _index.BooleanValue(realm, target.$IsExtensible());
  });

  // ECMA262 26.1.10
  obj.defineNativeMethod("ownKeys", 1, function (context, _ref19) {
    var _ref20 = _slicedToArray(_ref19, 1),
        target = _ref20[0];

    target = target.throwIfNotConcrete();

    // 1. If Type(target) is not Object, throw a TypeError exception.
    if (!(target instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    }

    // 2. Let keys be ? target.[[OwnPropertyKeys]]().
    var keys = target.$OwnPropertyKeys();

    // 3. Return CreateArrayFromList(keys).
    return (0, _index2.CreateArrayFromList)(realm, keys);
  });

  // ECMA262 26.1.11
  obj.defineNativeMethod("preventExtensions", 1, function (context, _ref21) {
    var _ref22 = _slicedToArray(_ref21, 1),
        target = _ref22[0];

    target = target.throwIfNotConcrete();

    // 1. If Type(target) is not Object, throw a TypeError exception.
    if (!(target instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    }

    // 2. Return ? target.[[PreventExtensions]]().
    return new _index.BooleanValue(realm, target.$PreventExtensions());
  });

  // ECMA262 26.1.12
  obj.defineNativeMethod("set", 3, function (context, _ref23) {
    var _ref24 = _slicedToArray(_ref23, 4),
        target = _ref24[0],
        propertyKey = _ref24[1],
        V = _ref24[2],
        receiver = _ref24[3];

    target = target.throwIfNotConcrete();

    // 1. If Type(target) is not Object, throw a TypeError exception.
    if (!(target instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    }

    // 2. Let key be ? ToPropertyKey(propertyKey).
    var key = (0, _index2.ToPropertyKey)(realm, propertyKey);

    // 3. If receiver is not present, then
    if (!receiver) {
      // a. Let receiver be target.
      receiver = target;
    }

    // 5. Return ? target.[[Set]](key, V, receiver).
    return new _index.BooleanValue(realm, target.$Set(key, V, receiver));
  });

  // ECMA262 26.1.13
  obj.defineNativeMethod("setPrototypeOf", 2, function (context, _ref25) {
    var _ref26 = _slicedToArray(_ref25, 2),
        target = _ref26[0],
        proto = _ref26[1];

    target = target.throwIfNotConcrete();
    proto = proto.throwIfNotConcrete();

    // 1. If Type(target) is not Object, throw a TypeError exception.
    if (!(target instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    }

    // 2. If Type(proto) is not Object and proto is not null, throw a TypeError exception.
    if (!(proto instanceof _index.ObjectValue) && !(proto instanceof _index.NullValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    }

    // 3. Return ? target.[[SetPrototypeOf]](proto).
    return new _index.BooleanValue(realm, target.$SetPrototypeOf(proto));
  });

  return obj;
};

var _index = require("../../values/index.js");

var _index2 = require("../../methods/index.js");

var _singletons = require("../../singletons.js");
//# sourceMappingURL=Reflect.js.map