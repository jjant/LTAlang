"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Copyright (c) 2017-present, Facebook, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * This source code is licensed under the BSD-style license found in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * LICENSE file in the root directory of this source tree. An additional grant
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * of patent rights can be found in the PATENTS file in the same directory.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */

exports.default = function (realm, obj) {
  // ECMA262 22.2.3.1
  obj.defineNativeGetter("buffer", function (context) {
    // 1. Let O be the this value.
    var O = context.throwIfNotConcrete();

    // 2. If Type(O) is not Object, return undefined.
    if (!(O instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(O) is not Object");
    }

    // 3. If O does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.
    if (!("$TypedArrayName" in O)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "O does not have a [[TypedArrayName]] internal slot");
    }

    // 4. Assert: O has a [[ViewedArrayBuffer]] internal slot.
    (0, _invariant2.default)(O.$ViewedArrayBuffer, "O has a [[ViewedArrayBuffer]]");

    // 5. Let buffer be O.[[ViewedArrayBuffer]].
    var buffer = O.$ViewedArrayBuffer;

    // 6. Return buffer.
    return buffer;
  });

  // ECMA262 22.2.3.2
  obj.defineNativeGetter("byteLength", function (context) {
    // 1. Let O be the this value.
    var O = context.throwIfNotConcrete();

    // 2. If Type(O) is not Object, throw a TypeError exception.
    if (!(O instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(O) is not Object");
    }

    // 3. If O does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.
    if (!("$TypedArrayName" in O)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "O does not have a [[TypedArrayName]] internal slot");
    }

    // 4. Assert: O has [[ViewedArrayBuffer]] and [[ArrayLength]] internal slots.
    (0, _invariant2.default)(O.$ViewedArrayBuffer, "O has a [[ViewedArrayBuffer]] internal slot");

    // 5. Let buffer be O.[[ViewedArrayBuffer]].
    var buffer = O.$ViewedArrayBuffer;
    (0, _invariant2.default)(buffer);

    // 6. If IsDetachedBuffer(buffer) is true, return 0.
    if ((0, _is.IsDetachedBuffer)(realm, buffer) === true) return realm.intrinsics.zero;

    // 7. Let size be O.[[ByteLength]].
    var size = O.$ByteLength;
    (0, _invariant2.default)(typeof size === "number");

    // 8. Return size.
    return new _index.NumberValue(realm, size);
  });

  // ECMA262 22.2.3.3
  obj.defineNativeGetter("byteOffset", function (context) {
    // 1. Let O be the this value.
    var O = context.throwIfNotConcrete();

    // 2. If Type(O) is not Object, throw a TypeError exception.
    if (!(O instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(O) is not Object");
    }

    // 3. If O does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.
    if (!("$TypedArrayName" in O)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "O does not have a [[TypedArrayName]] internal slot");
    }

    // 4. Assert: O has [[ViewedArrayBuffer]] and [[ArrayLength]] internal slots.
    (0, _invariant2.default)(O.$ViewedArrayBuffer, "O has a [[ViewedArrayBuffer]] internal slot");

    // 5. Let buffer be O.[[ViewedArrayBuffer]].
    var buffer = O.$ViewedArrayBuffer;
    (0, _invariant2.default)(buffer);

    // 6. If IsDetachedBuffer(buffer) is true, return 0.
    if ((0, _is.IsDetachedBuffer)(realm, buffer) === true) return realm.intrinsics.zero;

    // 7. Let offset be O.[[ByteOffset]].
    var offset = O.$ByteOffset;
    (0, _invariant2.default)(typeof offset === "number");

    // 8. Return offset.
    return new _index.NumberValue(realm, offset);
  });

  // ECMA262 22.2.3.5
  obj.defineNativeMethod("copyWithin", 2, function (context, _ref) {
    var _ref2 = _slicedToArray(_ref, 3),
        target = _ref2[0],
        start = _ref2[1],
        end = _ref2[2];

    // 1. Let O be ? ToObject(this value).
    var O = (0, _to.ToObject)(realm, context.throwIfNotConcrete());

    // 2. Perform ? ValidateTypedArray(O).
    (0, _typedarray.ValidateTypedArray)(realm, O);

    // 3. Let len be O.[[ArrayLength]].
    var len = O.$ArrayLength;
    (0, _invariant2.default)(typeof len === "number");

    // 4. Let relativeTarget be ? ToInteger(target).
    var relativeTarget = (0, _to.ToInteger)(realm, target);

    // 5. If relativeTarget < 0, let to be max((len + relativeTarget), 0); else let to be min(relativeTarget, len).
    var to = relativeTarget < 0 ? Math.max(len + relativeTarget, 0) : Math.min(relativeTarget, len);

    // 6. Let relativeStart be ? ToInteger(start).
    var relativeStart = (0, _to.ToInteger)(realm, start);

    // 7. If relativeStart < 0, let from be max((len + relativeStart), 0); else let from be min(relativeStart, len).
    var from = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);

    // 8. If end is undefined, let relativeEnd be len; else let relativeEnd be ? ToInteger(end).
    var relativeEnd = !end || end instanceof _index.UndefinedValue ? len : (0, _to.ToInteger)(realm, end.throwIfNotConcrete());

    // 9. If relativeEnd < 0, let final be max((len + relativeEnd), 0); else let final be min(relativeEnd, len).
    var final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);

    // 10. Let count be min(final-from, len-to).
    var count = Math.min(final - from, len - to);

    var direction = void 0;
    // 11. If from<to and to<from+count, then
    if (from < to && to < from + count) {
      // a. Let direction be -1.
      direction = -1;

      // b. Let from be from + count - 1.
      from = from + count - 1;

      // c. Let to be to + count - 1.
      to = to + count - 1;
    } else {
      // 12. Else,
      // a. Let direction be 1.
      direction = 1;
    }

    // 13. Repeat, while count > 0
    while (count > 0) {
      // a. Let fromKey be ! ToString(from).
      var fromKey = (0, _to.ToString)(realm, new _index.NumberValue(realm, from));

      // b. Let toKey be ! ToString(to).
      var toKey = (0, _to.ToString)(realm, new _index.NumberValue(realm, to));

      // c. Let fromPresent be ? HasProperty(O, fromKey).
      var fromPresent = (0, _has.HasProperty)(realm, O, fromKey);

      // d. If fromPresent is true, then
      if (fromPresent === true) {
        // i. Let fromVal be ? Get(O, fromKey).
        var fromVal = (0, _get.Get)(realm, O, fromKey);
        // ii. Perform ? Set(O, toKey, fromVal, true).
        _singletons.Properties.Set(realm, O, toKey, fromVal, true);
      } else {
        // e. Else fromPresent is false,
        // i. Perform ? DeletePropertyOrThrow(O, toKey).
        _singletons.Properties.DeletePropertyOrThrow(realm, O, toKey);
      }

      // f. Let from be from + direction.
      from = from + direction;

      // g. Let to be to + direction.
      to = to + direction;

      // h. Let count be count - 1.
      count = count - 1;
    }

    // 14. Return O.
    return O;
  });

  // ECMA262 22.2.3.6
  obj.defineNativeMethod("entries", 0, function (context) {
    // 1. Let O be the this value.
    var O = context;

    // 2. Perform ? ValidateTypedArray(O).
    (0, _typedarray.ValidateTypedArray)(realm, O);
    (0, _invariant2.default)(O instanceof _index.ObjectValue);

    // 3. Return CreateArrayIterator(O, "key+value").
    return (0, _create.CreateArrayIterator)(realm, O, "key+value");
  });

  // ECMA262 22.2.3.7
  obj.defineNativeMethod("every", 1, function (context, _ref3) {
    var _ref4 = _slicedToArray(_ref3, 2),
        callbackfn = _ref4[0],
        thisArg = _ref4[1];

    // 1. Let O be ? ToObject(this value).
    var O = (0, _to.ToObject)(realm, context.throwIfNotConcrete());

    // 2. Perform ? ValidateTypedArray(O).
    (0, _typedarray.ValidateTypedArray)(realm, O);

    // 3. Let len be O.[[ArrayLength]].
    var len = O.$ArrayLength;
    (0, _invariant2.default)(typeof len === "number");

    // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.
    if (!(0, _is.IsCallable)(realm, callbackfn)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "not a function");
    }

    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
    var T = thisArg || realm.intrinsics.undefined;

    // 6. Let k be 0.
    var k = 0;

    // 7. Repeat, while k < len
    while (k < len) {
      // a. Let Pk be ! ToString(k).
      var Pk = new _index.StringValue(realm, k + "");

      // b. Let kPresent be ? HasProperty(O, Pk).
      var kPresent = (0, _has.HasProperty)(realm, O, Pk);

      // c. If kPresent is true, then
      if (kPresent) {
        // i. Let kValue be ? Get(O, Pk).
        var kValue = (0, _get.Get)(realm, O, Pk);

        // ii. Let testResult be ToBoolean(? Call(callbackfn, T, « kValue, k, O »)).
        var testResult = (0, _to.ToBooleanPartial)(realm, (0, _call.Call)(realm, callbackfn, T, [kValue, new _index.NumberValue(realm, k), O]));

        // iii. If testResult is false, return false.
        if (!testResult) return realm.intrinsics.false;
      }

      // d. Increase k by 1.
      k++;
    }

    // 8. Return true.
    return realm.intrinsics.true;
  });

  // ECMA262 22.2.3.8
  obj.defineNativeMethod("fill", 1, function (context, _ref5) {
    var _ref6 = _slicedToArray(_ref5, 3),
        value = _ref6[0],
        start = _ref6[1],
        end = _ref6[2];

    // 1. Let O be ? ToObject(this value).
    var O = (0, _to.ToObject)(realm, context.throwIfNotConcrete());

    // 2. Perform ? ValidateTypedArray(O).
    (0, _typedarray.ValidateTypedArray)(realm, O);

    // 3. Let len be O.[[ArrayLength]].
    var len = O.$ArrayLength;
    (0, _invariant2.default)(typeof len === "number");

    // 4. Let relativeStart be ? ToInteger(start).
    var relativeStart = (0, _to.ToInteger)(realm, start || realm.intrinsics.undefined);

    // 5. If relativeStart < 0, let k be max((len + relativeStart), 0); else let k be min(relativeStart, len).
    var k = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);

    // 6. If end is undefined, let relativeEnd be len; else let relativeEnd be ? ToInteger(end).
    var relativeEnd = !end || end instanceof _index.UndefinedValue ? len : (0, _to.ToInteger)(realm, end.throwIfNotConcrete());

    // 7. If relativeEnd < 0, let final be max((len + relativeEnd), 0); else let final be min(relativeEnd, len).
    var final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);

    // 8. Repeat, while k < final
    while (k < final) {
      // a. Let Pk be ! ToString(k).
      var Pk = new _index.StringValue(realm, k + "");

      // b. Perform ? Set(O, Pk, value, true).
      _singletons.Properties.Set(realm, O, Pk, value, true);

      // c. Increase k by 1.
      k++;
    }

    // 9. Return O.
    return O;
  });

  // ECMA262 22.2.3.9
  obj.defineNativeMethod("filter", 1, function (context, _ref7) {
    var _ref8 = _slicedToArray(_ref7, 2),
        callbackfn = _ref8[0],
        thisArg = _ref8[1];

    // 1. Let O be the this value.
    var O = context;

    // 2. Perform ? ValidateTypedArray(O).
    (0, _typedarray.ValidateTypedArray)(realm, O);
    (0, _invariant2.default)(O instanceof _index.ObjectValue);

    // 3. Let len be O.[[ArrayLength]].
    var len = O.$ArrayLength;
    (0, _invariant2.default)(typeof len === "number");

    // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.
    if ((0, _is.IsCallable)(realm, callbackfn) === false) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "IsCallable(callbackfn) is false");
    }

    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
    var T = thisArg ? thisArg : realm.intrinsics.undefined;

    // 6. Let kept be a new empty List.
    var kept = [];

    // 7. Let k be 0.
    var k = 0;

    // 8. Let captured be 0.
    var captured = 0;

    // 9. Repeat, while k < len
    while (k < len) {
      // a. Let Pk be ! ToString(k).
      var Pk = (0, _to.ToString)(realm, new _index.NumberValue(realm, k));

      // b. Let kValue be ? Get(O, Pk).
      var kValue = (0, _get.Get)(realm, O, Pk);

      // c. Let selected be ToBoolean(? Call(callbackfn, T, « kValue, k, O »)).
      var selected = (0, _to.ToBooleanPartial)(realm, (0, _call.Call)(realm, callbackfn, T, [kValue, new _index.NumberValue(realm, k), O]));

      // d. If selected is true, then
      if (selected === true) {
        // i. Append kValue to the end of kept.
        kept.push(kValue);

        // ii. Increase captured by 1.
        captured += 1;
      }

      // e. Increase k by 1.
      k += 1;
    }

    // 10. Let A be ? TypedArraySpeciesCreate(O, « captured »).
    var A = (0, _typedarray.TypedArraySpeciesCreate)(realm, O, [new _index.NumberValue(realm, captured)]);

    // 11. Let n be 0.
    var n = 0;

    // 12. For each element e of kept
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = kept[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var e = _step.value;

        // a. Perform ! Set(A, ! ToString(n), e, true).
        _singletons.Properties.Set(realm, A, new _index.StringValue(realm, (0, _to.ToString)(realm, new _index.NumberValue(realm, n))), e, true);

        // b. Increment n by 1.
        n = n + 1;
      }

      // 13. Return A.
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return A;
  });

  // ECMA262 22.2.3.10
  obj.defineNativeMethod("find", 1, function (context, _ref9) {
    var _ref10 = _slicedToArray(_ref9, 2),
        predicate = _ref10[0],
        thisArg = _ref10[1];

    // 1. Let O be ? ToObject(this value).
    var O = (0, _to.ToObject)(realm, context.throwIfNotConcrete());

    // 2. Perform ? ValidateTypedArray(O).
    (0, _typedarray.ValidateTypedArray)(realm, O);

    // 3. Let len be O.[[ArrayLength]].
    var len = O.$ArrayLength;
    (0, _invariant2.default)(typeof len === "number");

    // 4. If IsCallable(predicate) is false, throw a TypeError exception.
    if (!(0, _is.IsCallable)(realm, predicate)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "not a function");
    }

    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
    var T = thisArg || realm.intrinsics.undefined;

    // 6. Let k be 0.
    var k = 0;

    // 7. Repeat, while k < len
    while (k < len) {
      // a. Let Pk be ! ToString(k).
      var Pk = new _index.StringValue(realm, k + "");

      // b. Let kValue be ? Get(O, Pk).
      var kValue = (0, _get.Get)(realm, O, Pk);

      // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).
      var testResult = (0, _to.ToBooleanPartial)(realm, (0, _call.Call)(realm, predicate, T, [kValue, new _index.NumberValue(realm, k), O]));

      // d. If testResult is true, return kValue.
      if (testResult) return kValue;

      // e. Increase k by 1.
      k++;
    }

    // 8. Return undefined.
    return realm.intrinsics.undefined;
  });

  // ECMA262 22.2.3.11
  obj.defineNativeMethod("findIndex", 1, function (context, _ref11) {
    var _ref12 = _slicedToArray(_ref11, 2),
        predicate = _ref12[0],
        thisArg = _ref12[1];

    // 1. Let O be ? ToObject(this value).
    var O = (0, _to.ToObject)(realm, context.throwIfNotConcrete());

    // 2. Perform ? ValidateTypedArray(O).
    (0, _typedarray.ValidateTypedArray)(realm, O);

    // 3. Let len be O.[[ArrayLength]].
    var len = O.$ArrayLength;
    (0, _invariant2.default)(typeof len === "number");

    // 4. If IsCallable(predicate) is false, throw a TypeError exception.
    if ((0, _is.IsCallable)(realm, predicate) === false) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "not a function");
    }

    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
    var T = thisArg ? thisArg : realm.intrinsics.undefined;

    // 6. Let k be 0.
    var k = 0;

    // 7. Repeat, while k < len
    while (k < len) {
      // a. Let Pk be ! ToString(k).
      var Pk = (0, _to.ToString)(realm, new _index.NumberValue(realm, k));

      // b. Let kValue be ? Get(O, Pk).
      var kValue = (0, _get.Get)(realm, O, new _index.StringValue(realm, Pk));

      // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).
      var testResult = (0, _to.ToBooleanPartial)(realm, (0, _call.Call)(realm, predicate, T, [kValue, new _index.NumberValue(realm, k), O]));

      // d. If testResult is true, return k.
      if (testResult === true) return new _index.NumberValue(realm, k);

      // e. Increase k by 1.
      k = k + 1;
    }

    // 8. Return -1.
    return new _index.NumberValue(realm, -1);
  });

  // ECMA262 22.2.3.12
  obj.defineNativeMethod("forEach", 1, function (context, _ref13) {
    var _ref14 = _slicedToArray(_ref13, 2),
        callbackfn = _ref14[0],
        thisArg = _ref14[1];

    // 1. Let O be ? ToObject(this value).
    var O = (0, _to.ToObject)(realm, context.throwIfNotConcrete());

    // 2. Perform ? ValidateTypedArray(O).
    (0, _typedarray.ValidateTypedArray)(realm, O);

    // 3. Let len be O.[[ArrayLength]].
    var len = O.$ArrayLength;
    (0, _invariant2.default)(typeof len === "number");

    // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.
    if (!(0, _is.IsCallable)(realm, callbackfn)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "not a function");
    }

    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
    var T = thisArg || realm.intrinsics.undefined;

    // 6. Let k be 0.
    var k = 0;

    // 7. Repeat, while k < len
    while (k < len) {
      // a. Let Pk be ! ToString(k).
      var Pk = new _index.StringValue(realm, k + "");

      // b. Let kPresent be ? HasProperty(O, Pk).
      var kPresent = (0, _has.HasProperty)(realm, O, Pk);

      // c. If kPresent is true, then
      if (kPresent) {
        // i. Let kValue be ? Get(O, Pk).
        var kValue = (0, _get.Get)(realm, O, Pk);

        // ii. Perform ? Call(callbackfn, T, « kValue, k, O »).
        (0, _call.Call)(realm, callbackfn, T, [kValue, new _index.NumberValue(realm, k), O]);
      }

      // d. Increase k by 1.
      k++;
    }

    // 8. Return undefined.
    return realm.intrinsics.undefined;
  });

  // ECMA262 22.2.3.14
  obj.defineNativeMethod("includes", 1, function (context, _ref15) {
    var _ref16 = _slicedToArray(_ref15, 2),
        searchElement = _ref16[0],
        fromIndex = _ref16[1];

    // 1. Let O be ? ToObject(this value).
    var O = (0, _to.ToObject)(realm, context.throwIfNotConcrete());

    // 2. Perform ? ValidateTypedArray(O).
    (0, _typedarray.ValidateTypedArray)(realm, O);

    // 3. Let len be O.[[ArrayLength]].
    var len = O.$ArrayLength;
    (0, _invariant2.default)(typeof len === "number");

    // 4. If len is 0, return false.
    if (len === 0) return realm.intrinsics.false;

    // 5. Let n be ? ToInteger(fromIndex). (If fromIndex is undefined, this step produces the value 0.)
    var n = (0, _to.ToInteger)(realm, fromIndex || realm.intrinsics.undefined);

    var k = void 0;
    // 6. If n ≥ 0, then
    if (n >= 0) {
      // a. Let k be n.
      k = n;
    } else {
      // 7. Else n < 0,
      // a. Let k be len + n.
      k = len + n;
      // b. If k < 0, let k be 0.
      if (k < 0) k = 0;
    }

    // 8. Repeat, while k < len
    while (k < len) {
      // a. Let elementK be the result of ? Get(O, ! ToString(k)).
      var elementK = (0, _get.Get)(realm, O, (0, _to.ToString)(realm, new _index.NumberValue(realm, k)));

      // b. If SameValueZero(searchElement, elementK) is true, return true.
      if ((0, _abstract.SameValueZeroPartial)(realm, searchElement, elementK) === true) return realm.intrinsics.true;

      // c. Increase k by 1.
      k = k + 1;
    }

    // 9. Return false.
    return realm.intrinsics.false;
  });

  // ECMA262 22.2.3.14
  obj.defineNativeMethod("indexOf", 1, function (context, _ref17) {
    var _ref18 = _slicedToArray(_ref17, 2),
        searchElement = _ref18[0],
        fromIndex = _ref18[1];

    // 1. Let O be ? ToObject(this value).
    var O = (0, _to.ToObject)(realm, context.throwIfNotConcrete());

    // 2. Perform ? ValidateTypedArray(O).
    (0, _typedarray.ValidateTypedArray)(realm, O);

    // 3. Let len be O.[[ArrayLength]].
    var len = O.$ArrayLength;
    (0, _invariant2.default)(typeof len === "number");

    // 4. If len is 0, return -1.
    if (len === 0) return new _index.NumberValue(realm, -1);

    // 5. Let n be ? ToInteger(fromIndex). (If fromIndex is undefined, this step produces the value 0.)
    var n = fromIndex ? (0, _to.ToInteger)(realm, fromIndex) : 0;

    // 6. If n ≥ len, return -1.
    if (n >= len) return new _index.NumberValue(realm, -1);

    // 7. If n ≥ 0, then
    var k = void 0;
    if (n >= 0) {
      // a. If n is -0, let k be +0; else let k be n.
      k = Object.is(n, -0) ? +0 : n;
    } else {
      // 8. Else n < 0,
      // a. Let k be len + n.
      k = len + n;

      // b. If k < 0, let k be 0.
      if (k < 0) k = 0;
    }

    // 9. Repeat, while k < len
    while (k < len) {
      // a. Let kPresent be ? HasProperty(O, ! ToString(k)).
      var kPresent = (0, _has.HasProperty)(realm, O, k + "");

      // b. If kPresent is true, then
      if (kPresent === true) {
        // i. Let elementK be ? Get(O, ! ToString(k)).
        var elementK = (0, _get.Get)(realm, O, k + "");

        // ii. Let same be the result of performing Strict Equality Comparison searchElement === elementK.
        var same = (0, _abstract.StrictEqualityComparisonPartial)(realm, searchElement, elementK);

        // iii. If same is true, return k.
        if (same) return new _index.NumberValue(realm, k);
      }

      // c. Increase k by 1.
      k++;
    }

    // 10. Return -1.
    return new _index.NumberValue(realm, -1);
  });

  // ECMA262 22.2.3.15
  obj.defineNativeMethod("join", 1, function (context, _ref19) {
    var _ref20 = _slicedToArray(_ref19, 1),
        separator = _ref20[0];

    // 1. Let O be ? ToObject(this value).
    var O = (0, _to.ToObject)(realm, context.throwIfNotConcrete());

    // 2. Perform ? ValidateTypedArray(O).
    (0, _typedarray.ValidateTypedArray)(realm, O);

    // 3. Let len be O.[[ArrayLength]].
    var len = O.$ArrayLength;
    (0, _invariant2.default)(typeof len === "number");

    // 4. If separator is undefined, let separator be the single-element String ",".
    if (!separator || separator instanceof _index.UndefinedValue) separator = new _index.StringValue(realm, ",");

    // 5. Let sep be ? ToString(separator).
    var sep = (0, _to.ToStringPartial)(realm, separator);

    // 6. If len is zero, return the empty String.
    if (len === 0) return realm.intrinsics.emptyString;

    // 7. Let element0 be Get(O, "0").
    var element0 = (0, _get.Get)(realm, O, "0");

    // 8. If element0 is undefined or null, let R be the empty String; otherwise, let R be ? ToString(element0).
    var R = void 0;
    if ((0, _has.HasSomeCompatibleType)(element0, _index.UndefinedValue, _index.NullValue)) {
      R = "";
    } else {
      R = (0, _to.ToStringPartial)(realm, element0);
    }

    // 9. Let k be 1.
    var k = 1;

    // 10. Repeat, while k < len
    while (k < len) {
      // a. Let S be the String value produced by concatenating R and sep.
      var S = R + sep;

      // b. Let element be ? Get(O, ! ToString(k)).
      var element = (0, _get.Get)(realm, O, new _index.StringValue(realm, k + ""));

      // c. If element is undefined or null, let next be the empty String; otherwise, let next be ? ToString(element).
      var next = void 0;
      if ((0, _has.HasSomeCompatibleType)(element, _index.UndefinedValue, _index.NullValue)) {
        next = "";
      } else {
        next = (0, _to.ToStringPartial)(realm, element);
      }

      // d. Let R be a String value produced by concatenating S and next.
      R = S + next;

      // e. Increase k by 1.
      k++;
    }

    // 11. Return R.
    return new _index.StringValue(realm, R + "");
  });

  // ECMA262 22.2.3.16
  obj.defineNativeMethod("keys", 0, function (context) {
    // 1. Let O be the this value.
    var O = context;

    // 2. Perform ? ValidateTypedArray(O).
    (0, _typedarray.ValidateTypedArray)(realm, O);
    (0, _invariant2.default)(O instanceof _index.ObjectValue);

    // 3. Return CreateArrayIterator(O, "key").
    return (0, _create.CreateArrayIterator)(realm, O, "key");
  });

  // ECMA262 22.2.3.17
  obj.defineNativeMethod("lastIndexOf", 1, function (context, _ref21) {
    var _ref22 = _slicedToArray(_ref21, 2),
        searchElement = _ref22[0],
        fromIndex = _ref22[1];

    // 1. Let O be ? ToObject(this value).
    var O = (0, _to.ToObject)(realm, context.throwIfNotConcrete());

    // 2. Perform ? ValidateTypedArray(O).
    (0, _typedarray.ValidateTypedArray)(realm, O);

    // 3. Let len be O.[[ArrayLength]].
    var len = O.$ArrayLength;
    (0, _invariant2.default)(typeof len === "number");

    // 4. If len is 0, return -1.
    if (len === 0) return new _index.NumberValue(realm, -1);

    // 5. If argument fromIndex was passed, let n be ? ToInteger(fromIndex); else let n be len-1.
    var n = fromIndex ? (0, _to.ToInteger)(realm, fromIndex) : len - 1;

    // 6. If n ≥ 0, then
    var k = void 0;
    if (n >= 0) {
      // a. If n is -0, let k be +0; else let k be min(n, len - 1).
      k = Object.is(n, -0) ? +0 : Math.min(n, len - 1);
    } else {
      // 7. Else n < 0,
      // a. Let k be len + n.
      k = len + n;
    }

    // 8. Repeat, while k ≥ 0
    while (k >= 0) {
      // a. Let kPresent be ? HasProperty(O, ! ToString(k)).
      var kPresent = (0, _has.HasProperty)(realm, O, new _index.StringValue(realm, k + ""));

      // b. If kPresent is true, then
      if (kPresent) {
        // i. Let elementK be ? Get(O, ! ToString(k)).
        var elementK = (0, _get.Get)(realm, O, new _index.StringValue(realm, k + ""));

        // ii. Let same be the result of performing Strict Equality Comparison searchElement === elementK.
        var same = (0, _abstract.StrictEqualityComparisonPartial)(realm, searchElement, elementK);

        // iii. If same is true, return k.
        if (same) return new _index.NumberValue(realm, k);
      }

      // c. Decrease k by 1.
      k--;
    }

    // 9. Return -1.
    return new _index.NumberValue(realm, -1);
  });

  // ECMA262 22.2.3.18
  obj.defineNativeGetter("length", function (context) {
    // 1. Let O be the this value.
    var O = context.throwIfNotConcrete();

    // 2. If Type(O) is not Object, throw a TypeError exception.
    if (!(O instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(O) is not Object");
    }

    // 3. If O does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.
    if (!("$TypedArrayName" in O)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "O does not have a [[TypedArrayName]] internal slot");
    }

    // 4. Assert: O has [[ViewedArrayBuffer]] and [[ArrayLength]] internal slots.
    (0, _invariant2.default)(O.$ViewedArrayBuffer, "O has a [[ViewedArrayBuffer]] internal slot");

    // 5. Let buffer be O.[[ViewedArrayBuffer]].
    var buffer = O.$ViewedArrayBuffer;
    (0, _invariant2.default)(buffer);

    // 6. If IsDetachedBuffer(buffer) is true, return 0.
    if ((0, _is.IsDetachedBuffer)(realm, buffer) === true) return realm.intrinsics.zero;

    // 7. Let length be O.[[ArrayLength]].
    var length = O.$ArrayLength;
    (0, _invariant2.default)(typeof length === "number");

    // 8. Return length.
    return new _index.NumberValue(realm, length);
  });

  // ECMA262 22.2.3.19
  obj.defineNativeMethod("map", 1, function (context, _ref23) {
    var _ref24 = _slicedToArray(_ref23, 2),
        callbackfn = _ref24[0],
        thisArg = _ref24[1];

    // 1. Let O be the this value.
    var O = context;

    // 2. Perform ? ValidateTypedArray(O).
    (0, _typedarray.ValidateTypedArray)(realm, O);
    (0, _invariant2.default)(O instanceof _index.ObjectValue);

    // 3. Let len be O.[[ArrayLength]].
    var len = O.$ArrayLength;
    (0, _invariant2.default)(typeof len === "number");

    // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.
    if ((0, _is.IsCallable)(realm, callbackfn) === false) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "IsCallable(callbackfn) is false");
    }

    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
    var T = thisArg ? thisArg : realm.intrinsics.undefined;

    // 6. Let A be ? TypedArraySpeciesCreate(O, « len »).
    var A = (0, _typedarray.TypedArraySpeciesCreate)(realm, O, [new _index.NumberValue(realm, len)]);

    // 7. Let k be 0.
    var k = 0;

    // 8. Repeat, while k < len
    while (k < len) {
      // a. Let Pk be ! ToString(k).
      var Pk = (0, _to.ToString)(realm, new _index.NumberValue(realm, k));

      // b. Let kValue be ? Get(O, Pk).
      var kValue = (0, _get.Get)(realm, O, Pk);

      // c. Let mappedValue be ? Call(callbackfn, T, « kValue, k, O »).
      var mappedValue = (0, _call.Call)(realm, callbackfn, T, [kValue, new _index.NumberValue(realm, k), O]);

      // d. Perform ? Set(A, Pk, mappedValue, true).
      _singletons.Properties.Set(realm, A, Pk, mappedValue, true);

      // e. Increase k by 1.
      k = k + 1;
    }

    // 9. Return A.
    return A;
  });

  // ECMA262 22.2.3.20
  obj.defineNativeMethod("reduce", 1, function (context, _ref25) {
    var _ref26 = _slicedToArray(_ref25, 2),
        callbackfn = _ref26[0],
        initialValue = _ref26[1];

    // 1. Let O be ? ToObject(this value).
    var O = (0, _to.ToObject)(realm, context.throwIfNotConcrete());

    // 2. Perform ? ValidateTypedArray(O).
    (0, _typedarray.ValidateTypedArray)(realm, O);

    // 3. Let len be O.[[ArrayLength]].
    var len = O.$ArrayLength;
    (0, _invariant2.default)(typeof len === "number");

    // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.
    if (!(0, _is.IsCallable)(realm, callbackfn)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "not a function");
    }

    // 5. If len is 0 and initialValue is not present, throw a TypeError exception.
    if (len === 0 && !initialValue) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Array.prototype");
    }

    // 6. Let k be 0.
    var k = 0;

    // 7. If initialValue is present, then
    var accumulator = void 0;
    if (initialValue) {
      // a. Set accumulator to initialValue.
      accumulator = initialValue;
    } else {
      // 8. Else initialValue is not present,
      // a. Let kPresent be false.
      var kPresent = false;

      // b. Repeat, while kPresent is false and k < len
      while (kPresent === false && k < len) {
        // i. Let Pk be ! ToString(k).
        var Pk = new _index.StringValue(realm, k + "");

        // ii. Let kPresent be ? HasProperty(O, Pk).
        kPresent = (0, _has.HasProperty)(realm, O, Pk);

        // iv. If kPresent is true, then
        if (kPresent) {
          // 1. Let accumulator be ? Get(O, Pk).
          accumulator = (0, _get.Get)(realm, O, Pk);
        }

        // v. Increase k by 1.
        k++;
      }

      // c. If kPresent is false, throw a TypeError exception.
      if (!kPresent) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "kPresent is false");
      }

      (0, _invariant2.default)(accumulator);
    }

    // 9. Repeat, while k < len
    while (k < len) {
      // a. Let Pk be ! ToString(k).
      var _Pk = new _index.StringValue(realm, k + "");

      // b. Let kPresent be ? HasProperty(O, Pk).
      var _kPresent = (0, _has.HasProperty)(realm, O, _Pk);

      // c. If kPresent is true, then
      if (_kPresent) {
        // i. Let kValue be ? Get(O, Pk).
        var kValue = (0, _get.Get)(realm, O, _Pk);

        // ii. Let accumulator be ? Call(callbackfn, undefined, « accumulator, kValue, k, O »).
        accumulator = (0, _call.Call)(realm, callbackfn, realm.intrinsics.undefined, [accumulator, kValue, new _index.NumberValue(realm, k), O]);
      }

      // d. Increase k by 1.
      k++;
    }

    // 10. Return accumulator.
    return accumulator;
  });

  // ECMA262 22.2.3.21
  obj.defineNativeMethod("reduceRight", 1, function (context, _ref27) {
    var _ref28 = _slicedToArray(_ref27, 2),
        callbackfn = _ref28[0],
        initialValue = _ref28[1];

    // 1. Let O be ? ToObject(this value).
    var O = (0, _to.ToObject)(realm, context.throwIfNotConcrete());

    // 2. Perform ? ValidateTypedArray(O).
    (0, _typedarray.ValidateTypedArray)(realm, O);

    // 3. Let len be O.[[ArrayLength]].
    var len = O.$ArrayLength;
    (0, _invariant2.default)(typeof len === "number");

    // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.
    if (!(0, _is.IsCallable)(realm, callbackfn)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "not a function");
    }

    // 5. If len is 0 and initialValue is not present, throw a TypeError exception.
    if (len === 0 && !initialValue) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Array.prototype");
    }

    // 6. Let k be len-1.
    var k = len - 1;

    // 7. If initialValue is present, then
    var accumulator = void 0;
    if (initialValue) {
      // 1. Set accumulator to initialValue.
      accumulator = initialValue;
    } else {
      // 8. Else initialValue is not present,
      // a. Let kPresent be false.
      var kPresent = false;

      // b. Repeat, while kPresent is false and k ≥ 0
      while (!kPresent && k >= 0) {
        // i. Let Pk be ! ToString(k).
        var Pk = new _index.StringValue(realm, k + "");

        // ii. Let kPresent be ? HasProperty(O, Pk).
        kPresent = (0, _has.HasProperty)(realm, O, Pk);

        // iii. If kPresent is true, then
        if (kPresent) {
          // 1. Let accumulator be ? Get(O, Pk).
          accumulator = (0, _get.Get)(realm, O, Pk);
        }

        // iv. Decrease k by 1.
        k--;
      }

      // c. If kPresent is false, throw a TypeError exception.
      if (!kPresent || !accumulator) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Array.prototype");
      }
    }

    // 9. Repeat, while k ≥ 0
    while (k >= 0) {
      // a. Let Pk be ! ToString(k).
      var _Pk2 = new _index.StringValue(realm, k + "");

      // b. Let kPresent be ? HasProperty(O, Pk).
      var _kPresent2 = (0, _has.HasProperty)(realm, O, _Pk2);

      // c. If kPresent is true, then
      if (_kPresent2) {
        // i. Let kValue be ? Get(O, Pk).
        var kValue = (0, _get.Get)(realm, O, _Pk2);

        // ii. Let accumulator be ? Call(callbackfn, undefined, « accumulator, kValue, k, O »).
        accumulator = (0, _call.Call)(realm, callbackfn, realm.intrinsics.undefined, [accumulator, kValue, new _index.NumberValue(realm, k), O]);
      }

      // d. Decrease k by 1.
      k--;
    }

    // 10. Return accumulator.
    return accumulator;
  });

  // ECMA262 22.2.3.21
  obj.defineNativeMethod("reverse", 0, function (context) {
    // 1. Let O be ? ToObject(this value).
    var O = (0, _to.ToObject)(realm, context.throwIfNotConcrete());

    // 2. Perform ? ValidateTypedArray(O).
    (0, _typedarray.ValidateTypedArray)(realm, O);

    // 3. Let len be O.[[ArrayLength]].
    var len = O.$ArrayLength;
    (0, _invariant2.default)(typeof len === "number");

    // 4. Let middle be floor(len/2).
    var middle = Math.floor(len / 2);

    // 5. Let lower be 0.
    var lower = 0;

    // 6. Repeat, while lower ≠ middle
    while (lower !== middle) {
      // a. Let upper be len - lower - 1.
      var upper = len - lower - 1;

      // b. Let upperP be ! ToString(upper).
      var upperP = new _index.StringValue(realm, upper + "");

      // c. Let lowerP be ! ToString(lower).
      var lowerP = new _index.StringValue(realm, lower + "");

      // d. Let lowerExists be ? HasProperty(O, lowerP).
      var lowerExists = (0, _has.HasProperty)(realm, O, lowerP);

      // e. If lowerExists is true, then
      var lowerValue = void 0;
      if (lowerExists) {
        // i. Let lowerValue be ? Get(O, lowerP).
        lowerValue = (0, _get.Get)(realm, O, lowerP);
      }

      // f. Let upperExists be ? HasProperty(O, upperP).
      var upperExists = (0, _has.HasProperty)(realm, O, upperP);

      // g. If upperExists is true, then
      var upperValue = void 0;
      if (upperExists) {
        // i. Let upperValue be ? Get(O, upperP).
        upperValue = (0, _get.Get)(realm, O, upperP);
      }

      // h. If lowerExists is true and upperExists is true, then
      if (lowerExists && upperExists) {
        (0, _invariant2.default)(lowerValue, "expected lower value to exist");
        (0, _invariant2.default)(upperValue, "expected upper value to exist");

        // i. Perform ? Set(O, lowerP, upperValue, true).
        _singletons.Properties.Set(realm, O, lowerP, upperValue, true);

        // ii. Perform ? Set(O, upperP, lowerValue, true).
        _singletons.Properties.Set(realm, O, upperP, lowerValue, true);
      } else if (!lowerExists && upperExists) {
        // i. Else if lowerExists is false and upperExists is true, then
        (0, _invariant2.default)(upperValue, "expected upper value to exist");

        // i. Perform ? Set(O, lowerP, upperValue, true).
        _singletons.Properties.Set(realm, O, lowerP, upperValue, true);

        // ii. Perform ? DeletePropertyOrThrow(O, upperP).
        _singletons.Properties.DeletePropertyOrThrow(realm, O, upperP);
      } else if (lowerExists && !upperExists) {
        // j. Else if lowerExists is true and upperExists is false, then
        (0, _invariant2.default)(lowerValue, "expected lower value to exist");

        // i. Perform ? DeletePropertyOrThrow(O, lowerP).
        _singletons.Properties.DeletePropertyOrThrow(realm, O, lowerP);

        // ii. Perform ? Set(O, upperP, lowerValue, true).
        _singletons.Properties.Set(realm, O, upperP, lowerValue, true);
      } else {}
      // k. Else both lowerExists and upperExists are false,
      // i. No action is required.


      // l. Increase lower by 1.
      lower++;
    }

    // 7. Return O.
    return O;
  });

  // ECMA262 22.2.3.23
  obj.defineNativeMethod("set", 1, function (context, _ref29) {
    var _ref30 = _slicedToArray(_ref29, 2),
        overloaded = _ref30[0],
        offset = _ref30[1];

    if (!overloaded.$TypedArrayName) {
      var array = overloaded;

      // 1. Assert: array is any ECMAScript language value other than an Object with a [[TypedArrayName]] internal slot. If it is such an Object, the definition in 22.2.3.23.2 applies.
      (0, _invariant2.default)(!(overloaded instanceof _index.ObjectValue && overloaded.$TypedArrayName));

      // 2. Let target be the this value.
      var target = context.throwIfNotConcrete();

      // 3. If Type(target) is not Object, throw a TypeError exception.
      if (!(target instanceof _index.ObjectValue)) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(target) is not Object");
      }

      // 4. If target does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.
      if (typeof target.$TypedArrayName !== "string") {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "target does not have a [[TypedArrayName]] internal slot");
      }

      // 5. Assert: target has a [[ViewedArrayBuffer]] internal slot.
      (0, _invariant2.default)(target.$ViewedArrayBuffer, "target has a [[ViewedArrayBuffer]] internal slot");

      // 6. Let targetOffset be ? ToInteger(offset).
      var targetOffset = (0, _to.ToInteger)(realm, offset || realm.intrinsics.undefined);

      // 7. If targetOffset < 0, throw a RangeError exception.
      if (targetOffset < 0) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, "targetOffset < 0");
      }

      // 8. Let targetBuffer be target.[[ViewedArrayBuffer]].
      var targetBuffer = target.$ViewedArrayBuffer;
      (0, _invariant2.default)(targetBuffer instanceof _index.ObjectValue);

      // 9. If IsDetachedBuffer(targetBuffer) is true, throw a TypeError exception.
      if ((0, _is.IsDetachedBuffer)(realm, targetBuffer) === true) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "IsDetachedBuffer(targetBuffer) is true");
      }

      // 10. Let targetLength be target.[[ArrayLength]].
      var targetLength = target.$ArrayLength;
      (0, _invariant2.default)(typeof targetLength === "number");

      // 11. Let targetName be the String value of target.[[TypedArrayName]].
      var targetName = target.$TypedArrayName;
      (0, _invariant2.default)(typeof targetName === "string");

      // 12. Let targetElementSize be the Number value of the Element Size value specified in Table 50 for targetName.
      var targetElementSize = _typedarray.ArrayElementSize[targetName];

      // 13. Let targetType be the String value of the Element Type value in Table 50 for targetName.
      var targetType = _typedarray.ArrayElementType[targetName];

      // 14. Let targetByteOffset be target.[[ByteOffset]].
      var targetByteOffset = target.$ByteOffset;
      (0, _invariant2.default)(typeof targetByteOffset === "number");

      // 15. Let src be ? ToObject(array).
      var src = (0, _to.ToObjectPartial)(realm, array);

      // 16. Let srcLength be ? ToLength(? Get(src, "length")).
      var srcLength = (0, _to.ToLength)(realm, (0, _get.Get)(realm, src, "length"));

      // 17. If srcLength + targetOffset > targetLength, throw a RangeError exception.
      if (srcLength + targetOffset > targetLength) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, "srcLength + targetOffset > targetLength");
      }

      // 18. Let targetByteIndex be targetOffset × targetElementSize + targetByteOffset.
      var targetByteIndex = targetOffset * targetElementSize + targetByteOffset;

      // 19. Let k be 0.
      var k = 0;

      // 20. Let limit be targetByteIndex + targetElementSize × srcLength.
      var limit = targetByteIndex + targetElementSize * srcLength;

      // 21. Repeat, while targetByteIndex < limit
      while (targetByteIndex < limit) {
        // a. Let Pk be ! ToString(k).
        var Pk = (0, _to.ToString)(realm, new _index.NumberValue(realm, k));

        // b. Let kNumber be ? ToNumber(? Get(src, Pk)).
        var kNumber = (0, _to.ToNumber)(realm, (0, _get.Get)(realm, src, Pk));

        // c. If IsDetachedBuffer(targetBuffer) is true, throw a TypeError exception.
        if ((0, _is.IsDetachedBuffer)(realm, targetBuffer) === true) {
          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "IsDetachedBuffer(targetBuffer) is true");
        }

        // d. Perform SetValueInBuffer(targetBuffer, targetByteIndex, targetType, kNumber).
        (0, _arraybuffer.SetValueInBuffer)(realm, targetBuffer, targetByteIndex, targetType, kNumber);

        // e. Set k to k + 1.
        k = k + 1;

        // f. Set targetByteIndex to targetByteIndex + targetElementSize.
        targetByteIndex = targetByteIndex + targetElementSize;
      }

      // 22. Return undefined.
      return realm.intrinsics.undefined;
    } else {
      var typedArray = overloaded;

      // 1. Assert: typedArray has a [[TypedArrayName]] internal slot. If it does not, the definition in 22.2.3.23.1 applies.
      (0, _invariant2.default)(typedArray instanceof _index.ObjectValue && typedArray.$TypedArrayName);

      // 2. Let target be the this value.
      var _target = context.throwIfNotConcrete();

      // 3. If Type(target) is not Object, throw a TypeError exception.
      if (!(_target instanceof _index.ObjectValue)) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(target) is not Object");
      }

      // 4. If target does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.
      if (typeof _target.$TypedArrayName !== "string") {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "target does not have a [[TypedArrayName]] internal slot");
      }

      // 5. Assert: target has a [[ViewedArrayBuffer]] internal slot.
      (0, _invariant2.default)(_target.$ViewedArrayBuffer);

      // 6. Let targetOffset be ? ToInteger(offset).
      var _targetOffset = (0, _to.ToInteger)(realm, offset || realm.intrinsics.undefined);

      // 7. If targetOffset < 0, throw a RangeError exception.
      if (_targetOffset < 0) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, "targetOffset < 0");
      }

      // 8. Let targetBuffer be target.[[ViewedArrayBuffer]].
      var _targetBuffer = _target.$ViewedArrayBuffer;
      (0, _invariant2.default)(_targetBuffer instanceof _index.ObjectValue);

      // 9. If IsDetachedBuffer(targetBuffer) is true, throw a TypeError exception.
      if ((0, _is.IsDetachedBuffer)(realm, _targetBuffer) === true) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "IsDetachedBuffer(targetBuffer) is true");
      }

      // 10. Let targetLength be target.[[ArrayLength]].
      var _targetLength = _target.$ArrayLength;
      (0, _invariant2.default)(typeof _targetLength === "number");

      // 11. Let srcBuffer be typedArray.[[ViewedArrayBuffer]].
      var srcBuffer = typedArray.$ViewedArrayBuffer;
      (0, _invariant2.default)(srcBuffer);

      // 12. If IsDetachedBuffer(srcBuffer) is true, throw a TypeError exception.
      if ((0, _is.IsDetachedBuffer)(realm, srcBuffer) === true) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "IsDetachedBuffer(srcBuffer) is true");
      }

      // 13. Let targetName be the String value of target.[[TypedArrayName]].
      var _targetName = _target.$TypedArrayName;
      (0, _invariant2.default)(typeof _targetName === "string");

      // 14. Let targetType be the String value of the Element Type value in Table 50 for targetName.
      var _targetType = _typedarray.ArrayElementType[_targetName];

      // 15. Let targetElementSize be the Number value of the Element Size value specified in Table 50 for targetName.
      var _targetElementSize = _typedarray.ArrayElementSize[_targetName];

      // 16. Let targetByteOffset be target.[[ByteOffset]].
      var _targetByteOffset = _target.$ByteOffset;
      (0, _invariant2.default)(typeof _targetByteOffset === "number");

      // 17. Let srcName be the String value of typedArray.[[TypedArrayName]].
      var srcName = typedArray.$TypedArrayName;
      (0, _invariant2.default)(typeof srcName === "string");

      // 18. Let srcType be the String value of the Element Type value in Table 50 for srcName.
      var srcType = _typedarray.ArrayElementType[srcName];

      // 19. Let srcElementSize be the Number value of the Element Size value specified in Table 50 for srcName.
      var srcElementSize = _typedarray.ArrayElementSize[srcName];

      // 20. Let srcLength be typedArray.[[ArrayLength]].
      var _srcLength = typedArray.$ArrayLength;
      (0, _invariant2.default)(typeof _srcLength === "number");

      // 21. Let srcByteOffset be typedArray.[[ByteOffset]].
      var srcByteOffset = typedArray.$ByteOffset;
      (0, _invariant2.default)(typeof srcByteOffset === "number");

      // 22. If srcLength + targetOffset > targetLength, throw a RangeError exception.
      if (_srcLength + _targetOffset > _targetLength) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, "srcLength + targetOffset > targetLength");
      }

      var srcByteIndex = void 0;
      // 23. If SameValue(srcBuffer, targetBuffer) is true, then
      if ((0, _abstract.SameValue)(realm, srcBuffer, _targetBuffer) === true) {
        // a. Let srcBuffer be ? CloneArrayBuffer(targetBuffer, srcByteOffset, %ArrayBuffer%).
        srcBuffer = (0, _arraybuffer.CloneArrayBuffer)(realm, _targetBuffer, srcByteOffset, realm.intrinsics.ArrayBuffer);

        // b. NOTE: %ArrayBuffer% is used to clone srcBuffer because is it known to not have any observable side-effects.

        // c. Let srcByteIndex be 0.
        srcByteIndex = 0;
      } else {
        // 24. Else, let srcByteIndex be srcByteOffset.
        srcByteIndex = srcByteOffset;
      }

      // 25. Let targetByteIndex be targetOffset × targetElementSize + targetByteOffset.
      var _targetByteIndex = _targetOffset * _targetElementSize + _targetByteOffset;

      // 26. Let limit be targetByteIndex + targetElementSize × srcLength.
      var _limit = _targetByteIndex + _targetElementSize * _srcLength;

      // 27. If SameValue(srcType, targetType) is true, then
      if (srcType === _targetType) {
        // a. NOTE: If srcType and targetType are the same, the transfer must be performed in a manner that preserves the bit-level encoding of the source data.

        // b. Repeat, while targetByteIndex < limit
        while (_targetByteIndex < _limit) {
          // i. Let value be GetValueFromBuffer(srcBuffer, srcByteIndex, "Uint8").
          var value = (0, _arraybuffer.GetValueFromBuffer)(realm, srcBuffer, srcByteIndex, "Uint8");

          // ii. Perform SetValueInBuffer(targetBuffer, targetByteIndex, "Uint8", value).
          (0, _arraybuffer.SetValueInBuffer)(realm, _targetBuffer, _targetByteIndex, "Uint8", value.value);

          // iii. Set srcByteIndex to srcByteIndex + 1.
          srcByteIndex += 1;

          // iv. Set targetByteIndex to targetByteIndex + 1.
          _targetByteIndex += 1;
        }
      } else {
        // 28. Else,
        // a. Repeat, while targetByteIndex < limit
        while (_targetByteIndex < _limit) {
          // i. Let value be GetValueFromBuffer(srcBuffer, srcByteIndex, srcType).
          var _value = (0, _arraybuffer.GetValueFromBuffer)(realm, srcBuffer, srcByteIndex, srcType);

          // ii. Perform SetValueInBuffer(targetBuffer, targetByteIndex, targetType, value).
          (0, _arraybuffer.SetValueInBuffer)(realm, _targetBuffer, _targetByteIndex, _targetType, _value.value);

          // iii. Set srcByteIndex to srcByteIndex + srcElementSize.
          srcByteIndex = srcByteIndex + srcElementSize;

          // iv. Set targetByteIndex to targetByteIndex + targetElementSize.
          _targetByteIndex = _targetByteIndex + _targetElementSize;
        }
      }

      // 29. Return undefined.
      return realm.intrinsics.undefined;
    }
  });

  // ECMA262 22.2.3.24
  obj.defineNativeMethod("slice", 2, function (context, _ref31) {
    var _ref32 = _slicedToArray(_ref31, 2),
        start = _ref32[0],
        end = _ref32[1];

    // 1. Let O be the this value.
    var O = context;

    // 2. Perform ? ValidateTypedArray(O).
    (0, _typedarray.ValidateTypedArray)(realm, O);
    (0, _invariant2.default)(O instanceof _index.ObjectValue);

    // 3. Let len be O.[[ArrayLength]].
    var len = O.$ArrayLength;
    (0, _invariant2.default)(typeof len === "number");

    // 4. Let relativeStart be ? ToInteger(start).
    var relativeStart = (0, _to.ToInteger)(realm, start);

    // 5. If relativeStart < 0, let k be max((len + relativeStart), 0); else let k be min(relativeStart, len).
    var k = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);

    // 6. If end is undefined, let relativeEnd be len; else let relativeEnd be ? ToInteger(end).
    var relativeEnd = !end || end instanceof _index.UndefinedValue ? len : (0, _to.ToInteger)(realm, end.throwIfNotConcrete());

    // 7. If relativeEnd < 0, let final be max((len + relativeEnd), 0); else let final be min(relativeEnd, len).
    var final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);

    // 8. Let count be max(final - k, 0).
    var count = Math.max(final - k, 0);

    // 9. Let A be ? TypedArraySpeciesCreate(O, « count »).
    var A = (0, _typedarray.TypedArraySpeciesCreate)(realm, O, [new _index.NumberValue(realm, count)]);

    // 10. Let srcName be the String value of O.[[TypedArrayName]].
    var srcName = O.$TypedArrayName;
    (0, _invariant2.default)(typeof srcName === "string");

    // 11. Let srcType be the String value of the Element Type value in Table 50 for srcName.
    var srcType = _typedarray.ArrayElementType[srcName];

    // 12. Let targetName be the String value of A.[[TypedArrayName]].
    var targetName = A.$TypedArrayName;
    (0, _invariant2.default)(typeof targetName === "string");

    // 13. Let targetType be the String value of the Element Type value in Table 50 for targetName.
    var targetType = _typedarray.ArrayElementType[targetName];

    // 14. If SameValue(srcType, targetType) is false, then
    if (srcType !== targetType) {
      // a. Let n be 0.
      var n = 0;

      // b. Repeat, while k < final
      while (k < final) {
        // i. Let Pk be ! ToString(k).
        var Pk = (0, _to.ToString)(realm, new _index.NumberValue(realm, k));

        // ii. Let kValue be ? Get(O, Pk).
        var kValue = (0, _get.Get)(realm, O, Pk);

        // iii. Perform ! Set(A, ! ToString(n), kValue).
        _singletons.Properties.Set(realm, A, (0, _to.ToString)(realm, new _index.NumberValue(realm, n)), kValue, true);

        // iv. Increase k by 1.
        k += 1;

        // v. Increase n by 1.
        n += 1;
      }
    } else if (count > 0) {
      // 15. Else if count > 0, then
      // a. Let srcBuffer be O.[[ViewedArrayBuffer]].
      var srcBuffer = O.$ViewedArrayBuffer;
      (0, _invariant2.default)(srcBuffer);

      // b. If IsDetachedBuffer(srcBuffer) is true, throw a TypeError exception.
      if ((0, _is.IsDetachedBuffer)(realm, srcBuffer) === true) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "IsDetachedBuffer(srcBuffer) is true");
      }

      // c. Let targetBuffer be A.[[ViewedArrayBuffer]].
      var targetBuffer = A.$ViewedArrayBuffer;
      (0, _invariant2.default)(targetBuffer instanceof _index.ObjectValue);

      // d. Let elementSize be the Number value of the Element Size value specified in Table 50 for srcType.
      var elementSize = _types.ElementSize[srcType];

      // e. NOTE: If srcType and targetType are the same, the transfer must be performed in a manner that preserves the bit-level encoding of the source data.

      // f. Let srcByteOffset be O.[[ByteOffset]].
      var srcByteOffset = O.$ByteOffset;
      (0, _invariant2.default)(typeof srcByteOffset === "number");

      // g. Let targetByteIndex be A.[[ByteOffset]].
      var targetByteIndex = A.$ByteOffset;
      (0, _invariant2.default)(typeof targetByteIndex === "number");

      // h. Let srcByteIndex be (k × elementSize) + srcByteOffset.
      var srcByteIndex = k * elementSize + srcByteOffset;

      // i. Let limit be targetByteIndex + count × elementSize.
      var limit = targetByteIndex + count * elementSize;

      // j. Repeat, while targetByteIndex < limit
      while (targetByteIndex < limit) {
        // i. Let value be GetValueFromBuffer(srcBuffer, srcByteIndex, "Uint8").
        var value = (0, _arraybuffer.GetValueFromBuffer)(realm, srcBuffer, srcByteIndex, "Uint8");

        // ii. Perform SetValueInBuffer(targetBuffer, targetByteIndex, "Uint8", value).
        (0, _arraybuffer.SetValueInBuffer)(realm, targetBuffer, targetByteIndex, "Uint8", value.value);

        // iii. Increase srcByteIndex by 1.
        srcByteIndex += 1;

        // iv. Increase targetByteIndex by 1.
        targetByteIndex += 1;
      }
    }

    // 16. Return A.
    return A;
  });

  // ECMA262 22.2.3.25
  obj.defineNativeMethod("some", 1, function (context, _ref33) {
    var _ref34 = _slicedToArray(_ref33, 2),
        callbackfn = _ref34[0],
        thisArg = _ref34[1];

    // 1. Let O be ? ToObject(this value).
    var O = (0, _to.ToObject)(realm, context.throwIfNotConcrete());

    // 2. Perform ? ValidateTypedArray(O).
    (0, _typedarray.ValidateTypedArray)(realm, O);

    // 3. Let len be O.[[ArrayLength]].
    var len = O.$ArrayLength;
    (0, _invariant2.default)(typeof len === "number");

    // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.
    if (!(0, _is.IsCallable)(realm, callbackfn)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "callback passed to Array.prototype.some isn't callable");
    }

    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
    var T = thisArg || realm.intrinsics.undefined;

    // 6. Let k be 0.
    var k = 0;

    // 7. Repeat, while k < len
    while (k < len) {
      // a. Let Pk be ! ToString(k).
      var Pk = new _index.StringValue(realm, k + "");

      // b. Let kPresent be ? HasProperty(O, Pk).
      var kPresent = (0, _has.HasProperty)(realm, O, Pk);

      // c. If kPresent is true, then
      if (kPresent) {
        // i. Let kValue be ? Get(O, Pk).
        var kValue = (0, _get.Get)(realm, O, Pk);

        // ii. Let testResult be ToBoolean(? Call(callbackfn, T, « kValue, k, O »)).
        var testResult = (0, _to.ToBooleanPartial)(realm, (0, _call.Call)(realm, callbackfn, T, [kValue, new _index.NumberValue(realm, k), O]));

        // iii. If testResult is true, return true.
        if (testResult) return realm.intrinsics.true;
      }

      // d. Increase k by 1.
      k++;
    }

    // 8. Return false.
    return realm.intrinsics.false;
  });

  // ECMA262 22.2.3.26
  obj.defineNativeMethod("sort", 1, function (context, _ref35) {
    var _ref36 = _slicedToArray(_ref35, 1),
        comparefn = _ref36[0];

    // 1. Let obj be the this value.
    var O = (0, _to.ToObject)(realm, context.throwIfNotConcrete());

    // 2. Let buffer be ? ValidateTypedArray(obj).
    var buffer = (0, _typedarray.ValidateTypedArray)(realm, O);

    // 3. Let len be the value of obj's [[ArrayLength]] internal slot.
    var len = O.$ArrayLength;
    (0, _invariant2.default)(typeof len === "number");

    // 22.2.3.26 Runtime Semantics: SortCompare( x, y )#
    var SortCompare = function SortCompare(x, y) {
      // 1. Assert: Both Type(x) and Type(y) is Number.
      (0, _invariant2.default)(x instanceof _index.NumberValue);
      (0, _invariant2.default)(y instanceof _index.NumberValue);

      // 2. If the argument comparefn is not undefined, then
      if (!comparefn.mightBeUndefined()) {
        // a. Let v be ? Call(comparefn, undefined, « x, y »).
        var v = (0, _call.Call)(realm, comparefn, realm.intrinsics.undefined, [x, y]);

        // b. If IsDetachedBuffer(buffer) is true, throw a TypeError exception.
        if ((0, _is.IsDetachedBuffer)(realm, buffer) === true) throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "array buffer has been detached");

        // c. If v is NaN, return +0.
        if (v instanceof _index.NumberValue && isNaN(v.value)) return realm.intrinsics.zero;

        // d. Return v.
        return v;
      }
      comparefn.throwIfNotConcrete();

      // If x and y are both NaN, return +0.
      // If x is NaN, return 1.
      if (isNaN(x.value)) {
        if (isNaN(y.value)) return realm.intrinsics.zero;
        return new _index.NumberValue(realm, 1);
      }

      // If y is NaN, return -1.
      if (isNaN(y.value)) return new _index.NumberValue(realm, -1);

      // If x < y, return -1.
      if (x.value < y.value) return new _index.NumberValue(realm, -1);

      // If x > y, return 1.
      if (x.value > y.value) return new _index.NumberValue(realm, +1);

      // If x is -0 and y is +0, return -1.
      if (Object.is(x.value, -0) && Object.is(y.value, +0)) return new _index.NumberValue(realm, -1);

      // If x is +0 and y is -0, return 1.
      if (Object.is(x.value, +0) && Object.is(y.value, -0)) return new _index.NumberValue(realm, 1);

      // Return +0.
      return realm.intrinsics.zero;
    };

    //1. Perform an implementation-dependent sequence of calls to the [[Get]] and [[Set]] internal methods of obj, to the DeletePropertyOrThrow and HasOwnProperty abstract operation with obj as the first argument, and to SortCompare (described below), such that:
    //   The property key argument for each call to [[Get]], [[Set]], HasOwnProperty, or DeletePropertyOrThrow is the string representation of a nonnegative integer less than len.

    // We leverage the underlying implementation sort by copying the element in a temp. array, sorting it, and
    // transfering back the value inside the our array.

    // We need to adapt the comparefn function to match the expected types
    var comparefn_ = function comparefn_(x, y) {
      (0, _invariant2.default)(x instanceof _index.NumberValue, "Unexpected type");
      (0, _invariant2.default)(y instanceof _index.NumberValue, "Unexpected type");

      var result_ = SortCompare(x, y);
      var numb = (0, _to.ToNumber)(realm, result_);
      return numb;
    };

    var arr = [];
    for (var j = 0; j < len; j++) {
      var val = (0, _typedarray.IntegerIndexedElementGet)(realm, O, j);
      arr[j] = val;
    }

    arr.sort(comparefn_);

    //Apply the permutation back to the original array.
    for (var _j = 0; _j < len; _j++) {
      (0, _typedarray.IntegerIndexedElementSet)(realm, O, _j, arr[_j]);
    }

    // 2. Return obj;
    return context;
  });

  // ECMA262 22.2.3.27
  obj.defineNativeMethod("subarray", 2, function (context, _ref37) {
    var _ref38 = _slicedToArray(_ref37, 2),
        begin = _ref38[0],
        end = _ref38[1];

    // 1. Let O be the this value.
    var O = context.throwIfNotConcrete();

    // 2. If Type(O) is not Object, throw a TypeError exception.
    if (!(O instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(O) is not Object");
    }

    // 3. If O does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.
    if (!("$TypedArrayName" in O)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "O does not have a [[TypedArrayName]] internal slot");
    }

    // 4. Assert: O has a [[ViewedArrayBuffer]] internal slot.
    (0, _invariant2.default)(O.$ViewedArrayBuffer, "O has a [[ViewedArrayBuffer]] internal slot");

    // 5. Let buffer be O.[[ViewedArrayBuffer]].
    var buffer = O.$ViewedArrayBuffer;
    (0, _invariant2.default)(buffer);

    // 6. Let srcLength be O.[[ArrayLength]].
    var srcLength = O.$ArrayLength;
    (0, _invariant2.default)(typeof srcLength === "number");

    // 7. Let relativeBegin be ? ToInteger(begin).
    var relativeBegin = (0, _to.ToInteger)(realm, begin);

    // 8. If relativeBegin < 0, let beginIndex be max((srcLength + relativeBegin), 0); else let beginIndex be min(relativeBegin, srcLength).
    var beginIndex = relativeBegin < 0 ? Math.max(srcLength + relativeBegin, 0) : Math.min(relativeBegin, srcLength);

    // 9. If end is undefined, let relativeEnd be srcLength; else, let relativeEnd be ? ToInteger(end).
    var relativeEnd = !end || end instanceof _index.UndefinedValue ? srcLength : (0, _to.ToInteger)(realm, end.throwIfNotConcrete());

    // 10. If relativeEnd < 0, let endIndex be max((srcLength + relativeEnd), 0); else let endIndex be min(relativeEnd, srcLength).
    var endIndex = relativeEnd < 0 ? Math.max(srcLength + relativeEnd, 0) : Math.min(relativeEnd, srcLength);

    // 11. Let newLength be max(endIndex - beginIndex, 0).
    var newLength = Math.max(endIndex - beginIndex, 0);

    // 12. Let constructorName be the String value of O.[[TypedArrayName]].
    var constructorName = O.$TypedArrayName;
    (0, _invariant2.default)(typeof constructorName === "string");

    // 13. Let elementSize be the Number value of the Element Size value specified in Table 50 for constructorName.
    var elementSize = _typedarray.ArrayElementSize[constructorName];

    // 14. Let srcByteOffset be O.[[ByteOffset]].
    var srcByteOffset = O.$ByteOffset;
    (0, _invariant2.default)(typeof srcByteOffset === "number");

    // 15. Let beginByteOffset be srcByteOffset + beginIndex × elementSize.
    var beginByteOffset = srcByteOffset + beginIndex * elementSize;

    // 16. Let argumentsList be « buffer, beginByteOffset, newLength ».
    var argumentsList = [buffer, new _index.NumberValue(realm, beginByteOffset), new _index.NumberValue(realm, newLength)];

    // 17. Return ? TypedArraySpeciesCreate(O, argumentsList).
    return (0, _typedarray.TypedArraySpeciesCreate)(realm, O, argumentsList);
  });

  // ECMA262 22.2.3.28
  obj.defineNativeMethod("toLocaleString", 0, function (context) {
    // 1. Let array be ? ToObject(this value).
    var array = (0, _to.ToObject)(realm, context.throwIfNotConcrete());

    // 2. Perform ? ValidateTypedArray(array).
    (0, _typedarray.ValidateTypedArray)(realm, array);

    // 3. Let len be array.[[ArrayLength]].
    var len = array.$ArrayLength;
    (0, _invariant2.default)(typeof len === "number");

    // 4. Let separator be the String value for the list-separator String appropriate for the host environment's current locale (this is derived in an implementation-defined way).
    var separator = ",";

    // 5. If len is zero, return the empty String.
    if (len === 0) return realm.intrinsics.emptyString;

    // 6. Let firstElement be ? Get(array, "0").
    var firstElement = (0, _get.Get)(realm, array, "0");

    // 7. If firstElement is undefined or null, then
    var R = void 0;
    if ((0, _has.HasSomeCompatibleType)(firstElement, _index.UndefinedValue, _index.NullValue)) {
      // a. Let R be the empty String.
      R = "";
    } else {
      // 8. Else,
      // a. Let R be ? ToString(? Invoke(firstElement, "toLocaleString")).
      R = (0, _to.ToStringPartial)(realm, (0, _call.Invoke)(realm, firstElement, "toLocaleString"));
    }

    // 9. Let k be 1.
    var k = 1;

    // 10. Repeat, while k < len
    while (k < len) {
      // a. Let S be a String value produced by concatenating R and separator.
      var S = R + separator;

      // b. Let nextElement be ? Get(array, ! ToString(k)).
      var nextElement = (0, _get.Get)(realm, array, new _index.StringValue(realm, k + ""));

      // c. If nextElement is undefined or null, then
      if ((0, _has.HasSomeCompatibleType)(nextElement, _index.UndefinedValue, _index.NullValue)) {
        // i. Let R be the empty String.
        R = "";
      } else {
        // d. Else,
        // i. Let R be ? ToString(? Invoke(nextElement, "toLocaleString")).
        R = (0, _to.ToStringPartial)(realm, (0, _call.Invoke)(realm, nextElement, "toLocaleString"));
      }

      // e. Let R be a String value produced by concatenating S and R.
      R = S + R;

      // f. Increase k by 1.
      k++;
    }

    // 11. Return R.
    return new _index.StringValue(realm, R);
  });

  // ECMA262 22.2.3.29
  obj.defineNativeProperty("toString", realm.intrinsics.ArrayProto_toString);

  // ECMA262 22.2.3.30
  obj.defineNativeProperty("values", realm.intrinsics.TypedArrayProto_values);

  // ECMA262 22.2.3.31
  obj.defineNativeProperty(realm.intrinsics.SymbolIterator, realm.intrinsics.TypedArrayProto_values);

  // ECMA262 22.2.3.32
  obj.defineNativeGetter(realm.intrinsics.SymbolToStringTag, function (context) {
    // 1. Let O be the this value.
    var O = context.throwIfNotConcrete();

    // 2. If Type(O) is not Object, return undefined.
    if (!(O instanceof _index.ObjectValue)) return realm.intrinsics.undefined;

    // 3. If O does not have a [[TypedArrayName]] internal slot, return undefined.
    if (!("$TypedArrayName" in O)) return realm.intrinsics.undefined;

    // 4. Let name be O.[[TypedArrayName]].
    var name = O.$TypedArrayName;

    // 5. Assert: name is a String value.
    (0, _invariant2.default)(typeof name === "string", "name is a String value");

    // 6. Return name.
    return new _index.StringValue(realm, name);
  });
};

exports.build = build;

var _types = require("../../types.js");

var _index = require("../../values/index.js");

var _to = require("../../methods/to.js");

var _call = require("../../methods/call.js");

var _get = require("../../methods/get.js");

var _has = require("../../methods/has.js");

var _is = require("../../methods/is.js");

var _typedarray = require("../../methods/typedarray.js");

var _create = require("../../methods/create.js");

var _arraybuffer = require("../../methods/arraybuffer.js");

var _abstract = require("../../methods/abstract.js");

var _singletons = require("../../singletons.js");

var _invariant = require("../../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function build(realm, obj, type) {
  // ECMA262 22.2.6
  obj.$Prototype = realm.intrinsics.TypedArrayPrototype;

  // ECMA262 22.2.6.1
  obj.defineNativeConstant("BYTES_PER_ELEMENT", new _index.NumberValue(realm, _types.ElementSize[type]));
}
//# sourceMappingURL=TypedArrayPrototype.js.map