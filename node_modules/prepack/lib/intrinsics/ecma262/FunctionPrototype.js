"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.default = function (realm, obj) {
  // ECMA262 19.2.3
  obj.$Call = function (thisArgument, argsList) {
    return realm.intrinsics.undefined;
  };

  // ECMA262 19.2.3
  obj.defineNativeProperty("length", realm.intrinsics.zero, { writable: false });

  // ECMA262 19.2.3
  obj.defineNativeProperty("name", realm.intrinsics.emptyString, { writable: false });

  // ECMA262 19.2.3.3
  obj.defineNativeMethod("call", 1, function (func, _ref) {
    var _ref2 = _toArray(_ref),
        thisArg = _ref2[0],
        argList = _ref2.slice(1);

    // 1. If IsCallable(func) is false, throw a TypeError exception.
    if ((0, _is.IsCallable)(realm, func) === false) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "not callable");
    }

    // 2. Let argList be a new empty List.
    // 3. If this method was called with more than one argument, then in left to right order,
    //    starting with the second argument, append each argument as the last element of argList.
    argList;

    // TODO #1008 4. Perform PrepareForTailCall().

    // 5. Return ? Call(func, thisArg, argList).
    return (0, _call.Call)(realm, func, thisArg, argList);
  });

  // ECMA262 19.2.3.1
  obj.defineNativeMethod("apply", 2, function (func, _ref3) {
    var _ref4 = _slicedToArray(_ref3, 2),
        thisArg = _ref4[0],
        argArray = _ref4[1];

    // 1. If IsCallable(func) is false, throw a TypeError exception.
    if ((0, _is.IsCallable)(realm, func) === false) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "not callable");
    }

    // 2. If argArray is null or undefined, then
    if ((0, _has.HasSomeCompatibleType)(argArray, _index.NullValue, _index.UndefinedValue)) {
      // TODO #1008 a. Perform PrepareForTailCall().

      // b. Return ? Call(func, thisArg).
      return (0, _call.Call)(realm, func, thisArg);
    }

    // 3. Let argList be ? CreateListFromArrayLike(argArray).
    var argList = (0, _create.CreateListFromArrayLike)(realm, argArray);

    // TODO #1008 4. Perform PrepareForTailCall().

    // 5. Return ? Call(func, thisArg, argList).
    return (0, _call.Call)(realm, func, thisArg, argList);
  });

  // ECMA262 19.2.3.2
  obj.defineNativeMethod("bind", 1, function (context, _ref5) {
    var _ref6 = _toArray(_ref5),
        thisArg = _ref6[0],
        args = _ref6.slice(1);

    // 1. Let Target be the realm value.
    var Target = context;

    // 2. If IsCallable(Target) is false, throw a TypeError exception.
    if ((0, _is.IsCallable)(realm, Target) === false) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    }
    (0, _invariant2.default)(Target instanceof _index.ObjectValue);

    // 3. Let args be a new (possibly empty) List consisting of all of the argument values provided after thisArg in order.
    args;

    // 4. Let F be ? BoundFunctionCreate(Target, thisArg, args).
    var F = _singletons.Functions.BoundFunctionCreate(realm, Target, thisArg, args);

    // 5. Let targetHasLength be ? HasOwnProperty(Target, "length").
    var targetHasLength = (0, _has.HasOwnProperty)(realm, Target, new _index.StringValue(realm, "length"));

    var L = void 0;

    // 6. If targetHasLength is true, then
    if (targetHasLength === true) {
      // a. Let targetLen be ? Get(Target, "length").
      var targetLen = (0, _get.Get)(realm, Target, new _index.StringValue(realm, "length"));

      // b. If Type(targetLen) is not Number, let L be 0.
      if (!targetLen.mightBeNumber()) {
        L = 0;
      } else {
        // c. Else,
        targetLen = targetLen.throwIfNotConcreteNumber();
        // i. Let targetLen be ToInteger(targetLen).
        targetLen = (0, _to.ToInteger)(realm, targetLen);

        // ii. Let L be the larger of 0 and the result of targetLen minus the number of elements of args.
        L = Math.max(0, targetLen - args.length);
      }
    } else {
      // 7. Else let L be 0.
      L = 0;
    }

    // 8. Perform ! DefinePropertyOrThrow(F, "length", PropertyDescriptor {[[Value]]: L, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true}).
    _singletons.Properties.DefinePropertyOrThrow(realm, F, "length", {
      value: new _index.NumberValue(realm, L),
      writable: false,
      enumerable: false,
      configurable: true
    });

    // 9. Let targetName be ? Get(Target, "name").
    var targetName = (0, _get.Get)(realm, Target, new _index.StringValue(realm, "name"));

    // 10. If Type(targetName) is not String, let targetName be the empty string.
    if (!(targetName instanceof _index.StringValue)) targetName = realm.intrinsics.emptyString;

    // 11. Perform SetFunctionName(F, targetName, "bound").
    _singletons.Functions.SetFunctionName(realm, F, targetName, "bound");

    // 12. Return F.
    return F;
  });

  // ECMA262 19.2.3.6
  obj.defineNativeMethod(realm.intrinsics.SymbolHasInstance, 1, function (context, _ref7) {
    var _ref8 = _slicedToArray(_ref7, 1),
        V = _ref8[0];

    // 1. Let F be the this value.
    var F = context;

    // 2. Return ? OrdinaryHasInstance(F, V).
    return new _index.BooleanValue(realm, (0, _abstract.OrdinaryHasInstance)(realm, F, V));
  }, { writable: false, configurable: false });

  // ECMA262 19.2.3.5
  obj.defineNativeMethod("toString", 0, function (context) {
    context = context.throwIfNotConcrete();
    if (context instanceof _index.NativeFunctionValue) {
      var name = context.name;
      if (name instanceof _index.AbstractValue) {
        return new _index.StringValue(realm, "function () {[native code]}");
      } else {
        (0, _invariant2.default)(typeof name === "string");
        return new _index.StringValue(realm, "function " + name + "() { [native code] }");
      }
    } else if (context instanceof _index.FunctionValue) {
      // TODO #1009: provide function source code
      return new _index.StringValue(realm, "function () { }");
    } else {
      // 3. Throw a TypeError exception.
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, new _index.StringValue(realm, "Function.prototype.toString is not generic"));
    }
  });
};

var _singletons = require("../../singletons.js");

var _index = require("../../values/index.js");

var _call = require("../../methods/call.js");

var _to = require("../../methods/to.js");

var _create = require("../../methods/create.js");

var _get = require("../../methods/get.js");

var _is = require("../../methods/is.js");

var _has = require("../../methods/has.js");

var _abstract = require("../../methods/abstract.js");

var _invariant = require("../../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); } /**
                                                                               * Copyright (c) 2017-present, Facebook, Inc.
                                                                               * All rights reserved.
                                                                               *
                                                                               * This source code is licensed under the BSD-style license found in the
                                                                               * LICENSE file in the root directory of this source tree. An additional grant
                                                                               * of patent rights can be found in the PATENTS file in the same directory.
                                                                               */
//# sourceMappingURL=FunctionPrototype.js.map