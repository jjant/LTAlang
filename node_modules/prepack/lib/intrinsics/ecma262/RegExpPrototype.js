"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Copyright (c) 2017-present, Facebook, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * This source code is licensed under the BSD-style license found in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * LICENSE file in the root directory of this source tree. An additional grant
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * of patent rights can be found in the PATENTS file in the same directory.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */

exports.default = function (realm, obj) {
  // ECMA262 21.2.5.2
  obj.defineNativeMethod("exec", 1, function (context, _ref) {
    var _ref2 = _slicedToArray(_ref, 1),
        string = _ref2[0];

    // 1. Let R be the this value.
    var R = context.throwIfNotConcrete();

    // 2. If Type(R) is not Object, throw a TypeError exception.
    if (!(R instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(R) is not an object");
    }

    // 3. If R does not have a [[RegExpMatcher]] internal slot, throw a TypeError exception.
    if (R.$RegExpMatcher === undefined) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "R does not have a [[RegExpMatcher]] internal slot");
    }

    // 4. Let S be ? ToString(string).
    var S = (0, _to.ToStringPartial)(realm, string);

    // 5. Return ? RegExpBuiltinExec(R, S).
    return (0, _regexp.RegExpBuiltinExec)(realm, R, S);
  });

  // ECMA262 21.2.5.3
  obj.defineNativeGetter("flags", function (context) {
    // 1. Let R be the this value.
    var R = context.throwIfNotConcrete();

    // 2. If Type(R) is not Object, throw a TypeError exception.
    if (!(R instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(R) is not an object");
    }

    // 3. Let result be the empty String.
    var result = "";

    // 4. Let global be ToBoolean(? Get(R, "global")).
    var global = (0, _to.ToBooleanPartial)(realm, (0, _get.Get)(realm, R, "global"));

    // 5. If global is true, append "g" as the last code unit of result.
    if (global) result += "g";

    // 6. Let ignoreCase be ToBoolean(? Get(R, "ignoreCase")).
    var ignoreCase = (0, _to.ToBooleanPartial)(realm, (0, _get.Get)(realm, R, "ignoreCase"));

    // 7. If ignoreCase is true, append "i" as the last code unit of result.
    if (ignoreCase) result += "i";

    // 8. Let multiline be ToBoolean(? Get(R, "multiline")).
    var multiline = (0, _to.ToBooleanPartial)(realm, (0, _get.Get)(realm, R, "multiline"));

    // 9. If multiline is true, append "m" as the last code unit of result.
    if (multiline) result += "m";

    // 10. Let unicode be ToBoolean(? Get(R, "unicode")).
    var unicode = (0, _to.ToBooleanPartial)(realm, (0, _get.Get)(realm, R, "unicode"));

    // 11. If unicode is true, append "u" as the last code unit of result.
    if (unicode) result += "u";

    // 12. Let sticky be ToBoolean(? Get(R, "sticky")).
    var sticky = (0, _to.ToBooleanPartial)(realm, (0, _get.Get)(realm, R, "sticky"));

    // 13. If sticky is true, append "y" as the last code unit of result.
    if (sticky) result += "y";

    // 14. Return result.
    return new _index.StringValue(realm, result);
  });

  // ECMA262 21.2.5.4
  obj.defineNativeGetter("global", function (context) {
    return InternalHasFlag(realm, context, "g");
  });

  // ECMA262 21.2.5.5
  obj.defineNativeGetter("ignoreCase", function (context) {
    return InternalHasFlag(realm, context, "i");
  });

  // ECMA262 21.2.5.6
  obj.defineNativeMethod(realm.intrinsics.SymbolMatch, 1, function (context, _ref3) {
    var _ref4 = _slicedToArray(_ref3, 1),
        string = _ref4[0];

    // 1. Let rx be the this value.
    var rx = context.throwIfNotConcrete();

    // 2. If Type(rx) is not Object, throw a TypeError exception.
    if (!(rx instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(R) is not an object");
    }

    // 3. Let S be ? ToString(string).
    var S = (0, _to.ToStringPartial)(realm, string);

    // 4. Let global be ToBoolean(? Get(rx, "global")).
    var global = (0, _to.ToBooleanPartial)(realm, (0, _get.Get)(realm, rx, "global"));

    // 5. If global is false, then
    if (global === false) {
      // a. Return ? RegExpExec(rx, S).
      return (0, _regexp.RegExpExec)(realm, rx, S);
    } else {
      // 6. Else global is true,
      // a. Let fullUnicode be ToBoolean(? Get(rx, "unicode")).
      var fullUnicode = (0, _to.ToBooleanPartial)(realm, (0, _get.Get)(realm, rx, "unicode"));

      // b. Perform ? Set(rx, "lastIndex", 0, true).
      _singletons.Properties.Set(realm, rx, "lastIndex", realm.intrinsics.zero, true);

      // c. Let A be ArrayCreate(0).
      var A = (0, _create.ArrayCreate)(realm, 0);

      // d. Let n be 0.
      var n = 0;

      // e. Repeat,
      while (true) {
        // i. Let result be ? RegExpExec(rx, S).
        var result = (0, _regexp.RegExpExec)(realm, rx, S);

        // ii. If result is null, then
        if (result instanceof _index.NullValue) {
          // 1. If n=0, return null.
          if (n === 0) {
            return realm.intrinsics.null;
          } else {
            // 2. Else, return A.
            return A;
          }
        } else {
          // iii. Else result is not null,
          // 1. Let matchStr be ? ToString(? Get(result, "0")).
          var matchStr = (0, _to.ToStringPartial)(realm, (0, _get.Get)(realm, result, "0"));

          // 2. Let status be CreateDataProperty(A, ! ToString(n), matchStr).
          var status = (0, _create.CreateDataProperty)(realm, A, (0, _to.ToString)(realm, new _index.NumberValue(realm, n)), new _index.StringValue(realm, matchStr));

          // 3. Assert: status is true.
          (0, _invariant2.default)(status === true, "status is true");

          // 4. If matchStr is the empty String, then
          if (matchStr === "") {
            // a. Let thisIndex be ? ToLength(? Get(rx, "lastIndex")).
            var thisIndex = (0, _to.ToLength)(realm, (0, _get.Get)(realm, rx, "lastIndex"));

            // b. Let nextIndex be AdvanceStringIndex(S, thisIndex, fullUnicode).
            var nextIndex = (0, _regexp.AdvanceStringIndex)(realm, S, thisIndex, fullUnicode);

            // c .Perform ? Set(rx, "lastIndex", nextIndex, true).
            _singletons.Properties.Set(realm, rx, "lastIndex", new _index.NumberValue(realm, nextIndex), true);
          }

          // 5. Increment n.
          n += 1;
        }
      }

      (0, _invariant2.default)(false);
    }
  });

  // ECMA262 21.2.5.7
  obj.defineNativeGetter("multiline", function (context) {
    return InternalHasFlag(realm, context, "m");
  });

  // ECMA262 21.2.5.8
  obj.defineNativeMethod(realm.intrinsics.SymbolReplace, 2, function (context, _ref5) {
    var _ref6 = _slicedToArray(_ref5, 2),
        string = _ref6[0],
        replaceValue = _ref6[1];

    // 1. Let rx be the this value.
    var rx = context.throwIfNotConcrete();

    // 2. If Type(rx) is not Object, throw a TypeError exception.
    if (!(rx instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(R) is not an object");
    }

    // 3. Let S be ? ToString(string).
    var S = (0, _to.ToStringPartial)(realm, string);

    // 4. Let lengthS be the number of code unit elements in S.
    var lengthS = S.length;

    // 5. Let functionalReplace be IsCallable(replaceValue).
    var functionalReplace = (0, _is.IsCallable)(realm, replaceValue);

    // 6. If functionalReplace is false, then
    if (functionalReplace === false) {
      // a. Let replaceValue be ? ToString(replaceValue).
      replaceValue = new _index.StringValue(realm, (0, _to.ToStringPartial)(realm, replaceValue));
    }

    // 7. Let global be ToBoolean(? Get(rx, "global")).
    var global = (0, _to.ToBooleanPartial)(realm, (0, _get.Get)(realm, rx, "global"));

    var fullUnicode = void 0;
    // 8. If global is true, then
    if (global === true) {
      // a. Let fullUnicode be ToBoolean(? Get(rx, "unicode")).
      fullUnicode = (0, _to.ToBooleanPartial)(realm, (0, _get.Get)(realm, rx, "unicode"));

      // b. Perform ? Set(rx, "lastIndex", 0, true).
      _singletons.Properties.Set(realm, rx, "lastIndex", realm.intrinsics.zero, true);
    }

    // 9. Let results be a new empty List.
    var results = [];

    // 10. Let done be false.
    var done = false;

    // 11. Repeat, while done is false
    while (done === false) {
      // a. Let result be ? RegExpExec(rx, S).
      var result = (0, _regexp.RegExpExec)(realm, rx, S);

      // b. If result is null, set done to true.
      if (result instanceof _index.NullValue) {
        done = true;
      } else {
        // c. Else result is not null,
        // i. Append result to the end of results.
        results.push(result);

        // ii. If global is false, set done to true.
        if (global === false) {
          done = true;
        } else {
          // iii. Else,
          (0, _invariant2.default)(fullUnicode !== undefined);

          // 1. Let matchStr be ? ToString(? Get(result, "0")).
          var matchStr = (0, _to.ToStringPartial)(realm, (0, _get.Get)(realm, result, "0"));

          // 2. If matchStr is the empty String, then
          if (matchStr === "") {
            // a. Let thisIndex be ? ToLength(? Get(rx, "lastIndex")).
            var thisIndex = (0, _to.ToLength)(realm, (0, _get.Get)(realm, rx, "lastIndex"));

            // b. Let nextIndex be AdvanceStringIndex(S, thisIndex, fullUnicode).
            var nextIndex = (0, _regexp.AdvanceStringIndex)(realm, S, thisIndex, fullUnicode);

            // c. Perform ? Set(rx, "lastIndex", nextIndex, true).
            _singletons.Properties.Set(realm, rx, "lastIndex", new _index.NumberValue(realm, nextIndex), true);
          }
        }
      }
    }

    // 12. Let accumulatedResult be the empty String value.
    var accumulatedResult = "";

    // 13. Let nextSourcePosition be 0.
    var nextSourcePosition = 0;

    // 14. Repeat, for each result in results,
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = results[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _result = _step.value;

        // a. Let nCaptures be ? ToLength(? Get(result, "length")).
        var nCaptures = (0, _to.ToLength)(realm, (0, _get.Get)(realm, _result, "length"));

        // b. Let nCaptures be max(nCaptures - 1, 0).
        nCaptures = Math.max(nCaptures - 1, 0);

        // c. Let matched be ? ToString(? Get(result, "0")).
        var matched = (0, _to.ToStringPartial)(realm, (0, _get.Get)(realm, _result, "0"));

        // d. Let matchLength be the number of code units in matched.
        var matchLength = matched.length;

        // e. Let position be ? ToInteger(? Get(result, "index")).
        var position = (0, _to.ToInteger)(realm, (0, _get.Get)(realm, _result, "index"));

        // f. Let position be max(min(position, lengthS), 0).
        position = Math.max(Math.min(position, lengthS), 0);

        // g. Let n be 1.
        var n = 1;

        // h. Let captures be a new empty List.
        var captures = [];

        // i. Repeat while n ≤ nCaptures
        while (n <= nCaptures) {
          // i. Let capN be ? Get(result, ! ToString(n)).
          var capN = (0, _get.Get)(realm, _result, (0, _to.ToString)(realm, new _index.NumberValue(realm, n)));

          // ii. If capN is not undefined, then
          if (!capN.mightBeUndefined()) {
            // 1. Let capN be ? ToString(capN).
            capN = (0, _to.ToStringPartial)(realm, capN);
          } else {
            capN.throwIfNotConcrete();
            capN = undefined;
          }

          // iii. Append capN as the last element of captures.
          captures.push(capN);

          // iv. Let n be n+1.
          n = n + 1;
        }

        var replacement = void 0;
        // j. If functionalReplace is true, then
        if (functionalReplace) {
          // i. Let replacerArgs be « matched ».
          var replacerArgs = [new _index.StringValue(realm, matched)];

          // ii. Append in list order the elements of captures to the end of the List replacerArgs.
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = captures[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var capture = _step2.value;

              replacerArgs.push(capture === undefined ? realm.intrinsics.undefined : new _index.StringValue(realm, capture));
            }

            // iii. Append position and S as the last two elements of replacerArgs.
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }

          replacerArgs = replacerArgs.concat([new _index.NumberValue(realm, position), new _index.StringValue(realm, S)]);

          // iv. Let replValue be ? Call(replaceValue, undefined, replacerArgs).
          var replValue = (0, _call.Call)(realm, replaceValue, realm.intrinsics.undefined, replacerArgs);

          // v. Let replacement be ? ToString(replValue).
          replacement = (0, _to.ToStringPartial)(realm, replValue);
        } else {
          // k. Else,
          (0, _invariant2.default)(replaceValue instanceof _index.StringValue);
          // i. Let replacement be GetSubstitution(matched, S, position, captures, replaceValue).
          replacement = (0, _get.GetSubstitution)(realm, matched, S, position, captures, replaceValue.value);
        }

        // l. If position ≥ nextSourcePosition, then
        if (position >= nextSourcePosition) {
          // i. NOTE position should not normally move backwards. If it does, it is an indication of an ill-behaving RegExp subclass or use of an access triggered side-effect to change the global flag or other characteristics of rx. In such cases, the corresponding substitution is ignored.
          // ii. Let accumulatedResult be the String formed by concatenating the code units of the current value of accumulatedResult with the substring of S consisting of the code units from nextSourcePosition (inclusive) up to position (exclusive) and with the code units of replacement.
          accumulatedResult = accumulatedResult + S.substr(nextSourcePosition, position - nextSourcePosition) + replacement;

          // iii. Let nextSourcePosition be position + matchLength.
          nextSourcePosition = position + matchLength;
        }
      }
      // 15. If nextSourcePosition ≥ lengthS, return accumulatedResult.
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    if (nextSourcePosition >= lengthS) return new _index.StringValue(realm, accumulatedResult);

    // 16. Return the String formed by concatenating the code units of accumulatedResult with the substring of S consisting of the code units from nextSourcePosition (inclusive) up through the final code unit of S (inclusive).
    return new _index.StringValue(realm, accumulatedResult + S.substr(nextSourcePosition));
  });

  // ECMA262 21.2.5.9
  obj.defineNativeMethod(realm.intrinsics.SymbolSearch, 1, function (context, _ref7) {
    var _ref8 = _slicedToArray(_ref7, 1),
        string = _ref8[0];

    // 1. Let rx be the this value.
    var rx = context.throwIfNotConcrete();

    // 2. If Type(rx) is not Object, throw a TypeError exception.
    if (!(rx instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(R) is not an object");
    }

    // 3. Let S be ? ToString(string).
    var S = (0, _to.ToStringPartial)(realm, string);

    // 4. Let previousLastIndex be ? Get(rx, "lastIndex").
    var previousLastIndex = (0, _get.Get)(realm, rx, "lastIndex");

    // 5. Perform ? Set(rx, "lastIndex", 0, true).
    _singletons.Properties.Set(realm, rx, "lastIndex", realm.intrinsics.zero, true);

    // 6. Let result be ? RegExpExec(rx, S).
    var result = (0, _regexp.RegExpExec)(realm, rx, S);

    // 7. Perform ? Set(rx, "lastIndex", previousLastIndex, true).
    _singletons.Properties.Set(realm, rx, "lastIndex", previousLastIndex, true);

    // 8. If result is null, return -1.
    if (result instanceof _index.NullValue) return new _index.NumberValue(realm, -1);

    // 9. Return ? Get(result, "index").
    return (0, _get.Get)(realm, result, "index");
  });

  // ECMA262 21.2.5.10
  obj.defineNativeGetter("source", function (context) {
    // 1. Let R be the this value.
    var R = context.throwIfNotConcrete();

    // 2. If Type(R) is not Object, throw a TypeError exception.
    if (!(R instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(R) is not an object");
    }

    // 3. If R does not have an [[OriginalSource]] internal slot, throw a TypeError exception.
    if (typeof R.$OriginalSource !== "string") {
      // a. If SameValue(R, %RegExpPrototype%) is true, return undefined.
      if ((0, _abstract.SameValue)(realm, R, realm.intrinsics.RegExpPrototype)) {
        return new _index.StringValue(realm, "(?:)");
      } else {
        // b. Otherwise, throw a TypeError exception.
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "R does not have an [[OriginalSource]] internal slot");
      }
    }

    // 4. Assert: R has an [[OriginalFlags]] internal slot.
    (0, _invariant2.default)(R.$OriginalFlags !== undefined, "R has an [[OriginalFlags]] internal slot");

    // 5. Let src be R.[[OriginalSource]].
    var src = R.$OriginalSource;
    (0, _invariant2.default)(typeof src === "string");

    // 6. Let flags be R.[[OriginalFlags]].
    var flags = R.$OriginalFlags;
    (0, _invariant2.default)(typeof flags === "string");

    // 7. Return EscapeRegExpPattern(src, flags).
    return new _index.StringValue(realm, (0, _regexp.EscapeRegExpPattern)(realm, src, flags));
  });

  // ECMA262 21.2.5.11
  obj.defineNativeMethod(realm.intrinsics.SymbolSplit, 2, function (context, _ref9) {
    var _ref10 = _slicedToArray(_ref9, 2),
        string = _ref10[0],
        limit = _ref10[1];

    // 1. Let rx be the this value.
    var rx = context.throwIfNotConcrete();

    // 2. If Type(rx) is not Object, throw a TypeError exception.
    if (!(rx instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(rx) is not an object");
    }

    // 3. Let S be ? ToString(string).
    var S = (0, _to.ToStringPartial)(realm, string);

    // 4. Let C be ? SpeciesConstructor(rx, %RegExp%).
    var C = (0, _construct.SpeciesConstructor)(realm, rx, realm.intrinsics.RegExp);

    // 5. Let flags be ? ToString(? Get(rx, "flags")).
    var flags = (0, _to.ToStringPartial)(realm, (0, _get.Get)(realm, rx, "flags"));

    var unicodeMatching = void 0;
    // 6. If flags contains "u", let unicodeMatching be true.
    if (flags.indexOf("u") >= 0) {
      unicodeMatching = true;
    } else {
      // 7. Else, let unicodeMatching be false.
      unicodeMatching = false;
    }

    var newFlags = void 0;
    // 8. If flags contains "y", let newFlags be flags.
    if (flags.indexOf("y") >= 0) {
      newFlags = flags;
    } else {
      // 9. Else, let newFlags be the string that is the concatenation of flags and "y".
      newFlags = flags + "y";
    }

    // 10. Let splitter be ? Construct(C, « rx, newFlags »).
    var splitter = (0, _construct.Construct)(realm, C, [rx, new _index.StringValue(realm, newFlags)]);

    // 11. Let A be ArrayCreate(0).
    var A = (0, _create.ArrayCreate)(realm, 0);

    // 12. Let lengthA be 0.
    var lengthA = 0;

    // 13. If limit is undefined, let lim be 2^32-1; else let lim be ? ToUint32(limit).
    var lim = limit instanceof _index.UndefinedValue ? Math.pow(2, 32) - 1 : (0, _to.ToUint32)(realm, limit.throwIfNotConcrete());

    // 14. Let size be the number of elements in S.
    var size = S.length;

    // 15. Let p be 0.
    var p = 0;

    // 16. If lim = 0, return A.
    if (lim === 0) return A;

    // 17. If size = 0, then
    if (size === 0) {
      // a. Let z be ? RegExpExec(splitter, S).
      var z = (0, _regexp.RegExpExec)(realm, splitter, S);

      // b. If z is not null, return A.
      if (!(z instanceof _index.NullValue)) return A;

      // c. Perform ! CreateDataProperty(A, "0", S).
      (0, _create.CreateDataProperty)(realm, A, "0", new _index.StringValue(realm, S));

      // d Return A.
      return A;
    }

    // 18. Let q be p.
    var q = p;

    // 19. Repeat, while q < size
    while (q < size) {
      // a. Perform ? Set(splitter, "lastIndex", q, true).
      _singletons.Properties.Set(realm, splitter, "lastIndex", new _index.NumberValue(realm, q), true);

      // b. Let z be ? RegExpExec(splitter, S).
      var _z = (0, _regexp.RegExpExec)(realm, splitter, S);

      // c. If z is null, let q be AdvanceStringIndex(S, q, unicodeMatching).
      if (_z instanceof _index.NullValue) {
        q = (0, _regexp.AdvanceStringIndex)(realm, S, q, unicodeMatching);
      } else {
        // d. Else z is not null,
        // i. Let e be ? ToLength(? Get(splitter, "lastIndex")).
        var e = (0, _to.ToLength)(realm, (0, _get.Get)(realm, splitter, "lastIndex"));

        // ii. Let e be min(e, size).
        e = Math.min(e, size);

        // iii. If e = p, let q be AdvanceStringIndex(S, q, unicodeMatching).
        if (e === p) {
          q = (0, _regexp.AdvanceStringIndex)(realm, S, q, unicodeMatching);
        } else {
          // iv. Else e ≠ p,
          // 1. Let T be a String value equal to the substring of S consisting of the elements at indices p (inclusive) through q (exclusive).
          var _T = S.substr(p, q - p);

          // 2. Perform ! CreateDataProperty(A, ! ToString(lengthA), T).
          (0, _create.CreateDataProperty)(realm, A, (0, _to.ToString)(realm, new _index.NumberValue(realm, lengthA)), new _index.StringValue(realm, _T));

          // 3. Let lengthA be lengthA + 1.
          lengthA = lengthA + 1;

          // 4. If lengthA = lim, return A.
          if (lengthA === lim) return A;

          // 5. Let p be e.
          p = e;

          // 6. Let numberOfCaptures be ? ToLength(? Get(z, "length")).
          var numberOfCaptures = (0, _to.ToLength)(realm, (0, _get.Get)(realm, _z, "length"));

          // 7. Let numberOfCaptures be max(numberOfCaptures-1, 0).
          numberOfCaptures = Math.max(numberOfCaptures - 1, 0);

          // 8. Let i be 1.
          var i = 1;

          // 9. Repeat, while i ≤ numberOfCaptures,
          while (i <= numberOfCaptures) {
            // a. Let nextCapture be ? Get(z, ! ToString(i)).
            var nextCapture = (0, _get.Get)(realm, _z, (0, _to.ToString)(realm, new _index.NumberValue(realm, i)));

            // b. Perform ! CreateDataProperty(A, ! ToString(lengthA), nextCapture).
            (0, _create.CreateDataProperty)(realm, A, (0, _to.ToString)(realm, new _index.NumberValue(realm, lengthA)), nextCapture);

            // c. Let i be i + 1.
            i = i + 1;

            // d. Let lengthA be lengthA + 1.
            lengthA = lengthA + 1;

            // e. If lengthA = lim, return A.
            if (lengthA === lim) return A;
          }

          // 10. Let q be p.
          q = p;
        }
      }
    }

    // 20. Let T be a String value equal to the substring of S consisting of the elements at indices p (inclusive) through size (exclusive).
    var T = S.substr(p, size - p);

    // 21. Perform ! CreateDataProperty(A, ! ToString(lengthA), T).
    (0, _create.CreateDataProperty)(realm, A, (0, _to.ToString)(realm, new _index.NumberValue(realm, lengthA)), new _index.StringValue(realm, T));

    // 22. Return A.
    return A;
  });

  // ECMA262 21.2.5.12
  obj.defineNativeGetter("sticky", function (context) {
    return InternalHasFlag(realm, context, "y");
  });

  // ECMA262 21.2.5.13
  obj.defineNativeMethod("test", 1, function (context, _ref11) {
    var _ref12 = _slicedToArray(_ref11, 1),
        S = _ref12[0];

    // 1. Let R be the this value.
    var R = context.throwIfNotConcrete();

    // 2. If Type(R) is not Object, throw a TypeError exception.
    if (!(R instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(R) is not an object");
    }

    // 3. Let string be ? ToString(S).
    var string = (0, _to.ToStringPartial)(realm, S);

    // 4. Let match be ? RegExpExec(R, string).
    var match = (0, _regexp.RegExpExec)(realm, R, string);

    // 5. If match is not null, return true; else return false.
    return new _index.BooleanValue(realm, !(match instanceof _index.NullValue) ? true : false);
  });

  // ECMA262 21.2.5.14
  obj.defineNativeMethod("toString", 0, function (context) {
    // 1. Let R be the this value.
    var R = context.throwIfNotConcrete();

    // 2. If Type(R) is not Object, throw a TypeError exception.
    if (!(R instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(R) is not an object");
    }

    // 3. Let pattern be ? ToString(? Get(R, "source")).
    var pattern = (0, _to.ToStringPartial)(realm, (0, _get.Get)(realm, R, "source"));

    // 4. Let flags be ? ToString(? Get(R, "flags")).
    var flags = (0, _to.ToStringPartial)(realm, (0, _get.Get)(realm, R, "flags"));

    // 5. Let result be the String value formed by concatenating "/", pattern, "/", and flags.
    var result = "/" + pattern + "/" + flags;

    // 6. Return result.
    return new _index.StringValue(realm, result);
  });

  // ECMA262 21.2.5.15
  obj.defineNativeGetter("unicode", function (context) {
    return InternalHasFlag(realm, context, "u");
  });
};

var _invariant = require("../../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _index = require("../../values/index.js");

var _create = require("../../methods/create.js");

var _abstract = require("../../methods/abstract.js");

var _call = require("../../methods/call.js");

var _construct = require("../../methods/construct.js");

var _get = require("../../methods/get.js");

var _singletons = require("../../singletons.js");

var _is = require("../../methods/is.js");

var _to = require("../../methods/to.js");

var _regexp = require("../../methods/regexp.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function InternalHasFlag(realm, context, flag) {
  // 1. Let R be the this value.
  var R = context.throwIfNotConcrete();

  // 2. If Type(R) is not Object, throw a TypeError exception.
  if (!(R instanceof _index.ObjectValue)) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(R) is not an object");
  }

  // 3. If R does not have an [[OriginalFlags]] internal slot, throw a TypeError exception.
  if (typeof R.$OriginalFlags !== "string") {
    // a. If SameValue(R, %RegExpPrototype%) is true, return undefined.
    if ((0, _abstract.SameValue)(realm, R, realm.intrinsics.RegExpPrototype)) {
      return realm.intrinsics.undefined;
    } else {
      // b. Otherwise, throw a TypeError exception.
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "R does not have an [[OriginalFlags]] internal slot");
    }
  }

  // 4. Let flags be the value of R's [[OriginalFlags]] internal slot.
  var flags = R.$OriginalFlags;

  // 5. If flags contains the code unit "g", return true.
  if (flags.indexOf(flag) >= 0) {
    return realm.intrinsics.true;
  }

  // 6. Return false.
  return realm.intrinsics.false;
}
//# sourceMappingURL=RegExpPrototype.js.map