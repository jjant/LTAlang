"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Copyright (c) 2017-present, Facebook, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * This source code is licensed under the BSD-style license found in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * LICENSE file in the root directory of this source tree. An additional grant
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * of patent rights can be found in the PATENTS file in the same directory.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */

exports.default = function (realm, obj) {
  // ECMA262 20.3.4.2
  obj.defineNativeMethod("getDate", 0, function (context) {
    // 1. Let t be ? thisTimeValue(this value).
    var t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value;

    // 2. If t is NaN, return NaN.
    if (isNaN(t)) return realm.intrinsics.NaN;

    // 3. Return DateFromTime(LocalTime(t)).
    return new _index.NumberValue(realm, (0, _index2.DateFromTime)(realm, (0, _index2.LocalTime)(realm, t)));
  });

  // ECMA262 20.3.4.3
  obj.defineNativeMethod("getDay", 0, function (context) {
    // 1. Let t be ? thisTimeValue(this value).
    var t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value;

    // 2. If t is NaN, return NaN.
    if (isNaN(t)) return realm.intrinsics.NaN;

    // 3. Return WeekDay(LocalTime(t)).
    return new _index.NumberValue(realm, (0, _index2.WeekDay)(realm, (0, _index2.LocalTime)(realm, t)));
  });

  // ECMA262 20.3.4.4
  obj.defineNativeMethod("getFullYear", 0, function (context) {
    // 1. Let t be ? thisTimeValue(this value).
    var t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value;

    // 2. If t is NaN, return NaN.
    if (isNaN(t)) return realm.intrinsics.NaN;

    // 3. Return YearFromTime(LocalTime(t)).
    return new _index.NumberValue(realm, (0, _index2.YearFromTime)(realm, (0, _index2.LocalTime)(realm, t)));
  });

  // ECMA262 20.3.4.5
  obj.defineNativeMethod("getHours", 0, function (context) {
    // 1. Let t be ? thisTimeValue(this value).
    var t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value;

    // 2. If t is NaN, return NaN.
    if (isNaN(t)) return realm.intrinsics.NaN;

    // 3. Return HourFromTime(LocalTime(t)).
    return new _index.NumberValue(realm, (0, _index2.HourFromTime)(realm, (0, _index2.LocalTime)(realm, t)));
  });

  // ECMA262 20.3.4.6
  obj.defineNativeMethod("getMilliseconds", 0, function (context) {
    // 1. Let t be ? thisTimeValue(this value).
    var t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value;

    // 2. If t is NaN, return NaN.
    if (isNaN(t)) return realm.intrinsics.NaN;

    // 3. Return msFromTime(LocalTime(t)).
    return new _index.NumberValue(realm, (0, _index2.msFromTime)(realm, (0, _index2.LocalTime)(realm, t)));
  });

  // ECMA262 20.3.4.7
  obj.defineNativeMethod("getMinutes", 0, function (context) {
    // 1. Let t be ? thisTimeValue(this value).
    var t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value;

    // 2. If t is NaN, return NaN.
    if (isNaN(t)) return realm.intrinsics.NaN;

    // 3. Return MinFromTime(LocalTime(t)).
    return new _index.NumberValue(realm, (0, _index2.MinFromTime)(realm, (0, _index2.LocalTime)(realm, t)));
  });

  // ECMA262 20.3.4.8
  obj.defineNativeMethod("getMonth", 0, function (context) {
    // 1. Let t be ? thisTimeValue(this value).
    var t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value;

    // 2. If t is NaN, return NaN.
    if (isNaN(t)) return realm.intrinsics.NaN;

    // 3. Return MonthFromTime(LocalTime(t)).
    return new _index.NumberValue(realm, (0, _index2.MonthFromTime)(realm, (0, _index2.LocalTime)(realm, t)));
  });

  // ECMA262 20.3.4.9
  obj.defineNativeMethod("getSeconds", 0, function (context) {
    // 1. Let t be ? thisTimeValue(this value).
    var t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value;

    // 2. If t is NaN, return NaN.
    if (isNaN(t)) return realm.intrinsics.NaN;

    // 3. Return SecFromTime(LocalTime(t)).
    return new _index.NumberValue(realm, (0, _index2.SecFromTime)(realm, (0, _index2.LocalTime)(realm, t)));
  });

  // ECMA262 20.3.4.10
  obj.defineNativeMethod("getTime", 0, function (context) {
    // 1. Return ? thisTimeValue(this value).
    return (0, _index2.thisTimeValue)(realm, context);
  });

  // ECMA262 20.3.4.11
  obj.defineNativeMethod("getTimezoneOffset", 0, function (context) {
    // 1. Let t be ? thisTimeValue(this value).
    var t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value;

    // 2. If t is NaN, return NaN.
    if (isNaN(t)) return realm.intrinsics.NaN;

    // 3. Return (t - LocalTime(t)) / msPerMinute.
    return new _index.NumberValue(realm, (t - (0, _index2.LocalTime)(realm, t)) / _index2.msPerMinute);
  });

  // ECMA262 20.3.4.12
  obj.defineNativeMethod("getUTCDate", 0, function (context) {
    // 1. Let t be ? thisTimeValue(this value).
    var t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value;

    // 2. If t is NaN, return NaN.
    if (isNaN(t)) return realm.intrinsics.NaN;

    // 3. Return DateFromTime(t).
    return new _index.NumberValue(realm, (0, _index2.DateFromTime)(realm, t));
  });

  // ECMA262 20.3.4.13
  obj.defineNativeMethod("getUTCDay", 0, function (context) {
    // 1. Let t be ? thisTimeValue(this value).
    var t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value;

    // 2. If t is NaN, return NaN.
    if (isNaN(t)) return realm.intrinsics.NaN;

    // 3. Return WeekDay(t).
    return new _index.NumberValue(realm, (0, _index2.WeekDay)(realm, t));
  });

  // ECMA262 20.3.4.14
  obj.defineNativeMethod("getUTCFullYear", 0, function (context) {
    // 1. Let t be ? thisTimeValue(this value).
    var t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value;

    // 2. If t is NaN, return NaN.
    if (isNaN(t)) return realm.intrinsics.NaN;

    // 3. Return YearFromTime(t).
    return new _index.NumberValue(realm, (0, _index2.YearFromTime)(realm, t));
  });

  // ECMA262 20.3.4.15
  obj.defineNativeMethod("getUTCHours", 0, function (context) {
    // 1. Let t be ? thisTimeValue(this value).
    var t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value;

    // 2. If t is NaN, return NaN.
    if (isNaN(t)) return realm.intrinsics.NaN;

    // 3. Return HourFromTime(t).
    return new _index.NumberValue(realm, (0, _index2.HourFromTime)(realm, t));
  });

  // ECMA262 20.3.4.16
  obj.defineNativeMethod("getUTCMilliseconds", 0, function (context) {
    // 1. Let t be ? thisTimeValue(this value).
    var t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value;

    // 2. If t is NaN, return NaN.
    if (isNaN(t)) return realm.intrinsics.NaN;

    // 3. Return msFromTime(t).
    return new _index.NumberValue(realm, (0, _index2.msFromTime)(realm, t));
  });

  // ECMA262 20.3.4.17
  obj.defineNativeMethod("getUTCMinutes", 0, function (context) {
    // 1. Let t be ? thisTimeValue(this value).
    var t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value;

    // 2. If t is NaN, return NaN.
    if (isNaN(t)) return realm.intrinsics.NaN;

    // 3. Return MinFromTime(t).
    return new _index.NumberValue(realm, (0, _index2.MinFromTime)(realm, t));
  });

  // ECMA262 20.3.4.18
  obj.defineNativeMethod("getUTCMonth", 0, function (context) {
    // 1. Let t be ? thisTimeValue(this value).
    var t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value;

    // 2. If t is NaN, return NaN.
    if (isNaN(t)) return realm.intrinsics.NaN;

    // 3. Return MonthFromTime(t).
    return new _index.NumberValue(realm, (0, _index2.MonthFromTime)(realm, t));
  });

  // ECMA262 20.3.4.19
  obj.defineNativeMethod("getUTCSeconds", 0, function (context) {
    // 1. Let t be ? thisTimeValue(this value).
    var t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value;
    (0, _invariant2.default)(context instanceof _index.ObjectValue);

    // 2. If t is NaN, return NaN.
    if (isNaN(t)) return realm.intrinsics.NaN;

    // 3. Return SecFromTime(t).
    return new _index.NumberValue(realm, (0, _index2.SecFromTime)(realm, t));
  });

  // ECMA262 20.3.4.20
  obj.defineNativeMethod("setDate", 1, function (context, _ref) {
    var _ref2 = _slicedToArray(_ref, 1),
        date = _ref2[0];

    // 1. Let t be LocalTime(? thisTimeValue(this value)).
    var t = (0, _index2.LocalTime)(realm, (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value);
    (0, _invariant2.default)(context instanceof _index.ObjectValue);

    // 2. Let dt be ? ToNumber(date).
    var dt = (0, _index2.ToNumber)(realm, date);

    // 3. Let newDate be MakeDate(MakeDay(YearFromTime(t), MonthFromTime(t), dt), TimeWithinDay(t)).
    var newDate = (0, _index2.MakeDate)(realm, (0, _index2.MakeDay)(realm, (0, _index2.YearFromTime)(realm, t), (0, _index2.MonthFromTime)(realm, t), dt), (0, _index2.TimeWithinDay)(realm, t));

    // 4. Let u be TimeClip(UTC(newDate)).
    var u = (0, _index2.TimeClip)(realm, (0, _index2.UTC)(realm, newDate));

    // 5. Set the [[DateValue]] internal slot of this Date object to u.
    context.$DateValue = u;

    // 6. Return u.
    return u;
  });

  // ECMA262 20.3.4.21
  obj.defineNativeMethod("setFullYear", 3, function (context, _ref3, argCount) {
    var _ref4 = _slicedToArray(_ref3, 3),
        year = _ref4[0],
        month = _ref4[1],
        date = _ref4[2];

    // 1. Let t be ? thisTimeValue(this value).
    var t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value;
    (0, _invariant2.default)(context instanceof _index.ObjectValue);

    // 2. If t is NaN, let t be +0; otherwise, let t be LocalTime(t).
    t = isNaN(t) ? +0 : (0, _index2.LocalTime)(realm, t);

    // 3. Let y be ? ToNumber(year).
    var y = (0, _index2.ToNumber)(realm, year);

    // 4. If month is not specified, let m be MonthFromTime(t); otherwise, let m be ? ToNumber(month).
    var m = argCount >= 2 ? (0, _index2.ToNumber)(realm, month) : (0, _index2.MonthFromTime)(realm, t);

    // 5. If date is not specified, let dt be DateFromTime(t); otherwise, let dt be ? ToNumber(date).
    var dt = argCount >= 3 ? (0, _index2.ToNumber)(realm, date) : (0, _index2.DateFromTime)(realm, t);

    // 6. Let newDate be MakeDate(MakeDay(y, m, dt), TimeWithinDay(t)).
    var newDate = (0, _index2.MakeDate)(realm, (0, _index2.MakeDay)(realm, y, m, dt), (0, _index2.TimeWithinDay)(realm, t));

    // 7. Let u be TimeClip(UTC(newDate)).
    var u = (0, _index2.TimeClip)(realm, (0, _index2.UTC)(realm, newDate));

    // 8. Set the [[DateValue]] internal slot of this Date object to u.
    context.$DateValue = u;

    // 9. Return u.
    return u;
  });

  // ECMA262 20.3.4.22
  obj.defineNativeMethod("setHours", 4, function (context, _ref5, argCount) {
    var _ref6 = _slicedToArray(_ref5, 4),
        hour = _ref6[0],
        min = _ref6[1],
        sec = _ref6[2],
        ms = _ref6[3];

    // 1. Let t be LocalTime(? thisTimeValue(this value)).
    var t = (0, _index2.LocalTime)(realm, (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value);
    (0, _invariant2.default)(context instanceof _index.ObjectValue);

    // 2. Let h be ? ToNumber(hour).
    var h = (0, _index2.ToNumber)(realm, hour);

    // 3. If min is not specified, let m be MinFromTime(t); otherwise, let m be ? ToNumber(min).
    var m = argCount >= 2 ? (0, _index2.ToNumber)(realm, min) : (0, _index2.MinFromTime)(realm, t);

    // 4. If sec is not specified, let s be SecFromTime(t); otherwise, let s be ? ToNumber(sec).
    var s = argCount >= 3 ? (0, _index2.ToNumber)(realm, sec) : (0, _index2.SecFromTime)(realm, t);

    // 5. If ms is not specified, let milli be msFromTime(t); otherwise, let milli be ? ToNumber(ms).
    var milli = argCount >= 4 ? (0, _index2.ToNumber)(realm, ms) : (0, _index2.msFromTime)(realm, t);

    // 6. Let date be MakeDate(Day(t), MakeTime(h, m, s, milli)).
    var date = (0, _index2.MakeDate)(realm, (0, _index2.Day)(realm, t), (0, _index2.MakeTime)(realm, h, m, s, milli));

    // 7. Let u be TimeClip(UTC(date)).
    var u = (0, _index2.TimeClip)(realm, (0, _index2.UTC)(realm, date));

    // 8. Set the [[DateValue]] internal slot of this Date object to u.
    context.$DateValue = u;

    // 9. Return u.
    return u;
  });

  // ECMA262 20.3.4.23
  obj.defineNativeMethod("setMilliseconds", 1, function (context, _ref7) {
    var _ref8 = _slicedToArray(_ref7, 1),
        ms = _ref8[0];

    // 1. Let t be LocalTime(? thisTimeValue(this value)).
    var t = (0, _index2.LocalTime)(realm, (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value);
    (0, _invariant2.default)(context instanceof _index.ObjectValue);

    // 2. Let ms be ? ToNumber(ms).
    ms = (0, _index2.ToNumber)(realm, ms);

    // 3. Let time be MakeTime(HourFromTime(t), MinFromTime(t), SecFromTime(t), ms).
    var time = (0, _index2.MakeTime)(realm, (0, _index2.HourFromTime)(realm, t), (0, _index2.MinFromTime)(realm, t), (0, _index2.SecFromTime)(realm, t), ms);

    // 4. Let u be TimeClip(UTC(MakeDate(Day(t), time))).
    var u = (0, _index2.TimeClip)(realm, (0, _index2.UTC)(realm, (0, _index2.MakeDate)(realm, (0, _index2.Day)(realm, t), time)));

    // 5. Set the [[DateValue]] internal slot of this Date object to u.
    context.$DateValue = u;

    // 6. Return u.
    return u;
  });

  // ECMA262 20.3.4.24
  obj.defineNativeMethod("setMinutes", 3, function (context, _ref9, argCount) {
    var _ref10 = _slicedToArray(_ref9, 3),
        min = _ref10[0],
        sec = _ref10[1],
        ms = _ref10[2];

    // 1. Let t be LocalTime(? thisTimeValue(this value)).
    var t = (0, _index2.LocalTime)(realm, (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value);
    (0, _invariant2.default)(context instanceof _index.ObjectValue);

    // 2. Let m be ? ToNumber(min).
    var m = (0, _index2.ToNumber)(realm, min);

    // 3. If sec is not specified, let s be SecFromTime(t); otherwise, let s be ? ToNumber(sec).
    var s = argCount >= 2 ? (0, _index2.ToNumber)(realm, sec) : (0, _index2.SecFromTime)(realm, t);

    // 4. If ms is not specified, let milli be msFromTime(t); otherwise, let milli be ? ToNumber(ms).
    var milli = argCount >= 3 ? (0, _index2.ToNumber)(realm, ms) : (0, _index2.msFromTime)(realm, t);

    // 5. Let date be MakeDate(Day(t), MakeTime(HourFromTime(t), m, s, milli)).
    var date = (0, _index2.MakeDate)(realm, (0, _index2.Day)(realm, t), (0, _index2.MakeTime)(realm, (0, _index2.HourFromTime)(realm, t), m, s, milli));

    // 6. Let u be TimeClip(UTC(date)).
    var u = (0, _index2.TimeClip)(realm, (0, _index2.UTC)(realm, date));

    // 7. Set the [[DateValue]] internal slot of this Date object to u.
    context.$DateValue = u;

    // 8. Return u.
    return u;
  });

  // ECMA262 20.3.4.25
  obj.defineNativeMethod("setMonth", 2, function (context, _ref11, argCount) {
    var _ref12 = _slicedToArray(_ref11, 2),
        month = _ref12[0],
        date = _ref12[1];

    // 1. Let t be LocalTime(? thisTimeValue(this value)).
    var t = (0, _index2.LocalTime)(realm, (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value);
    (0, _invariant2.default)(context instanceof _index.ObjectValue);

    // 2. Let m be ? ToNumber(month).
    var m = (0, _index2.ToNumber)(realm, month);

    // 3. If date is not specified, let dt be DateFromTime(t); otherwise, let dt be ? ToNumber(date).
    var dt = argCount >= 2 ? (0, _index2.ToNumber)(realm, date) : (0, _index2.DateFromTime)(realm, t);

    // 4. Let newDate be MakeDate(MakeDay(YearFromTime(t), m, dt), TimeWithinDay(t)).
    var newDate = (0, _index2.MakeDate)(realm, (0, _index2.MakeDay)(realm, (0, _index2.YearFromTime)(realm, t), m, dt), (0, _index2.TimeWithinDay)(realm, t));

    // 5. Let u be TimeClip(UTC(newDate)).
    var u = (0, _index2.TimeClip)(realm, (0, _index2.UTC)(realm, newDate));

    // 6. Set the [[DateValue]] internal slot of this Date object to u.
    context.$DateValue = u;

    // 7. Return u.
    return u;
  });

  // ECMA262 20.3.4.26
  obj.defineNativeMethod("setSeconds", 2, function (context, _ref13, argCount) {
    var _ref14 = _slicedToArray(_ref13, 2),
        sec = _ref14[0],
        ms = _ref14[1];

    // 1. Let t be LocalTime(? thisTimeValue(this value)).
    var t = (0, _index2.LocalTime)(realm, (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value);
    (0, _invariant2.default)(context instanceof _index.ObjectValue);

    // 2. Let s be ? ToNumber(sec).
    var s = (0, _index2.ToNumber)(realm, sec);

    // 3. If ms is not specified, let milli be msFromTime(t); otherwise, let milli be ? ToNumber(ms).
    var milli = argCount >= 2 ? (0, _index2.ToNumber)(realm, ms) : (0, _index2.msFromTime)(realm, t);

    // 4. Let date be MakeDate(Day(t), MakeTime(HourFromTime(t), MinFromTime(t), s, milli)).
    var date = (0, _index2.MakeDate)(realm, (0, _index2.Day)(realm, t), (0, _index2.MakeTime)(realm, (0, _index2.HourFromTime)(realm, t), (0, _index2.MinFromTime)(realm, t), s, milli));

    // 5. Let u be TimeClip(UTC(date)).
    var u = (0, _index2.TimeClip)(realm, (0, _index2.UTC)(realm, date));

    // 6. Set the [[DateValue]] internal slot of this Date object to u.
    context.$DateValue = u;

    // 7. Return u.
    return u;
  });

  // ECMA262 20.3.4.27
  obj.defineNativeMethod("setTime", 1, function (context, _ref15) {
    var _ref16 = _slicedToArray(_ref15, 1),
        time = _ref16[0];

    // 1. Perform ? thisTimeValue(this value).
    (0, _index2.thisTimeValue)(realm, context);
    (0, _invariant2.default)(context instanceof _index.ObjectValue);

    // 2. Let t be ? ToNumber(time).
    var t = (0, _index2.ToNumber)(realm, time);

    // 3. Let v be TimeClip(t).
    var v = (0, _index2.TimeClip)(realm, t);

    // 4. Set the [[DateValue]] internal slot of this Date object to v.
    context.$DateValue = v;

    // 5. Return v.
    return v;
  });

  // ECMA262 20.3.4.28
  obj.defineNativeMethod("setUTCDate", 1, function (context, _ref17) {
    var _ref18 = _slicedToArray(_ref17, 1),
        date = _ref18[0];

    // 1. Let t be ? thisTimeValue(this value).
    var t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value;
    (0, _invariant2.default)(context instanceof _index.ObjectValue);

    // 2. Let dt be ? ToNumber(date).
    var dt = (0, _index2.ToNumber)(realm, date);

    // 3. Let newDate be MakeDate(MakeDay(YearFromTime(t), MonthFromTime(t), dt), TimeWithinDay(t)).
    var newDate = (0, _index2.MakeDate)(realm, (0, _index2.MakeDay)(realm, (0, _index2.YearFromTime)(realm, t), (0, _index2.MonthFromTime)(realm, t), dt), (0, _index2.TimeWithinDay)(realm, t));

    // 4. Let v be TimeClip(newDate).
    var v = (0, _index2.TimeClip)(realm, newDate);

    // 5. Set the [[DateValue]] internal slot of this Date object to v.
    context.$DateValue = v;

    // 6. Return v.
    return v;
  });

  // ECMA262 20.3.4.29
  obj.defineNativeMethod("setUTCFullYear", 3, function (context, _ref19, argCount) {
    var _ref20 = _slicedToArray(_ref19, 3),
        year = _ref20[0],
        month = _ref20[1],
        date = _ref20[2];

    // 1. Let t be ? thisTimeValue(this value).
    var t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value;
    (0, _invariant2.default)(context instanceof _index.ObjectValue);

    // 2. If t is NaN, let t be +0.
    if (isNaN(t)) t = +0;

    // 3. Let y be ? ToNumber(year).
    var y = (0, _index2.ToNumber)(realm, year);

    // 4. If month is not specified, let m be MonthFromTime(t); otherwise, let m be ? ToNumber(month).
    var m = argCount >= 2 ? (0, _index2.ToNumber)(realm, month) : (0, _index2.MonthFromTime)(realm, t);

    // 5. If date is not specified, let dt be DateFromTime(t); otherwise, let dt be ? ToNumber(date).
    var dt = argCount >= 3 ? (0, _index2.ToNumber)(realm, date) : (0, _index2.DateFromTime)(realm, t);

    // 6. Let newDate be MakeDate(MakeDay(y, m, dt), TimeWithinDay(t)).
    var newDate = (0, _index2.MakeDate)(realm, (0, _index2.MakeDay)(realm, y, m, dt), (0, _index2.TimeWithinDay)(realm, t));

    // 7. Let v be TimeClip(newDate).
    var v = (0, _index2.TimeClip)(realm, newDate);

    // 8. Set the [[DateValue]] internal slot of this Date object to v.
    context.$DateValue = v;

    // 9. Return v.
    return v;
  });

  // ECMA262 20.3.4.30
  obj.defineNativeMethod("setUTCHours", 4, function (context, _ref21, argCount) {
    var _ref22 = _slicedToArray(_ref21, 4),
        hour = _ref22[0],
        min = _ref22[1],
        sec = _ref22[2],
        ms = _ref22[3];

    // 1. Let t be ? thisTimeValue(this value).
    var t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value;
    (0, _invariant2.default)(context instanceof _index.ObjectValue);

    // 2. Let h be ? ToNumber(hour).
    var h = (0, _index2.ToNumber)(realm, hour);

    // 3. If min is not specified, let m be MinFromTime(t); otherwise, let m be ? ToNumber(min).
    var m = argCount >= 2 ? (0, _index2.ToNumber)(realm, min) : (0, _index2.MinFromTime)(realm, t);

    // 4. If sec is not specified, let s be SecFromTime(t); otherwise, let s be ? ToNumber(sec).
    var s = argCount >= 3 ? (0, _index2.ToNumber)(realm, sec) : (0, _index2.SecFromTime)(realm, t);

    // 5. If ms is not specified, let milli be msFromTime(t); otherwise, let milli be ? ToNumber(ms).
    var milli = argCount >= 4 ? (0, _index2.ToNumber)(realm, ms) : (0, _index2.msFromTime)(realm, t);

    // 6. Let newDate be MakeDate(Day(t), MakeTime(h, m, s, milli)).
    var newDate = (0, _index2.MakeDate)(realm, (0, _index2.Day)(realm, t), (0, _index2.MakeTime)(realm, h, m, s, milli));

    // 7. Let v be TimeClip(newDate).
    var v = (0, _index2.TimeClip)(realm, newDate);

    // 8. Set the [[DateValue]] internal slot of this Date object to v.
    context.$DateValue = v;

    // 9. Return v.
    return v;
  });

  // ECMA262 20.3.4.31
  obj.defineNativeMethod("setUTCMilliseconds", 1, function (context, _ref23) {
    var _ref24 = _slicedToArray(_ref23, 1),
        ms = _ref24[0];

    // 1. Let t be ? thisTimeValue(this value).
    var t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value;
    (0, _invariant2.default)(context instanceof _index.ObjectValue);

    // 2. Let milli be ? ToNumber(ms).
    var milli = (0, _index2.ToNumber)(realm, ms);

    // 3. Let time be MakeTime(HourFromTime(t), MinFromTime(t), SecFromTime(t), milli).
    var time = (0, _index2.MakeTime)(realm, (0, _index2.HourFromTime)(realm, t), (0, _index2.MinFromTime)(realm, t), (0, _index2.SecFromTime)(realm, t), milli);

    // 4. Let v be TimeClip(MakeDate(Day(t), time)).
    var v = (0, _index2.TimeClip)(realm, (0, _index2.MakeDate)(realm, (0, _index2.Day)(realm, t), time));

    // 5. Set the [[DateValue]] internal slot of this Date object to v.
    context.$DateValue = v;

    // 6. Return v.
    return v;
  });

  // ECMA262 20.3.4.32
  obj.defineNativeMethod("setUTCMinutes", 3, function (context, _ref25, argCount) {
    var _ref26 = _slicedToArray(_ref25, 3),
        min = _ref26[0],
        sec = _ref26[1],
        ms = _ref26[2];

    // 1. Let t be ? thisTimeValue(this value).
    var t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value;
    (0, _invariant2.default)(context instanceof _index.ObjectValue);

    // 2. Let m be ? ToNumber(min).
    var m = (0, _index2.ToNumber)(realm, min);

    // 3. If sec is not specified, let s be SecFromTime(t).
    var s = void 0;
    if (argCount < 2) {
      s = (0, _index2.SecFromTime)(realm, t);
    } else {
      // 4. Else,
      // a. Let s be ? ToNumber(sec).
      s = (0, _index2.ToNumber)(realm, sec);
    }

    // 5. If ms is not specified, let milli be msFromTime(t).
    var milli = void 0;
    if (argCount < 3) {
      milli = (0, _index2.msFromTime)(realm, t);
    } else {
      // 6. Else,
      // a. Let milli be ? ToNumber(ms).
      milli = (0, _index2.ToNumber)(realm, ms);
    }

    // 7. Let date be MakeDate(Day(t), MakeTime(HourFromTime(t), m, s, milli)).
    var date = (0, _index2.MakeDate)(realm, (0, _index2.Day)(realm, t), (0, _index2.MakeTime)(realm, (0, _index2.HourFromTime)(realm, t), m, s, milli));

    // 8. Let v be TimeClip(date).
    var v = (0, _index2.TimeClip)(realm, date);

    // 9. Set the [[DateValue]] internal slot of this Date object to v.
    context.$DateValue = v;

    // 10. Return v.
    return v;
  });

  // ECMA262 20.3.4.33
  obj.defineNativeMethod("setUTCMonth", 2, function (context, _ref27, argCount) {
    var _ref28 = _slicedToArray(_ref27, 2),
        month = _ref28[0],
        date = _ref28[1];

    // 1. Let t be ? thisTimeValue(this value).
    var t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value;
    (0, _invariant2.default)(context instanceof _index.ObjectValue);

    // 2. Let m be ? ToNumber(month).
    var m = (0, _index2.ToNumber)(realm, month);

    // 3. If date is not specified, let dt be DateFromTime(t).
    var dt = void 0;
    if (argCount < 2) {
      dt = (0, _index2.DateFromTime)(realm, t);
    } else {
      // 4. Else,
      // a. Let dt be ? ToNumber(date).
      dt = (0, _index2.ToNumber)(realm, date);
    }

    // 5. Let newDate be MakeDate(MakeDay(YearFromTime(t), m, dt), TimeWithinDay(t)).
    var newDate = (0, _index2.MakeDate)(realm, (0, _index2.MakeDay)(realm, (0, _index2.YearFromTime)(realm, t), m, dt), (0, _index2.TimeWithinDay)(realm, t));

    // 6. Let v be TimeClip(newDate).
    var v = (0, _index2.TimeClip)(realm, newDate);

    // 7. Set the [[DateValue]] internal slot of this Date object to v.
    context.$DateValue = v;

    // 8. Return v.
    return v;
  });

  // ECMA262 20.3.4.34
  obj.defineNativeMethod("setUTCSeconds", 2, function (context, _ref29, argCount) {
    var _ref30 = _slicedToArray(_ref29, 2),
        sec = _ref30[0],
        ms = _ref30[1];

    // 1. Let t be ? thisTimeValue(this value).
    var t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value;
    (0, _invariant2.default)(context instanceof _index.ObjectValue);

    // 2. Let s be ? ToNumber(sec).
    var s = (0, _index2.ToNumber)(realm, sec);

    // 3. If ms is not specified, let milli be msFromTime(t).
    var milli = void 0;
    if (argCount < 2) {
      milli = (0, _index2.msFromTime)(realm, t);
    } else {
      // 4. Else,
      // a. Let milli be ? ToNumber(ms).
      milli = (0, _index2.ToNumber)(realm, ms);
    }

    // 5. Let date be MakeDate(Day(t), MakeTime(HourFromTime(t), MinFromTime(t), s, milli)).
    var date = (0, _index2.MakeDate)(realm, (0, _index2.Day)(realm, t), (0, _index2.MakeTime)(realm, (0, _index2.HourFromTime)(realm, t), (0, _index2.MinFromTime)(realm, t), s, milli));

    // 6. Let v be TimeClip(date).
    var v = (0, _index2.TimeClip)(realm, date);

    // 7. Set the [[DateValue]] internal slot of this Date object to v.
    context.$DateValue = v;

    // 8. Return v.
    return v;
  });

  // ECMA262 20.3.4.35
  obj.defineNativeMethod("toDateString", 0, function (context) {
    throw new _errors.FatalError("TODO #1005: implement Date.prototype.toDateString");
  });

  // ECMA262 20.3.4.36
  obj.defineNativeMethod("toISOString", 0, function (context) {
    var t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value;
    if (!isFinite(t)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError);
    }

    return new _index.StringValue(realm, new Date(t).toISOString());
  });

  // ECMA262 20.3.4.37
  obj.defineNativeMethod("toJSON", 1, function (context, _ref31) {
    var _ref32 = _slicedToArray(_ref31, 1),
        key = _ref32[0];

    // 1. Let O be ? ToObject(this value).
    var O = (0, _index2.ToObject)(realm, context.throwIfNotConcrete());

    // 2. Let tv be ? ToPrimitive(O, hint Number).
    var tv = (0, _index2.ToPrimitive)(realm, O, "number");

    // 3. If Type(tv) is Number and tv is not finite, return null.
    if (tv instanceof _index.NumberValue && !isFinite(tv.value)) {
      return realm.intrinsics.null;
    }

    // 4. Return ? Invoke(O, "toISOString").
    return (0, _index2.Invoke)(realm, O, "toISOString");
  });

  // ECMA262 20.3.4.38
  obj.defineNativeMethod("toLocaleDateString", 0, function (context) {
    throw new _errors.FatalError("TODO #1005: implement Date.prototype.toLocaleDateString");
  });

  // ECMA262 20.3.4.39
  obj.defineNativeMethod("toLocaleString", 0, function (context) {
    throw new _errors.FatalError("TODO #1005: implement Date.prototype.toLocaleString");
  });

  // ECMA262 20.3.4.40
  obj.defineNativeMethod("toLocaleTimeString", 0, function (context) {
    throw new _errors.FatalError("TODO #1005: implement Date.prototype.toLocaleTimeString");
  });

  // ECMA262 20.3.4.41
  obj.defineNativeMethod("toString", 0, function (context) {
    // 1. Let O be this Date object.
    var O = context;

    // 2. If O does not have a [[DateValue]] internal slot, then
    var tv = void 0;
    if (O.$DateValue === undefined) {
      // a. Let tv be NaN.
      tv = NaN;
    } else {
      // 3. Else,
      // a. Let tv be thisTimeValue(O).
      tv = (0, _index2.thisTimeValue)(realm, O).throwIfNotConcreteNumber().value;
    }

    // 4. Return ToDateString(tv).
    return new _index.StringValue(realm, (0, _index2.ToDateString)(realm, tv));
  });

  // ECMA262 20.3.4.42
  obj.defineNativeMethod("toTimeString", 0, function (context) {
    throw new _errors.FatalError("TODO #1005: implement Date.prototype.toTimeString");
  });

  // ECMA262 20.3.4.43
  obj.defineNativeMethod("toUTCString", 0, function (context) {
    throw new _errors.FatalError("TODO #1005: implement Date.prototype.toUTCString");
  });

  // ECMA262 20.3.4.44
  obj.defineNativeMethod("valueOf", 0, function (context) {
    // 1. Return ? thisTimeValue(this value).
    return (0, _index2.thisTimeValue)(realm, context);
  });

  // ECMA262 20.3.4.45
  obj.defineNativeMethod(realm.intrinsics.SymbolToPrimitive, 1, function (context, _ref33) {
    var _ref34 = _slicedToArray(_ref33, 1),
        hint = _ref34[0];

    // 1. Let O be the this value.
    var O = context.throwIfNotConcrete();

    // 2. If Type(O) is not Object, throw a TypeError exception.
    if (!(O instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(O) is not Object");
    }

    var tryFirst = void 0;
    hint = hint.throwIfNotConcrete();
    // 3. If hint is the String value "string" or the String value "default", then
    if (hint instanceof _index.StringValue && (hint.value === "string" || hint.value === "default")) {
      // a. Let tryFirst be "string".
      tryFirst = "string";
    } else if (hint instanceof _index.StringValue && hint.value === "number") {
      // 4. Else if hint is the String value "number", then
      // a. Let tryFirst be "number".
      tryFirst = "number";
    } else {
      // 5. Else, throw a TypeError exception.
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(O) is not Object");
    }

    // 6. Return ? OrdinaryToPrimitive(O, tryFirst).
    return (0, _index2.OrdinaryToPrimitive)(realm, O, tryFirst);
  }, { writable: false });

  // B.2.4.1
  obj.defineNativeMethod("getYear", 0, function (context) {
    // 1. Let t be ? thisTimeValue(this value).
    var t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value;

    // 2. If t is NaN, return NaN.
    if (isNaN(t)) return realm.intrinsics.NaN;

    // 3. Return YearFromTime(LocalTime(t)) - 1900.
    return new _index.NumberValue(realm, (0, _index2.YearFromTime)(realm, (0, _index2.LocalTime)(realm, t)) - 1900);
  });

  // B.2.4.2
  obj.defineNativeMethod("setYear", 1, function (context, _ref35) {
    var _ref36 = _slicedToArray(_ref35, 1),
        year = _ref36[0];

    // 1. Let t be ? thisTimeValue(this value).
    var t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value;
    (0, _invariant2.default)(context instanceof _index.ObjectValue);

    // 2. If t is NaN, let t be +0; otherwise, let t be LocalTime(t).
    t = isNaN(t) ? +0 : (0, _index2.LocalTime)(realm, t);

    // 3. Let y be ? ToNumber(year).
    var y = (0, _index2.ToNumber)(realm, year);

    // 4. If y is NaN, set the [[DateValue]] internal slot of this Date object to NaN and return NaN.
    if (isNaN(y)) {
      context.$DateValue = realm.intrinsics.NaN;
      return realm.intrinsics.NaN;
    }

    // 5. If y is not NaN and 0 ≤ ToInteger(y) ≤ 99, let yyyy be ToInteger(y) + 1900.
    var yyyy = void 0;
    if ((0, _index2.ToInteger)(realm, y) < 99) {
      yyyy = (0, _index2.ToInteger)(realm, y) + 1900;
    } else {
      // 6. Else, let yyyy be y.
      yyyy = y;
    }

    // 7. Let d be MakeDay(yyyy, MonthFromTime(t), DateFromTime(t)).
    var d = (0, _index2.MakeDay)(realm, yyyy, (0, _index2.MonthFromTime)(realm, t), (0, _index2.DateFromTime)(realm, t));

    // 8. Let date be UTC(MakeDate(d, TimeWithinDay(t))).
    var date = (0, _index2.UTC)(realm, (0, _index2.MakeDate)(realm, d, (0, _index2.TimeWithinDay)(realm, t)));

    // 9. Set the [[DateValue]] internal slot of this Date object to TimeClip(date).
    var dateValue = (0, _index2.TimeClip)(realm, date);
    context.$DateValue = dateValue;

    // 10. Return the value of the [[DateValue]] internal slot of this Date object.
    return dateValue;
  });

  // B.2.4.3
  obj.defineNativeProperty("toGMTString", obj.$Get("toUTCString", obj));
};

var _errors = require("../../errors.js");

var _index = require("../../values/index.js");

var _index2 = require("../../methods/index.js");

var _invariant = require("../../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
//# sourceMappingURL=DatePrototype.js.map