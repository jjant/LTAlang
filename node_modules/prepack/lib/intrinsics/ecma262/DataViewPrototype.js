"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Copyright (c) 2017-present, Facebook, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * This source code is licensed under the BSD-style license found in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * LICENSE file in the root directory of this source tree. An additional grant
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * of patent rights can be found in the PATENTS file in the same directory.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */

exports.default = function (realm, obj) {
  // ECMA262 24.2.4.1
  obj.defineNativeGetter("buffer", function (context) {
    // 1. Let O be the this value.
    var O = context.throwIfNotConcrete();

    // 2. If Type(O) is not Object, throw a TypeError exception.
    if (!(O instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(O) is not Object");
    }

    // 3. If O does not have a [[DataView]] internal slot, throw a TypeError exception.
    if (!("$DataView" in O)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "O does not have a [[DataView]] internal slot");
    }

    // 4. Assert: O has a [[ViewedArrayBuffer]] internal slot.
    (0, _invariant2.default)(O.$ViewedArrayBuffer);

    // 5. Let buffer be O.[[ViewedArrayBuffer]].
    var buffer = O.$ViewedArrayBuffer;

    // 6. Return buffer.
    return buffer;
  });

  // ECMA262 24.2.4.2
  obj.defineNativeGetter("byteLength", function (context) {
    // 1. Let O be the this value.
    var O = context.throwIfNotConcrete();

    // 2. If Type(O) is not Object, throw a TypeError exception.
    if (!(O instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(O) is not Object");
    }

    // 3. If O does not have a [[DataView]] internal slot, throw a TypeError exception.
    if (!("$DataView" in O)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "O does not have a [[DataView]] internal slot");
    }

    // 4. Assert: O has a [[ViewedArrayBuffer]] internal slot.
    (0, _invariant2.default)(O.$ViewedArrayBuffer);

    // 5. Let buffer be O.[[ViewedArrayBuffer]].
    var buffer = O.$ViewedArrayBuffer;

    // 6. If IsDetachedBuffer(buffer) is true, throw a TypeError exception.
    if ((0, _is.IsDetachedBuffer)(realm, buffer) === true) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "IsDetachedBuffer(buffer) is true");
    }

    // 7. Let size be O.[[ByteLength]].
    var size = O.$ByteLength;
    (0, _invariant2.default)(typeof size === "number");

    // 8. Return size.
    return new _index.NumberValue(realm, size);
  });

  // ECMA262 24.2.4.3
  obj.defineNativeGetter("byteOffset", function (context) {
    // 1. Let O be the this value.
    var O = context.throwIfNotConcrete();

    // 2. If Type(O) is not Object, throw a TypeError exception.
    if (!(O instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(O) is not Object");
    }

    // 3. If O does not have a [[DataView]] internal slot, throw a TypeError exception.
    if (!("$DataView" in O)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "O does not have a [[DataView]] internal slot");
    }

    // 4. Assert: O has a [[ViewedArrayBuffer]] internal slot.
    (0, _invariant2.default)(O.$ViewedArrayBuffer);

    // 5. Let buffer be O.[[ViewedArrayBuffer]].
    var buffer = O.$ViewedArrayBuffer;

    // 6. If IsDetachedBuffer(buffer) is true, throw a TypeError exception.
    if ((0, _is.IsDetachedBuffer)(realm, buffer) === true) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "IsDetachedBuffer(buffer) is true");
    }

    // 7. Let offset be O.[[ByteOffset]].
    var offset = O.$ByteOffset;
    (0, _invariant2.default)(typeof offset === "number");

    // 8. Return offset.
    return new _index.NumberValue(realm, offset);
  });

  // ECMA262 24.2.4.5
  obj.defineNativeMethod("getFloat32", 1, function (context, _ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        byteOffset = _ref2[0],
        littleEndian = _ref2[1];

    // 1. Let v be the this value.
    var v = context;

    // 2. If littleEndian is not present, let littleEndian be false.
    if (!littleEndian) littleEndian = realm.intrinsics.false;

    // 3. Return ? GetViewValue(v, byteOffset, littleEndian, "Float32").
    return (0, _arraybuffer.GetViewValue)(realm, v, byteOffset, littleEndian, "Float32");
  });

  // ECMA262 24.2.4.6
  obj.defineNativeMethod("getFloat64", 1, function (context, _ref3) {
    var _ref4 = _slicedToArray(_ref3, 2),
        byteOffset = _ref4[0],
        littleEndian = _ref4[1];

    // 1. Let v be the this value.
    var v = context;

    // 2. If littleEndian is not present, let littleEndian be false.
    if (!littleEndian) littleEndian = realm.intrinsics.false;

    // 3. Return ? GetViewValue(v, byteOffset, littleEndian, "Float64").
    return (0, _arraybuffer.GetViewValue)(realm, v, byteOffset, littleEndian, "Float64");
  });

  // ECMA262 24.2.4.7
  obj.defineNativeMethod("getInt8", 1, function (context, _ref5) {
    var _ref6 = _slicedToArray(_ref5, 1),
        byteOffset = _ref6[0];

    // 1. Let v be the this value.
    var v = context;

    // 2. Return ? GetViewValue(v, byteOffset, true, "Int8").
    return (0, _arraybuffer.GetViewValue)(realm, v, byteOffset, realm.intrinsics.true, "Int8");
  });

  // ECMA262 24.2.4.8
  obj.defineNativeMethod("getInt16", 1, function (context, _ref7) {
    var _ref8 = _slicedToArray(_ref7, 2),
        byteOffset = _ref8[0],
        littleEndian = _ref8[1];

    // 1. Let v be the this value.
    var v = context;

    // 2. If littleEndian is not present, let littleEndian be false.
    if (!littleEndian) littleEndian = realm.intrinsics.false;

    // 3. Return ? GetViewValue(v, byteOffset, littleEndian, "Int16").
    return (0, _arraybuffer.GetViewValue)(realm, v, byteOffset, littleEndian, "Int16");
  });

  // ECMA262 24.2.4.9
  obj.defineNativeMethod("getInt32", 1, function (context, _ref9) {
    var _ref10 = _slicedToArray(_ref9, 2),
        byteOffset = _ref10[0],
        littleEndian = _ref10[1];

    // 1. Let v be the this value.
    var v = context;

    // 2. If littleEndian is not present, let littleEndian be false.
    if (!littleEndian) littleEndian = realm.intrinsics.false;

    // 3. Return ? GetViewValue(v, byteOffset, littleEndian, "Int32").
    return (0, _arraybuffer.GetViewValue)(realm, v, byteOffset, littleEndian, "Int32");
  });

  // ECMA262 24.2.4.10
  obj.defineNativeMethod("getUint8", 1, function (context, _ref11) {
    var _ref12 = _slicedToArray(_ref11, 1),
        byteOffset = _ref12[0];

    // 1. Let v be the this value.
    var v = context;

    // 2. Return ? GetViewValue(v, byteOffset, true, "Uint8").
    return (0, _arraybuffer.GetViewValue)(realm, v, byteOffset, realm.intrinsics.true, "Uint8");
  });

  // ECMA262 24.2.4.11
  obj.defineNativeMethod("getUint16", 1, function (context, _ref13) {
    var _ref14 = _slicedToArray(_ref13, 2),
        byteOffset = _ref14[0],
        littleEndian = _ref14[1];

    // 1. Let v be the this value.
    var v = context;

    // 2. If littleEndian is not present, let littleEndian be false.
    if (!littleEndian) littleEndian = realm.intrinsics.false;

    // 3. Return ? GetViewValue(v, byteOffset, littleEndian, "Uint16").
    return (0, _arraybuffer.GetViewValue)(realm, v, byteOffset, littleEndian, "Uint16");
  });

  // ECMA262 24.2.4.12
  obj.defineNativeMethod("getUint32", 1, function (context, _ref15) {
    var _ref16 = _slicedToArray(_ref15, 2),
        byteOffset = _ref16[0],
        littleEndian = _ref16[1];

    // 1. Let v be the this value.
    var v = context;

    // 2. If littleEndian is not present, let littleEndian be false.
    if (!littleEndian) littleEndian = realm.intrinsics.false;

    // 3. Return ? GetViewValue(v, byteOffset, littleEndian, "Uint32").
    return (0, _arraybuffer.GetViewValue)(realm, v, byteOffset, littleEndian, "Uint32");
  });

  // ECMA262 24.2.4.13
  obj.defineNativeMethod("setFloat32", 2, function (context, _ref17) {
    var _ref18 = _slicedToArray(_ref17, 3),
        byteOffset = _ref18[0],
        value = _ref18[1],
        littleEndian = _ref18[2];

    // 1. Let v be the this value.
    var v = context;

    // 2. If littleEndian is not present, let littleEndian be false.
    if (!littleEndian) littleEndian = realm.intrinsics.false;

    // 3. Return ? SetViewValue(v, byteOffset, littleEndian, "Float32", value).
    return (0, _arraybuffer.SetViewValue)(realm, v, byteOffset, littleEndian, "Float32", value);
  });

  // ECMA262 24.2.4.14
  obj.defineNativeMethod("setFloat64", 2, function (context, _ref19) {
    var _ref20 = _slicedToArray(_ref19, 3),
        byteOffset = _ref20[0],
        value = _ref20[1],
        littleEndian = _ref20[2];

    // 1. Let v be the this value.
    var v = context;

    // 2. If littleEndian is not present, let littleEndian be false.
    if (!littleEndian) littleEndian = realm.intrinsics.false;

    // 3. Return ? SetViewValue(v, byteOffset, littleEndian, "Float64", value).
    return (0, _arraybuffer.SetViewValue)(realm, v, byteOffset, littleEndian, "Float64", value);
  });

  // ECMA262 24.2.4.15
  obj.defineNativeMethod("setInt8", 2, function (context, _ref21) {
    var _ref22 = _slicedToArray(_ref21, 2),
        byteOffset = _ref22[0],
        value = _ref22[1];

    // 1. Let v be the this value.
    var v = context;

    // 2. Return ? SetViewValue(v, byteOffset, true, "Int8", value).
    return (0, _arraybuffer.SetViewValue)(realm, v, byteOffset, realm.intrinsics.true, "Int8", value);
  });

  // ECMA262 24.2.4.16
  obj.defineNativeMethod("setInt16", 2, function (context, _ref23) {
    var _ref24 = _slicedToArray(_ref23, 3),
        byteOffset = _ref24[0],
        value = _ref24[1],
        littleEndian = _ref24[2];

    // 1. Let v be the this value.
    var v = context;

    // 2. If littleEndian is not present, let littleEndian be false.
    if (!littleEndian) littleEndian = realm.intrinsics.false;

    // 3. Return ? SetViewValue(v, byteOffset, littleEndian, "Int16", value).
    return (0, _arraybuffer.SetViewValue)(realm, v, byteOffset, littleEndian, "Int16", value);
  });

  // ECMA262 24.2.4.17
  obj.defineNativeMethod("setInt32", 2, function (context, _ref25) {
    var _ref26 = _slicedToArray(_ref25, 3),
        byteOffset = _ref26[0],
        value = _ref26[1],
        littleEndian = _ref26[2];

    // 1. Let v be the this value.
    var v = context;

    // 2. If littleEndian is not present, let littleEndian be false.
    if (!littleEndian) littleEndian = realm.intrinsics.false;

    // 3. Return ? SetViewValue(v, byteOffset, littleEndian, "Int32", value).
    return (0, _arraybuffer.SetViewValue)(realm, v, byteOffset, littleEndian, "Int32", value);
  });

  // ECMA262 24.2.4.18
  obj.defineNativeMethod("setUint8", 2, function (context, _ref27) {
    var _ref28 = _slicedToArray(_ref27, 2),
        byteOffset = _ref28[0],
        value = _ref28[1];

    // 1. Let v be the this value.
    var v = context;

    // 2. Return ? SetViewValue(v, byteOffset, true, "Uint8", value).
    return (0, _arraybuffer.SetViewValue)(realm, v, byteOffset, realm.intrinsics.true, "Uint8", value);
  });

  // ECMA262 24.2.4.19
  obj.defineNativeMethod("setUint16", 2, function (context, _ref29) {
    var _ref30 = _slicedToArray(_ref29, 3),
        byteOffset = _ref30[0],
        value = _ref30[1],
        littleEndian = _ref30[2];

    // 1. Let v be the this value.
    var v = context;

    // 2. If littleEndian is not present, let littleEndian be false.
    if (!littleEndian) littleEndian = realm.intrinsics.false;

    // 3. Return ? SetViewValue(v, byteOffset, littleEndian, "Uint16", value).
    return (0, _arraybuffer.SetViewValue)(realm, v, byteOffset, littleEndian, "Uint16", value);
  });

  // ECMA262 24.2.4.20
  obj.defineNativeMethod("setUint32", 2, function (context, _ref31) {
    var _ref32 = _slicedToArray(_ref31, 3),
        byteOffset = _ref32[0],
        value = _ref32[1],
        littleEndian = _ref32[2];

    // 1. Let v be the this value.
    var v = context;

    // 2. If littleEndian is not present, let littleEndian be false.
    if (!littleEndian) littleEndian = realm.intrinsics.false;

    // 3. Return ? SetViewValue(v, byteOffset, littleEndian, "Uint32", value).
    return (0, _arraybuffer.SetViewValue)(realm, v, byteOffset, littleEndian, "Uint32", value);
  });

  // ECMA26224.2.4.21
  obj.defineNativeProperty(realm.intrinsics.SymbolToStringTag, new _index.StringValue(realm, "DataView"), { writable: false });
};

var _index = require("../../values/index.js");

var _is = require("../../methods/is.js");

var _arraybuffer = require("../../methods/arraybuffer.js");

var _invariant = require("../../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
//# sourceMappingURL=DataViewPrototype.js.map