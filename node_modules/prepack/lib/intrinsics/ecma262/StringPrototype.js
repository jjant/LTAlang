"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Copyright (c) 2017-present, Facebook, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * This source code is licensed under the BSD-style license found in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * LICENSE file in the root directory of this source tree. An additional grant
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * of patent rights can be found in the PATENTS file in the same directory.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */

exports.default = function (realm, obj) {
  // ECMA262 21.1.3
  obj.$StringData = realm.intrinsics.emptyString;

  // ECMA262 21.1.3
  obj.defineNativeProperty("length", realm.intrinsics.zero);

  // ECMA262 21.1.3.1
  obj.defineNativeMethod("charAt", 1, function (context, _ref) {
    var _ref2 = _slicedToArray(_ref, 1),
        pos = _ref2[0];

    // 1. Let O be ? RequireObjectCoercible(this value).
    var O = (0, _abstract.RequireObjectCoercible)(realm, context);

    // 2. Let S be ? ToString(O).
    var S = (0, _to.ToString)(realm, O.throwIfNotConcrete());

    // 3. Let position be ? ToInteger(pos).
    var position = (0, _to.ToInteger)(realm, pos);

    // 4. Let size be the number of elements in S.
    var size = S.length;

    // 5. If position < 0 or position ≥ size, return the empty String.
    if (position < 0 || position >= size) return realm.intrinsics.emptyString;

    // 6. Return a String of length 1, containing one code unit from S, namely the code unit at index position.
    return new _index.StringValue(realm, S.charAt(position));
  });

  // ECMA262 21.1.3.2
  obj.defineNativeMethod("charCodeAt", 1, function (context, _ref3) {
    var _ref4 = _slicedToArray(_ref3, 1),
        pos = _ref4[0];

    // 1. Let O be ? RequireObjectCoercible(this value).
    var O = (0, _abstract.RequireObjectCoercible)(realm, context);

    // 2. Let S be ? ToString(O).
    var S = (0, _to.ToString)(realm, O.throwIfNotConcrete());

    // 3. Let position be ? ToInteger(pos).
    var position = (0, _to.ToInteger)(realm, pos);

    // 4. Let size be the number of elements in S.
    var size = S.length;

    // 5. If position < 0 or position ≥ size, return NaN.
    if (position < 0 || position >= size) return realm.intrinsics.NaN;

    // 6. Return a value of Number type, whose value is the code unit value of the element at index position
    //    in the String S.
    return new _index.NumberValue(realm, S.charCodeAt(position));
  });

  // ECMA262 21.1.3.3
  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION)) obj.defineNativeMethod("codePointAt", 1, function (context, _ref5) {
    var _ref6 = _slicedToArray(_ref5, 1),
        pos = _ref6[0];

    // 1. Let O be ? RequireObjectCoercible(this value).
    var O = (0, _abstract.RequireObjectCoercible)(realm, context);

    // 2. Let S be ? ToString(O).
    var S = (0, _to.ToString)(realm, O.throwIfNotConcrete());

    // 3. Let position be ? ToInteger(pos).
    var position = (0, _to.ToInteger)(realm, pos);

    // 4. Let size be the number of elements in S.
    var size = S.length;

    // 5. If position < 0 or position ≥ size, return undefined.
    if (position < 0 || position >= size) return realm.intrinsics.undefined;

    // 6. Let first be the code unit value of the element at index position in the String S.
    // 7. If first < 0xD800 or first > 0xDBFF or position+1 = size, return first.
    // 8. Let second be the code unit value of the element at index position+1 in the String S.
    // 9. If second < 0xDC00 or second > 0xDFFF, return first.
    // 10. Return UTF16Decode(first, second).
    return new _index.NumberValue(realm, S.codePointAt(position));
  });

  // ECMA262 21.1.3.4
  obj.defineNativeMethod("concat", 1, function (context, args, argCount) {
    // 1. Let O be ? RequireObjectCoercible(this value).
    var O = (0, _abstract.RequireObjectCoercible)(realm, context);

    // 2. Let S be ? ToString(O).
    var S = (0, _to.ToString)(realm, O.throwIfNotConcrete());

    // 3. Let args be a List whose elements are the arguments passed to this function.
    args = argCount === 0 ? [] : args;

    // 4. Let R be S.
    var R = S;

    // 5. Repeat, while args is not empty
    while (args.length) {
      // a. Remove the first element from args and let next be the value of that element.
      var next = args.shift();

      // b. Let nextString be ? ToString(next).
      var nextString = (0, _to.ToStringPartial)(realm, next);

      // c. Let R be the String value consisting of the code units of the previous value of R followed by the code units of nextString.
      R = R + nextString;
    }

    // 6. Return R.
    return new _index.StringValue(realm, R);
  });

  // ECMA262 21.1.3.6
  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION)) obj.defineNativeMethod("endsWith", 1, function (context, _ref7) {
    var _ref8 = _slicedToArray(_ref7, 2),
        searchString = _ref8[0],
        endPosition = _ref8[1];

    // 1. Let O be ? RequireObjectCoercible(this value).
    var O = (0, _abstract.RequireObjectCoercible)(realm, context);

    // 2. Let S be ? ToString(O).
    var S = (0, _to.ToString)(realm, O.throwIfNotConcrete());

    // 3. Let isRegExp be ? IsRegExp(searchString).
    var isRegExp = (0, _is.IsRegExp)(realm, searchString);

    // 4. If isRegExp is true, throw a TypeError exception.
    if (isRegExp) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "String.prototype");
    }

    // 5. Let searchStr be ? ToString(searchString).
    var searchStr = (0, _to.ToStringPartial)(realm, searchString);

    // 6. Let len be the number of elements in S.
    var len = S.length;

    // 7. If endPosition is undefined, let pos be len, else let pos be ? ToInteger(endPosition).)
    var pos = void 0;
    if (!endPosition || endPosition instanceof _index.UndefinedValue) {
      pos = len;
    } else {
      pos = (0, _to.ToInteger)(realm, endPosition.throwIfNotConcrete());
    }

    // 8. Let end be min(max(pos, 0), len).
    var end = Math.min(Math.max(pos, 0), len);

    // 9. Let searchLength be the number of elements in searchStr.
    var searchLength = searchStr.length;

    // 10. Let start be end - searchLength.
    var start = end - searchLength;

    // 11. If start is less than 0, return false.
    if (start < 0) return realm.intrinsics.false;

    // 12. If the sequence of elements of S starting at start of length searchLength is the same as the full
    //     element sequence of searchStr, return true.
    if (S.substr(start, searchLength) === searchStr) return realm.intrinsics.true;

    // 13. Otherwise, return false.
    return realm.intrinsics.false;
  });

  // ECMA262 21.1.3.7
  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION)) obj.defineNativeMethod("includes", 1, function (context, _ref9) {
    var _ref10 = _slicedToArray(_ref9, 2),
        searchString = _ref10[0],
        position = _ref10[1];

    // 1. Let O be ? RequireObjectCoercible(this value).
    var O = (0, _abstract.RequireObjectCoercible)(realm, context);

    // 2. Let S be ? ToString(O).
    var S = (0, _to.ToString)(realm, O.throwIfNotConcrete());

    // 3. Let isRegExp be ? IsRegExp(searchString).
    var isRegExp = (0, _is.IsRegExp)(realm, searchString);

    // 4. If isRegExp is true, throw a TypeError exception.
    if (isRegExp) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "String.prototype");
    }

    // 5. Let searchStr be ? ToString(searchString).
    var searchStr = (0, _to.ToStringPartial)(realm, searchString);

    // 6. Let pos be ? ToInteger(position). (If position is undefined, this step produces the value 0.)
    var pos = (0, _to.ToInteger)(realm, position || realm.intrinsics.undefined);

    // 7. Let len be the number of elements in S.
    var len = S.length;

    // 8. Let start be min(max(pos, 0), len).
    var start = Math.min(Math.max(pos, 0), len);

    // 9. Let searchLen be the number of elements in searchStr.
    var searchLen = searchStr.length;

    // 10. If there exists any integer k not smaller than start such that k + searchLen is not greater than
    //     len, and for all nonnegative integers j less than searchLen, the code unit at index k+j of S is the
    //     same as the code unit at index j of searchStr, return true; but if there is no such integer k,
    //     return false.
    if (searchLen === 0) {
      return realm.intrinsics.true;
    } else {
      for (var k = start; k + searchLen <= len; ++k) {
        var found = true;
        for (var j = 0; j < searchLen; ++j) {
          if (S.charCodeAt(k + j) !== searchStr.charCodeAt(j)) {
            found = false;
          }
        }
        if (found) return realm.intrinsics.true;
      }
      return realm.intrinsics.false;
    }
  });

  // ECMA262 21.1.3.8
  obj.defineNativeMethod("indexOf", 1, function (context, _ref11) {
    var _ref12 = _slicedToArray(_ref11, 2),
        searchString = _ref12[0],
        position = _ref12[1];

    // 1. Let O be ? RequireObjectCoercible(this value).
    var O = (0, _abstract.RequireObjectCoercible)(realm, context);

    // 2. Let S be ? ToString(O).
    var S = (0, _to.ToString)(realm, O.throwIfNotConcrete());

    // 3. Let searchStr be ? ToString(searchString).
    var searchStr = (0, _to.ToStringPartial)(realm, searchString);

    // 4. Let pos be ? ToInteger(position). (If position is undefined, this step produces the value 0.)
    var pos = position ? (0, _to.ToInteger)(realm, position) : 0;

    // 5. Let len be the number of elements in S.
    // 6. Let start be min(max(pos, 0), len).
    // 7. Let searchLen be the number of elements in searchStr.
    // 8. Return the smallest possible integer k not smaller than start such that k+searchLen is not greater
    //    than len, and for all nonnegative integers j less than searchLen, the code unit at index k+j of S is
    //    the same as the code unit at index j of searchStr; but if there is no such integer k, return the
    //    value -1.
    return new _index.NumberValue(realm, S.indexOf(searchStr, pos));
  });

  // ECMA262 21.1.3.9
  obj.defineNativeMethod("lastIndexOf", 1, function (context, _ref13) {
    var _ref14 = _slicedToArray(_ref13, 2),
        searchString = _ref14[0],
        position = _ref14[1];

    // 1. Let O be ? RequireObjectCoercible(this value).
    var O = (0, _abstract.RequireObjectCoercible)(realm, context);

    // 2. Let S be ? ToString(O).
    var S = (0, _to.ToString)(realm, O.throwIfNotConcrete());

    // 3. Let searchStr be ? ToString(searchString).
    var searchStr = (0, _to.ToStringPartial)(realm, searchString);

    // 4. Let numPos be ? ToNumber(position). (If position is undefined, this step produces the value NaN.)
    var numPos = (0, _to.ToNumber)(realm, position || realm.intrinsics.undefined);

    // 5. If numPos is NaN, let pos be +∞; otherwise, let pos be ToInteger(numPos).
    var pos = void 0;
    if (isNaN(numPos)) {
      pos = Infinity;
    } else {
      pos = (0, _to.ToInteger)(realm, numPos);
    }

    // 6. Let len be the number of elements in S.
    // 7. Let start be min(max(pos, 0), len).
    // 8. Let searchLen be the number of elements in searchStr.
    // 9. Return the largest possible nonnegative integer k not larger than start such that k+searchLen is not
    //    greater than len, and for all nonnegative integers j less than searchLen, the code unit at index k+j
    //    of S is the same as the code unit at index j of searchStr; but if there is no such integer k, return
    //    the value -1.
    return new _index.NumberValue(realm, S.lastIndexOf(searchStr, pos));
  });

  // ECMA262 21.1.3.10
  obj.defineNativeMethod("localeCompare", 1, function (context, _ref15) {
    var _ref16 = _slicedToArray(_ref15, 1),
        that = _ref16[0];

    // 1. Let O be ? RequireObjectCoercible(this value).
    var O = (0, _abstract.RequireObjectCoercible)(realm, context);

    // 2. Let S be ? ToString(O).
    var S = (0, _to.ToString)(realm, O.throwIfNotConcrete());

    // 3. Let That be ? ToString(that).
    var That = (0, _to.ToStringPartial)(realm, that);

    return new _index.NumberValue(realm, S.localeCompare(That));
  });

  // ECMA262 21.1.3.11
  obj.defineNativeMethod("match", 1, function (context, _ref17) {
    var _ref18 = _slicedToArray(_ref17, 1),
        regexp = _ref18[0];

    // 1. Let O be ? RequireObjectCoercible(this value).
    var O = (0, _abstract.RequireObjectCoercible)(realm, context);

    // 2. If regexp is neither undefined nor null, then
    if (!(0, _has.HasSomeCompatibleType)(regexp, _index.UndefinedValue, _index.NullValue)) {
      // a. Let matcher be ? GetMethod(regexp, @@match).
      var matcher = (0, _get.GetMethod)(realm, regexp, realm.intrinsics.SymbolMatch);

      // b. If matcher is not undefined, then
      if (!matcher.mightBeUndefined()) {
        // i. Return ? Call(matcher, regexp, « O »).
        return (0, _call.Call)(realm, matcher, regexp, [O]);
      }
      matcher.throwIfNotConcrete();
    }

    // 3. Let S be ? ToString(O).
    var S = new _index.StringValue(realm, (0, _to.ToStringPartial)(realm, O));

    // 4. Let rx be ? RegExpCreate(regexp, undefined).
    var rx = (0, _regexp.RegExpCreate)(realm, regexp, undefined);

    // 5. Return ? Invoke(rx, @@match, « S »).
    return (0, _call.Invoke)(realm, rx, realm.intrinsics.SymbolMatch, [S]);
  });

  // ECMA262 21.1.3.12
  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION)) obj.defineNativeMethod("normalize", 0, function (context, _ref19) {
    var _ref20 = _slicedToArray(_ref19, 1),
        form = _ref20[0];

    // 1. Let O be ? RequireObjectCoercible(this value).
    var O = (0, _abstract.RequireObjectCoercible)(realm, context);

    // 2. Let S be ? ToString(O).
    var S = (0, _to.ToString)(realm, O.throwIfNotConcrete());

    // 3. If form is not provided or form is undefined, let form be "NFC".
    if (!form || form instanceof _index.UndefinedValue) form = new _index.StringValue(realm, "NFC");

    // 4. Let f be ? ToString(form).
    var f = (0, _to.ToStringPartial)(realm, form);

    // 5. If f is not one of "NFC", "NFD", "NFKC", or "NFKD", throw a RangeError exception.
    if (f !== "NFC" && f !== "NFD" && f !== "NFKC" && f !== "NFKD") {
      throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError);
    }

    // 6. Let ns be the String value that is the result of normalizing S into the normalization form named by
    //    f as specified in http://www.unicode.org/reports/tr15/tr15-29.html.
    // 7. Return ns.
    return new _index.StringValue(realm, S.normalize(f));
  });

  // ECMA262 21.1.3.13
  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION)) obj.defineNativeMethod("padEnd", 1, function (context, _ref21) {
    var _ref22 = _slicedToArray(_ref21, 2),
        maxLength = _ref22[0],
        fillString = _ref22[1];

    // 1. Let O be ? RequireObjectCoercible(this value).
    var O = (0, _abstract.RequireObjectCoercible)(realm, context);

    // 2. Let S be ? ToString(O).
    var S = (0, _to.ToString)(realm, O.throwIfNotConcrete());

    // 3. Let intMaxLength be ? ToLength(maxLength).
    var intMaxLength = (0, _to.ToLength)(realm, maxLength);

    // 4. Let stringLength be the number of elements in S.
    var stringLength = S.length;

    // 5. If intMaxLength is not greater than stringLength, return S.
    if (intMaxLength <= stringLength) return new _index.StringValue(realm, S);

    var filler = void 0;
    // 6. If fillString is undefined, let filler be a String consisting solely of the code unit 0x0020 (SPACE).
    if (!fillString || fillString instanceof _index.UndefinedValue) filler = " ";else
      // 7. Else, let filler be ? ToString(fillString).
      filler = (0, _to.ToStringPartial)(realm, fillString);

    // 8. If filler is the empty String, return S.
    if (filler === "") return new _index.StringValue(realm, S);

    // 9. Let fillLen be intMaxLength - stringLength.
    var fillLen = intMaxLength - stringLength;

    // 10. Let truncatedStringFiller be a new String value consisting of repeated concatenations of filler truncated to length fillLen.
    var truncatedStringFiller = filler.repeat(Math.ceil(fillLen / filler.length)).substr(0, fillLen);

    // 11. Return a new String value computed by the concatenation of S and truncatedStringFiller.
    return new _index.StringValue(realm, S + truncatedStringFiller);
  });

  // ECMA262 21.1.3.14
  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION)) obj.defineNativeMethod("padStart", 1, function (context, _ref23) {
    var _ref24 = _slicedToArray(_ref23, 2),
        maxLength = _ref24[0],
        fillString = _ref24[1];

    // 1. Let O be ? RequireObjectCoercible(this value).
    var O = (0, _abstract.RequireObjectCoercible)(realm, context);

    // 2. Let S be ? ToString(O).
    var S = (0, _to.ToString)(realm, O.throwIfNotConcrete());

    // 3. Let intMaxLength be ? ToLength(maxLength).
    var intMaxLength = (0, _to.ToLength)(realm, maxLength);

    // 4. Let stringLength be the number of elements in S.
    var stringLength = S.length;

    // 5. If intMaxLength is not greater than stringLength, return S.
    if (intMaxLength <= stringLength) return new _index.StringValue(realm, S);

    var filler = void 0;
    // 6. If fillString is undefined, let filler be a String consisting solely of the code unit 0x0020 (SPACE).
    if (!fillString || fillString instanceof _index.UndefinedValue) filler = " ";else
      // 7. Else, let filler be ? ToString(fillString).
      filler = (0, _to.ToStringPartial)(realm, fillString);

    // 8. If filler is the empty String, return S.
    if (filler === "") return new _index.StringValue(realm, S);

    // 9. Let fillLen be intMaxLength - stringLength.
    var fillLen = intMaxLength - stringLength;

    // 10. Let truncatedStringFiller be a new String value consisting of repeated concatenations of filler truncated to length fillLen.
    var truncatedStringFiller = filler.repeat(Math.ceil(fillLen / filler.length)).substr(0, fillLen);

    // 11. Return a new String value computed by the concatenation of truncatedStringFiller and S.
    return new _index.StringValue(realm, truncatedStringFiller + S);
  });

  // ECMA262 21.1.3.13
  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION)) obj.defineNativeMethod("repeat", 1, function (context, _ref25) {
    var _ref26 = _slicedToArray(_ref25, 1),
        count = _ref26[0];

    // 1. Let O be ? RequireObjectCoercible(this value).
    var O = (0, _abstract.RequireObjectCoercible)(realm, context);

    // 2. Let S be ? ToString(O).
    var S = (0, _to.ToString)(realm, O.throwIfNotConcrete());

    // 3. Let n be ? ToInteger(count).
    var n = (0, _to.ToInteger)(realm, count);

    // 4. If n < 0, throw a RangeError exception.
    if (n < 0) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError);
    }

    // 5. If n is +∞, throw a RangeError exception.
    if (!isFinite(n)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError);
    }

    // 6. Let T be a String value that is made from n copies of S appended together. If n is 0, T is the empty String.
    var T = "";
    if (S) while (n--) {
      T += S;
    } // 7. Return T.
    return new _index.StringValue(realm, T);
  });

  // ECMA262 21.1.3.14
  obj.defineNativeMethod("replace", 2, function (context, _ref27) {
    var _ref28 = _slicedToArray(_ref27, 2),
        searchValue = _ref28[0],
        replaceValue = _ref28[1];

    var replStr = void 0;

    // 1. Let O be ? RequireObjectCoercible(this value).
    var O = (0, _abstract.RequireObjectCoercible)(realm, context);

    // 2. If searchValue is neither undefined nor null, then
    if (!(0, _has.HasSomeCompatibleType)(searchValue, _index.NullValue, _index.UndefinedValue)) {
      // a. Let replacer be ? GetMethod(searchValue, @@replace).
      var replacer = (0, _get.GetMethod)(realm, searchValue, realm.intrinsics.SymbolReplace);

      // b. If replacer is not undefined, then
      if (!(replacer instanceof _index.UndefinedValue)) {
        // i. Return ? Call(replacer, searchValue, « O, replaceValue »).
        return (0, _call.Call)(realm, replacer, searchValue, [O, replaceValue]);
      }
    }

    // 3. Let string be ? ToString(O).
    var string = (0, _to.ToString)(realm, O.throwIfNotConcrete());

    // 4. Let searchString be ? ToString(searchValue).
    var searchString = (0, _to.ToStringPartial)(realm, searchValue);

    // 5. Let functionalReplace be IsCallable(replaceValue).
    var functionalReplace = (0, _is.IsCallable)(realm, replaceValue);

    var replaceValueString = void 0;
    // 6. If functionalReplace is false, then
    if (functionalReplace === false) {
      // a. Let replaceValue be ? ToString(replaceValue).
      replaceValueString = (0, _to.ToStringPartial)(realm, replaceValue);
    }

    // 7. Search string for the first occurrence of searchString and
    //    let pos be the index within string of the first code unit of the matched substring and
    var pos = string.search(searchString);

    //    let matched be searchString.
    var matched = searchString;

    //    If no occurrences of searchString were found, return string.
    if (pos < 0) return new _index.StringValue(realm, string);

    // 8. If functionalReplace is true, then
    if (functionalReplace === true) {
      // a. Let replValue be ? Call(replaceValue, undefined, « matched, pos, string »).
      var replValue = (0, _call.Call)(realm, replaceValue, realm.intrinsics.undefined, [new _index.StringValue(realm, matched), new _index.NumberValue(realm, pos), new _index.StringValue(realm, string)]);

      // b. Let replStr be ? ToString(replValue).
      replStr = (0, _to.ToStringPartial)(realm, replValue);
    } else {
      // 9. Else,
      // a. Let captures be an empty List.
      var captures = [];

      // b. Let replStr be GetSubstitution(matched, string, pos, captures, replaceValue).
      (0, _invariant2.default)(typeof replaceValueString === "string");
      replStr = (0, _to.ToString)(realm, (0, _get.GetSubstitution)(realm, matched, string, pos, captures, replaceValueString));
    }

    // 10. Let tailPos be pos + the number of code units in matched.
    var tailPos = pos + matched.length;

    // 11. Let newString be the String formed by concatenating the first pos code units of string,
    //     replStr, and the trailing substring of string starting at index tailPos. If pos is 0,
    //     the first element of the concatenation will be the empty String.
    var newString = string.substr(0, pos) + replStr + string.substr(tailPos);

    // 12. Return newString.
    return new _index.StringValue(realm, newString);
  });

  // ECMA262 21.1.3.15
  obj.defineNativeMethod("search", 1, function (context, _ref29) {
    var _ref30 = _slicedToArray(_ref29, 1),
        regexp = _ref30[0];

    // 1. Let O be ? RequireObjectCoercible(this value).
    var O = (0, _abstract.RequireObjectCoercible)(realm, context);

    // 2. If regexp is neither undefined nor null, then
    if (!(0, _has.HasSomeCompatibleType)(regexp, _index.UndefinedValue, _index.NullValue)) {
      // a. Let searcher be ? GetMethod(regexp, @@search).
      var searcher = (0, _get.GetMethod)(realm, regexp, realm.intrinsics.SymbolSearch);

      // b. If searcher is not undefined, then
      if (!(searcher instanceof _index.UndefinedValue)) {
        // i. Return ? Call(searcher, regexp, « O »).
        return (0, _call.Call)(realm, searcher, regexp, [O]);
      }
    }

    // 3. Let string be ? ToString(O).
    var string = (0, _to.ToStringPartial)(realm, O);

    // 4. Let rx be ? RegExpCreate(regexp, undefined).
    var rx = (0, _regexp.RegExpCreate)(realm, regexp, undefined);

    // 5. Return ? Invoke(rx, @@search, « string »).
    return (0, _call.Invoke)(realm, rx, realm.intrinsics.SymbolSearch, [new _index.StringValue(realm, string)]);
  });

  // ECMA262 21.1.3.16
  obj.defineNativeMethod("slice", 2, function (context, _ref31) {
    var _ref32 = _slicedToArray(_ref31, 2),
        start = _ref32[0],
        end = _ref32[1];

    // 1. Let O be ? RequireObjectCoercible(this value).
    var O = (0, _abstract.RequireObjectCoercible)(realm, context);

    if (O instanceof _index.AbstractValue && O.getType() === _index.StringValue) {
      return _index.AbstractValue.createFromTemplate(realm, sliceTemplate, _index.StringValue, [O, start, end], sliceTemplateSrc);
    }

    // 2. Let S be ? ToString(O).
    var S = (0, _to.ToString)(realm, O.throwIfNotConcrete());

    // 3. Let len be the number of elements in S.
    var len = S.length;

    // 4. Let intStart be ? ToInteger(start).
    var intStart = (0, _to.ToInteger)(realm, start);

    // 5. If end is undefined, let intEnd be len; else let intEnd be ? ToInteger(end).
    var intEnd = !end || end instanceof _index.UndefinedValue ? len : (0, _to.ToInteger)(realm, end.throwIfNotConcrete());

    // 6. If intStart < 0, let from be max(len + intStart, 0); otherwise let from be min(intStart, len).
    var from = intStart < 0 ? Math.max(len + intStart, 0) : Math.min(intStart, len);

    // 7. If intEnd < 0, let to be max(len + intEnd, 0); otherwise let to be min(intEnd, len).
    var to = intEnd < 0 ? Math.max(len + intEnd, 0) : Math.min(intEnd, len);

    // 8. Let span be max(to - from, 0).
    var span = Math.max(to - from, 0);

    // 9. Return a String value containing span consecutive elements from S beginning with the element at index from.
    return new _index.StringValue(realm, S.substr(from, span));
  });

  // ECMA262 21.1.3.17
  obj.defineNativeMethod("split", 2, function (context, _ref33) {
    var _ref34 = _slicedToArray(_ref33, 2),
        separator = _ref34[0],
        limit = _ref34[1];

    // 1. Let O be ? RequireObjectCoercible(this value).
    var O = (0, _abstract.RequireObjectCoercible)(realm, context);

    if (O instanceof _index.AbstractValue && O.getType() === _index.StringValue) {
      return _index.AbstractValue.createFromTemplate(realm, splitTemplate, _index.StringValue, [O, separator, limit], splitTemplateSrc);
    }

    // 2. If separator is neither undefined nor null, then
    if (!(0, _has.HasSomeCompatibleType)(separator, _index.UndefinedValue, _index.NullValue)) {
      // a. Let splitter be ? GetMethod(separator, @@split).
      var splitter = (0, _get.GetMethod)(realm, separator, realm.intrinsics.SymbolSplit);

      // b. If splitter is not undefined, then
      if (!(splitter instanceof _index.UndefinedValue)) {
        // i. Return ? Call(splitter, separator, « O, limit »).
        return (0, _call.Call)(realm, splitter, separator, [O, limit]);
      }
    }

    // 3. Let S be ? ToString(O).
    var S = (0, _to.ToString)(realm, O.throwIfNotConcrete());

    // 4. Let A be ArrayCreate(0).
    var A = (0, _create.ArrayCreate)(realm, 0);

    // 5. Let lengthA be 0.
    var lengthA = 0;

    // 6. If limit is undefined, let lim be 232-1; else let lim be ? ToUint32(limit).
    var lim = !limit || limit instanceof _index.UndefinedValue ? Math.pow(2, 32) - 1 : (0, _to.ToUint32)(realm, limit.throwIfNotConcrete());

    // 7. Let s be the number of elements in S.
    var s = S.length;

    // 8. Let p be 0.
    var p = 0;

    // 9. Let R be ? ToString(separator).
    var R = (0, _to.ToStringPartial)(realm, separator);

    // 10. If lim = 0, return A.
    if (lim === 0) return A;

    // 11. If separator is undefined, then
    if (!separator || separator instanceof _index.UndefinedValue) {
      // a. Perform ! CreateDataProperty(A, "0", S).
      (0, _create.CreateDataProperty)(realm, A, "0", new _index.StringValue(realm, S));

      // b. Return A.
      return A;
    }

    // 12. If s = 0, then
    if (s === 0) {
      // a. Let z be SplitMatch(S, 0, R).
      var z = (0, _abstract.SplitMatch)(realm, S, 0, R);

      // b. If z is not false, return A.
      if (z !== false) return A;

      // c. Perform ! CreateDataProperty(A, "0", S).
      (0, _create.CreateDataProperty)(realm, A, "0", new _index.StringValue(realm, S));
      // d. Return A.
      return A;
    }

    // 13. Let q be p.
    var q = p;

    // 14. Repeat, while q ≠ s
    while (q !== s) {
      // a. Let e be SplitMatch(S, q, R).
      var e = (0, _abstract.SplitMatch)(realm, S, q, R);

      // b. If e is false, let q be q+1.
      if (e === false) {
        q++;
      } else {
        // c. Else e is an integer index ≤ s,
        // i. If e = p, let q be q+1.
        if (e === p) {
          q++;
        } else {
          // ii. Else e ≠ p,
          // 1. Let T be a String value equal to the substring of S consisting of the code units at indices p (inclusive) through q (exclusive).
          var _T = S.substring(p, q);

          // 2. Perform ! CreateDataProperty(A, ! ToString(lengthA), T).
          (0, _create.CreateDataProperty)(realm, A, new _index.StringValue(realm, lengthA + ""), new _index.StringValue(realm, _T));

          // 3. Increment lengthA by 1.
          lengthA++;

          // 4. If lengthA = lim, return A.
          if (lengthA === lim) return A;

          // 5. Let p be e.
          p = e;

          // 6. Let q be p.
          q = p;
        }
      }
    }

    // 15. Let T be a String value equal to the substring of S consisting of the code units at indices p (inclusive) through s (exclusive).
    var T = S.substring(p, s);

    // 16. Perform ! CreateDataProperty(A, ! ToString(lengthA), T).
    (0, _create.CreateDataProperty)(realm, A, new _index.StringValue(realm, lengthA + ""), new _index.StringValue(realm, T));

    // 17. Return A.
    return A;
  });

  // ECMA262 21.1.3.18
  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION)) obj.defineNativeMethod("startsWith", 1, function (context, _ref35) {
    var _ref36 = _slicedToArray(_ref35, 2),
        searchString = _ref36[0],
        position = _ref36[1];

    // 1. Let O be ? RequireObjectCoercible(this value).
    var O = (0, _abstract.RequireObjectCoercible)(realm, context);

    // 2. Let S be ? ToString(O).
    var S = (0, _to.ToString)(realm, O.throwIfNotConcrete());

    // 3. Let isRegExp be ? IsRegExp(searchString).
    var isRegExp = (0, _is.IsRegExp)(realm, searchString);

    // 4. If isRegExp is true, throw a TypeError exception.
    if (isRegExp) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "String.prototype");
    }

    // 5. Let searchStr be ? ToString(searchString).
    var searchStr = (0, _to.ToStringPartial)(realm, searchString);

    // 6. Let pos be ? ToInteger(position). (If position is undefined, this step produces the value 0.)
    var pos = (0, _to.ToInteger)(realm, position || realm.intrinsics.undefined);

    // 7. Let len be the number of elements in S.
    var len = S.length;

    // 8. Let start be min(max(pos, 0), len).
    var start = Math.min(Math.max(pos, 0), len);

    // 9. Let searchLength be the number of elements in searchStr.
    var searchLength = searchStr.length;

    // 10. If searchLength+start is greater than len, return false.
    if (searchLength + start > len) return realm.intrinsics.false;

    // 11. If the sequence of elements of S starting at start of length searchLength is the same as the full element sequence of searchStr, return true.
    if (S.substr(start, searchLength) === searchStr) return realm.intrinsics.true;

    // 12. Otherwise, return false.
    return realm.intrinsics.false;
  });

  // ECMA262 21.1.3.19
  obj.defineNativeMethod("substring", 2, function (context, _ref37) {
    var _ref38 = _slicedToArray(_ref37, 2),
        start = _ref38[0],
        end = _ref38[1];

    // 1. Let O be ? RequireObjectCoercible(this value).
    var O = (0, _abstract.RequireObjectCoercible)(realm, context);

    // 2. Let S be ? ToString(O).
    var S = (0, _to.ToString)(realm, O.throwIfNotConcrete());

    // 3. Let len be the number of elements in S.
    var len = S.length;

    // 4. Let intStart be ? ToInteger(start).
    var intStart = (0, _to.ToInteger)(realm, start);

    // 5. If end is undefined, let intEnd be len; else let intEnd be ? ToInteger(end).
    var intEnd = !end || end instanceof _index.UndefinedValue ? len : (0, _to.ToInteger)(realm, end.throwIfNotConcrete());

    // 6. Let finalStart be min(max(intStart, 0), len).
    var finalStart = Math.min(Math.max(intStart, 0), len);

    // 7. Let finalEnd be min(max(intEnd, 0), len).
    var finalEnd = Math.min(Math.max(intEnd, 0), len);

    // 8. Let from be min(finalStart, finalEnd).
    var frm = Math.min(finalStart, finalEnd);

    // 9. Let to be max(finalStart, finalEnd).
    var to = Math.max(finalStart, finalEnd);

    // 10. Return a String whose length is to - from, containing code units from S, namely the code units with indices from through to - 1, in ascending order.
    return new _index.StringValue(realm, S.slice(frm, to));
  });

  function toCase(type, context, locales) {
    // 1. Let O be RequireObjectCoercible(this value).
    var O = (0, _abstract.RequireObjectCoercible)(realm, context);

    // 2. Let S be ToString(O)
    var S = (0, _to.ToString)(realm, O.throwIfNotConcrete());

    if (realm.isCompatibleWith(realm.MOBILE_JSC_VERSION)) {
      locales = undefined;
    } else {
      // TODO #1013 filter locales for only serialisable values
      if (locales) locales = locales.serialize();
    }

    if (realm.useAbstractInterpretation && (type === "LocaleUpper" || type === "LocaleLower")) {
      // The locale is environment-dependent
      _index.AbstractValue.reportIntrospectionError(O);
      throw new _errors.FatalError();
    }

    // Omit the rest of the arguments. Just use the native impl.
    return new _index.StringValue(realm, S["to" + type + "Case"](locales));
  }

  // ECMA-262 21.1.3.20
  // ECMA-402 13.1.2
  obj.defineNativeMethod("toLocaleLowerCase", 0, function (context, _ref39) {
    var _ref40 = _slicedToArray(_ref39, 1),
        locales = _ref40[0];

    return toCase("LocaleLower", context, locales);
  });

  // ECMA-262 21.1.3.21
  // ECMA-402 13.1.3
  obj.defineNativeMethod("toLocaleUpperCase", 0, function (context, _ref41) {
    var _ref42 = _slicedToArray(_ref41, 1),
        locales = _ref42[0];

    return toCase("LocaleUpper", context, locales);
  });

  // ECMA262 21.1.3.22
  obj.defineNativeMethod("toLowerCase", 0, function (context) {
    return toCase("Lower", context);
  });

  // ECMA262 21.1.3.23
  obj.defineNativeMethod("toString", 0, function (context) {
    var target = context instanceof _index.ObjectValue ? context.$StringData : context;
    if (target instanceof _index.AbstractValue && target.getType() === _index.StringValue) {
      return target;
    }
    // 1. Return ? thisStringValue(this value).
    return (0, _to.thisStringValue)(realm, context);
  });

  // ECMA262 21.1.3.24
  obj.defineNativeMethod("toUpperCase", 0, function (context) {
    return toCase("Upper", context);
  });

  // ECMA262 21.1.3.25
  obj.defineNativeMethod("trim", 0, function (context) {
    // 1. Let O be ? RequireObjectCoercible(this value).
    var O = (0, _abstract.RequireObjectCoercible)(realm, context);

    // 2. Let S be ? ToString(O).
    var S = (0, _to.ToString)(realm, O.throwIfNotConcrete());

    // 3. Let T be a String value that is a copy of S with both leading and trailing white space removed. The definition of white space is the union of WhiteSpace and LineTerminator. When determining whether a Unicode code point is in Unicode general category “Zs”, code unit sequences are interpreted as UTF-16 encoded code point sequences as specified in 6.1.4.
    var T = S.trim();

    // 4. Return T.
    return new _index.StringValue(realm, T);
  });

  // ECMA262 21.1.3.26
  obj.defineNativeMethod("valueOf", 0, function (context) {
    // 1. Return ? thisStringValue(this value).
    return (0, _to.thisStringValue)(realm, context);
  });

  // ECMA262 21.1.3.27
  obj.defineNativeMethod(realm.intrinsics.SymbolIterator, 0, function (context) {
    // 1. Let O be ? RequireObjectCoercible(this value).
    var O = (0, _abstract.RequireObjectCoercible)(realm, context);

    // 2. Let S be ? ToString(O).
    var S = (0, _to.ToString)(realm, O.throwIfNotConcrete());

    // 3. Return CreateStringIterator(S).
    return (0, _create.CreateStringIterator)(realm, new _index.StringValue(realm, S));
  });

  // B.2.3.1
  obj.defineNativeMethod("substr", 2, function (context, _ref43) {
    var _ref44 = _slicedToArray(_ref43, 2),
        start = _ref44[0],
        length = _ref44[1];

    // 1. Let O be RequireObjectCoercible(this value).
    var O = (0, _abstract.RequireObjectCoercible)(realm, context);

    // 2. Let S be ToString(O).
    var S = (0, _to.ToStringPartial)(realm, O);

    // 3. ReturnIfAbrupt(S).

    // 4. Let intStart be ToInteger(start).
    var intStart = (0, _to.ToInteger)(realm, start);

    // 5. ReturnIfAbrupt(intStart).

    // 6. If length is undefined, let end be +∞; otherwise let end be ToInteger(length).
    var end = void 0;
    if (!length || length instanceof _index.UndefinedValue) {
      end = Infinity;
    } else {
      end = (0, _to.ToInteger)(realm, length.throwIfNotConcrete());
    }

    // 7. ReturnIfAbrupt(end).

    // 8. Let size be the number of code units in S.
    var size = S.length;

    // 9. If intStart < 0, let intStart be max(size + intStart,0).
    if (intStart < 0) intStart = Math.max(size + intStart, 0);

    // 10. Let resultLength be min(max(end,0), size – intStart).
    var resultLength = Math.min(Math.max(end, 0), size - intStart);

    // 11. If resultLength ≤ 0, return the empty String "".
    if (resultLength <= 0) return realm.intrinsics.emptyString;

    // 12. Return a String containing resultLength consecutive code units from S beginning with the code unit at index intStart.
    return new _index.StringValue(realm, S.slice(intStart, intStart + resultLength));
  });

  // B.2.3.2
  obj.defineNativeMethod("anchor", 1, function (context, _ref45) {
    var _ref46 = _slicedToArray(_ref45, 1),
        name = _ref46[0];

    // 1. Let S be the this value.
    var S = context;

    // 2. // 2. Return ? CreateHTML(S, "a", "name", name).
    return (0, _create.CreateHTML)(realm, S, "a", "name", name);
  });

  // B.2.3.3
  obj.defineNativeMethod("big", 0, function (context) {
    // 1. Let S be the this value.
    var S = context;

    // 2. Return ? CreateHTML(S, "big", "", "").
    return (0, _create.CreateHTML)(realm, S, "big", "", "");
  });

  // B.2.3.4
  obj.defineNativeMethod("blink", 0, function (context) {
    // 1. Let S be the this value.
    var S = context;

    // 2. Return ? CreateHTML(S, "blink", "", "").
    return (0, _create.CreateHTML)(realm, S, "blink", "", "");
  });

  // B.2.3.5
  obj.defineNativeMethod("bold", 0, function (context) {
    // 1. Let S be the this value.
    var S = context;

    // 2. Return ? CreateHTML(S, "b", "", "").
    return (0, _create.CreateHTML)(realm, S, "b", "", "");
  });

  // B.2.3.6
  obj.defineNativeMethod("fixed", 0, function (context) {
    // 1. Let S be the this value.
    var S = context;

    // 2. Return ? CreateHTML(S, "tt", "", "").
    return (0, _create.CreateHTML)(realm, S, "tt", "", "");
  });

  // B.2.3.7
  obj.defineNativeMethod("fontcolor", 1, function (context, _ref47) {
    var _ref48 = _slicedToArray(_ref47, 1),
        color = _ref48[0];

    // 1. Let S be the this value.
    var S = context;

    // 2. Return ? CreateHTML(S, "font", "color", color).
    return (0, _create.CreateHTML)(realm, S, "font", "color", color);
  });

  // B.2.3.8
  obj.defineNativeMethod("fontsize", 1, function (context, _ref49) {
    var _ref50 = _slicedToArray(_ref49, 1),
        size = _ref50[0];

    // 1. Let S be the this value.
    var S = context;

    // 2. Return ? CreateHTML(S, "font", "size", size).
    return (0, _create.CreateHTML)(realm, S, "font", "size", size);
  });

  // B.2.3.9
  obj.defineNativeMethod("italics", 0, function (context) {
    // 1. Let S be the this value.
    var S = context;

    // 2. Return ? CreateHTML(S, "i", "", "").
    return (0, _create.CreateHTML)(realm, S, "i", "", "");
  });

  // B.2.3.10
  obj.defineNativeMethod("link", 1, function (context, _ref51) {
    var _ref52 = _slicedToArray(_ref51, 1),
        url = _ref52[0];

    // 1. Let S be the this value.
    var S = context;

    // 2. Return ? CreateHTML(S, "a", "href", url).
    return (0, _create.CreateHTML)(realm, S, "a", "href", url);
  });

  // B.2.3.11
  obj.defineNativeMethod("small", 0, function (context) {
    // 1. Let S be the this value.
    var S = context;

    // 2. Return ? CreateHTML(S, "small", "", "").
    return (0, _create.CreateHTML)(realm, S, "small", "", "");
  });

  // B.2.3.12
  obj.defineNativeMethod("strike", 0, function (context) {
    // 1. Let S be the this value.
    var S = context;

    // 2. Return ? CreateHTML(S, "strike", "", "").
    return (0, _create.CreateHTML)(realm, S, "strike", "", "");
  });

  // B.2.3.13
  obj.defineNativeMethod("sub", 0, function (context) {
    // 1. Let S be the this value.
    var S = context;

    // 2. Return ? CreateHTML(S, "sub", "", "").
    return (0, _create.CreateHTML)(realm, S, "sub", "", "");
  });

  // B.2.3.14
  obj.defineNativeMethod("sup", 0, function (context) {
    // 1. Let S be the this value.
    var S = context;

    // 2. Return ? CreateHTML(S, "sup", "", "").
    return (0, _create.CreateHTML)(realm, S, "sup", "", "");
  });

  return obj;
};

var _realm = require("../../realm.js");

var _errors = require("../../errors.js");

var _index = require("../../values/index.js");

var _is = require("../../methods/is.js");

var _get = require("../../methods/get.js");

var _call = require("../../methods/call.js");

var _create = require("../../methods/create.js");

var _regexp = require("../../methods/regexp.js");

var _to = require("../../methods/to.js");

var _abstract = require("../../methods/abstract.js");

var _has = require("../../methods/has.js");

var _invariant = require("../../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _builder = require("../../utils/builder.js");

var _builder2 = _interopRequireDefault(_builder);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var sliceTemplateSrc = "(A).slice(B,C)";
var sliceTemplate = (0, _builder2.default)(sliceTemplateSrc);
var splitTemplateSrc = "(A).split(B,C)";
var splitTemplate = (0, _builder2.default)(splitTemplateSrc);
//# sourceMappingURL=StringPrototype.js.map