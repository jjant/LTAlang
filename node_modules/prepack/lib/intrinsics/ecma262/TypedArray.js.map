{"version":3,"sources":["../../../src/intrinsics/ecma262/TypedArray.js"],"names":["realm","func","createErrorThrowCompletion","intrinsics","TypeError","defineNativeMethod","context","source","mapfn","thisArg","C","mapping","undefined","mightBeUndefined","throwIfNotConcrete","T","usingIterator","SymbolIterator","values","len","length","targetObj","k","Pk","kValue","shift","mappedValue","Set","arrayLike","items","argCount","newObj","defineNativeGetter","SymbolSpecies","build","getConstructorName","type","args","NewTarget","constructorName","elementLength","typedArray","$TypedArrayName","O","srcArray","srcData","$ViewedArrayBuffer","elementType","$ArrayLength","srcName","srcType","srcElementSize","srcByteOffset","$ByteOffset","elementSize","byteLength","data","bufferConstructor","ArrayBuffer","srcByteIndex","targetByteIndex","count","value","$ByteLength","object","$ArrayBufferData","buffer","byteOffset","offset","RangeError","bufferByteLength","$ArrayBufferByteLength","newByteLength","newLength","$Prototype","TypedArray","defineNativeConstant"],"mappings":"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","file":"TypedArray.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../../realm.js\";\nimport type { ElementType, TypedArrayKind } from \"../../types.js\";\nimport { ElementSize } from \"../../types.js\";\nimport { NumberValue, NativeFunctionValue, ObjectValue, StringValue, UndefinedValue } from \"../../values/index.js\";\nimport {\n  ArrayElementSize,\n  ArrayElementType,\n  AllocateTypedArray,\n  AllocateTypedArrayBuffer,\n  TypedArrayCreate,\n} from \"../../methods/typedarray.js\";\nimport { SpeciesConstructor } from \"../../methods/construct.js\";\nimport { ToIndexPartial, ToLength, ToString, ToObjectPartial } from \"../../methods/to.js\";\nimport { Get, GetMethod } from \"../../methods/get.js\";\nimport { Properties } from \"../../singletons.js\";\nimport { IterableToList } from \"../../methods/iterator.js\";\nimport { IsDetachedBuffer, IsConstructor, IsCallable } from \"../../methods/is.js\";\nimport { Call } from \"../../methods/call.js\";\nimport {\n  CloneArrayBuffer,\n  AllocateArrayBuffer,\n  GetValueFromBuffer,\n  SetValueInBuffer,\n} from \"../../methods/arraybuffer.js\";\nimport invariant from \"../../invariant.js\";\n\nexport default function(realm: Realm): NativeFunctionValue {\n  let func = new NativeFunctionValue(realm, \"TypedArray\", \"TypedArray\", 0, context => {\n    // 1. Throw a TypeError exception.\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"TypedArray\");\n  });\n\n  // ECMA262 22.2.2.1\n  func.defineNativeMethod(\"from\", 1, (context, [source, mapfn, thisArg]) => {\n    // 1. Let C be the this value.\n    let C = context;\n\n    // 2. If IsConstructor(C) is false, throw a TypeError exception.\n    if (IsConstructor(realm, C) === false) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsConstructor(C) is false\");\n    }\n    invariant(C instanceof ObjectValue);\n\n    let mapping;\n    // 3. If mapfn was supplied and mapfn is not undefined, then\n    if (mapfn !== undefined && !mapfn.mightBeUndefined()) {\n      // a. If IsCallable(mapfn) is false, throw a TypeError exception.\n      if (IsCallable(realm, mapfn) === false) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsConstructor(C) is false\");\n      }\n\n      // b. Let mapping be true.\n      mapping = true;\n    } else {\n      // 4. Else, let mapping be false.\n      mapfn === undefined || mapfn.throwIfNotConcrete();\n      mapping = false;\n    }\n\n    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.\n    let T = thisArg !== undefined ? thisArg : realm.intrinsics.undefined;\n\n    // 6. Let usingIterator be ? GetMethod(source, @@iterator).\n    let usingIterator = GetMethod(realm, source, realm.intrinsics.SymbolIterator);\n\n    // 7. If usingIterator is not undefined, then\n    if (!(usingIterator instanceof UndefinedValue)) {\n      // a. Let values be ? IterableToList(source, usingIterator).\n      let values = IterableToList(realm, source, usingIterator);\n\n      // b. Let len be the number of elements in values.\n      let len = values.length;\n\n      // c. Let targetObj be ? TypedArrayCreate(C, «len»).\n      let targetObj = TypedArrayCreate(realm, C, [new NumberValue(realm, len)]);\n\n      // d. Let k be 0.\n      let k = 0;\n\n      // e. Repeat, while k < len\n      while (k < len) {\n        // i. Let Pk be ! ToString(k).\n        let Pk = ToString(realm, new NumberValue(realm, k));\n\n        // ii. Let kValue be the first element of values and remove that element from values.\n        let kValue = values.shift();\n\n        let mappedValue;\n        // iii. If mapping is true, then\n        if (mapping === true) {\n          // 1. Let mappedValue be ? Call(mapfn, T, « kValue, k »).\n          mappedValue = Call(realm, mapfn, T, [kValue, new NumberValue(realm, k)]);\n        } else {\n          // iv. Else, let mappedValue be kValue.\n          mappedValue = kValue;\n        }\n\n        // v. Perform ? Set(targetObj, Pk, mappedValue, true).\n        Properties.Set(realm, targetObj, Pk, mappedValue, true);\n\n        // vi. Increase k by 1.\n        k = k + 1;\n      }\n\n      // f. Assert: values is now an empty List.\n      invariant(values.length === 0, \"values is not an empty List\");\n\n      // g. Return targetObj.\n      return targetObj;\n    }\n\n    // 8. NOTE: source is not an Iterable so assume it is already an array-like object.\n\n    // 9. Let arrayLike be ! ToObject(source).\n    let arrayLike = ToObjectPartial(realm, source);\n\n    // 10. Let len be ? ToLength(? Get(arrayLike, \"length\")).\n    let len = ToLength(realm, Get(realm, arrayLike, \"length\"));\n\n    // 11. Let targetObj be ? TypedArrayCreate(C, « len »).\n    let targetObj = TypedArrayCreate(realm, C, [new NumberValue(realm, len)]);\n\n    // 12. Let k be 0.\n    let k = 0;\n\n    // 13. Repeat, while k < len\n    while (k < len) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = ToString(realm, new NumberValue(realm, k));\n\n      // b. Let kValue be ? Get(arrayLike, Pk).\n      let kValue = Get(realm, arrayLike, Pk);\n\n      let mappedValue;\n      // c. If mapping is true, then\n      if (mapping === true) {\n        // i. Let mappedValue be ? Call(mapfn, T, « kValue, k »).\n        mappedValue = Call(realm, mapfn, T, [kValue, new NumberValue(realm, k)]);\n      } else {\n        // d. Else, let mappedValue be kValue.\n        mappedValue = kValue;\n      }\n\n      // e. Perform ? Set(targetObj, Pk, mappedValue, true).\n      Properties.Set(realm, targetObj, Pk, mappedValue, true);\n\n      // f. Increase k by 1.\n      k = k + 1;\n    }\n\n    // 14. Return targetObj.\n    return targetObj;\n  });\n\n  // ECMA262 22.2.2.2\n  func.defineNativeMethod(\"of\", 0, (context, items, argCount) => {\n    // 1. Let len be the actual number of arguments passed to this function.\n    let len = argCount;\n\n    // 2. Let items be the List of arguments passed to this function.\n    items;\n\n    // 3. Let C be the this value.\n    let C = context;\n\n    // 4. If IsConstructor(C) is false, throw a TypeError exception.\n    if (IsConstructor(realm, C) === false) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsConstructor(C) is false\");\n    }\n    invariant(C instanceof ObjectValue);\n\n    // 5. Let newObj be ? TypedArrayCreate(C, « len »).\n    let newObj = TypedArrayCreate(realm, C, [new NumberValue(realm, len)]);\n\n    // 6. Let k be 0.\n    let k = 0;\n\n    // 7. Repeat, while k < len\n    while (k < len) {\n      // a. Let kValue be items[k].\n      let kValue = items[k];\n\n      // b. Let Pk be ! ToString(k).\n      let Pk = ToString(realm, new NumberValue(realm, k));\n\n      // c. Perform ? Set(newObj, Pk, kValue, true).\n      Properties.Set(realm, newObj, Pk, kValue, true);\n\n      // d. Increase k by 1.\n      k = k + 1;\n    }\n\n    // 8. Return newObj.\n    return newObj;\n  });\n\n  // ECMA262 22.2.2.4\n  func.defineNativeGetter(realm.intrinsics.SymbolSpecies, context => {\n    // 1. Return the this value\n    return context;\n  });\n\n  return func;\n}\n\n// ECMA262 22.2 Table 50\nfunction getConstructorName(type: ElementType): TypedArrayKind {\n  switch (type) {\n    case \"Float32\":\n      return \"Float32Array\";\n    case \"Float64\":\n      return \"Float64Array\";\n    case \"Int8\":\n      return \"Int8Array\";\n    case \"Int16\":\n      return \"Int16Array\";\n    case \"Int32\":\n      return \"Int32Array\";\n    case \"Uint8\":\n      return \"Uint8Array\";\n    case \"Uint16\":\n      return \"Uint16Array\";\n    case \"Uint32\":\n      return \"Uint32Array\";\n    case \"Uint8Clamped\":\n      return \"Uint8ClampedArray\";\n    default:\n      invariant(false);\n  }\n}\n\nexport function build(realm: Realm, type: ElementType): NativeFunctionValue {\n  let func = new NativeFunctionValue(realm, `${type}Array`, `${type}Array`, 3, (context, args, argCount, NewTarget) => {\n    if (argCount === 0) {\n      // ECMA262 22.2.4.1\n\n      // 1. If NewTarget is undefined, throw a TypeError exception.\n      if (!NewTarget) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"NewTarget is undefined\");\n      }\n\n      // 2. Let constructorName be the String value of the Constructor Name value specified in Table 50 for this TypedArray constructor.\n      let constructorName = getConstructorName(type);\n\n      // 3. Return ? AllocateTypedArray(constructorName, NewTarget, \"%TypedArrayPrototype%\", 0).\n      return AllocateTypedArray(realm, constructorName, NewTarget, `${type}ArrayPrototype`, 0);\n    } else if (!(args[0] instanceof ObjectValue)) {\n      // ECMA262 22.2.4.2\n      let length = args[0].throwIfNotConcrete();\n\n      // 1. Assert: Type(length) is not Object.\n      invariant(!(length instanceof ObjectValue), \"Type(length) is not Object\");\n\n      // 2. If NewTarget is undefined, throw a TypeError exception.\n      if (!NewTarget) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"NewTarget is undefined\");\n      }\n\n      // 3. Let elementLength be ? ToIndex(length).\n      let elementLength = ToIndexPartial(realm, length);\n\n      // 4. Let constructorName be the String value of the Constructor Name value specified in Table 50 for this TypedArray constructor.\n      let constructorName = getConstructorName(type);\n\n      // 5. Return ? AllocateTypedArray(constructorName, NewTarget, \"%TypedArrayPrototype%\", elementLength).\n      return AllocateTypedArray(realm, constructorName, NewTarget, `${type}ArrayPrototype`, elementLength);\n    } else if (\"$TypedArrayName\" in args[0]) {\n      // ECMA262 22.2.4.3\n      let typedArray = args[0].throwIfNotConcrete();\n\n      // 1. Assert: Type(typedArray) is Object and typedArray has a [[TypedArrayName]] internal slot.\n      invariant(typedArray instanceof ObjectValue && typeof typedArray.$TypedArrayName === \"string\");\n\n      // 2. If NewTarget is undefined, throw a TypeError exception.\n      if (!NewTarget) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"NewTarget is undefined\");\n      }\n\n      // 3. Let constructorName be the String value of the Constructor Name value specified in Table 50 for this TypedArray constructor.\n      let constructorName = getConstructorName(type);\n\n      // 4. Let O be ? AllocateTypedArray(constructorName, NewTarget, \"%TypedArrayPrototype%\").\n      let O = AllocateTypedArray(realm, constructorName, NewTarget, `${type}ArrayPrototype`);\n\n      // 5. Let srcArray be typedArray.\n      let srcArray = typedArray;\n\n      // 6. Let srcData be srcArray.[[ViewedArrayBuffer]].\n      let srcData = srcArray.$ViewedArrayBuffer;\n      invariant(srcData);\n\n      // 7. If IsDetachedBuffer(srcData) is true, throw a TypeError exception.\n      if (IsDetachedBuffer(realm, srcData) === true) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsDetachedBuffer(srcData) is true\");\n      }\n\n      // 8. Let constructorName be the String value of O.[[TypedArrayName]].\n      constructorName = O.$TypedArrayName;\n      invariant(typeof constructorName === \"string\");\n\n      // 9. Let elementType be the String value of the Element Type value in Table 50 for constructorName.\n      let elementType = ArrayElementType[constructorName];\n\n      // 10. Let elementLength be srcArray.[[ArrayLength]].\n      let elementLength = srcArray.$ArrayLength;\n      invariant(typeof elementLength === \"number\");\n\n      // 11. Let srcName be the String value of srcArray.[[TypedArrayName]].\n      let srcName = srcArray.$TypedArrayName;\n      invariant(typeof srcName === \"string\");\n\n      // 12. Let srcType be the String value of the Element Type value in Table 50 for srcName.\n      let srcType = ArrayElementType[srcName];\n\n      // 13. Let srcElementSize be the Element Size value in Table 50 for srcName.\n      let srcElementSize = ArrayElementSize[srcName];\n\n      // 14. Let srcByteOffset be srcArray.[[ByteOffset]].\n      let srcByteOffset = srcArray.$ByteOffset;\n      invariant(typeof srcByteOffset === \"number\");\n\n      // 15. Let elementSize be the Element Size value in Table 50 for constructorName.\n      let elementSize = ArrayElementSize[constructorName];\n\n      // 16. Let byteLength be elementSize × elementLength.\n      let byteLength = elementSize * elementLength;\n\n      let data;\n      // 17. If SameValue(elementType, srcType) is true, then\n      if (elementType === srcType) {\n        // a. Let data be ? CloneArrayBuffer(srcData, srcByteOffset).\n        data = CloneArrayBuffer(realm, srcData, srcByteOffset);\n      } else {\n        // 18. Else,\n        // a. Let bufferConstructor be ? SpeciesConstructor(srcData, %ArrayBuffer%).\n        let bufferConstructor = SpeciesConstructor(realm, srcData, realm.intrinsics.ArrayBuffer);\n\n        // b. Let data be ? AllocateArrayBuffer(bufferConstructor, byteLength).\n        data = AllocateArrayBuffer(realm, bufferConstructor, byteLength);\n\n        // c. If IsDetachedBuffer(srcData) is true, throw a TypeError exception.\n        if (IsDetachedBuffer(realm, srcData) === true) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsDetachedBuffer(srcData) is true\");\n        }\n\n        // d. Let srcByteIndex be srcByteOffset.\n        let srcByteIndex = srcByteOffset;\n\n        // e. Let targetByteIndex be 0.\n        let targetByteIndex = 0;\n\n        // f. Let count be elementLength.\n        let count = elementLength;\n\n        // g. Repeat, while count > 0\n        while (count > 0) {\n          // i. Let value be GetValueFromBuffer(srcData, srcByteIndex, srcType).\n          let value = GetValueFromBuffer(realm, srcData, srcByteIndex, srcType);\n\n          // ii. Perform SetValueInBuffer(data, targetByteIndex, elementType, value).\n          SetValueInBuffer(realm, data, targetByteIndex, elementType, value.value);\n\n          // iii. Set srcByteIndex to srcByteIndex + srcElementSize.\n          srcByteIndex = srcByteIndex + srcElementSize;\n\n          // iv. Set targetByteIndex to targetByteIndex + elementSize.\n          targetByteIndex = targetByteIndex + elementSize;\n\n          // v. Decrement count by 1.\n          count -= 1;\n        }\n      }\n\n      // 19. Set O.[[ViewedArrayBuffer]] to data.\n      O.$ViewedArrayBuffer = data;\n\n      // 20. Set O.[[ByteLength]] to byteLength.\n      O.$ByteLength = byteLength;\n\n      // 21. Set O.[[ByteOffset]] to 0.\n      O.$ByteOffset = 0;\n\n      // 22. Set O.[[ArrayLength]] to elementLength.\n      O.$ArrayLength = elementLength;\n\n      // 23. Return O.\n      return O;\n    } else if (!(\"$ArrayBufferData\" in args[0]) && !(\"$TypedArrayName\" in args[0])) {\n      // ECMA262 22.2.4.4\n      let object = args[0].throwIfNotConcrete();\n\n      // 1. Assert: Type(object) is Object and object does not have either a [[TypedArrayName]] or an [[ArrayBufferData]] internal slot.\n      invariant(object instanceof ObjectValue && typeof object.$TypedArrayName && !object.$ArrayBufferData);\n\n      // 2. If NewTarget is undefined, throw a TypeError exception.\n      if (!NewTarget) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"NewTarget is undefined\");\n      }\n\n      // 3. Let constructorName be the String value of the Constructor Name value specified in Table 50 for this TypedArray constructor.\n      let constructorName = getConstructorName(type);\n\n      // 4. Let O be ? AllocateTypedArray(constructorName, NewTarget, \"%TypedArrayPrototype%\").\n      let O = AllocateTypedArray(realm, constructorName, NewTarget, `${type}ArrayPrototype`);\n\n      // 5. Let usingIterator be ? GetMethod(object, @@iterator).\n      let usingIterator = GetMethod(realm, object, realm.intrinsics.SymbolIterator);\n\n      // 6. If usingIterator is not undefined, then\n      if (!(usingIterator instanceof UndefinedValue)) {\n        // a. Let values be ? IterableToList(object, usingIterator).\n        let values = IterableToList(realm, object, usingIterator);\n\n        // b. Let len be the number of elements in values.\n        let len = values.length;\n\n        // c. Perform ? AllocateTypedArrayBuffer(O, len).\n        AllocateTypedArrayBuffer(realm, O, len);\n\n        // d. Let k be 0.\n        let k = 0;\n\n        // e. Repeat, while k < len\n        while (k < len) {\n          // i. Let Pk be ! ToString(k).\n          let Pk = new StringValue(realm, ToString(realm, new NumberValue(realm, k)));\n\n          // ii. Let kValue be the first element of values and remove that element from values.\n          let kValue = values.shift();\n\n          // iii. Perform ? Set(O, Pk, kValue, true).\n          Properties.Set(realm, O, Pk, kValue, true);\n\n          // iv. Increase k by 1.\n          k = k + 1;\n        }\n\n        // f. Assert: values is now an empty List.\n        invariant(values.length === 0);\n\n        // g. Return O.\n        return O;\n      }\n\n      // 7. NOTE: object is not an Iterable so assume it is already an array-like object.\n\n      // 8. Let arrayLike be object.\n      let arrayLike = object;\n\n      // 9. Let len be ? ToLength(? Get(arrayLike, \"length\")).\n      let len = ToLength(realm, Get(realm, arrayLike, \"length\"));\n\n      // 10. Perform ? AllocateTypedArrayBuffer(O, len).\n      AllocateTypedArrayBuffer(realm, O, len);\n\n      // 11. Let k be 0.\n      let k = 0;\n\n      // 12. Repeat, while k < len\n      while (k < len) {\n        // a. Let Pk be ! ToString(k).\n        let Pk = new StringValue(realm, ToString(realm, new NumberValue(realm, k)));\n\n        // b. Let kValue be ? Get(arrayLike, Pk).\n        let kValue = Get(realm, arrayLike, Pk);\n\n        // c. Perform ? Set(O, Pk, kValue, true).\n        Properties.Set(realm, O, Pk, kValue, true);\n\n        // d. Increase k by 1.\n        k += 1;\n      }\n\n      // 13. Return O.\n      return O;\n    } else {\n      // ECMA262 22.2.4.5\n      let buffer = args[0].throwIfNotConcrete(),\n        byteOffset = args[1],\n        length = args[2];\n\n      // 1. Assert: Type(buffer) is Object and buffer has an [[ArrayBufferData]] internal slot.\n      invariant(buffer instanceof ObjectValue && \"$ArrayBufferData\" in buffer);\n\n      // 2. If NewTarget is undefined, throw a TypeError exception.\n      if (!NewTarget) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"NewTarget is undefined\");\n      }\n\n      // 3. Let constructorName be the String value of the Constructor Name value specified in Table 50 for this TypedArray constructor.\n      let constructorName = getConstructorName(type);\n\n      // 4. Let O be ? AllocateTypedArray(constructorName, NewTarget, \"%TypedArrayPrototype%\").\n      let O = AllocateTypedArray(realm, constructorName, NewTarget, `${type}ArrayPrototype`);\n\n      // 5. Let constructorName be the String value of O.[[TypedArrayName]].\n      constructorName = O.$TypedArrayName;\n      invariant(constructorName);\n\n      // 6. Let elementSize be the Number value of the Element Size value in Table 50 for constructorName.\n      let elementSize = ArrayElementSize[constructorName];\n\n      // 7. Let offset be ? ToIndex(byteOffset).\n      let offset = ToIndexPartial(realm, byteOffset);\n\n      // 8. If offset modulo elementSize ≠ 0, throw a RangeError exception.\n      if (offset % elementSize !== 0) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"offset modulo elementSize ≠ 0\");\n      }\n\n      // 9. If IsDetachedBuffer(buffer) is true, throw a TypeError exception.\n      if (IsDetachedBuffer(realm, buffer) === true) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsDetachedBuffer(buffer) is true\");\n      }\n\n      // 10. Let bufferByteLength be buffer.[[ArrayBufferByteLength]].\n      let bufferByteLength = buffer.$ArrayBufferByteLength;\n      invariant(typeof bufferByteLength === \"number\");\n\n      let newByteLength;\n      // 11. If length is either not present or undefined, then\n      if (!length || length instanceof UndefinedValue) {\n        // a. If bufferByteLength modulo elementSize ≠ 0, throw a RangeError exception.\n        if (bufferByteLength % elementSize !== 0) {\n          throw realm.createErrorThrowCompletion(\n            realm.intrinsics.RangeError,\n            \"bufferByteLength modulo elementSize ≠ 0\"\n          );\n        }\n        // b. Let newByteLength be bufferByteLength - offset.\n        newByteLength = bufferByteLength - offset;\n\n        // c. If newByteLength < 0, throw a RangeError exception.\n        if (newByteLength < 0) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"newByteLength < 0\");\n        }\n      } else {\n        // 12. Else,\n        // a. Let newLength be ? ToIndex(length).\n        let newLength = ToIndexPartial(realm, length);\n\n        // b. Let newByteLength be newLength × elementSize.\n        newByteLength = newLength * elementSize;\n\n        // c. If offset+newByteLength > bufferByteLength, throw a RangeError exception.\n        if (offset + newByteLength > bufferByteLength) {\n          throw realm.createErrorThrowCompletion(\n            realm.intrinsics.RangeError,\n            \"offset+newByteLength > bufferByteLength\"\n          );\n        }\n      }\n\n      // 13. Set O.[[ViewedArrayBuffer]] to buffer.\n      O.$ViewedArrayBuffer = buffer;\n\n      // 14. Set O.[[ByteLength]] to newByteLength.\n      O.$ByteLength = newByteLength;\n\n      // 15. Set O.[[ByteOffset]] to offset.\n      O.$ByteOffset = offset;\n\n      // 16. Set O.[[ArrayLength]] to newByteLength / elementSize.\n      O.$ArrayLength = newByteLength / elementSize;\n\n      // 17. Return O.\n      return O;\n    }\n  });\n\n  // ECMA262 22.2.5\n  func.$Prototype = realm.intrinsics.TypedArray;\n\n  // ECMA262 22.2.5.1\n  func.defineNativeConstant(\"BYTES_PER_ELEMENT\", new NumberValue(realm, ElementSize[type]));\n\n  return func;\n}\n"]}