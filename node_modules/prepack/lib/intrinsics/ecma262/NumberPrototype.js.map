{"version":3,"sources":["../../../src/intrinsics/ecma262/NumberPrototype.js"],"names":["realm","obj","$NumberData","intrinsics","zero","defineNativeMethod","context","fractionDigits","x","value","throwIfNotConcrete","f","isNaN","s","Infinity","createErrorThrowCompletion","RangeError","positiveResultString","toExponential","undefined","toFixed","toLocaleStringSrc","toLocaleString","useAbstractInterpretation","createTemporalFromTemplate","precision","num","p","toPrecision","tsTemplateSrc","tsTemplate","radix","target","getType","createFromTemplate","radixNumber","TypeError","toString"],"mappings":"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","file":"NumberPrototype.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../../realm.js\";\nimport { ObjectValue, StringValue, UndefinedValue, AbstractValue, NumberValue } from \"../../values/index.js\";\nimport { ToInteger, ToString, thisNumberValue } from \"../../methods/index.js\";\nimport invariant from \"../../invariant.js\";\nimport buildExpressionTemplate from \"../../utils/builder.js\";\n\nexport default function(realm: Realm, obj: ObjectValue): void {\n  // ECMA262 20.1.3\n  obj.$NumberData = realm.intrinsics.zero;\n\n  // ECMA262 20.1.3.2\n  obj.defineNativeMethod(\"toExponential\", 1, (context, [fractionDigits]) => {\n    // 1. Let x be ? thisNumberValue(this value).\n    let x = thisNumberValue(realm, context).value;\n\n    // 2. Let f be ? ToInteger(fractionDigits).\n    fractionDigits = fractionDigits.throwIfNotConcrete();\n    let f = ToInteger(realm, fractionDigits);\n\n    // 3. Assert: f is 0, when fractionDigits is undefined.\n    invariant(f === 0 || !(fractionDigits instanceof UndefinedValue));\n\n    // 4. If x is NaN, return the String \"NaN\".\n    if (isNaN(x)) return new StringValue(realm, \"NaN\");\n\n    // 5. Let s be the empty String.\n    let s = \"\";\n\n    // 6. If x < 0, then\n    if (x < 0) {\n      // 6a. Let s be \"-\".\n      s = \"-\";\n\n      // 6b. Let x be -x.\n      x = -x;\n    }\n\n    // 7. If x = +∞, then\n    if (x === +Infinity) {\n      // 7a. Return the concatenation of the Strings s and \"Infinity\".\n      return new StringValue(realm, s + \"Infinity\");\n    }\n\n    // 8. If f < 0 or f > 20, throw a RangeError exception. However, an implementation is permitted to extend the behaviour of toExponential for values of f less than 0 or greater than 20. In this case toExponential would not necessarily throw RangeError for such values.\n    if (f < 0 || f > 20) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"f < 0 || f > 20\");\n    }\n\n    let positiveResultString = x.toExponential(fractionDigits instanceof UndefinedValue ? undefined : f);\n    return new StringValue(realm, s + positiveResultString);\n  });\n\n  // ECMA262 20.1.3.3\n  obj.defineNativeMethod(\"toFixed\", 1, (context, [fractionDigits]) => {\n    // 1. Let f be ToInteger(fractionDigits). (If fractionDigits is undefined, this step produces the value 0).\n    let f = ToInteger(realm, fractionDigits);\n\n    // 2. If f < 0 or f > 20, throw a RangeError exception.\n    if (f < 0 || f > 20) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"f < 0 || f > 20\");\n    }\n\n    // 3. Let x be this Number value.\n    let x = thisNumberValue(realm, context).value;\n\n    // 4. If x is NaN, return the String \"NaN\".\n    if (isNaN(x)) return new StringValue(realm, \"NaN\");\n\n    return new StringValue(realm, x.toFixed(f));\n  });\n\n  let toLocaleStringSrc = \"(A).toLocaleString()\";\n  let toLocaleString = buildExpressionTemplate(toLocaleStringSrc);\n\n  // ECMA262 20.1.3.4\n  obj.defineNativeMethod(\"toLocaleString\", 0, context => {\n    let x = thisNumberValue(realm, context);\n    if (realm.useAbstractInterpretation) {\n      // The locale is environment-dependent and may also be time-dependent\n      // so do this at runtime and at this point in time\n      return AbstractValue.createTemporalFromTemplate(realm, toLocaleString, StringValue, [x]);\n    } else {\n      return new StringValue(realm, x.toLocaleString());\n    }\n  });\n\n  // ECMA262 20.1.3.5\n  obj.defineNativeMethod(\"toPrecision\", 1, (context, [precision]) => {\n    // 1. Let x be ? thisNumberValue(this value).\n    let num = thisNumberValue(realm, context);\n    // 2. If precision is undefined, return ! ToString(x).\n    if (precision instanceof UndefinedValue) {\n      return new StringValue(realm, ToString(realm, num));\n    }\n    // 3. Let p be ? ToInteger(precision).\n    let p = ToInteger(realm, precision.throwIfNotConcrete());\n    // 4. If x is NaN, return the String \"NaN\".\n    let x = num.value;\n    if (isNaN(x)) {\n      return new StringValue(realm, \"NaN\");\n    }\n    // 5. Let s be the empty String.\n    let s = \"\";\n    // 6. If x < 0, then\n    if (x < 0) {\n      // a. Let s be code unit 0x002D (HYPHEN-MINUS).\n      s = \"-\";\n      // b. Let x be -x.\n      x = -x;\n    }\n    // 7. If x = +∞, then\n    if (x === +Infinity) {\n      // a. Return the String that is the concatenation of s and \"Infinity\".\n      return new StringValue(realm, s + \"Infinity\");\n    }\n    // 8. If p < 1 or p > 21, throw a RangeError exception.\n    // However, an implementation is permitted to extend the behaviour of\n    // toPrecision for values of p less than 1 or greater than 21.\n    // In this case toPrecision would not necessarily throw RangeError for such\n    // values.\n    if (p < 1 || p > 21) {\n      // for simplicity, throw the error\n      throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"p should be in between 1 and 21 inclusive\");\n    }\n    return new StringValue(realm, s + x.toPrecision(p));\n  });\n\n  const tsTemplateSrc = \"(A).toString()\";\n  const tsTemplate = buildExpressionTemplate(tsTemplateSrc);\n\n  // ECMA262 20.1.3.6\n  obj.defineNativeMethod(\"toString\", 1, (context, [radix]) => {\n    if (radix instanceof UndefinedValue) {\n      const target = context instanceof ObjectValue ? context.$NumberData : context;\n      if (target instanceof AbstractValue && target.getType() === NumberValue) {\n        return AbstractValue.createFromTemplate(realm, tsTemplate, StringValue, [target], tsTemplateSrc);\n      }\n    }\n    // 1. Let x be ? thisNumberValue(this value).\n    let x = thisNumberValue(realm, context);\n\n    // 2. If radix is not present, let radixNumber be 10.\n    // 3. Else if radix is undefined, let radixNumber be 10.\n    let radixNumber;\n    if (!radix || radix instanceof UndefinedValue) {\n      radixNumber = 10;\n    } else {\n      // 4. Else let radixNumber be ? ToInteger(radix).\n      radixNumber = ToInteger(realm, radix.throwIfNotConcrete());\n    }\n\n    // 5. If radixNumber < 2 or radixNumber > 36, throw a RangeError exception.\n    if (radixNumber < 2 || radixNumber > 36) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 6. If radixNumber = 10, return ! ToString(x).\n    if (radixNumber === 10) return new StringValue(realm, ToString(realm, x));\n\n    // 7. Return the String representation of this Number value using the radix specified by radixNumber.\n    //    Letters a-z are used for digits with values 10 through 35. The precise algorithm is\n    //    implementation-dependent, however the algorithm should be a generalization of that specified in\n    //    7.1.12.1.\n    return new StringValue(realm, x.value.toString(radixNumber));\n  });\n\n  // ECMA262 20.1.3.7\n  obj.defineNativeMethod(\"valueOf\", 0, context => {\n    // 1. Return ? thisNumberValue(this value).\n    return thisNumberValue(realm, context);\n  });\n}\n"]}