"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (realm, obj) {
  // ECMA262 23.1.5.2.1
  obj.defineNativeMethod("next", 0, function (context) {
    // 1. Let O be the this value.
    var O = context.throwIfNotConcrete();

    // 2. If Type(O) is not Object, throw a TypeError exception.
    if (!(O instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "not an object");
    }

    // 3. If O does not have all of the internal slots of a Set Iterator Instance (23.2.5.3), throw a TypeError exception.
    if (O.$Map === undefined || O.$MapNextIndex === undefined || O.$MapIterationKind === undefined) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "MapIteratorPrototype.next isn't generic");
    }

    // 4. Let m be O.[[Map]].
    var m = O.$Map;

    // 5. Let index be O.[[MapNextIndex]].
    var index = O.$MapNextIndex.value;

    // 6. Let itemKind be O.[[MapIterationKind]].
    var itemKind = O.$MapIterationKind;

    // 7. If m is undefined, return CreateIterResultObject(undefined, true).
    if (!m || m instanceof _index.UndefinedValue) return (0, _create.CreateIterResultObject)(realm, realm.intrinsics.undefined, true);
    (0, _invariant2.default)(m instanceof _index.ObjectValue);

    // 8. Assert: m has a [[MapData]] internal slot.
    (0, _invariant2.default)(m.$MapData, "m has a [[MapData]] internal slot");

    // 9. Let entries be the List that is m.[[MapData]].
    var entries = m.$MapData;
    (0, _invariant2.default)(entries);

    // 10. Repeat while index is less than the total number of elements of entries. The number of elements must be redetermined each time this method is evaluated.
    while (index < entries.length) {
      // a. Let e be the Record {[[Key]], [[Value]]} that is the value of entries[index].
      var e = entries[index];

      // b. Set index to index+1.
      index = index + 1;

      // c. Set O.[[MapNextIndex]] to index.
      O.$MapNextIndex = new _index.NumberValue(realm, index);

      // d. If e.[[Key]] is not empty, then
      if (e.$Key !== undefined) {
        (0, _invariant2.default)(e.$Value !== undefined);

        var result = void 0;
        // i. If itemKind is "key", let result be e.[[Key]].
        if (itemKind === "key") result = e.$Key;else if (itemKind === "value")
          // ii. Else if itemKind is "value", let result be e.[[Value]].
          result = e.$Value;else {
          // iii. Else,
          // 1. Assert: itemKind is "key+value".
          (0, _invariant2.default)(itemKind === "key+value");

          // 2. Let result be CreateArrayFromList(« e.[[Key]], e.[[Value]] »).
          result = (0, _create.CreateArrayFromList)(realm, [e.$Key, e.$Value]);
        }

        // iv. Return CreateIterResultObject(result, false).
        return (0, _create.CreateIterResultObject)(realm, result, false);
      }
    }

    // 11. Set O.[[Map]] to undefined.
    O.$Map = realm.intrinsics.undefined;

    // 12. Return CreateIterResultObject(undefined, true).
    return (0, _create.CreateIterResultObject)(realm, realm.intrinsics.undefined, true);
  });

  // ECMA262 23.1.5.2.2
  obj.defineNativeProperty(realm.intrinsics.SymbolToStringTag, new _index.StringValue(realm, "Map Iterator"), {
    writable: false
  });
};

var _index = require("../../values/index.js");

var _create = require("../../methods/create.js");

var _invariant = require("../../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
//# sourceMappingURL=MapIteratorPrototype.js.map