"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Copyright (c) 2017-present, Facebook, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * This source code is licensed under the BSD-style license found in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * LICENSE file in the root directory of this source tree. An additional grant
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * of patent rights can be found in the PATENTS file in the same directory.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */

exports.default = function (realm) {
  var func = new _index.NativeFunctionValue(realm, "RegExp", "RegExp", 2, function (context, _ref, argCount, NewTarget) {
    var _ref2 = _slicedToArray(_ref, 2),
        pattern = _ref2[0],
        flags = _ref2[1];

    // 1. Let patternIsRegExp be ? IsRegExp(pattern).
    var patternIsRegExp = (0, _is.IsRegExp)(realm, pattern);
    var newTarget = void 0;
    // 2. If NewTarget is not undefined, let newTarget be NewTarget.
    if (NewTarget) {
      newTarget = NewTarget;
    } else {
      // 3. Else,
      // a. Let newTarget be the active function object.
      newTarget = func;

      // b. If patternIsRegExp is true and flags is undefined, then
      if (patternIsRegExp && flags instanceof _index.UndefinedValue) {
        (0, _invariant2.default)(pattern instanceof _index.ObjectValue);
        // i. Let patternConstructor be ? Get(pattern, "constructor").
        var patternConstructor = (0, _get.Get)(realm, pattern, "constructor");

        // ii. If SameValue(newTarget, patternConstructor) is true, return pattern.
        if ((0, _abstract.SameValuePartial)(realm, newTarget, patternConstructor)) {
          return pattern;
        }
      }
    }

    var P = void 0,
        F = void 0;
    // 4. If Type(pattern) is Object and pattern has a [[RegExpMatcher]] internal slot, then
    if (pattern instanceof _index.ObjectValue && pattern.$RegExpMatcher) {
      // a. Let P be the value of pattern's [[OriginalSource]] internal slot.
      (0, _invariant2.default)(typeof pattern.$OriginalSource === "string");
      P = new _index.StringValue(realm, pattern.$OriginalSource);

      // b. If flags is undefined, let F be the value of pattern's [[OriginalFlags]] internal slot.
      if (flags instanceof _index.UndefinedValue) {
        (0, _invariant2.default)(typeof pattern.$OriginalFlags === "string");
        F = new _index.StringValue(realm, pattern.$OriginalFlags);
      } else {
        // c. Else, let F be flags.
        F = flags.throwIfNotConcrete();
      }
    } else if (patternIsRegExp) {
      // 5. Else if patternIsRegExp is true, then
      (0, _invariant2.default)(pattern instanceof _index.ObjectValue);
      // a. Let P be ? Get(pattern, "source").
      P = (0, _get.Get)(realm, pattern, "source");

      // b. If flags is undefined, then
      if (flags instanceof _index.UndefinedValue) {
        // i. Let F be ? Get(pattern, "flags").
        F = (0, _get.Get)(realm, pattern, "flags");
      } else {
        // c. Else, let F be flags.
        F = flags.throwIfNotConcrete();
      }
    } else {
      // 6. Else,
      // a. Let P be pattern.
      P = pattern.throwIfNotConcrete();
      // b. Let F be flags.
      F = flags.throwIfNotConcrete();
    }

    // 7. Let O be ? RegExpAlloc(newTarget).
    var O = (0, _regexp.RegExpAlloc)(realm, newTarget);

    // 8. Return ? RegExpInitialize(O, P, F).
    return (0, _regexp.RegExpInitialize)(realm, O, P, F);
  });

  // ECMA262 21.2.4.2
  func.defineNativeGetter(realm.intrinsics.SymbolSpecies, function (context) {
    // 1. Return the this value
    return context;
  });

  return func;
};

var _index = require("../../values/index.js");

var _is = require("../../methods/is.js");

var _get = require("../../methods/get.js");

var _abstract = require("../../methods/abstract.js");

var _regexp = require("../../methods/regexp.js");

var _invariant = require("../../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
//# sourceMappingURL=RegExp.js.map