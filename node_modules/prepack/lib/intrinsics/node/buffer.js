"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Copyright (c) 2017-present, Facebook, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * This source code is licensed under the BSD-style license found in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * LICENSE file in the root directory of this source tree. An additional grant
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * of patent rights can be found in the PATENTS file in the same directory.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */

exports.default = function (realm) {
  var nativeBuffer = process.binding("buffer");
  var nativeBufferPrototype = require("buffer").Buffer.prototype;

  var intrinsicName = 'process.binding("buffer")';
  var obj = new _index.ObjectValue(realm, realm.intrinsics.ObjectPrototype, intrinsicName);

  // Buffer

  var setupBufferJS = new _index.NativeFunctionValue(realm, intrinsicName + ".setupBufferJS", "setupBufferJS", 0, function (setupContext, setupArgs) {
    (0, _invariant2.default)(setupArgs.length === 2);
    (0, _invariant2.default)(setupArgs[0] instanceof _index.ObjectValue);
    (0, _invariant2.default)(setupArgs[1] instanceof _index.ObjectValue);
    // TODO: Mutate the second argument by setting one of the properties to
    // Buffer prototype just like the native implementation does.

    var _setupArgs = _slicedToArray(setupArgs, 1),
        proto = _setupArgs[0];

    var simpleWrapperNames = ["asciiSlice", "base64Slice", "latin1Slice", "hexSlice", "ucs2Slice", "asciiWrite", "base64Write", "latin1Write", "hexWrite", "ucs2Write", "utf8Write"];

    var _loop = function _loop(name) {
      var wrapper = new _index.NativeFunctionValue(realm, "Buffer.prototype." + name, name, 0, function (context, args) {
        throw new _errors.FatalError("TODO: " + name);
      });
      _singletons.Properties.Set(realm, proto, name, wrapper, true);
    };

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = simpleWrapperNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var name = _step.value;

        _loop(name);
      }

      // utf8Slice is used to read source code.
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    var utf8Slice = new _index.NativeFunctionValue(realm, "Buffer.prototype.utf8Slice", "utf8Slice", 0, function (context, args) {
      (0, _invariant2.default)(context instanceof _index.ObjectValue);
      var self = (0, _utils.getNodeBufferFromTypedArray)(realm, context);
      var decodedArgs = args.map(function (arg, i) {
        return (0, _index2.ToInteger)(realm, arg);
      });
      var utf8String = nativeBufferPrototype.utf8Slice.apply(self, decodedArgs);
      return new _index.StringValue(realm, utf8String);
    });
    _singletons.Properties.Set(realm, proto, "utf8Slice", utf8Slice, true);

    // copy has recently moved from the prototype to the instance upstream.
    var copy = new _index.NativeFunctionValue(realm, "Buffer.prototype.copy", "copy", 0, function (context, args) {
      (0, _invariant2.default)(context instanceof _index.ObjectValue);
      var self = (0, _utils.getNodeBufferFromTypedArray)(realm, context);
      var decodedArgs = args.map(function (arg, i) {
        if (i === 0) {
          (0, _invariant2.default)(arg instanceof _index.ObjectValue);
          return (0, _utils.getNodeBufferFromTypedArray)(realm, arg);
        } else {
          return (0, _index2.ToInteger)(realm, arg);
        }
      });
      var bytesCopied = nativeBufferPrototype.copy.apply(self, decodedArgs);
      return new _index.NumberValue(realm, bytesCopied);
    });
    _singletons.Properties.Set(realm, proto, "copy", copy, true);

    // TODO: Set up more methods on the prototype and bindingObject
    return realm.intrinsics.undefined;
  });
  _singletons.Properties.Set(realm, obj, "setupBufferJS", setupBufferJS, true);

  var createFromString = new _index.NativeFunctionValue(realm, intrinsicName + ".createFromString", "createFromString", 0, function (context, args) {
    throw new _errors.FatalError("TODO");
  });
  _singletons.Properties.Set(realm, obj, "createFromString", createFromString, true);

  var simpleWrapperNames = ["byteLengthUtf8", "copy", "compare", "compareOffset", "fill", "indexOfBuffer", "indexOfNumber", "indexOfString", "readDoubleBE", "readDoubleLE", "readFloatBE", "readFloatLE", "writeDoubleBE", "writeDoubleLE", "writeFloatBE", "writeFloatLE", "swap16", "swap32", "swap64"];

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = simpleWrapperNames[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var name = _step2.value;

      var wrapper = new _index.NativeFunctionValue(realm, intrinsicName + "." + name, name, 0, function (context, args) {
        throw new _errors.FatalError("TODO");
      });
      _singletons.Properties.Set(realm, obj, name, wrapper, true);
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  _singletons.Properties.Set(realm, obj, "kMaxLength", new _index.NumberValue(realm, nativeBuffer.kMaxLength), true);
  _singletons.Properties.Set(realm, obj, "kStringMaxLength", new _index.NumberValue(realm, nativeBuffer.kStringMaxLength), true);

  return obj;
};

var _invariant = require("../../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _errors = require("../../errors.js");

var _realm = require("../../realm.js");

var _index = require("../../values/index.js");

var _index2 = require("../../methods/index.js");

var _utils = require("./utils.js");

var _singletons = require("../../singletons.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
//# sourceMappingURL=buffer.js.map