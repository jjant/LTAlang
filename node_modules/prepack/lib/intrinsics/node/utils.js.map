{"version":3,"sources":["../../../src/intrinsics/node/utils.js"],"names":["getNodeBufferFromTypedArray","createDeepIntrinsic","copyProperty","realm","value","buffer","$ViewedArrayBuffer","$ArrayBufferData","intrinsicName","intrinsics","undefined","null","Array","isArray","prototype","Object","getPrototypeOf","constructor","name","toString","call","obj","ObjectPrototype","names","getOwnPropertyNames","newValue","originalObject","realmObject","desc","getOwnPropertyDescriptor","get","set","newDesc","writable","configurable","enumerable","DefinePropertyOrThrow"],"mappings":"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","file":"utils.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport invariant from \"../../invariant.js\";\nimport { FatalError } from \"../../errors.js\";\nimport type { Realm } from \"../../realm.js\";\nimport { type Value, BooleanValue, ObjectValue, NumberValue, StringValue } from \"../../values/index.js\";\nimport { Properties } from \"../../singletons.js\";\n\nexport function getNodeBufferFromTypedArray(realm: Realm, value: ObjectValue): Uint8Array {\n  let buffer = value.$ViewedArrayBuffer;\n  invariant(buffer instanceof ObjectValue && buffer.$ArrayBufferData);\n  return buffer.$ArrayBufferData;\n}\n\n// Takes a value from the host realm and create it into a Prepack Realm.\n// TODO: Move this to a bigger general purpose proxy between the environments.\n// See issue #644 for more details.\nexport function createDeepIntrinsic(realm: Realm, value: mixed, intrinsicName: string) {\n  switch (typeof value) {\n    case \"undefined\":\n      return realm.intrinsics.undefined;\n    case \"boolean\":\n      return new BooleanValue(realm, value, intrinsicName);\n    case \"number\":\n      return new NumberValue(realm, value, intrinsicName);\n    case \"string\":\n      return new StringValue(realm, value, intrinsicName);\n    // $FlowFixMe flow doesn't understand symbols.\n    case \"symbol\":\n      throw new FatalError(\"Symbol cannot be safely cloned.\");\n    case \"function\":\n      throw new FatalError(\"Functions could be supported but are not yet.\");\n    case \"object\": {\n      if (value === null) {\n        return realm.intrinsics.null;\n      }\n      if (Array.isArray(value)) {\n        throw new FatalError(\"Arrays are not supported yet.\");\n      }\n      let prototype = Object.getPrototypeOf(value);\n      if (prototype !== Object.prototype) {\n        throw new FatalError(\n          \"Only simple objects are supported for now. Got: \" +\n            ((typeof prototype.constructor === \"function\" && prototype.constructor.name) ||\n              Object.prototype.toString.call(prototype))\n        );\n      }\n      let obj = new ObjectValue(\n        realm,\n        realm.intrinsics.ObjectPrototype,\n        intrinsicName // We use the intrinsic name for Objects to preserve their referential equality\n      );\n      let names = Object.getOwnPropertyNames(value);\n      for (let name of names) {\n        // We intentionally invoke the getter on value[name] which resolves any\n        // lazy getters.\n        let newValue = createDeepIntrinsic(realm, value[name], intrinsicName + \".\" + name);\n        copyProperty(realm, value, obj, name, newValue);\n      }\n      return obj;\n    }\n    default:\n      invariant(false);\n  }\n}\n\n// Define a value with the same descriptor settings as the original object.\nexport function copyProperty(realm: Realm, originalObject: {}, realmObject: ObjectValue, name: string, value: Value) {\n  let desc = Object.getOwnPropertyDescriptor(originalObject, name);\n  if (!desc) {\n    return;\n  }\n  if (desc.get || desc.set) {\n    throw new FatalError(\"Getter/setters are not supported because functions are not supported yet.\");\n  }\n  let newDesc = {\n    value: value,\n    writable: !!desc.writable,\n    configurable: !!desc.configurable,\n    enumerable: !!desc.enumerable,\n  };\n  Properties.DefinePropertyOrThrow(realm, realmObject, name, newDesc);\n}\n"]}