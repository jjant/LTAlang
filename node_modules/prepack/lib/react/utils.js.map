{"version":3,"sources":["../../src/react/utils.js"],"names":["isReactElement","isTagName","isReactComponent","valueIsClassComponent","addKeyToReactElement","getUniqueReactElementKey","mapOverArrayValue","val","properties","has","realm","$Realm","$$typeof","symbolFromRegistry","globalSymbolRegistry","find","e","$Symbol","undefined","$Key","ast","type","test","name","length","toUpperCase","value","$Prototype","prototype","reactSerializerState","reactElement","currentKeyValue","intrinsics","null","uniqueKey","usedReactElementKeys","newKeyValue","$Set","index","key","Math","random","toString","replace","substring","add","arrayValue","mapFunc","lengthValue","i","elementProperty","get","elementPropertyDescriptor","descriptor","elementValue"],"mappings":"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","file":"utils.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { Realm } from \"../realm.js\";\nimport type { BabelNode, BabelNodeJSXIdentifier } from \"babel-types\";\nimport {\n  Value,\n  NumberValue,\n  ObjectValue,\n  SymbolValue,\n  FunctionValue,\n  StringValue,\n  ArrayValue,\n} from \"../values/index.js\";\nimport { Get } from \"../methods/index.js\";\nimport { computeBinary } from \"../evaluators/BinaryExpression.js\";\nimport { type ReactSerializerState } from \"../serializer/types.js\";\nimport invariant from \"../invariant.js\";\n\nexport function isReactElement(val: Value): boolean {\n  if (val instanceof ObjectValue && val.properties.has(\"$$typeof\")) {\n    let realm = val.$Realm;\n    let $$typeof = Get(realm, val, \"$$typeof\");\n    if ($$typeof instanceof SymbolValue) {\n      let symbolFromRegistry = realm.globalSymbolRegistry.find(e => e.$Symbol === $$typeof);\n      return symbolFromRegistry !== undefined && symbolFromRegistry.$Key === \"react.element\";\n    }\n  }\n  return false;\n}\n\nexport function isTagName(ast: BabelNode): boolean {\n  return ast.type === \"JSXIdentifier\" && /^[a-z]|\\-/.test(((ast: any): BabelNodeJSXIdentifier).name);\n}\n\nexport function isReactComponent(name: string) {\n  return name.length > 0 && name[0] === name[0].toUpperCase();\n}\n\nexport function valueIsClassComponent(realm: Realm, value: Value) {\n  if (!(value instanceof FunctionValue)) {\n    return false;\n  }\n  if (value.$Prototype instanceof ObjectValue) {\n    let prototype = Get(realm, value.$Prototype, \"prototype\");\n    if (prototype instanceof ObjectValue) {\n      return prototype.properties.has(\"isReactComponent\");\n    }\n  }\n  return false;\n}\n\nexport function addKeyToReactElement(\n  realm: Realm,\n  reactSerializerState: ReactSerializerState,\n  reactElement: ObjectValue\n): void {\n  // we need to apply a key when we're branched\n  let currentKeyValue = Get(realm, reactElement, \"key\") || realm.intrinsics.null;\n  let uniqueKey = getUniqueReactElementKey(\"\", reactSerializerState.usedReactElementKeys);\n  let newKeyValue = new StringValue(realm, uniqueKey);\n  if (currentKeyValue !== realm.intrinsics.null) {\n    newKeyValue = computeBinary(realm, \"+\", currentKeyValue, newKeyValue);\n  }\n  // TODO: This might not be safe in DEV because these objects are frozen (Object.freeze).\n  // We should probably go behind the scenes in this case to by-pass that.\n  reactElement.$Set(\"key\", newKeyValue, reactElement);\n}\n// we create a unique key for each JSXElement to prevent collisions\n// otherwise React will detect a missing/conflicting key at runtime and\n// this can break the reconcilation of JSXElements in arrays\nexport function getUniqueReactElementKey(index?: string, usedReactElementKeys: Set<string>) {\n  let key;\n  do {\n    key = Math.random().toString(36).replace(/[^a-z]+/g, \"\").substring(0, 2);\n  } while (usedReactElementKeys.has(key));\n  usedReactElementKeys.add(key);\n  if (index !== undefined) {\n    return `${key}${index}`;\n  }\n  return key;\n}\n\n// a helper function to map over ArrayValues\nexport function mapOverArrayValue(realm: Realm, arrayValue: ArrayValue, mapFunc: Function): void {\n  let lengthValue = Get(realm, arrayValue, \"length\");\n  invariant(lengthValue instanceof NumberValue, \"Invalid length on ArrayValue during reconcilation\");\n  let length = lengthValue.value;\n  for (let i = 0; i < length; i++) {\n    let elementProperty = arrayValue.properties.get(\"\" + i);\n    let elementPropertyDescriptor = elementProperty && elementProperty.descriptor;\n    invariant(elementPropertyDescriptor, `Invalid ArrayValue[${i}] descriptor`);\n    let elementValue = elementPropertyDescriptor.value;\n    if (elementValue instanceof Value) {\n      mapFunc(elementValue, elementPropertyDescriptor);\n    }\n  }\n}\n"]}