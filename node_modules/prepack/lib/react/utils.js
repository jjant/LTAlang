"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isReactElement = isReactElement;
exports.isTagName = isTagName;
exports.isReactComponent = isReactComponent;
exports.valueIsClassComponent = valueIsClassComponent;
exports.addKeyToReactElement = addKeyToReactElement;
exports.getUniqueReactElementKey = getUniqueReactElementKey;
exports.mapOverArrayValue = mapOverArrayValue;

var _realm = require("../realm.js");

var _index = require("../values/index.js");

var _index2 = require("../methods/index.js");

var _BinaryExpression = require("../evaluators/BinaryExpression.js");

require("../serializer/types.js");

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

function isReactElement(val) {
  if (val instanceof _index.ObjectValue && val.properties.has("$$typeof")) {
    var realm = val.$Realm;
    var $$typeof = (0, _index2.Get)(realm, val, "$$typeof");
    if ($$typeof instanceof _index.SymbolValue) {
      var symbolFromRegistry = realm.globalSymbolRegistry.find(function (e) {
        return e.$Symbol === $$typeof;
      });
      return symbolFromRegistry !== undefined && symbolFromRegistry.$Key === "react.element";
    }
  }
  return false;
}

function isTagName(ast) {
  return ast.type === "JSXIdentifier" && /^[a-z]|\-/.test(ast.name);
}

function isReactComponent(name) {
  return name.length > 0 && name[0] === name[0].toUpperCase();
}

function valueIsClassComponent(realm, value) {
  if (!(value instanceof _index.FunctionValue)) {
    return false;
  }
  if (value.$Prototype instanceof _index.ObjectValue) {
    var prototype = (0, _index2.Get)(realm, value.$Prototype, "prototype");
    if (prototype instanceof _index.ObjectValue) {
      return prototype.properties.has("isReactComponent");
    }
  }
  return false;
}

function addKeyToReactElement(realm, reactSerializerState, reactElement) {
  // we need to apply a key when we're branched
  var currentKeyValue = (0, _index2.Get)(realm, reactElement, "key") || realm.intrinsics.null;
  var uniqueKey = getUniqueReactElementKey("", reactSerializerState.usedReactElementKeys);
  var newKeyValue = new _index.StringValue(realm, uniqueKey);
  if (currentKeyValue !== realm.intrinsics.null) {
    newKeyValue = (0, _BinaryExpression.computeBinary)(realm, "+", currentKeyValue, newKeyValue);
  }
  // TODO: This might not be safe in DEV because these objects are frozen (Object.freeze).
  // We should probably go behind the scenes in this case to by-pass that.
  reactElement.$Set("key", newKeyValue, reactElement);
}
// we create a unique key for each JSXElement to prevent collisions
// otherwise React will detect a missing/conflicting key at runtime and
// this can break the reconcilation of JSXElements in arrays
function getUniqueReactElementKey(index, usedReactElementKeys) {
  var key = void 0;
  do {
    key = Math.random().toString(36).replace(/[^a-z]+/g, "").substring(0, 2);
  } while (usedReactElementKeys.has(key));
  usedReactElementKeys.add(key);
  if (index !== undefined) {
    return "" + key + index;
  }
  return key;
}

// a helper function to map over ArrayValues
function mapOverArrayValue(realm, arrayValue, mapFunc) {
  var lengthValue = (0, _index2.Get)(realm, arrayValue, "length");
  (0, _invariant2.default)(lengthValue instanceof _index.NumberValue, "Invalid length on ArrayValue during reconcilation");
  var length = lengthValue.value;
  for (var i = 0; i < length; i++) {
    var elementProperty = arrayValue.properties.get("" + i);
    var elementPropertyDescriptor = elementProperty && elementProperty.descriptor;
    (0, _invariant2.default)(elementPropertyDescriptor, "Invalid ArrayValue[" + i + "] descriptor");
    var elementValue = elementPropertyDescriptor.value;
    if (elementValue instanceof _index.Value) {
      mapFunc(elementValue, elementPropertyDescriptor);
    }
  }
}
//# sourceMappingURL=utils.js.map