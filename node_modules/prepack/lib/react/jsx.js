"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.convertExpressionToJSXIdentifier = convertExpressionToJSXIdentifier;
exports.convertJSXExpressionToIdentifier = convertJSXExpressionToIdentifier;
exports.convertKeyValueToJSXAttribute = convertKeyValueToJSXAttribute;

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function convertExpressionToJSXIdentifier(expr, isRoot) {
  switch (expr.type) {
    case "ThisExpression":
      (0, _invariant2.default)(isRoot === false, "invalid conversion of root expression to JSXIdentifier for ThisExpression");
      return t.jSXIdentifier("this");
    case "Identifier":
      var name = expr.name;
      (0, _invariant2.default)(
      // ensure the 1st character of the string is uppercase
      // for a component unless it is not the root
      isRoot === false || (0, _utils.isReactComponent)(name), "invalid JSXIdentifer from Identifier, Identifier name must be uppercase");
      return t.jSXIdentifier(name);
    case "StringLiteral":
      var value = expr.value;
      (0, _invariant2.default)(
      // ensure the 1st character of the string is lowercase
      // otherwise it will appear as a component
      value.length > 0 && value[0] === value[0].toLowerCase(), "invalid JSXIdentifer from string, strings must be lowercase");
      return t.jSXIdentifier(value);
    case "MemberExpression":
      (0, _invariant2.default)(expr.computed === false, "Cannot inline computed expressions in JSX type.");
      return t.jSXMemberExpression(convertExpressionToJSXIdentifier(expr.object, false), convertExpressionToJSXIdentifier(expr.property, false));
    default:
      (0, _invariant2.default)(false, "Invalid JSX type");
  }
} /**
   * Copyright (c) 2017-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   */

function convertJSXExpressionToIdentifier(expr) {
  switch (expr.type) {
    case "JSXIdentifier":
      return t.identifier(expr.name);
    case "JSXMemberExpression":
      return t.memberExpression(convertJSXExpressionToIdentifier(expr.object), convertJSXExpressionToIdentifier(expr.property));
    default:
      (0, _invariant2.default)(false, "Invalid JSX type");
  }
}

function convertKeyValueToJSXAttribute(key, expr) {
  return t.jSXAttribute(t.jSXIdentifier(key), expr.type === "StringLiteral" ? expr : t.jSXExpressionContainer(expr));
}
//# sourceMappingURL=jsx.js.map