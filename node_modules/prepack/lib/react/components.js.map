{"version":3,"sources":["../../src/react/components.js"],"names":["getInitialProps","getInitialContext","createClassInstance","t","realm","componentType","propsName","propTypes","react","flowRequired","superTypeParameters","$SuperTypeParameters","undefined","$FormalParameters","length","firstParam","isIdentifier","name","propsTypeAnnotation","typeAnnotation","contextName","contextTypes","secondParam","contextTypeAnnotation","props","context","componentPrototype","instance","properties","Set","makeSimple","makePartial"],"mappings":"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","file":"components.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { Realm } from \"../realm.js\";\nimport { ECMAScriptSourceFunctionValue, AbstractValue, ObjectValue, AbstractObjectValue } from \"../values/index.js\";\nimport { flowAnnotationToObjectTypeTemplate } from \"../flow/utils.js\";\nimport * as t from \"babel-types\";\nimport type { BabelNodeIdentifier } from \"babel-types\";\nimport { createAbstractObject } from \"../flow/abstractObjectFactories.js\";\nimport { valueIsClassComponent } from \"./utils\";\nimport { ExpectedBailOut } from \"./reconcilation.js\";\nimport { Get } from \"../methods/index.js\";\nimport { Properties } from \"../singletons.js\";\nimport invariant from \"../invariant.js\";\n\nexport function getInitialProps(\n  realm: Realm,\n  componentType: ECMAScriptSourceFunctionValue\n): ObjectValue | AbstractObjectValue {\n  let propsName = null;\n  let propTypes = null;\n  if (valueIsClassComponent(realm, componentType)) {\n    propsName = \"this.props\";\n    // if flow is not required, do not try to construct the object from Flow types\n    if (realm.react.flowRequired) {\n      // it's a class component, so we need to check the type on for props of the component prototype\n      let superTypeParameters = componentType.$SuperTypeParameters;\n      if (superTypeParameters !== undefined) {\n        throw new ExpectedBailOut(\"props on class components not yet supported\");\n      }\n    }\n  } else {\n    // otherwise it's a functional component, where the first paramater of the function is \"props\" (if it exists)\n    if (componentType.$FormalParameters.length > 0) {\n      let firstParam = componentType.$FormalParameters[0];\n      if (t.isIdentifier(firstParam)) {\n        propsName = ((firstParam: any): BabelNodeIdentifier).name;\n      }\n      // if flow is not required, do not try to construct the object from Flow types\n      if (realm.react.flowRequired) {\n        let propsTypeAnnotation = firstParam.typeAnnotation !== undefined && firstParam.typeAnnotation;\n        // we expect that if there's a props paramater, it should always have Flow annotations\n        if (!propsTypeAnnotation) {\n          throw new ExpectedBailOut(`root component missing Flow type annotations for the \"props\" paramater`);\n        }\n        propTypes = flowAnnotationToObjectTypeTemplate(propsTypeAnnotation);\n      }\n    }\n  }\n  return createAbstractObject(realm, propsName, propTypes);\n}\n\nexport function getInitialContext(\n  realm: Realm,\n  componentType: ECMAScriptSourceFunctionValue\n): ObjectValue | AbstractObjectValue {\n  let contextName = null;\n  let contextTypes = null;\n  if (valueIsClassComponent(realm, componentType)) {\n    // it's a class component, so we need to check the type on for context of the component prototype\n    let superTypeParameters = componentType.$SuperTypeParameters;\n    contextName = \"this.context\";\n\n    if (superTypeParameters !== undefined) {\n      throw new ExpectedBailOut(\"context on class components not yet supported\");\n    }\n  } else {\n    // otherwise it's a functional component, where the second paramater of the function is \"context\" (if it exists)\n    if (componentType.$FormalParameters.length > 1) {\n      let secondParam = componentType.$FormalParameters[1];\n      if (t.isIdentifier(secondParam)) {\n        contextName = ((secondParam: any): BabelNodeIdentifier).name;\n      }\n      let contextTypeAnnotation = secondParam.typeAnnotation !== undefined && secondParam.typeAnnotation;\n      // we expect that if there's a context param, it should always have Flow annotations\n      if (!contextTypeAnnotation) {\n        throw new ExpectedBailOut(`root component missing Flow type annotations for the \"context\" paramater`);\n      }\n      contextTypes = flowAnnotationToObjectTypeTemplate(contextTypeAnnotation);\n    }\n  }\n  return createAbstractObject(realm, contextName, contextTypes);\n}\n\nexport function createClassInstance(\n  realm: Realm,\n  componentType: ECMAScriptSourceFunctionValue,\n  props: ObjectValue | AbstractValue,\n  context: ObjectValue | AbstractValue\n): AbstractObjectValue {\n  let componentPrototype = Get(realm, componentType, \"prototype\");\n  invariant(componentPrototype instanceof ObjectValue);\n  let instance = createAbstractObject(realm, \"this\", null);\n  for (let [name] of componentPrototype.properties) {\n    if (name !== \"constructor\") {\n      Properties.Set(realm, instance, name, Get(realm, componentPrototype, name), true);\n    }\n  }\n  // make partial and simple to support user instance properties\n  instance.makeSimple();\n  instance.makePartial();\n  // assign state\n  Properties.Set(realm, instance, \"state\", createAbstractObject(realm, \"this.state\", null), true);\n  // assign refs\n  Properties.Set(realm, instance, \"refs\", createAbstractObject(realm, \"this.refs\", null), true);\n  // assign props\n  Properties.Set(realm, instance, \"props\", props, true);\n  // assign context\n  Properties.Set(realm, instance, \"context\", context, true);\n  // return the instance\n  return instance;\n}\n"]}