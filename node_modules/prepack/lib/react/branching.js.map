{"version":3,"sources":["../../src/react/branching.js"],"names":["BranchState","_branchesToValidate","realm","reactSerializerState","value","_applyBranchedLogicValue","elementValue","length","args","i","reactElementType","applyBranchedLogic","type","undefined","push"],"mappings":";;;;;;;qjBAAA;;;;;;;;;AAWA;;AACA;;AAYA;;AACA;;AACA;;;;AAWA;AACA;AACA;AACA;AACA;;;AAbA;AACA;AACA;AACA;AACA;AACA;AACA;IAQaA,W,WAAAA,W;AACX,yBAAc;AAAA;;AACZ,SAAKC,mBAAL,GAA2B,EAA3B;AACD;;;;6CACwBC,K,EAAcC,oB,EAA4CC,K,EAAoB;AAAA;;AACrG,UACEA,uCACAA,mCADA,IAEAA,oCAFA,IAGAA,iCAHA,IAIAA,sCALF,EAME;AACA;AACD,OARD,MAQO,IAAIA,uCAAgC,2BAAeA,KAAf,CAApC,EAA2D;AAChE,yCAAqBF,KAArB,EAA4BC,oBAA5B,EAAkDC,KAAlD;AACD,OAFM,MAEA,IAAIA,kCAAJ,EAAiC;AACtC,sCAAkBF,KAAlB,EAAyBE,KAAzB,EAAgC,wBAAgB;AAC9C,gBAAKC,wBAAL,CAA8BH,KAA9B,EAAqCC,oBAArC,EAA2DG,YAA3D;AACD,SAFD;AAGD,OAJM,MAIA,IAAIF,qCAAJ,EAAoC;AACzC,YAAIG,SAASH,MAAMI,IAAN,CAAWD,MAAxB;AACA,YAAIA,SAAS,CAAb,EAAgB;AACd,eAAK,IAAIE,IAAI,CAAb,EAAgBA,IAAIF,MAApB,EAA4BE,GAA5B,EAAiC;AAC/B,iBAAKJ,wBAAL,CAA8BH,KAA9B,EAAqCC,oBAArC,EAA2DC,MAAMI,IAAN,CAAWC,CAAX,CAA3D;AACD;AACF;AACF,OAPM,MAOA;AACL,cAAM,mCAAoB,sEAApB,CAAN;AACD;AACF;;;uCACkBP,K,EAAcC,oB,EAAkD;AACjF,UAAIO,yBAAJ;AACA,UAAIC,qBAAqB,KAAzB;;AAEA,WAAK,IAAIF,IAAI,CAAb,EAAgBA,IAAI,KAAKR,mBAAL,CAAyBM,MAA7C,EAAqDE,GAArD,EAA0D;AAAA,YAClDG,KADkD,GACzC,KAAKX,mBAAL,CAAyBQ,CAAzB,CADyC,CAClDG,IADkD;;AAExD,YAAIF,qBAAqBG,SAAzB,EAAoC;AAClCH,6BAAmBE,KAAnB;AACD,SAFD,MAEO,IAAIA,UAASF,gBAAb,EAA+B;AACpC;AACAC,+BAAqB,IAArB;AACA;AACD;AACF;AACD,UAAIA,kBAAJ,EAAwB;AACtB,aAAK,IAAIF,KAAI,CAAb,EAAgBA,KAAI,KAAKR,mBAAL,CAAyBM,MAA7C,EAAqDE,IAArD,EAA0D;AACxD,eAAKJ,wBAAL,CAA8BH,KAA9B,EAAqCC,oBAArC,EAA2D,KAAKF,mBAAL,CAAyBQ,EAAzB,EAA4BL,KAAvF;AACD;AACF;AACF;;;yCACoBQ,I,EAAmDR,K,EAAqB;AAC3F,WAAKH,mBAAL,CAAyBa,IAAzB,CAA8B,EAAEF,UAAF,EAAQR,YAAR,EAA9B;AACA,aAAOA,KAAP;AACD","file":"branching.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { Realm } from \"../realm.js\";\nimport {\n  ECMAScriptSourceFunctionValue,\n  Value,\n  UndefinedValue,\n  StringValue,\n  NumberValue,\n  BooleanValue,\n  NullValue,\n  AbstractValue,\n  ArrayValue,\n  ObjectValue,\n} from \"../values/index.js\";\nimport { type ReactSerializerState } from \"../serializer/types.js\";\nimport { isReactElement, addKeyToReactElement, mapOverArrayValue } from \"./utils\";\nimport { ExpectedBailOut } from \"./reconcilation.js\";\n\n// Branch status is used for when Prepack returns an abstract value from a render\n// that results in a conditional path occuring. This can be problematic for reconcilation\n// as the reconciler then needs to understand if this is the start of a new branch, or if\n// it's actually deep into an existing branch. If it's a new branch, we need to apply\n// keys to the root JSX element so that it keeps it identity (because we're folding trees).\n// Furthermore, we also need to bail-out of folding class components where they have lifecycle\n// events, as we can't merge lifecycles of mutliple trees when branched reliably\nexport type BranchStatusEnum = \"ROOT\" | \"NO_BRANCH\" | \"NEW_BRANCH\" | \"BRANCH\";\n\n// Branch state is used to capture branched ReactElements so they can be analyzed and compared\n// once all branches have been processed. This allows us to add keys to the respective ReactElement\n// objects depending on various heuristics (if they have the same \"type\" for example)\n// A new branch state is created on a branch status of \"NEW_BRANCH\" and is reset to null once the branch is no\n// longer new\nexport class BranchState {\n  constructor() {\n    this._branchesToValidate = [];\n  }\n  _applyBranchedLogicValue(realm: Realm, reactSerializerState: ReactSerializerState, value: Value): void {\n    if (\n      value instanceof StringValue ||\n      value instanceof NumberValue ||\n      value instanceof BooleanValue ||\n      value instanceof NullValue ||\n      value instanceof UndefinedValue\n    ) {\n      // terminal values\n    } else if (value instanceof ObjectValue && isReactElement(value)) {\n      addKeyToReactElement(realm, reactSerializerState, value);\n    } else if (value instanceof ArrayValue) {\n      mapOverArrayValue(realm, value, elementValue => {\n        this._applyBranchedLogicValue(realm, reactSerializerState, elementValue);\n      });\n    } else if (value instanceof AbstractValue) {\n      let length = value.args.length;\n      if (length > 0) {\n        for (let i = 0; i < length; i++) {\n          this._applyBranchedLogicValue(realm, reactSerializerState, value.args[i]);\n        }\n      }\n    } else {\n      throw new ExpectedBailOut(\"Unsupported value encountered when applying branched logic to values\");\n    }\n  }\n  applyBranchedLogic(realm: Realm, reactSerializerState: ReactSerializerState): void {\n    let reactElementType;\n    let applyBranchedLogic = false;\n\n    for (let i = 0; i < this._branchesToValidate.length; i++) {\n      let { type } = this._branchesToValidate[i];\n      if (reactElementType === undefined) {\n        reactElementType = type;\n      } else if (type !== reactElementType) {\n        // the types of the ReactElements do not match, so apply branch logic\n        applyBranchedLogic = true;\n        break;\n      }\n    }\n    if (applyBranchedLogic) {\n      for (let i = 0; i < this._branchesToValidate.length; i++) {\n        this._applyBranchedLogicValue(realm, reactSerializerState, this._branchesToValidate[i].value);\n      }\n    }\n  }\n  captureBranchedValue(type: StringValue | ECMAScriptSourceFunctionValue, value: Value): Value {\n    this._branchesToValidate.push({ type, value });\n    return value;\n  }\n  _branchesToValidate: Array<{\n    type: StringValue | ECMAScriptSourceFunctionValue,\n    value: Value,\n  }>;\n}\n"]}