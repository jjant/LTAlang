{"version":3,"sources":["../../src/react/reconcilation.js"],"names":["ExpectedBailOut","message","Reconciler","realm","moduleTracer","statistics","reactSerializerState","componentType","wrapInGlobalEnv","evaluateForEffects","initialProps","initialContext","_renderComponent","result","optimizedTrees","error","diagnostic","currentLocation","handleError","props","context","branchStatus","branchState","value","childContext","instance","renderMethod","$Call","intrinsics","undefined","_resolveDeeply","length","args","newBranchState","i","applyBranchedLogic","_resolveFragment","reactElement","typeValue","propsValue","refValue","childrenProperty","properties","get","childrenPropertyDescriptor","descriptor","childrenPropertyValue","resolvedChildren","_assignBailOutMessage","captureBranchedValue","inlinedComponents","$BailOutReason","arrayValue","elementValue","elementPropertyDescriptor"],"mappings":"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","file":"reconcilation.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { Realm, type Effects } from \"../realm.js\";\nimport { ModuleTracer } from \"../serializer/modules.js\";\nimport {\n  ECMAScriptSourceFunctionValue,\n  Value,\n  UndefinedValue,\n  StringValue,\n  NumberValue,\n  BooleanValue,\n  NullValue,\n  AbstractValue,\n  ArrayValue,\n  ObjectValue,\n  AbstractObjectValue,\n} from \"../values/index.js\";\nimport { ReactStatistics, type ReactSerializerState } from \"../serializer/types.js\";\nimport { isReactElement, valueIsClassComponent, mapOverArrayValue } from \"./utils\";\nimport { Get } from \"../methods/index.js\";\nimport invariant from \"../invariant.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { BranchState, type BranchStatusEnum } from \"./branching.js\";\nimport { getInitialProps, getInitialContext, createClassInstance } from \"./components.js\";\n\n// ExpectedBailOut is like an error, that gets thrown during the reconcilation phase\n// allowing the reconcilation to continue on other branches of the tree, the message\n// given to ExpectedBailOut will be assigned to the value.$BailOutReason property and serialized\n// as a comment in the output source to give the user hints as to what they need to do\n// to fix the bail-out case\nexport class ExpectedBailOut {\n  message: string;\n  constructor(message: string) {\n    this.message = message;\n  }\n}\n\nexport class Reconciler {\n  constructor(\n    realm: Realm,\n    moduleTracer: ModuleTracer,\n    statistics: ReactStatistics,\n    reactSerializerState: ReactSerializerState\n  ) {\n    this.realm = realm;\n    this.moduleTracer = moduleTracer;\n    this.statistics = statistics;\n    this.reactSerializerState = reactSerializerState;\n  }\n\n  realm: Realm;\n  moduleTracer: ModuleTracer;\n  statistics: ReactStatistics;\n  reactSerializerState: ReactSerializerState;\n\n  render(componentType: ECMAScriptSourceFunctionValue): Effects {\n    return this.realm.wrapInGlobalEnv(() =>\n      // TODO: (sebmarkbage): You could use the return value of this to detect if there are any mutations on objects other\n      // than newly created ones. Then log those to the error logger. That'll help us track violations in\n      // components. :)\n      this.realm.evaluateForEffects(() => {\n        // initialProps and initialContext are created from Flow types from:\n        // - if a functional component, the 1st and 2nd paramater of function\n        // - if a class component, use this.props and this.context\n        // if there are no Flow types for props or context, we will throw a\n        // FatalError, unless it's a functional component that has no paramater\n        // i.e let MyComponent = () => <div>Hello world</div>\n        try {\n          let initialProps = getInitialProps(this.realm, componentType);\n          let initialContext = getInitialContext(this.realm, componentType);\n          let { result } = this._renderComponent(componentType, initialProps, initialContext, \"ROOT\", null);\n          this.statistics.optimizedTrees++;\n          return result;\n        } catch (error) {\n          // if there was a bail-out on the root component in this reconcilation process, then this\n          // should be an invariant as the user has explicitly asked for this component to get folded\n          if (error instanceof ExpectedBailOut) {\n            let diagnostic = new CompilerDiagnostic(\n              `__registerReactComponentRoot() failed due to - ${error.message}`,\n              this.realm.currentLocation,\n              \"PP0019\",\n              \"FatalError\"\n            );\n            this.realm.handleError(diagnostic);\n            throw new FatalError();\n          }\n          throw error;\n        }\n      })\n    );\n  }\n  _renderComponent(\n    componentType: ECMAScriptSourceFunctionValue,\n    props: ObjectValue | AbstractObjectValue,\n    context: ObjectValue | AbstractObjectValue,\n    branchStatus: BranchStatusEnum,\n    branchState: BranchState | null\n  ) {\n    let value;\n    let childContext = context;\n    if (valueIsClassComponent(this.realm, componentType)) {\n      if (branchStatus !== \"ROOT\") {\n        throw new ExpectedBailOut(\"only class components at the root of __registerReactComponentRoot() are supported\");\n      }\n      // create a new instance of this React class component\n      let instance = createClassInstance(this.realm, componentType, props, context);\n      // get the \"render\" method off the instance\n      let renderMethod = Get(this.realm, instance, \"render\");\n      invariant(\n        renderMethod instanceof ECMAScriptSourceFunctionValue && renderMethod.$Call,\n        \"Expected render method to be a FunctionValue with $Call method\"\n      );\n      // the render method doesn't have any arguments, so we just assign the context of \"this\" to be the instance\n      value = renderMethod.$Call(instance, []);\n    } else {\n      invariant(componentType.$Call, \"Expected componentType to be a FunctionValue with $Call method\");\n      value = componentType.$Call(this.realm.intrinsics.undefined, [props, context]);\n    }\n    return {\n      result: this._resolveDeeply(value, context, branchStatus === \"ROOT\" ? \"NO_BRANCH\" : branchStatus, branchState),\n      childContext,\n    };\n  }\n  _resolveDeeply(\n    value: Value,\n    context: ObjectValue | AbstractObjectValue,\n    branchStatus: BranchStatusEnum,\n    branchState: BranchState | null\n  ) {\n    if (\n      value instanceof StringValue ||\n      value instanceof NumberValue ||\n      value instanceof BooleanValue ||\n      value instanceof NullValue ||\n      value instanceof UndefinedValue\n    ) {\n      // terminal values\n      return value;\n    } else if (value instanceof AbstractValue) {\n      let length = value.args.length;\n      if (length > 0) {\n        let newBranchState = new BranchState();\n        // TODO investigate what other kinds than \"conditional\" might be safe to deeply resolve\n        for (let i = 0; i < length; i++) {\n          value.args[i] = this._resolveDeeply(value.args[i], context, \"NEW_BRANCH\", newBranchState);\n        }\n        newBranchState.applyBranchedLogic(this.realm, this.reactSerializerState);\n      }\n      return value;\n    }\n    // TODO investigate what about other iterables type objects\n    if (value instanceof ArrayValue) {\n      this._resolveFragment(value, context, branchStatus, branchState);\n      return value;\n    }\n    if (value instanceof ObjectValue && isReactElement(value)) {\n      // we call value reactElement, to make it clearer what we're dealing with in this block\n      let reactElement = value;\n      let typeValue = Get(this.realm, reactElement, \"type\");\n      let propsValue = Get(this.realm, reactElement, \"props\");\n      let refValue = Get(this.realm, reactElement, \"ref\");\n      if (typeValue instanceof StringValue) {\n        // terminal host component. Start evaluating its children.\n        if (propsValue instanceof ObjectValue) {\n          let childrenProperty = propsValue.properties.get(\"children\");\n          if (childrenProperty) {\n            let childrenPropertyDescriptor = childrenProperty.descriptor;\n            // if the descriptor is undefined, the property is likely deleted, if it exists\n            // proceed to resolve the children\n            if (childrenPropertyDescriptor !== undefined) {\n              let childrenPropertyValue = childrenPropertyDescriptor.value;\n              invariant(childrenPropertyValue instanceof Value, `Bad \"children\" prop passed in JSXElement`);\n              let resolvedChildren = this._resolveDeeply(childrenPropertyValue, context, branchStatus, branchState);\n              childrenPropertyDescriptor.value = resolvedChildren;\n            }\n          }\n        }\n        return reactElement;\n      }\n      // we do not support \"ref\" on <Component /> ReactElements\n      if (!(refValue instanceof NullValue)) {\n        this._assignBailOutMessage(reactElement, `Bail-out: refs are not supported on <Components />`);\n        return reactElement;\n      }\n      if (!(propsValue instanceof ObjectValue || propsValue instanceof AbstractObjectValue)) {\n        this._assignBailOutMessage(\n          reactElement,\n          `Bail-out: props on <Component /> was not not an ObjectValue or an AbstractValue`\n        );\n        return reactElement;\n      }\n      if (!(typeValue instanceof ECMAScriptSourceFunctionValue)) {\n        this._assignBailOutMessage(\n          reactElement,\n          `Bail-out: type on <Component /> was not a ECMAScriptSourceFunctionValue`\n        );\n        return reactElement;\n      }\n      try {\n        let { result } = this._renderComponent(\n          typeValue,\n          propsValue,\n          context,\n          branchStatus === \"NEW_BRANCH\" ? \"BRANCH\" : branchStatus,\n          null\n        );\n        if (result instanceof UndefinedValue) {\n          this._assignBailOutMessage(reactElement, `Bail-out: undefined was returned from render`);\n          if (branchStatus === \"NEW_BRANCH\" && branchState) {\n            return branchState.captureBranchedValue(typeValue, reactElement);\n          }\n          return reactElement;\n        }\n        this.statistics.inlinedComponents++;\n        if (branchStatus === \"NEW_BRANCH\" && branchState) {\n          return branchState.captureBranchedValue(typeValue, result);\n        }\n        return result;\n      } catch (error) {\n        // assign a bail out message\n        if (error instanceof ExpectedBailOut) {\n          this._assignBailOutMessage(reactElement, \"Bail-out: \" + error.message);\n        } else if (error instanceof FatalError) {\n          this._assignBailOutMessage(reactElement, \"Evaluation bail-out\");\n        } else {\n          throw error;\n        }\n        // a child component bailed out during component folding, so return the function value and continue\n        if (branchStatus === \"NEW_BRANCH\" && branchState) {\n          return branchState.captureBranchedValue(typeValue, reactElement);\n        }\n        return reactElement;\n      }\n    } else {\n      throw new ExpectedBailOut(\"unsupported value type during reconcilation\");\n    }\n  }\n  _assignBailOutMessage(reactElement: ObjectValue, message: string): void {\n    // $BailOutReason is a field on ObjectValue that allows us to specify a message\n    // that gets serialized as a comment node during the ReactElement serialization stage\n    if (reactElement.$BailOutReason !== undefined) {\n      // merge bail out messages if one already exists\n      reactElement.$BailOutReason += `, ${message}`;\n    } else {\n      reactElement.$BailOutReason = message;\n    }\n  }\n  _resolveFragment(\n    arrayValue: ArrayValue,\n    context: ObjectValue | AbstractObjectValue,\n    branchStatus: BranchStatusEnum,\n    branchState: BranchState | null\n  ) {\n    mapOverArrayValue(this.realm, arrayValue, (elementValue, elementPropertyDescriptor) => {\n      elementPropertyDescriptor.value = this._resolveDeeply(elementValue, context, branchStatus, branchState);\n    });\n  }\n}\n"]}