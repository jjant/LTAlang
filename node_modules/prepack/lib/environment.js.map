{"version":3,"sources":["../src/environment.js"],"names":["canBecomeAnObject","t","sourceMap","require","EnvironmentRecord","realm","isReadOnly","DeclarativeEnvironmentRecord","bindings","Object","create","N","envRec","D","isGlobal","recordModifiedBinding","initialized","mutable","deletable","environment","name","intrinsics","undefined","S","strict","V","binding","value","empty","createErrorThrowCompletion","ReferenceError","CreateMutableBinding","InitializeBinding","TypeError","ObjectEnvironmentRecord","obj","object","foundBinding","withEnvironment","unscopables","SymbolUnscopables","blocked","throwIfNotConcrete","configValue","DefinePropertyOrThrow","writable","enumerable","configurable","SetMutableBinding","Set","$Delete","FunctionEnvironmentRecord","$ThisBindingStatus","$ThisValue","$HomeObject","home","$GetPrototypeOf","GlobalEnvironmentRecord","DclRec","$DeclarativeRecord","HasBinding","ObjRec","$ObjectRecord","CreateImmutableBinding","GetBindingValue","DeleteBinding","globalObject","existingProp","status","varNames","$VarNames","indexOf","splice","$GlobalThisValue","varDeclaredNames","$GetOwnProperty","ThrowIfMightHaveBeenDeleted","hasProperty","extensible","push","desc","LexicalEnvironment","globalAst","rvalue","globalValue","evaluate","PutValue","ast","strictCode","metadata","partiallyEvaluateCompletion","result","partial_ast","partial_io","Reference","GetValue","partiallyEvaluate","err","Error","evaluateCompletion","containsBreakOrContinue","reportIntrospectionError","joinCondition","evaluateAbstract","constructor","sources","sourceType","asts","code","directives","source","node","fileContents","filePath","sourceMapContents","length","fixup_source_locations","fixup_filenames","concat","program","body","e","error","message","$Get","location","handleError","file","onParse","context","lexicalEnvironment","variableEnvironment","pushContext","res","concatenateAndParse","popContext","options","partialAST","partiallyEvaluateCompletionDeref","type","fileAst","prog","sourceMaps","filename","map","smc","SourceMapConsumer","loc","fixup","start","end","fixup_comments","leadingComments","innerComments","trailingComments","new_loc","new_pos","old_pos","originalPositionFor","line","column","comments","c","cloc","debuggerInstance","checkForActions","currentLocation","testTimeout","evaluator","evaluators","partialEvaluator","partialEvaluators","base","getType","refName","thisValue","referencedName","mightNotBeString"],"mappings":";;;;;;;;;;;QA+uCgBA,iB,GAAAA,iB;;AAxtChB;;AAOA;;AACA;;AAEA;;AACA;;AAaA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;AACA;;AACA;;IAAYC,C;;;;;;;;;;0JArDZ;;;;;;;;;AAuDA,IAAMC,YAAYC,QAAQ,YAAR,CAAlB;;AAEA;;IACaC,iB,WAAAA,iB,GAKX,2BAAYC,KAAZ,EAA0B;AAAA;;AACxB,2BAAUA,KAAV,EAAiB,gBAAjB;AACA,OAAKA,KAAL,GAAaA,KAAb;AACA,OAAKC,UAAL,GAAkB,KAAlB;AACD,C;;AA8BH;IACaC,4B,WAAAA,4B;;;AACX,wCAAYF,KAAZ,EAA0B;AAAA;;AAAA,4JAClBA,KADkB;;AAExB,UAAKG,QAAL,GAAiBC,OAAOC,MAAP,CAAc,IAAd,CAAjB;AAFwB;AAGzB;;;;;;AAID;+BACWC,C,EAAoB;AAC7B;AACA,UAAIC,SAAS,IAAb;;AAEA;AACA,UAAIA,OAAOJ,QAAP,CAAgBG,CAAhB,CAAJ,EAAwB,OAAO,IAAP;;AAExB;AACA,aAAO,KAAP;AACD;;AAED;;;;yCACqBA,C,EAAWE,C,EAA8C;AAAA,UAAlCC,QAAkC,uEAAd,KAAc;;AAC5E,UAAIT,QAAQ,KAAKA,KAAjB;;AAEA;AACA,UAAIO,SAAS,IAAb;;AAEA;AACA,+BAAU,CAACA,OAAOJ,QAAP,CAAgBG,CAAhB,CAAX,kCAA6DA,CAA7D;;AAEA;AACA,WAAKH,QAAL,CAAcG,CAAd,IAAmBN,MAAMU,qBAAN,CAA4B;AAC7CC,qBAAa,KADgC;AAE7CC,iBAAS,IAFoC;AAG7CC,mBAAWL,CAHkC;AAI7CM,qBAAaP,MAJgC;AAK7CQ,cAAMT,CALuC;AAM7CG,kBAAUA;AANmC,OAA5B,CAAnB;;AASA;AACA,aAAOT,MAAMgB,UAAN,CAAiBC,SAAxB;AACD;;AAED;;;;2CACuBX,C,EAAWY,C,EAA8C;AAAA,UAAlCT,QAAkC,uEAAd,KAAc;;AAC9E,UAAIT,QAAQ,KAAKA,KAAjB;;AAEA;AACA,UAAIO,SAAS,IAAb;;AAEA;AACA,+BAAU,CAACA,OAAOJ,QAAP,CAAgBG,CAAhB,CAAX,kCAA6DA,CAA7D;;AAEA;AACA,WAAKH,QAAL,CAAcG,CAAd,IAAmBN,MAAMU,qBAAN,CAA4B;AAC7CC,qBAAa,KADgC;AAE7CQ,gBAAQD,CAFqC;AAG7CL,mBAAW,KAHkC;AAI7CC,qBAAaP,MAJgC;AAK7CQ,cAAMT,CALuC;AAM7CG,kBAAUA;AANmC,OAA5B,CAAnB;;AASA;AACA,aAAOT,MAAMgB,UAAN,CAAiBC,SAAxB;AACD;;AAED;;;;sCACkBX,C,EAAWc,C,EAAiB;AAC5C;AACA,UAAIb,SAAS,IAAb;;AAEA,UAAIc,UAAUd,OAAOJ,QAAP,CAAgBG,CAAhB,CAAd;;AAEA;AACA,+BAAUe,WAAW,CAACA,QAAQV,WAA9B,kCAAyEL,CAAzE;;AAEA;AACA,WAAKN,KAAL,CAAWU,qBAAX,CAAiCW,OAAjC,EAA0CC,KAA1C,GAAkDF,CAAlD;;AAEA;AACAC,cAAQV,WAAR,GAAsB,IAAtB;;AAEA;AACA,aAAO,KAAKX,KAAL,CAAWgB,UAAX,CAAsBO,KAA7B;AACD;;AAED;;;;sCACkBjB,C,EAAWc,C,EAAUF,C,EAAmB;AACxD,UAAIlB,QAAQ,KAAKA,KAAjB;;AAEA;AACA,UAAIO,SAAS,IAAb;;AAEA,UAAIc,UAAUd,OAAOJ,QAAP,CAAgBG,CAAhB,CAAd;;AAEA;AACA,UAAI,CAACe,OAAL,EAAc;AACZ;AACA,YAAIH,CAAJ,EAAO;AACL,gBAAMlB,MAAMwB,0BAAN,CAAiCxB,MAAMgB,UAAN,CAAiBS,cAAlD,EAAqEnB,CAArE,gBAAN;AACD;;AAED;AACAC,eAAOmB,oBAAP,CAA4BpB,CAA5B,EAA+B,IAA/B;;AAEA;AACAC,eAAOoB,iBAAP,CAAyBrB,CAAzB,EAA4Bc,CAA5B;;AAEA;AACA,eAAO,KAAKpB,KAAL,CAAWgB,UAAX,CAAsBO,KAA7B;AACD;;AAED;AACA,UAAIF,QAAQF,MAAZ,EAAoBD,IAAI,IAAJ;;AAEpB;AACA,UAAI,CAACG,QAAQV,WAAb,EAA0B;AACxB,cAAMX,MAAMwB,0BAAN,CAAiCxB,MAAMgB,UAAN,CAAiBS,cAAlD,EAAqEnB,CAArE,mCAAN;AACD,OAFD,MAEO,IAAIe,QAAQT,OAAZ,EAAqB;AAC1B;AACAZ,cAAMU,qBAAN,CAA4BW,OAA5B,EAAqCC,KAArC,GAA6CF,CAA7C;AACD,OAHM,MAGA;AACL;AACA;;AAEA;AACA,YAAIF,CAAJ,EAAO;AACL,gBAAMlB,MAAMwB,0BAAN,CAAiCxB,MAAMgB,UAAN,CAAiBY,SAAlD,EAA6D,qCAA7D,CAAN;AACD;AACF;;AAED;AACA,aAAO,KAAK5B,KAAL,CAAWgB,UAAX,CAAsBO,KAA7B;AACD;;AAED;;;;oCACgBjB,C,EAAWY,C,EAAmB;AAC5C,UAAIlB,QAAQ,KAAKA,KAAjB;;AAEA;AACA,UAAIO,SAAS,IAAb;;AAEA,UAAIc,UAAUd,OAAOJ,QAAP,CAAgBG,CAAhB,CAAd;;AAEA;AACA,+BAAUe,OAAV,EAAmB,kBAAnB;;AAEA;AACA,UAAI,CAACA,QAAQV,WAAb,EAA0B;AACxB,cAAMX,MAAMwB,0BAAN,CAAiCxB,MAAMgB,UAAN,CAAiBS,cAAlD,CAAN;AACD;;AAED;AACA,+BAAUJ,QAAQC,KAAlB;AACA,aAAOD,QAAQC,KAAf;AACD;;AAED;;;;kCACchB,C,EAAoB;AAChC;AACA,UAAIC,SAAS,IAAb;;AAEA;AACA,+BAAUA,OAAOJ,QAAP,CAAgBG,CAAhB,CAAV,EAA8B,2BAA9B;;AAEA;AACA,UAAI,CAACC,OAAOJ,QAAP,CAAgBG,CAAhB,EAAmBO,SAAxB,EAAmC,OAAO,KAAP;;AAEnC;AACA,WAAKb,KAAL,CAAWU,qBAAX,CAAiCH,OAAOJ,QAAP,CAAgBG,CAAhB,CAAjC,EAAqDgB,KAArD,GAA6DL,SAA7D;AACA,aAAOV,OAAOJ,QAAP,CAAgBG,CAAhB,CAAP;;AAEA;AACA,aAAO,IAAP;AACD;;AAED;;;;qCAC0B;AACxB;AACA,aAAO,KAAP;AACD;;AAED;;;;sCAC2B;AACzB;AACA,aAAO,KAAP;AACD;;AAED;;;;qCACwB;AACtB;AACA,aAAO,KAAKN,KAAL,CAAWgB,UAAX,CAAsBC,SAA7B;AACD;;;;EAlM+ClB,iB;;AAqMlD;;;IACa8B,uB,WAAAA,uB;;;AAIX,mCAAY7B,KAAZ,EAA0B8B,GAA1B,EAAkE;AAAA;;AAAA,mJAC1D9B,KAD0D;;AAEhE,WAAK+B,MAAL,GAAcD,GAAd;AAFgE;AAGjE;;AAED;;;;;+BACWxB,C,EAAoB;AAC7B,UAAIN,QAAQ,KAAKA,KAAjB;;AAEA;AACA,UAAIO,SAAS,IAAb;;AAEA;AACA,UAAIJ,WAAW,KAAK4B,MAApB;;AAEA;AACA,UAAIC,eAAe,yBAAYhC,KAAZ,EAAmBG,QAAnB,EAA6BG,CAA7B,CAAnB;;AAEA;AACA,UAAI,CAAC0B,YAAL,EAAmB,OAAO,KAAP;;AAEnB;AACA,UAAI,CAACzB,OAAO0B,eAAZ,EAA6B,OAAO,IAAP;;AAE7B;AACA,UAAIC,cAAc,iBAAIlC,KAAJ,EAAWG,QAAX,EAAqBH,MAAMgB,UAAN,CAAiBmB,iBAAtC,CAAlB;;AAEA;AACA,UAAID,6CAAsCA,iDAA1C,EAAsF;AACpF;AACA,YAAIE,UAAU,8BAAiBpC,KAAjB,EAAwB,iBAAIA,KAAJ,EAAWkC,WAAX,EAAwB5B,CAAxB,CAAxB,CAAd;;AAEA;AACA,YAAI8B,OAAJ,EAAa,OAAO,KAAP;AACd;AACDF,kBAAYG,kBAAZ;;AAEA;AACA,aAAO,IAAP;AACD;;AAED;;;;yCACqB/B,C,EAAWE,C,EAAmB;AACjD,UAAIR,QAAQ,KAAKA,KAAjB;;AAEA;AACA,UAAIO,SAAS,IAAb;;AAEA;AACA,UAAIJ,WAAWI,OAAOwB,MAAtB;;AAEA;AACA,UAAIO,cAAc9B,IAAI,IAAJ,GAAW,KAA7B;;AAEA;AACA,aAAO,wBACLR,KADK,EAEL,uBAAWuC,qBAAX,CAAiCvC,KAAjC,EAAwCG,QAAxC,EAAkDG,CAAlD,EAAqD;AACnDgB,eAAOtB,MAAMgB,UAAN,CAAiBC,SAD2B;AAEnDuB,kBAAU,IAFyC;AAGnDC,oBAAY,IAHuC;AAInDC,sBAAcJ;AAJqC,OAArD,CAFK,CAAP;AASD;;AAED;;;;2CACuBhC,C,EAAWY,C,EAAmB;AACnD;AACA,+BAAU,KAAV;AACD;;AAED;;;;sCACkBZ,C,EAAWc,C,EAAiB;AAC5C;AACA,UAAIb,SAAS,IAAb;;AAEA;AACA;;AAEA;AACA,aAAOA,OAAOoC,iBAAP,CAAyBrC,CAAzB,EAA4Bc,CAA5B,EAA+B,KAA/B,CAAP;AACD;;AAED;;;;sCACkBd,C,EAAWc,C,EAAUF,C,EAAmB;AACxD,UAAIlB,QAAQ,KAAKA,KAAjB;;AAEA;AACA,UAAIO,SAAS,IAAb;;AAEA;AACA,UAAIJ,WAAWI,OAAOwB,MAAtB;;AAEA;AACA,aAAO,wBAAiB/B,KAAjB,EAAwB,uBAAW4C,GAAX,CAAe5C,KAAf,EAAsBG,QAAtB,EAAgCG,CAAhC,EAAmCc,CAAnC,EAAsCF,CAAtC,CAAxB,CAAP;AACD;;AAED;;;;oCACgBZ,C,EAAWY,C,EAAmB;AAC5C,UAAIlB,QAAQ,KAAKA,KAAjB;;AAEA;AACA,UAAIO,SAAS,IAAb;;AAEA;AACA,UAAIJ,WAAWI,OAAOwB,MAAtB;;AAEA;AACA,UAAIT,QAAQ,yBAAYtB,KAAZ,EAAmBG,QAAnB,EAA6BG,CAA7B,CAAZ;;AAEA;AACA,UAAI,CAACgB,KAAL,EAAY;AACV;AACA,YAAI,CAACJ,CAAL,EAAQ;AACN,iBAAOlB,MAAMgB,UAAN,CAAiBC,SAAxB;AACD,SAFD,MAEO;AACL,gBAAMjB,MAAMwB,0BAAN,CAAiCxB,MAAMgB,UAAN,CAAiBS,cAAlD,CAAN;AACD;AACF;;AAED;AACA,aAAO,iBAAIzB,KAAJ,EAAWG,QAAX,EAAqBG,CAArB,CAAP;AACD;;AAED;;;;kCACcA,C,EAAoB;AAChC;AACA,UAAIC,SAAS,IAAb;;AAEA;AACA,UAAIJ,WAAWI,OAAOwB,MAAtB;;AAEA;AACA,aAAO5B,SAAS0C,OAAT,CAAiBvC,CAAjB,CAAP;AACD;;AAED;;;;qCAC0B;AACxB;AACA,aAAO,KAAP;AACD;;AAED;;;;sCAC2B;AACzB;AACA,aAAO,KAAP;AACD;;AAED;;;;qCACwB;AACtB;AACA,UAAIC,SAAS,IAAb;;AAEA;AACA,UAAIA,OAAO0B,eAAX,EAA4B,OAAO1B,OAAOwB,MAAd;;AAE5B;AACA,aAAO,KAAK/B,KAAL,CAAWgB,UAAX,CAAsBC,SAA7B;AACD;;;;EAnK0ClB,iB;;AAsK7C;;;IACa+C,yB,WAAAA,yB;;;;;;;;;;;;;AAMX;kCAEE1B,C,EACgE;AAChE,UAAIpB,QAAQ,KAAKA,KAAjB;;AAEA;AACA,UAAIO,SAAS,IAAb;;AAEA;AACA,+BAAUA,OAAOwC,kBAAP,KAA8B,SAAxC,EAAmD,0CAAnD;;AAEA;AACA,UAAIxC,OAAOwC,kBAAP,KAA8B,aAAlC,EAAiD;AAC/C,cAAM/C,MAAMwB,0BAAN,CAAiCxB,MAAMgB,UAAN,CAAiBS,cAAlD,CAAN;AACD;;AAED;AACAlB,aAAOyC,UAAP,GAAoB5B,CAApB;;AAEA;AACAb,aAAOwC,kBAAP,GAA4B,aAA5B;;AAEA;AACA,aAAO3B,CAAP;AACD;;AAED;;;;qCAC0B;AACxB;AACA,UAAIb,SAAS,IAAb;;AAEA;AACA,aAAOA,OAAOwC,kBAAP,KAA8B,SAA9B,GAA0C,KAA1C,GAAkD,IAAzD;AACD;;AAED;;;;sCAC2B;AACzB;AACA,UAAIxC,SAAS,IAAb;;AAEA;AACA,UAAIA,OAAOwC,kBAAP,KAA8B,SAAlC,EAA6C,OAAO,KAAP;;AAE7C;AACA,UAAIxC,OAAO0C,WAAP,KAAuBhC,SAA3B,EAAsC;AACpC,eAAO,KAAP;AACD,OAFD,MAEO;AACL,eAAO,IAAP;AACD;AACF;;AAED;;;;qCACiF;AAC/E,UAAIjB,QAAQ,KAAKA,KAAjB;;AAEA;AACA,UAAIO,SAAS,IAAb;;AAEA;AACA,+BAAUA,OAAOwC,kBAAP,KAA8B,SAAxC,EAAmD,0CAAnD;;AAEA;AACA,UAAIxC,OAAOwC,kBAAP,KAA8B,eAAlC,EAAmD;AACjD,cAAM/C,MAAMwB,0BAAN,CAAiCxB,MAAMgB,UAAN,CAAiBS,cAAlD,CAAN;AACD;;AAED;AACA,aAAOlB,OAAOyC,UAAd;AACD;;AAED;;;;mCACyD;AACvD;AACA,UAAIzC,SAAS,IAAb;;AAEA;AACA,UAAI2C,OAAO3C,OAAO0C,WAAlB;;AAEA;AACA,UAAIC,SAASjC,SAAb,EAAwB,OAAO,KAAKjB,KAAL,CAAWgB,UAAX,CAAsBC,SAA7B;;AAExB;AACA,+BAAUiC,kCAAV,EAAuC,uBAAvC;;AAEA;AACA,aAAOA,KAAKC,eAAL,EAAP;AACD;;;;EA7F4CjD,4B;;AAgG/C;;;IACakD,uB,WAAAA,uB;;;;;;;;;;;;;AAMX;+BACW9C,C,EAAoB;AAC7B;AACA,UAAIC,SAAS,IAAb;;AAEA;AACA,UAAI8C,SAAS9C,OAAO+C,kBAApB;;AAEA;AACA,UAAID,OAAOE,UAAP,CAAkBjD,CAAlB,CAAJ,EAA0B,OAAO,IAAP;;AAE1B;AACA,UAAIkD,SAASjD,OAAOkD,aAApB;;AAEA;AACA,aAAOD,OAAOD,UAAP,CAAkBjD,CAAlB,CAAP;AACD;;AAED;;;;yCACqBA,C,EAAWE,C,EAAmB;AACjD,UAAIR,QAAQ,KAAKA,KAAjB;;AAEA;AACA,UAAIO,SAAS,IAAb;;AAEA;AACA,UAAI8C,SAAS9C,OAAO+C,kBAApB;;AAEA;AACA,UAAID,OAAOE,UAAP,CAAkBjD,CAAlB,CAAJ,EAA0B;AACxB,cAAMN,MAAMwB,0BAAN,CAAiCxB,MAAMgB,UAAN,CAAiBY,SAAlD,CAAN;AACD;;AAED;AACA,aAAOyB,OAAO3B,oBAAP,CAA4BpB,CAA5B,EAA+BE,CAA/B,EAAkC,IAAlC,CAAP;AACD;;AAED;;;;2CACuBF,C,EAAWY,C,EAAmB;AACnD,UAAIlB,QAAQ,KAAKA,KAAjB;;AAEA;AACA,UAAIO,SAAS,IAAb;;AAEA;AACA,UAAI8C,SAAS9C,OAAO+C,kBAApB;;AAEA;AACA,UAAID,OAAOE,UAAP,CAAkBjD,CAAlB,CAAJ,EAA0B;AACxB,cAAMN,MAAMwB,0BAAN,CAAiCxB,MAAMgB,UAAN,CAAiBY,SAAlD,CAAN;AACD;;AAED;AACA,aAAOyB,OAAOK,sBAAP,CAA8BpD,CAA9B,EAAiCY,CAAjC,EAAoC,IAApC,CAAP;AACD;;AAED;;;;sCACkBZ,C,EAAWc,C,EAAiB;AAC5C;AACA,UAAIb,SAAS,IAAb;;AAEA;AACA,UAAI8C,SAAS9C,OAAO+C,kBAApB;;AAEA;AACA,UAAID,OAAOE,UAAP,CAAkBjD,CAAlB,CAAJ,EAA0B;AACxB;AACA,eAAO+C,OAAO1B,iBAAP,CAAyBrB,CAAzB,EAA4Bc,CAA5B,CAAP;AACD;;AAED;;AAEA;AACA,UAAIoC,SAASjD,OAAOkD,aAApB;;AAEA;AACA,aAAOD,OAAO7B,iBAAP,CAAyBrB,CAAzB,EAA4Bc,CAA5B,CAAP;AACD;;AAED;;;;sCACkBd,C,EAAWc,C,EAAUF,C,EAAmB;AACxD;AACA,UAAIX,SAAS,IAAb;;AAEA;AACA,UAAI8C,SAAS9C,OAAO+C,kBAApB;;AAEA;AACA,UAAID,OAAOE,UAAP,CAAkBjD,CAAlB,CAAJ,EAA0B;AACxB;AACA,eAAO+C,OAAOV,iBAAP,CAAyBrC,CAAzB,EAA4Bc,CAA5B,EAA+BF,CAA/B,CAAP;AACD;;AAED;AACA,UAAIsC,SAASjD,OAAOkD,aAApB;;AAEA;AACA,aAAOD,OAAOb,iBAAP,CAAyBrC,CAAzB,EAA4Bc,CAA5B,EAA+BF,CAA/B,CAAP;AACD;;AAED;;;;oCACgBZ,C,EAAWY,C,EAAmB;AAC5C;AACA,UAAIX,SAAS,IAAb;;AAEA;AACA,UAAI8C,SAAS9C,OAAO+C,kBAApB;;AAEA;AACA,UAAID,OAAOE,UAAP,CAAkBjD,CAAlB,CAAJ,EAA0B;AACxB;AACA,eAAO+C,OAAOM,eAAP,CAAuBrD,CAAvB,EAA0BY,CAA1B,CAAP;AACD;;AAED;AACA,UAAIsC,SAASjD,OAAOkD,aAApB;;AAEA;AACA,aAAOD,OAAOG,eAAP,CAAuBrD,CAAvB,EAA0BY,CAA1B,CAAP;AACD;;AAED;;;;kCACcZ,C,EAAoB;AAChC,UAAIN,QAAQ,KAAKA,KAAjB;;AAEA;AACA,UAAIO,SAAS,IAAb;;AAEA;AACA,UAAI8C,SAAS9C,OAAO+C,kBAApB;;AAEA;AACA,UAAID,OAAOE,UAAP,CAAkBjD,CAAlB,CAAJ,EAA0B;AACxB;AACA,eAAO+C,OAAOO,aAAP,CAAqBtD,CAArB,CAAP;AACD;;AAED;AACA,UAAIkD,SAASjD,OAAOkD,aAApB;;AAEA;AACA,UAAII,eAAeL,OAAOzB,MAA1B;;AAEA;AACA,UAAI+B,eAAe,4BAAe9D,KAAf,EAAsB6D,YAAtB,EAAoCvD,CAApC,CAAnB;;AAEA;AACA,UAAIwD,YAAJ,EAAkB;AAChB;AACA,YAAIC,SAASP,OAAOI,aAAP,CAAqBtD,CAArB,CAAb;;AAEA;AACA,YAAIyD,MAAJ,EAAY;AACV;AACA,cAAIC,WAAWzD,OAAO0D,SAAtB;;AAEA;AACA,cAAID,SAASE,OAAT,CAAiB5D,CAAjB,KAAuB,CAA3B,EAA8B;AAC5B0D,qBAASG,MAAT,CAAgBH,SAASE,OAAT,CAAiB5D,CAAjB,CAAhB,EAAqC,CAArC;AACD;AACF;;AAED;AACA,eAAOyD,MAAP;AACD;;AAED;AACA,aAAO,IAAP;AACD;;AAED;;;;qCAC0B;AACxB;AACA,aAAO,IAAP;AACD;;AAED;;;;sCAC2B;AACzB;AACA,aAAO,IAAP;AACD;;AAED;;;;qCACwB;AACtB;AACA,aAAO,KAAK/D,KAAL,CAAWgB,UAAX,CAAsBC,SAA7B;AACD;;AAED;;;;qCACiF;AAC/E;AACA,UAAIV,SAAS,IAAb;;AAEA,+BAAUA,OAAO6D,gBAAjB;AACA;AACA,aAAO7D,OAAO6D,gBAAd;AACD;;AAED;;;;sCACkB9D,C,EAAoB;AACpC;AACA,UAAIC,SAAS,IAAb;;AAEA;AACA,UAAI8D,mBAAmB9D,OAAO0D,SAA9B;;AAEA;AACA,UAAII,iBAAiBH,OAAjB,CAAyB5D,CAAzB,KAA+B,CAAnC,EAAsC,OAAO,IAAP;;AAEtC;AACA,aAAO,KAAP;AACD;;AAED;;;;0CACsBA,C,EAAoB;AACxC;AACA,UAAIC,SAAS,IAAb;;AAEA;AACA,UAAI8C,SAAS9C,OAAO+C,kBAApB;;AAEA;AACA,aAAOD,OAAOE,UAAP,CAAkBjD,CAAlB,CAAP;AACD;;AAED;;;;gDAC4BA,C,EAAoB;AAC9C;AACA,UAAIC,SAAS,IAAb;;AAEA;AACA,UAAIiD,SAASjD,OAAOkD,aAApB;;AAEA;AACA,UAAII,eAAeL,OAAOzB,MAA1B;;AAEA;AACA,UAAI+B,eAAeD,aAAaS,eAAb,CAA6BhE,CAA7B,CAAnB;;AAEA;AACA,UAAI,CAACwD,YAAL,EAAmB,OAAO,KAAP;AACnB,6BAAWS,2BAAX,CAAuCT,aAAaxC,KAApD;;AAEA;AACA,UAAIwC,aAAapB,YAAjB,EAA+B,OAAO,KAAP;;AAE/B;AACA,aAAO,IAAP;AACD;;AAED;;;;wCACoBpC,C,EAAoB;AACtC,UAAIN,QAAQ,KAAKA,KAAjB;;AAEA;AACA,UAAIO,SAAS,IAAb;;AAEA;AACA,UAAIiD,SAASjD,OAAOkD,aAApB;;AAEA;AACA,UAAII,eAAeL,OAAOzB,MAA1B;;AAEA;AACA,UAAIyC,cAAc,4BAAexE,KAAf,EAAsB6D,YAAtB,EAAoCvD,CAApC,CAAlB;;AAEA;AACA,UAAIkE,WAAJ,EAAiB,OAAO,IAAP;;AAEjB;AACA,aAAO,0BAAaxE,KAAb,EAAoB6D,YAApB,CAAP;AACD;;AAED;;;;6CACyBvD,C,EAAoB;AAC3C,UAAIN,QAAQ,KAAKA,KAAjB;;AAEA;AACA,UAAIO,SAAS,IAAb;;AAEA;AACA,UAAIiD,SAASjD,OAAOkD,aAApB;;AAEA;AACA,UAAII,eAAeL,OAAOzB,MAA1B;;AAEA;AACA,UAAI+B,eAAeD,aAAaS,eAAb,CAA6BhE,CAA7B,CAAnB;;AAEA;AACA,UAAI,CAACwD,YAAL,EAAmB,OAAO,0BAAa9D,KAAb,EAAoB6D,YAApB,CAAP;AACnB,6BAAWU,2BAAX,CAAuCT,aAAaxC,KAApD;;AAEA;AACA,UAAIwC,aAAapB,YAAjB,EAA+B,OAAO,IAAP;;AAE/B;AACA,UAAI,8BAAiB1C,KAAjB,EAAwB8D,YAAxB,KAAyCA,aAAatB,QAAtD,IAAkEsB,aAAarB,UAAnF,EAA+F;AAC7F,eAAO,IAAP;AACD;;AAED;AACA,aAAO,KAAP;AACD;;AAED;;;;2CACuBnC,C,EAAWE,C,EAAY;AAC5C,UAAIR,QAAQ,KAAKA,KAAjB;;AAEA;AACA,UAAIO,SAAS,IAAb;;AAEA;AACA,UAAIiD,SAASjD,OAAOkD,aAApB;;AAEA;AACA,UAAII,eAAeL,OAAOzB,MAA1B;;AAEA;AACA,UAAIyC,cAAc,4BAAexE,KAAf,EAAsB6D,YAAtB,EAAoCvD,CAApC,CAAlB;;AAEA;AACA,UAAImE,aAAa,0BAAazE,KAAb,EAAoB6D,YAApB,CAAjB;;AAEA;AACA,UAAI,CAACW,WAAD,IAAgBC,UAApB,EAAgC;AAC9B;AACAjB,eAAO9B,oBAAP,CAA4BpB,CAA5B,EAA+BE,CAA/B;;AAEA;AACAgD,eAAO7B,iBAAP,CAAyBrB,CAAzB,EAA4B,KAAKN,KAAL,CAAWgB,UAAX,CAAsBC,SAAlD;AACD;;AAED;AACA,UAAIoD,mBAAmB9D,OAAO0D,SAA9B;;AAEA;AACA,UAAII,iBAAiBH,OAAjB,CAAyB5D,CAAzB,IAA8B,CAAlC,EAAqC;AACnC;AACA+D,yBAAiBK,IAAjB,CAAsBpE,CAAtB;AACD;;AAED;AACD;;AAED;;;;gDAC4BA,C,EAAWc,C,EAAUZ,C,EAAY;AAC3D;AACA,UAAID,SAAS,IAAb;;AAEA;AACA,UAAIiD,SAASjD,OAAOkD,aAApB;;AAEA;AACA,UAAII,eAAeL,OAAOzB,MAA1B;;AAEA;AACA,UAAI+B,eAAeD,aAAaS,eAAb,CAA6BhE,CAA7B,CAAnB;;AAEA;AACA,UAAIqE,aAAJ;AACA,UAAI,CAACb,YAAD,IAAiBA,aAAapB,YAAlC,EAAgD;AAC9C;AACAiC,eAAO,EAAErD,OAAOF,CAAT,EAAYoB,UAAU,IAAtB,EAA4BC,YAAY,IAAxC,EAA8CC,cAAclC,CAA5D,EAAP;AACD,OAHD,MAGO;AACL;AACA,+BAAW+D,2BAAX,CAAuCT,aAAaxC,KAApD;AACA;AACAqD,eAAO,EAAErD,OAAOF,CAAT,EAAP;AACD;;AAED;AACA,6BAAWmB,qBAAX,CAAiC,KAAKvC,KAAtC,EAA6C6D,YAA7C,EAA2DvD,CAA3D,EAA8DqE,IAA9D;;AAEA;;AAEA;AACA,6BAAW/B,GAAX,CAAe,KAAK5C,KAApB,EAA2B6D,YAA3B,EAAyCvD,CAAzC,EAA4Cc,CAA5C,EAA+C,KAA/C;;AAEA;AACA,UAAIiD,mBAAmB9D,OAAO0D,SAA9B;;AAEA;AACA,UAAII,iBAAiBH,OAAjB,CAAyB5D,CAAzB,IAA8B,CAAlC,EAAqC;AACnC;AACA+D,yBAAiBK,IAAjB,CAAsBpE,CAAtB;AACD;;AAED;AACD;;;;EA3Y0CP,iB;;AA8Y7C;;;IACa6E,kB,WAAAA,kB;AACX,8BAAY5E,KAAZ,EAA0B;AAAA;;AACxB,6BAAUA,KAAV,EAAiB,gBAAjB;AACA,SAAKA,KAAL,GAAaA,KAAb;AACD;;;;mCAMc6E,S,EAA0BC,M,EAAe;AACtD,UAAIC,cAAc,KAAKC,QAAL,CAAcH,SAAd,EAAyB,KAAzB,CAAlB;AACA,6BAAWI,QAAX,CAAoB,KAAKjF,KAAzB,EAAgC+E,WAAhC,EAA6CD,MAA7C;AACD;;;qDAGCI,G,EACAC,U,EACAC,Q,EAC4D;AAAA,kCACpB,KAAKC,2BAAL,CAAiCH,GAAjC,EAAsCC,UAAtC,EAAkDC,QAAlD,CADoB;AAAA;AAAA,UACvDE,MADuD;AAAA,UAC/CC,WAD+C;AAAA,UAClCC,UADkC;;AAE5D,UAAIF,kBAAkBG,SAAtB,EAAiC;AAC/BH,iBAAS,wBAAYI,QAAZ,CAAqB,KAAK1F,KAA1B,EAAiCsF,MAAjC,CAAT;AACD;AACD,aAAO,CAACA,MAAD,EAASC,WAAT,EAAsBC,UAAtB,CAAP;AACD;;;gDAGCN,G,EACAC,U,EACAC,Q,EACwE;AACxE,UAAI;AACF,eAAO,KAAKO,iBAAL,CAAuBT,GAAvB,EAA4BC,UAA5B,EAAwCC,QAAxC,CAAP;AACD,OAFD,CAEE,OAAOQ,GAAP,EAAY;AACZ,YAAIA,sCAAJ,EAA+B,OAAO,CAACA,GAAD,EAAMV,GAAN,EAAW,EAAX,CAAP;AAC/B,YAAIU,eAAeC,KAAnB;AACE;AACA,gBAAMD,GAAN;AACF;AACA,cAAM,uBAAeA,GAAf,CAAN;AACD;AACF;;;4CAEuBV,G,EAAgBC,U,EAAqBC,Q,EAA0C;AACrG,UAAIE,SAAS,KAAKQ,kBAAL,CAAwBZ,GAAxB,EAA6BC,UAA7B,EAAyCC,QAAzC,CAAb;AACA,UAAIE,kBAAkBG,SAAtB,EAAiCH,SAAS,wBAAYI,QAAZ,CAAqB,KAAK1F,KAA1B,EAAiCsF,MAAjC,CAAT;AACjC,aAAOA,MAAP;AACD;;;uCAEkBJ,G,EAAgBC,U,EAAqBC,Q,EAAsD;AAC5G,UAAI;AACF,eAAO,KAAKJ,QAAL,CAAcE,GAAd,EAAmBC,UAAnB,EAA+BC,QAA/B,CAAP;AACD,OAFD,CAEE,OAAOQ,GAAP,EAAY;AACZ,YACE,CAACA,uDAA0CA,oDAA3C,KACAA,IAAIG,uBAAJ,EAFF,EAGE;AACA,+BAAcC,wBAAd,CAAuCJ,IAAIK,aAA3C;AACA,gBAAM,wBAAN;AACD;AACD,YAAIL,4CAAJ,EAAqC,OAAOA,GAAP;AACrC,YAAIA,eAAeC,KAAnB;AACE;AACA,gBAAMD,GAAN;AACF;AACA,cAAM,uBAAeA,GAAf,CAAN;AACD;AACF;;;+CAE0BV,G,EAAgBC,U,EAAqBC,Q,EAAgD;AAC9G,UAAI;AACF,eAAO,KAAKc,gBAAL,CAAsBhB,GAAtB,EAA2BC,UAA3B,EAAuCC,QAAvC,CAAP;AACD,OAFD,CAEE,OAAOQ,GAAP,EAAY;AACZ,YAAIA,sCAAJ,EAA+B,OAAOA,GAAP;AAC/B,YAAIA,eAAeC,KAAnB;AACE;AACA,gBAAMD,GAAN;AACF;AACA,YAAIA,eAAexF,MAAnB,EAA2B,MAAM,uBAAewF,IAAIO,WAAJ,CAAgBpF,IAAhB,GAAuB,IAAvB,GAA8B6E,GAA7C,CAAN;AAC3B,cAAM,uBAAeA,GAAf,CAAN;AACD;AACF;;;wCAEmBQ,O,EAAqF;AAAA,UAAzDC,UAAyD,uEAAhC,QAAgC;;AACvG,UAAIC,OAAO,EAAX;AACA,UAAIC,OAAO,EAAX;AACA,UAAIC,aAAa,EAAjB;AAHuG;AAAA;AAAA;;AAAA;AAIvG,6BAAmBJ,OAAnB,8HAA4B;AAAA,cAAnBK,MAAmB;;AAC1B,cAAI;AACF,gBAAIC,OAAO,qBAAM,KAAK1G,KAAX,EAAkByG,OAAOE,YAAzB,EAAuCF,OAAOG,QAA9C,EAAwDP,UAAxD,CAAX;AACA,gBAAII,OAAOI,iBAAP,IAA4BJ,OAAOI,iBAAP,CAAyBC,MAAzB,GAAkC,CAAlE,EACE,KAAKC,sBAAL,CAA4BL,IAA5B,EAAkCD,OAAOI,iBAAzC;AACF,iBAAKG,eAAL,CAAqBN,IAArB;AACAJ,mBAAOA,KAAKW,MAAL,CAAYP,KAAKQ,OAAL,CAAaC,IAAzB,CAAP;AACAZ,iBAAKE,OAAOG,QAAZ,IAAwBH,OAAOE,YAA/B;AACAH,yBAAaA,WAAWS,MAAX,CAAkBP,KAAKQ,OAAL,CAAaV,UAA/B,CAAb;AACD,WARD,CAQE,OAAOY,CAAP,EAAU;AACV,gBAAIA,yCAAJ,EAAkC;AAChC,kBAAIC,QAAQD,EAAE9F,KAAd;AACA,kBAAI+F,mCAAJ,EAAkC;AAChC,oBAAIC,UAAUD,MAAME,IAAN,CAAW,SAAX,EAAsBF,KAAtB,CAAd;AACAD,kBAAEI,QAAF,CAAWf,MAAX,GAAoBA,OAAOG,QAA3B;AACA,oBAAIhB,MAAM,+BAAuB0B,QAAQhG,KAA/B,EAAsC8F,EAAEI,QAAxC,EAAkD,QAAlD,EAA4D,YAA5D,CAAV;AACA,qBAAKxH,KAAL,CAAWyH,WAAX,CAAuB7B,GAAvB;AACA,sBAAM,uBAAe,cAAf,CAAN;AACD;AACF;AACD,kBAAMwB,CAAN;AACD;AACF;AA1BsG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA2BvG,aAAO,CAACxH,EAAE8H,IAAF,CAAO9H,EAAEsH,OAAF,CAAUZ,IAAV,EAAgBE,UAAhB,CAAP,CAAD,EAAsCD,IAAtC,CAAP;AACD;;;mCAGCH,O,EAGiC;AAAA,UAFjCC,UAEiC,uEAFR,QAEQ;AAAA,UADjCsB,OACiC,uEADS1G,SACT;;AACjC,UAAI2G,UAAU,6BAAd;AACAA,cAAQC,kBAAR,GAA6B,IAA7B;AACAD,cAAQE,mBAAR,GAA8B,IAA9B;AACAF,cAAQ5H,KAAR,GAAgB,KAAKA,KAArB;AACA,WAAKA,KAAL,CAAW+H,WAAX,CAAuBH,OAAvB;AACA,UAAII,YAAJ;AAAA,UAASzB,aAAT;AACA,UAAI;AACF,YAAIrB,YAAJ;;AADE,mCAEY,KAAK+C,mBAAL,CAAyB7B,OAAzB,EAAkCC,UAAlC,CAFZ;;AAAA;;AAEDnB,WAFC;AAEIqB,YAFJ;;AAGF,YAAIoB,OAAJ,EAAaA,QAAQzC,GAAR;AACb8C,cAAM,KAAKlC,kBAAL,CAAwBZ,GAAxB,EAA6B,KAA7B,CAAN;AACD,OALD,SAKU;AACR,aAAKlF,KAAL,CAAWkI,UAAX,CAAsBN,OAAtB;AACD;AACD,UAAII,4CAAJ,EAAqC,OAAO,CAACA,GAAD,EAAMzB,IAAN,CAAP;;AAErC,aAAO,CAAC,wBAAYb,QAAZ,CAAqB,KAAK1F,KAA1B,EAAiCgI,GAAjC,CAAD,EAAwCzB,IAAxC,CAAP;AACD;;;4CAGCH,O,EAGsD;AAAA,UAFtD+B,OAEsD;AAAA,UADtD9B,UACsD,uEAD7B,QAC6B;;AAAA,kCACpC,KAAK4B,mBAAL,CAAyB7B,OAAzB,EAAkCC,UAAlC,CADoC;AAAA;AAAA,UACjDnB,GADiD;AAAA,UAC5CqB,IAD4C;;AAEtD,UAAIqB,UAAU,6BAAd;AACAA,cAAQC,kBAAR,GAA6B,IAA7B;AACAD,cAAQE,mBAAR,GAA8B,IAA9B;AACAF,cAAQ5H,KAAR,GAAgB,KAAKA,KAArB;AACA,WAAKA,KAAL,CAAW+H,WAAX,CAAuBH,OAAvB;AACA,UAAIQ,mBAAJ;AACA,UAAI;AACF,YAAIJ,YAAJ;;AADE,qCAEkB,KAAKK,gCAAL,CAAsCnD,GAAtC,EAA2C,KAA3C,CAFlB;;AAAA;;AAED8C,WAFC;AAEII,kBAFJ;;AAGF,YAAIJ,4CAAJ,EAAqC,OAAOA,GAAP;AACtC,OAJD,SAIU;AACR,aAAKhI,KAAL,CAAWkI,UAAX,CAAsBN,OAAtB;AACD;AACD,+BAAUQ,WAAWE,IAAX,KAAoB,MAA9B;AACA,UAAIC,UAAYH,UAAhB;AACA,UAAII,OAAO5I,EAAEsH,OAAF,CAAUqB,QAAQrB,OAAR,CAAgBC,IAA1B,EAAgCjC,IAAIgC,OAAJ,CAAYV,UAA5C,CAAX;AACA,WAAKQ,eAAL,CAAqBwB,IAArB;AACA,aAAO,8BAASA,IAAT,EAAe,EAAEC,YAAYN,QAAQM,UAAtB,EAAf,EAAoDlC,IAApD,CAAP;AACD;;;4BAGCA,I,EACAmC,Q,EAI0B;AAAA,UAH1BC,GAG0B,uEAHZ,EAGY;AAAA,UAF1BtC,UAE0B,uEAFD,QAEC;AAAA,UAD1BsB,OAC0B,uEADgB1G,SAChB;;AAC1B,UAAI2G,UAAU,6BAAd;AACAA,cAAQC,kBAAR,GAA6B,IAA7B;AACAD,cAAQE,mBAAR,GAA8B,IAA9B;AACAF,cAAQ5H,KAAR,GAAgB,KAAKA,KAArB;;AAEA,WAAKA,KAAL,CAAW+H,WAAX,CAAuBH,OAAvB;;AAEA,UAAI1C,YAAJ;AAAA,UAAS8C,YAAT;AACA,UAAI;AACF,YAAI;AACF9C,gBAAM,qBAAM,KAAKlF,KAAX,EAAkBuG,IAAlB,EAAwBmC,QAAxB,EAAkCrC,UAAlC,CAAN;AACD,SAFD,CAEE,OAAOe,CAAP,EAAU;AACV,cAAIA,yCAAJ,EAAkC,OAAOA,CAAP;AAClC,gBAAMA,CAAN;AACD;AACD,YAAIO,OAAJ,EAAaA,QAAQzC,GAAR;AACb,YAAIyD,IAAI7B,MAAJ,GAAa,CAAjB,EAAoB,KAAKC,sBAAL,CAA4B7B,GAA5B,EAAiCyD,GAAjC;AACpB,aAAK3B,eAAL,CAAqB9B,GAArB;AACA8C,cAAM,KAAKlC,kBAAL,CAAwBZ,GAAxB,EAA6B,KAA7B,CAAN;AACD,OAXD,SAWU;AACR,aAAKlF,KAAL,CAAWkI,UAAX,CAAsBN,OAAtB;AACD;AACD,UAAII,4CAAJ,EAAqC,OAAOA,GAAP;;AAErC,aAAO,wBAAYtC,QAAZ,CAAqB,KAAK1F,KAA1B,EAAiCgI,GAAjC,CAAP;AACD;;;2CAEsB9C,G,EAAgByD,G,EAAa;AAClD,UAAMC,MAAM,IAAI/I,UAAUgJ,iBAAd,CAAgCF,GAAhC,CAAZ;AACA,kCAAazD,GAAb,EAAkB,gBAAQ;AACxB,YAAI4D,MAAMpC,KAAKoC,GAAf;AACA,YAAI,CAACA,GAAL,EAAU,OAAO,KAAP;AACVC,cAAMD,GAAN,EAAWA,IAAIE,KAAf;AACAD,cAAMD,GAAN,EAAWA,IAAIG,GAAf;AACAC,uBAAexC,KAAKyC,eAApB;AACAD,uBAAexC,KAAK0C,aAApB;AACAF,uBAAexC,KAAK2C,gBAApB;AACA,eAAO,KAAP;;AAEA,iBAASN,KAAT,CAAeO,OAAf,EAAiDC,OAAjD,EAA6E;AAC3E,cAAIC,UAAUZ,IAAIa,mBAAJ,CAAwB,EAAEC,MAAMH,QAAQG,IAAhB,EAAsBC,QAAQJ,QAAQI,MAAtC,EAAxB,CAAd;AACA,cAAIH,QAAQ/C,MAAR,KAAmB,IAAvB,EAA6B;AAC7B8C,kBAAQG,IAAR,GAAeF,QAAQE,IAAvB;AACAH,kBAAQI,MAAR,GAAiBH,QAAQG,MAAzB;AACAL,kBAAQ7C,MAAR,GAAiB+C,QAAQ/C,MAAzB;AACD;;AAED,iBAASyC,cAAT,CAAwBU,QAAxB,EAA4D;AAC1D,cAAI,CAACA,QAAL,EAAe;AAD2C;AAAA;AAAA;;AAAA;AAE1D,kCAAcA,QAAd,mIAAwB;AAAA,kBAAfC,CAAe;;AACtB,kBAAIC,OAAOD,EAAEf,GAAb;AACA,kBAAI,CAACgB,IAAL,EAAW;AACXf,oBAAMe,IAAN,EAAYA,KAAKd,KAAjB;AACAD,oBAAMe,IAAN,EAAYA,KAAKb,GAAjB;AACD;AAPyD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQ3D;AACF,OA3BD;AA4BD;;;oCAEe/D,G,EAAgB;AAC9B,kCAAaA,GAAb,EAAkB,gBAAQ;AACxB,YAAI4D,MAAMpC,KAAKoC,GAAf;AACA,YAAI,CAACA,GAAD,IAAQ,CAACA,IAAIrC,MAAjB,EAAyB;AACvBC,eAAKyC,eAAL,GAAuB,IAAvB;AACAzC,eAAK0C,aAAL,GAAqB,IAArB;AACA1C,eAAK2C,gBAAL,GAAwB,IAAxB;AACA3C,eAAKoC,GAAL,GAAW,IAAX;AACD,SALD,MAKO;AACL,cAAIJ,WAAWI,IAAIrC,MAAnB;AACCqC,aAAD,CAAWJ,QAAX,GAAsBA,QAAtB;AACAQ,yBAAexC,KAAKyC,eAApB,EAAqCT,QAArC;AACAQ,yBAAexC,KAAK0C,aAApB,EAAmCV,QAAnC;AACAQ,yBAAexC,KAAK2C,gBAApB,EAAsCX,QAAtC;AACD;AACD,eAAO,KAAP;;AAEA,iBAASQ,cAAT,CAAwBU,QAAxB,EAA4DlB,QAA5D,EAA8E;AAC5E,cAAI,CAACkB,QAAL,EAAe;AAD6D;AAAA;AAAA;;AAAA;AAE5E,kCAAcA,QAAd,mIAAwB;AAAA,kBAAfC,CAAe;;AACtB,kBAAIA,EAAEf,GAAN,EAAW;AACRe,kBAAEf,GAAH,CAAaJ,QAAb,GAAwBA,QAAxB;AACAmB,kBAAEf,GAAF,CAAMrC,MAAN,GAAeiC,QAAf;AACD;AACF;AAP2E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQ7E;AACF,OAzBD;AA0BD;;;6BAEQxD,G,EAAgBC,U,EAAqBC,Q,EAAmC;AAC/E,UAAI,KAAKpF,KAAL,CAAW+J,gBAAf,EAAiC;AAC/B,aAAK/J,KAAL,CAAW+J,gBAAX,CAA4BC,eAA5B,CAA4C9E,GAA5C;AACD;AACD,UAAI8C,MAAM,KAAK9B,gBAAL,CAAsBhB,GAAtB,EAA2BC,UAA3B,EAAuCC,QAAvC,CAAV;AACA,+BAAU4C,+BAAwBA,eAAevC,SAAjD,EAA4DP,IAAIoD,IAAhE;AACA,aAAON,GAAP;AACD;;;qCAEgB9C,G,EAAgBC,U,EAAqBC,Q,EAAmC;AACvF,WAAKpF,KAAL,CAAWiK,eAAX,GAA6B/E,IAAI4D,GAAjC;AACA,WAAK9I,KAAL,CAAWkK,WAAX;;AAEA,UAAIC,YAAY,KAAKnK,KAAL,CAAWoK,UAAX,CAAuBlF,IAAIoD,IAA3B,CAAhB;AACA,UAAI6B,SAAJ,EAAe;AACb,YAAI7E,SAAS6E,UAAUjF,GAAV,EAAeC,UAAf,EAA2B,IAA3B,EAAiC,KAAKnF,KAAtC,EAA6CoF,QAA7C,CAAb;AACA,eAAOE,MAAP;AACD;;AAED,YAAM,IAAI1D,SAAJ,4BAAuCsD,IAAIoD,IAA3C,CAAN;AACD;;;sCAGCpD,G,EACAC,U,EACAC,Q,EACwE;AACxE,UAAIiF,mBAAmB,KAAKrK,KAAL,CAAWsK,iBAAX,CAA8BpF,IAAIoD,IAAlC,CAAvB;AACA,UAAI+B,gBAAJ,EAAsB;AACpB,eAAOA,iBAAiBnF,GAAjB,EAAsBC,UAAtB,EAAkC,IAAlC,EAAwC,KAAKnF,KAA7C,EAAoDoF,QAApD,CAAP;AACD;;AAED,UAAIQ,MAAM,IAAIhE,SAAJ,4BAAuCsD,IAAIoD,IAA3C,CAAV;AACA,YAAM1C,GAAN;AACD;;;;;;AAGH;AACA;AACA;AACA;AACA;;;AAIO,SAASjG,iBAAT,CAA2B4K,IAA3B,EAAiD;AACtD,MAAIjC,OAAOiC,KAAKC,OAAL,EAAX;AACA,SAAOlC,gCAAyBA,2BAAzB,IAAiDA,2BAAjD,IAAyEA,2BAAhF;AACD;;IAEY7C,S,WAAAA,S,GAMX,mBACE8E,IADF,EAEEE,OAFF,EAGEtJ,MAHF,EAIEuJ,SAJF,EAKE;AAAA;;AACA,2BACEH,8CACEA,SAAStJ,SADX,IAEEsJ,kCAFF,IAGEA,gBAAgBxK,iBAHlB,IAIEJ,kBAAkB4K,IAAlB,CALJ;AAOA,OAAKA,IAAL,GAAYA,IAAZ;AACA,OAAKI,cAAL,GAAsBF,OAAtB;AACA,2BAAU,EAAEA,uCAAF,KAAuC,CAACA,QAAQG,gBAAR,EAAlD;AACA,OAAKzJ,MAAL,GAAcA,MAAd;AACA,OAAKuJ,SAAL,GAAiBA,SAAjB;AACA,2BAAUA,cAAczJ,SAAd,IAA2B,EAAEsJ,gBAAgBxK,iBAAlB,CAArC;AACD,C","file":"environment.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type {\n  BabelNode,\n  BabelNodeComment,\n  BabelNodeFile,\n  BabelNodeLVal,\n  BabelNodePosition,\n  BabelNodeStatement,\n  BabelNodeSourceLocation,\n} from \"babel-types\";\nimport type { Realm } from \"./realm.js\";\nimport type { SourceFile, SourceMap, SourceType } from \"./types.js\";\n\nimport {\n  AbruptCompletion,\n  Completion,\n  JoinedAbruptCompletions,\n  PossiblyNormalCompletion,\n  ThrowCompletion,\n} from \"./completions.js\";\nimport { CompilerDiagnostic, FatalError } from \"./errors.js\";\nimport { defaultOptions } from \"./options\";\nimport type { PartialEvaluatorOptions } from \"./options\";\nimport { ExecutionContext } from \"./realm.js\";\nimport { Value } from \"./values/index.js\";\nimport {\n  AbstractValue,\n  NullValue,\n  SymbolValue,\n  BooleanValue,\n  FunctionValue,\n  NumberValue,\n  ObjectValue,\n  AbstractObjectValue,\n  StringValue,\n  UndefinedValue,\n} from \"./values/index.js\";\nimport generate from \"babel-generator\";\nimport parse from \"./utils/parse.js\";\nimport invariant from \"./invariant.js\";\nimport traverseFast from \"./utils/traverse-fast.js\";\nimport { ToBooleanPartial, HasProperty, Get, IsExtensible, HasOwnProperty, IsDataDescriptor } from \"./methods/index.js\";\nimport { Environment, Properties } from \"./singletons.js\";\nimport * as t from \"babel-types\";\n\nconst sourceMap = require(\"source-map\");\n\n// ECMA262 8.1.1\nexport class EnvironmentRecord {\n  realm: Realm;\n  isReadOnly: boolean;\n  $NewTarget: void | ObjectValue;\n\n  constructor(realm: Realm) {\n    invariant(realm, \"expected realm\");\n    this.realm = realm;\n    this.isReadOnly = false;\n  }\n\n  +HasBinding: (N: string) => boolean;\n  +CreateMutableBinding: (N: string, D: boolean, isGlobal?: boolean) => Value;\n  +CreateImmutableBinding: (N: string, S: boolean, isGlobal?: boolean) => Value;\n  +InitializeBinding: (N: string, V: Value) => Value;\n  +SetMutableBinding: (N: string, V: Value, S: boolean) => Value;\n  +GetBindingValue: (N: string, S: boolean) => Value;\n  +DeleteBinding: (N: string) => boolean;\n  +HasThisBinding: () => boolean;\n  +GetThisBinding: () => NullValue | ObjectValue | AbstractObjectValue | UndefinedValue;\n  +HasSuperBinding: () => boolean;\n  +WithBaseObject: () => Value;\n  +BindThisValue: (\n    V: NullValue | ObjectValue | AbstractObjectValue | UndefinedValue\n  ) => NullValue | ObjectValue | AbstractObjectValue | UndefinedValue;\n}\n\nexport type Binding = {\n  value?: Value,\n  initialized?: boolean,\n  mutable?: boolean,\n  deletable?: boolean,\n  // back-references to the environment containing the binding and the key\n  // used to access this binding\n  environment: EnvironmentRecord,\n  name: string,\n  isGlobal: boolean,\n};\n\n// ECMA262 8.1.1.1\nexport class DeclarativeEnvironmentRecord extends EnvironmentRecord {\n  constructor(realm: Realm) {\n    super(realm);\n    this.bindings = (Object.create(null): any);\n  }\n\n  bindings: { [name: string]: Binding };\n\n  // ECMA262 8.1.1.1.1\n  HasBinding(N: string): boolean {\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. If envRec has a binding for the name that is the value of N, return true.\n    if (envRec.bindings[N]) return true;\n\n    // 3. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.1.2\n  CreateMutableBinding(N: string, D: boolean, isGlobal: boolean = false): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Assert: envRec does not already have a binding for N.\n    invariant(!envRec.bindings[N], `shouldn't have the binding ${N}`);\n\n    // 3. Create a mutable binding in envRec for N and record that it is uninitialized. If D is true, record that the newly created binding may be deleted by a subsequent DeleteBinding call.\n    this.bindings[N] = realm.recordModifiedBinding({\n      initialized: false,\n      mutable: true,\n      deletable: D,\n      environment: envRec,\n      name: N,\n      isGlobal: isGlobal,\n    });\n\n    // 4. Return NormalCompletion(empty).\n    return realm.intrinsics.undefined;\n  }\n\n  // ECMA262 8.1.1.1.3\n  CreateImmutableBinding(N: string, S: boolean, isGlobal: boolean = false): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Assert: envRec does not already have a binding for N.\n    invariant(!envRec.bindings[N], `shouldn't have the binding ${N}`);\n\n    // 3. Create an immutable binding in envRec for N and record that it is uninitialized. If S is true, record that the newly created binding is a strict binding.\n    this.bindings[N] = realm.recordModifiedBinding({\n      initialized: false,\n      strict: S,\n      deletable: false,\n      environment: envRec,\n      name: N,\n      isGlobal: isGlobal,\n    });\n\n    // 4. Return NormalCompletion(empty).\n    return realm.intrinsics.undefined;\n  }\n\n  // ECMA262 8.1.1.1.4\n  InitializeBinding(N: string, V: Value): Value {\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    let binding = envRec.bindings[N];\n\n    // 2. Assert: envRec must have an uninitialized binding for N.\n    invariant(binding && !binding.initialized, `shouldn't have the binding ${N}`);\n\n    // 3. Set the bound value for N in envRec to V.\n    this.realm.recordModifiedBinding(binding).value = V;\n\n    // 4. Record that the binding for N in envRec has been initialized.\n    binding.initialized = true;\n\n    // 5. Return NormalCompletion(empty).\n    return this.realm.intrinsics.empty;\n  }\n\n  // ECMA262 8.1.1.1.5\n  SetMutableBinding(N: string, V: Value, S: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    let binding = envRec.bindings[N];\n\n    // 2. If envRec does not have a binding for N, then\n    if (!binding) {\n      // a. If S is true, throw a ReferenceError exception.\n      if (S) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError, `${N} not found`);\n      }\n\n      // b. Perform envRec.CreateMutableBinding(N, true).\n      envRec.CreateMutableBinding(N, true);\n\n      // c. Perform envRec.InitializeBinding(N, V).\n      envRec.InitializeBinding(N, V);\n\n      // d. Return NormalCompletion(empty).\n      return this.realm.intrinsics.empty;\n    }\n\n    // 3. If the binding for N in envRec is a strict binding, let S be true.\n    if (binding.strict) S = true;\n\n    // 4. If the binding for N in envRec has not yet been initialized, throw a ReferenceError exception.\n    if (!binding.initialized) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError, `${N} has not yet been initialized`);\n    } else if (binding.mutable) {\n      // 5. Else if the binding for N in envRec is a mutable binding, change its bound value to V.\n      realm.recordModifiedBinding(binding).value = V;\n    } else {\n      // 6. Else,\n      // a. Assert: This is an attempt to change the value of an immutable binding.\n\n      // b. If S is true, throw a TypeError exception.\n      if (S) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"attempt to change immutable binding\");\n      }\n    }\n\n    // 7. Return NormalCompletion(empty).\n    return this.realm.intrinsics.empty;\n  }\n\n  // ECMA262 8.1.1.1.6\n  GetBindingValue(N: string, S: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    let binding = envRec.bindings[N];\n\n    // 2. Assert: envRec has a binding for N.\n    invariant(binding, \"expected binding\");\n\n    // 3. If the binding for N in envRec is an uninitialized binding, throw a ReferenceError exception.\n    if (!binding.initialized) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError);\n    }\n\n    // 4. Return the value currently bound to N in envRec.\n    invariant(binding.value);\n    return binding.value;\n  }\n\n  // ECMA262 8.1.1.1.7\n  DeleteBinding(N: string): boolean {\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Assert: envRec has a binding for the name that is the value of N.\n    invariant(envRec.bindings[N], \"expected binding to exist\");\n\n    // 3. If the binding for N in envRec cannot be deleted, return false.\n    if (!envRec.bindings[N].deletable) return false;\n\n    // 4. Remove the binding for N from envRec.\n    this.realm.recordModifiedBinding(envRec.bindings[N]).value = undefined;\n    delete envRec.bindings[N];\n\n    // 5. Return true.\n    return true;\n  }\n\n  // ECMA262 8.1.1.1.8\n  HasThisBinding(): boolean {\n    // 1. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.1.9\n  HasSuperBinding(): boolean {\n    // 1. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.1.10\n  WithBaseObject(): Value {\n    // 1. Return undefined.\n    return this.realm.intrinsics.undefined;\n  }\n}\n\n// ECMA262 8.1.1.2\nexport class ObjectEnvironmentRecord extends EnvironmentRecord {\n  object: ObjectValue | AbstractObjectValue;\n  withEnvironment: boolean;\n\n  constructor(realm: Realm, obj: ObjectValue | AbstractObjectValue) {\n    super(realm);\n    this.object = obj;\n  }\n\n  // ECMA262 8.1.1.2.1\n  HasBinding(N: string): boolean {\n    let realm = this.realm;\n\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let bindings be the binding object for envRec.\n    let bindings = this.object;\n\n    // 3. Let foundBinding be ? HasProperty(bindings, N).\n    let foundBinding = HasProperty(realm, bindings, N);\n\n    // 4. If foundBinding is false, return false.\n    if (!foundBinding) return false;\n\n    // 5. If the withEnvironment flag of envRec is false, return true.\n    if (!envRec.withEnvironment) return true;\n\n    // 6. Let unscopables be ? Get(bindings, @@unscopables).\n    let unscopables = Get(realm, bindings, realm.intrinsics.SymbolUnscopables);\n\n    // 7. If Type(unscopables) is Object, then\n    if (unscopables instanceof ObjectValue || unscopables instanceof AbstractObjectValue) {\n      // a. Let blocked be ToBoolean(? Get(unscopables, N)).\n      let blocked = ToBooleanPartial(realm, Get(realm, unscopables, N));\n\n      // b. If blocked is true, return false.\n      if (blocked) return false;\n    }\n    unscopables.throwIfNotConcrete();\n\n    // 8. Return true.\n    return true;\n  }\n\n  // ECMA262 8.1.1.2.2\n  CreateMutableBinding(N: string, D: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let bindings be the binding object for envRec.\n    let bindings = envRec.object;\n\n    // 3. If D is true, let configValue be true; otherwise let configValue be false.\n    let configValue = D ? true : false;\n\n    // 4. Return ? DefinePropertyOrThrow(bindings, N, PropertyDescriptor{[[Value]]: undefined, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: configValue}).\n    return new BooleanValue(\n      realm,\n      Properties.DefinePropertyOrThrow(realm, bindings, N, {\n        value: realm.intrinsics.undefined,\n        writable: true,\n        enumerable: true,\n        configurable: configValue,\n      })\n    );\n  }\n\n  // ECMA262 8.1.1.2.3\n  CreateImmutableBinding(N: string, S: boolean): Value {\n    // The concrete Environment Record method CreateImmutableBinding is never used within this specification in association with object Environment Records.\n    invariant(false);\n  }\n\n  // ECMA262 8.1.1.2.4\n  InitializeBinding(N: string, V: Value): Value {\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Assert: envRec must have an uninitialized binding for N.\n    // 3. Record that the binding for N in envRec has been initialized.\n\n    // 4. Return ? envRec.SetMutableBinding(N, V, false).\n    return envRec.SetMutableBinding(N, V, false);\n  }\n\n  // ECMA262 8.1.1.2.5\n  SetMutableBinding(N: string, V: Value, S: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let bindings be the binding object for envRec.\n    let bindings = envRec.object;\n\n    // 3. Return ? Set(bindings, N, V, S).\n    return new BooleanValue(realm, Properties.Set(realm, bindings, N, V, S));\n  }\n\n  // ECMA262 8.1.1.2.6\n  GetBindingValue(N: string, S: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let bindings be the binding object for envRec.\n    let bindings = envRec.object;\n\n    // 3. Let value be ? HasProperty(bindings, N).\n    let value = HasProperty(realm, bindings, N);\n\n    // 4. If value is false, then\n    if (!value) {\n      // a. If S is false, return the value undefined; otherwise throw a ReferenceError exception.\n      if (!S) {\n        return realm.intrinsics.undefined;\n      } else {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError);\n      }\n    }\n\n    // 5. Return ? Get(bindings, N).\n    return Get(realm, bindings, N);\n  }\n\n  // ECMA262 8.1.1.2.7\n  DeleteBinding(N: string): boolean {\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let bindings be the binding object for envRec.\n    let bindings = envRec.object;\n\n    // 3. Return ? bindings.[[Delete]](N).\n    return bindings.$Delete(N);\n  }\n\n  // ECMA262 8.1.1.2.8\n  HasThisBinding(): boolean {\n    // 1. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.2.9\n  HasSuperBinding(): boolean {\n    // 1. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.2.10\n  WithBaseObject(): Value {\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. If the withEnvironment flag of envRec is true, return the binding object for envRec.\n    if (envRec.withEnvironment) return envRec.object;\n\n    // 3. Otherwise, return undefined.\n    return this.realm.intrinsics.undefined;\n  }\n}\n\n// ECMA262 8.1.1.3\nexport class FunctionEnvironmentRecord extends DeclarativeEnvironmentRecord {\n  $ThisBindingStatus: \"lexical\" | \"initialized\" | \"uninitialized\";\n  $ThisValue: UndefinedValue | NullValue | ObjectValue | AbstractObjectValue;\n  $HomeObject: void | ObjectValue;\n  $FunctionObject: FunctionValue;\n\n  // ECMA262 8.1.1.3.1\n  BindThisValue(\n    V: NullValue | ObjectValue | AbstractObjectValue | UndefinedValue\n  ): NullValue | ObjectValue | AbstractObjectValue | UndefinedValue {\n    let realm = this.realm;\n\n    // 1. Let envRec be the function Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Assert: envRec.[[ThisBindingStatus]] is not \"lexical\".\n    invariant(envRec.$ThisBindingStatus !== \"lexical\", \"this binding status shouldn't be lexical\");\n\n    // 3. If envRec.[[ThisBindingStatus]] is \"initialized\", throw a ReferenceError exception.\n    if (envRec.$ThisBindingStatus === \"initialized\") {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError);\n    }\n\n    // 4. Set envRec.[[ThisValue]] to V.\n    envRec.$ThisValue = V;\n\n    // 5. Set envRec.[[ThisBindingStatus]] to \"initialized\".\n    envRec.$ThisBindingStatus = \"initialized\";\n\n    // 6. Return V.\n    return V;\n  }\n\n  // ECMA262 8.1.1.3.2\n  HasThisBinding(): boolean {\n    // 1. Let envRec be the function Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. If envRec.[[ThisBindingStatus]] is \"lexical\", return false; otherwise, return true.\n    return envRec.$ThisBindingStatus === \"lexical\" ? false : true;\n  }\n\n  // ECMA262 8.1.1.3.3\n  HasSuperBinding(): boolean {\n    // 1. Let envRec be the function Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. If envRec.[[ThisBindingStatus]] is \"lexical\", return false.\n    if (envRec.$ThisBindingStatus === \"lexical\") return false;\n\n    // 3. If envRec.[[HomeObject]] has the value undefined, return false; otherwise, return true.\n    if (envRec.$HomeObject === undefined) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n\n  // ECMA262 8.1.1.3.4\n  GetThisBinding(): NullValue | ObjectValue | AbstractObjectValue | UndefinedValue {\n    let realm = this.realm;\n\n    // 1. Let envRec be the function Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Assert: envRec.[[ThisBindingStatus]] is not \"lexical\".\n    invariant(envRec.$ThisBindingStatus !== \"lexical\", \"this binding status shouldn't be lexical\");\n\n    // 3. If envRec.[[ThisBindingStatus]] is \"uninitialized\", throw a ReferenceError exception.\n    if (envRec.$ThisBindingStatus === \"uninitialized\") {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError);\n    }\n\n    // 4. Return envRec.[[ThisValue]].\n    return envRec.$ThisValue;\n  }\n\n  // ECMA262 8.1.1.3.5\n  GetSuperBase(): ObjectValue | NullValue | UndefinedValue {\n    // 1. Let envRec be the function Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let home be the value of envRec.[[HomeObject]].\n    let home = envRec.$HomeObject;\n\n    // 3. If home has the value undefined, return undefined.\n    if (home === undefined) return this.realm.intrinsics.undefined;\n\n    // 4. Assert: Type(home) is Object.\n    invariant(home instanceof ObjectValue, \"expected object value\");\n\n    // 5. Return ? home.[[GetPrototypeOf]]().\n    return home.$GetPrototypeOf();\n  }\n}\n\n// ECMA262 8.1.1.4\nexport class GlobalEnvironmentRecord extends EnvironmentRecord {\n  $DeclarativeRecord: EnvironmentRecord;\n  $ObjectRecord: ObjectEnvironmentRecord;\n  $VarNames: Array<string>;\n  $GlobalThisValue: ObjectValue;\n\n  // ECMA262 8.1.1.4.1\n  HasBinding(N: string): boolean {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, return true.\n    if (DclRec.HasBinding(N)) return true;\n\n    // 4. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 5. Return ? ObjRec.HasBinding(N).\n    return ObjRec.HasBinding(N);\n  }\n\n  // ECMA262 8.1.1.4.2\n  CreateMutableBinding(N: string, D: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, throw a TypeError exception.\n    if (DclRec.HasBinding(N)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 4. Return DclRec.CreateMutableBinding(N, D).\n    return DclRec.CreateMutableBinding(N, D, true);\n  }\n\n  // ECMA262 8.1.1.4.3\n  CreateImmutableBinding(N: string, S: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, throw a TypeError exception.\n    if (DclRec.HasBinding(N)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 4. Return DclRec.CreateImmutableBinding(N, S).\n    return DclRec.CreateImmutableBinding(N, S, true);\n  }\n\n  // ECMA262 8.1.1.4.4\n  InitializeBinding(N: string, V: Value): Value {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, then\n    if (DclRec.HasBinding(N)) {\n      // a. Return DclRec.InitializeBinding(N, V).\n      return DclRec.InitializeBinding(N, V);\n    }\n\n    // 4. Assert: If the binding exists, it must be in the object Environment Record.\n\n    // 5. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 6. Return ? ObjRec.InitializeBinding(N, V).\n    return ObjRec.InitializeBinding(N, V);\n  }\n\n  // ECMA262 8.1.1.4.5\n  SetMutableBinding(N: string, V: Value, S: boolean): Value {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, then\n    if (DclRec.HasBinding(N)) {\n      // a. Return DclRec.SetMutableBinding(N, V, S).\n      return DclRec.SetMutableBinding(N, V, S);\n    }\n\n    // 4. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 5. Return ? ObjRec.SetMutableBinding(N, V, S).\n    return ObjRec.SetMutableBinding(N, V, S);\n  }\n\n  // ECMA262 8.1.1.4.6\n  GetBindingValue(N: string, S: boolean): Value {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, then\n    if (DclRec.HasBinding(N)) {\n      // a. Return DclRec.GetBindingValue(N, S).\n      return DclRec.GetBindingValue(N, S);\n    }\n\n    // 4. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 5. Return ? ObjRec.GetBindingValue(N, S).\n    return ObjRec.GetBindingValue(N, S);\n  }\n\n  // ECMA262 8.1.1.4.7\n  DeleteBinding(N: string): boolean {\n    let realm = this.realm;\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, then\n    if (DclRec.HasBinding(N)) {\n      // a. Return DclRec.DeleteBinding(N).\n      return DclRec.DeleteBinding(N);\n    }\n\n    // 4. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 5. Let globalObject be the binding object for ObjRec.\n    let globalObject = ObjRec.object;\n\n    // 6. Let existingProp be ? HasOwnProperty(globalObject, N).\n    let existingProp = HasOwnProperty(realm, globalObject, N);\n\n    // 7. If existingProp is true, then\n    if (existingProp) {\n      // a. Let status be ? ObjRec.DeleteBinding(N).\n      let status = ObjRec.DeleteBinding(N);\n\n      // b. If status is true, then\n      if (status) {\n        // i. Let varNames be envRec.[[VarNames]].\n        let varNames = envRec.$VarNames;\n\n        // ii. If N is an element of varNames, remove that element from the varNames.\n        if (varNames.indexOf(N) >= 0) {\n          varNames.splice(varNames.indexOf(N), 1);\n        }\n      }\n\n      // c. Return status.\n      return status;\n    }\n\n    // 8. Return true.\n    return true;\n  }\n\n  // ECMA262 8.1.1.4.8\n  HasThisBinding(): boolean {\n    // 1. Return true.\n    return true;\n  }\n\n  // ECMA262 8.1.1.4.9\n  HasSuperBinding(): boolean {\n    // 1. Return true.\n    return true;\n  }\n\n  // ECMA262 8.1.1.4.10\n  WithBaseObject(): Value {\n    // 1. Return undefined.\n    return this.realm.intrinsics.undefined;\n  }\n\n  // ECMA262 8.1.1.4.11\n  GetThisBinding(): NullValue | ObjectValue | AbstractObjectValue | UndefinedValue {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    invariant(envRec.$GlobalThisValue);\n    // 2. Return envRec.[[GlobalThisValue]].\n    return envRec.$GlobalThisValue;\n  }\n\n  // ECMA262 8.1.1.4.12\n  HasVarDeclaration(N: string): boolean {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let varDeclaredNames be envRec.[[VarNames]].\n    let varDeclaredNames = envRec.$VarNames;\n\n    // 3. If varDeclaredNames contains the value of N, return true.\n    if (varDeclaredNames.indexOf(N) >= 0) return true;\n\n    // 4. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.4.13\n  HasLexicalDeclaration(N: string): boolean {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. Return DclRec.HasBinding(N).\n    return DclRec.HasBinding(N);\n  }\n\n  // ECMA262 8.1.1.4.14\n  HasRestrictedGlobalProperty(N: string): boolean {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 3. Let globalObject be the binding object for ObjRec.\n    let globalObject = ObjRec.object;\n\n    // 4. Let existingProp be ? globalObject.[[GetOwnProperty]](N).\n    let existingProp = globalObject.$GetOwnProperty(N);\n\n    // 5. If existingProp is undefined, return false.\n    if (!existingProp) return false;\n    Properties.ThrowIfMightHaveBeenDeleted(existingProp.value);\n\n    // 6. If existingProp.[[Configurable]] is true, return false.\n    if (existingProp.configurable) return false;\n\n    // 7. Return true.\n    return true;\n  }\n\n  // ECMA262 8.1.1.4.15\n  CanDeclareGlobalVar(N: string): boolean {\n    let realm = this.realm;\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 3. Let globalObject be the binding object for ObjRec.\n    let globalObject = ObjRec.object;\n\n    // 4. Let hasProperty be ? HasOwnProperty(globalObject, N).\n    let hasProperty = HasOwnProperty(realm, globalObject, N);\n\n    // 5. If hasProperty is true, return true.\n    if (hasProperty) return true;\n\n    // 6. Return ? IsExtensible(globalObject).\n    return IsExtensible(realm, globalObject);\n  }\n\n  // ECMA262 8.1.1.4.16\n  CanDeclareGlobalFunction(N: string): boolean {\n    let realm = this.realm;\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 3. Let globalObject be the binding object for ObjRec.\n    let globalObject = ObjRec.object;\n\n    // 4. Let existingProp be ? globalObject.[[GetOwnProperty]](N).\n    let existingProp = globalObject.$GetOwnProperty(N);\n\n    // 5. If existingProp is undefined, return ? IsExtensible(globalObject).\n    if (!existingProp) return IsExtensible(realm, globalObject);\n    Properties.ThrowIfMightHaveBeenDeleted(existingProp.value);\n\n    // 6. If existingProp.[[Configurable]] is true, return true.\n    if (existingProp.configurable) return true;\n\n    // 7. If IsDataDescriptor(existingProp) is true and existingProp has attribute values {[[Writable]]: true, [[Enumerable]]: true}, return true.\n    if (IsDataDescriptor(realm, existingProp) && existingProp.writable && existingProp.enumerable) {\n      return true;\n    }\n\n    // 8. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.4.17\n  CreateGlobalVarBinding(N: string, D: boolean) {\n    let realm = this.realm;\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 3. Let globalObject be the binding object for ObjRec.\n    let globalObject = ObjRec.object;\n\n    // 4. Let hasProperty be ? HasOwnProperty(globalObject, N).\n    let hasProperty = HasOwnProperty(realm, globalObject, N);\n\n    // 5. Let extensible be ? IsExtensible(globalObject).\n    let extensible = IsExtensible(realm, globalObject);\n\n    // 6. If hasProperty is false and extensible is true, then\n    if (!hasProperty && extensible) {\n      // a. Perform ? ObjRec.CreateMutableBinding(N, D).\n      ObjRec.CreateMutableBinding(N, D);\n\n      // b. Perform ? ObjRec.InitializeBinding(N, undefined).\n      ObjRec.InitializeBinding(N, this.realm.intrinsics.undefined);\n    }\n\n    // 7. Let varDeclaredNames be envRec.[[VarNames]].\n    let varDeclaredNames = envRec.$VarNames;\n\n    // 8. If varDeclaredNames does not contain the value of N, then\n    if (varDeclaredNames.indexOf(N) < 0) {\n      // a. Append N to varDeclaredNames.\n      varDeclaredNames.push(N);\n    }\n\n    // 9. Return NormalCompletion(empty).\n  }\n\n  // ECMA262 8.1.1.4.18\n  CreateGlobalFunctionBinding(N: string, V: Value, D: boolean) {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 3. Let globalObject be the binding object for ObjRec.\n    let globalObject = ObjRec.object;\n\n    // 4. Let existingProp be ? globalObject.[[GetOwnProperty]](N).\n    let existingProp = globalObject.$GetOwnProperty(N);\n\n    // 5. If existingProp is undefined or existingProp.[[Configurable]] is true, then\n    let desc;\n    if (!existingProp || existingProp.configurable) {\n      // a. Let desc be the PropertyDescriptor{[[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: D}.\n      desc = { value: V, writable: true, enumerable: true, configurable: D };\n    } else {\n      // 6. Else,\n      Properties.ThrowIfMightHaveBeenDeleted(existingProp.value);\n      // a. Let desc be the PropertyDescriptor{[[Value]]: V }.\n      desc = { value: V };\n    }\n\n    // 7. Perform ? DefinePropertyOrThrow(globalObject, N, desc).\n    Properties.DefinePropertyOrThrow(this.realm, globalObject, N, desc);\n\n    // 8. Record that the binding for N in ObjRec has been initialized.\n\n    // 9. Perform ? Set(globalObject, N, V, false).\n    Properties.Set(this.realm, globalObject, N, V, false);\n\n    // 10. Let varDeclaredNames be envRec.[[VarNames]].\n    let varDeclaredNames = envRec.$VarNames;\n\n    // 11. If varDeclaredNames does not contain the value of N, then\n    if (varDeclaredNames.indexOf(N) < 0) {\n      // a. Append N to varDeclaredNames.\n      varDeclaredNames.push(N);\n    }\n\n    // 12. Return NormalCompletion(empty).\n  }\n}\n\n// ECMA262 8.1\nexport class LexicalEnvironment {\n  constructor(realm: Realm) {\n    invariant(realm, \"expected realm\");\n    this.realm = realm;\n  }\n\n  environmentRecord: EnvironmentRecord;\n  parent: null | LexicalEnvironment;\n  realm: Realm;\n\n  assignToGlobal(globalAst: BabelNodeLVal, rvalue: Value) {\n    let globalValue = this.evaluate(globalAst, false);\n    Properties.PutValue(this.realm, globalValue, rvalue);\n  }\n\n  partiallyEvaluateCompletionDeref(\n    ast: BabelNode,\n    strictCode: boolean,\n    metadata?: any\n  ): [Completion | Value, BabelNode, Array<BabelNodeStatement>] {\n    let [result, partial_ast, partial_io] = this.partiallyEvaluateCompletion(ast, strictCode, metadata);\n    if (result instanceof Reference) {\n      result = Environment.GetValue(this.realm, result);\n    }\n    return [result, partial_ast, partial_io];\n  }\n\n  partiallyEvaluateCompletion(\n    ast: BabelNode,\n    strictCode: boolean,\n    metadata?: any\n  ): [Completion | Reference | Value, BabelNode, Array<BabelNodeStatement>] {\n    try {\n      return this.partiallyEvaluate(ast, strictCode, metadata);\n    } catch (err) {\n      if (err instanceof Completion) return [err, ast, []];\n      if (err instanceof Error)\n        // rethrowing Error should preserve stack trace\n        throw err;\n      // let's wrap into a proper Error to create stack trace\n      throw new FatalError(err);\n    }\n  }\n\n  evaluateCompletionDeref(ast: BabelNode, strictCode: boolean, metadata?: any): AbruptCompletion | Value {\n    let result = this.evaluateCompletion(ast, strictCode, metadata);\n    if (result instanceof Reference) result = Environment.GetValue(this.realm, result);\n    return result;\n  }\n\n  evaluateCompletion(ast: BabelNode, strictCode: boolean, metadata?: any): AbruptCompletion | Value | Reference {\n    try {\n      return this.evaluate(ast, strictCode, metadata);\n    } catch (err) {\n      if (\n        (err instanceof JoinedAbruptCompletions || err instanceof PossiblyNormalCompletion) &&\n        err.containsBreakOrContinue()\n      ) {\n        AbstractValue.reportIntrospectionError(err.joinCondition);\n        throw new FatalError();\n      }\n      if (err instanceof AbruptCompletion) return err;\n      if (err instanceof Error)\n        // rethrowing Error should preserve stack trace\n        throw err;\n      // let's wrap into a proper Error to create stack trace\n      throw new FatalError(err);\n    }\n  }\n\n  evaluateAbstractCompletion(ast: BabelNode, strictCode: boolean, metadata?: any): Completion | Value | Reference {\n    try {\n      return this.evaluateAbstract(ast, strictCode, metadata);\n    } catch (err) {\n      if (err instanceof Completion) return err;\n      if (err instanceof Error)\n        // rethrowing Error should preserve stack trace\n        throw err;\n      // let's wrap into a proper Error to create stack trace\n      if (err instanceof Object) throw new FatalError(err.constructor.name + \": \" + err);\n      throw new FatalError(err);\n    }\n  }\n\n  concatenateAndParse(sources: Array<SourceFile>, sourceType: SourceType = \"script\"): [BabelNodeFile, any] {\n    let asts = [];\n    let code = {};\n    let directives = [];\n    for (let source of sources) {\n      try {\n        let node = parse(this.realm, source.fileContents, source.filePath, sourceType);\n        if (source.sourceMapContents && source.sourceMapContents.length > 0)\n          this.fixup_source_locations(node, source.sourceMapContents);\n        this.fixup_filenames(node);\n        asts = asts.concat(node.program.body);\n        code[source.filePath] = source.fileContents;\n        directives = directives.concat(node.program.directives);\n      } catch (e) {\n        if (e instanceof ThrowCompletion) {\n          let error = e.value;\n          if (error instanceof ObjectValue) {\n            let message = error.$Get(\"message\", error);\n            e.location.source = source.filePath;\n            let err = new CompilerDiagnostic(message.value, e.location, \"PP1004\", \"FatalError\");\n            this.realm.handleError(err);\n            throw new FatalError(\"syntax error\");\n          }\n        }\n        throw e;\n      }\n    }\n    return [t.file(t.program(asts, directives)), code];\n  }\n\n  executeSources(\n    sources: Array<SourceFile>,\n    sourceType: SourceType = \"script\",\n    onParse: void | (BabelNodeFile => void) = undefined\n  ): [AbruptCompletion | Value, any] {\n    let context = new ExecutionContext();\n    context.lexicalEnvironment = this;\n    context.variableEnvironment = this;\n    context.realm = this.realm;\n    this.realm.pushContext(context);\n    let res, code;\n    try {\n      let ast;\n      [ast, code] = this.concatenateAndParse(sources, sourceType);\n      if (onParse) onParse(ast);\n      res = this.evaluateCompletion(ast, false);\n    } finally {\n      this.realm.popContext(context);\n    }\n    if (res instanceof AbruptCompletion) return [res, code];\n\n    return [Environment.GetValue(this.realm, res), code];\n  }\n\n  executePartialEvaluator(\n    sources: Array<SourceFile>,\n    options: PartialEvaluatorOptions = defaultOptions,\n    sourceType: SourceType = \"script\"\n  ): AbruptCompletion | { code: string, map?: SourceMap } {\n    let [ast, code] = this.concatenateAndParse(sources, sourceType);\n    let context = new ExecutionContext();\n    context.lexicalEnvironment = this;\n    context.variableEnvironment = this;\n    context.realm = this.realm;\n    this.realm.pushContext(context);\n    let partialAST;\n    try {\n      let res;\n      [res, partialAST] = this.partiallyEvaluateCompletionDeref(ast, false);\n      if (res instanceof AbruptCompletion) return res;\n    } finally {\n      this.realm.popContext(context);\n    }\n    invariant(partialAST.type === \"File\");\n    let fileAst = ((partialAST: any): BabelNodeFile);\n    let prog = t.program(fileAst.program.body, ast.program.directives);\n    this.fixup_filenames(prog);\n    return generate(prog, { sourceMaps: options.sourceMaps }, (code: any));\n  }\n\n  execute(\n    code: string,\n    filename: string,\n    map: string = \"\",\n    sourceType: SourceType = \"script\",\n    onParse: void | (BabelNodeFile => void) = undefined\n  ): AbruptCompletion | Value {\n    let context = new ExecutionContext();\n    context.lexicalEnvironment = this;\n    context.variableEnvironment = this;\n    context.realm = this.realm;\n\n    this.realm.pushContext(context);\n\n    let ast, res;\n    try {\n      try {\n        ast = parse(this.realm, code, filename, sourceType);\n      } catch (e) {\n        if (e instanceof ThrowCompletion) return e;\n        throw e;\n      }\n      if (onParse) onParse(ast);\n      if (map.length > 0) this.fixup_source_locations(ast, map);\n      this.fixup_filenames(ast);\n      res = this.evaluateCompletion(ast, false);\n    } finally {\n      this.realm.popContext(context);\n    }\n    if (res instanceof AbruptCompletion) return res;\n\n    return Environment.GetValue(this.realm, res);\n  }\n\n  fixup_source_locations(ast: BabelNode, map: string) {\n    const smc = new sourceMap.SourceMapConsumer(map);\n    traverseFast(ast, node => {\n      let loc = node.loc;\n      if (!loc) return false;\n      fixup(loc, loc.start);\n      fixup(loc, loc.end);\n      fixup_comments(node.leadingComments);\n      fixup_comments(node.innerComments);\n      fixup_comments(node.trailingComments);\n      return false;\n\n      function fixup(new_loc: BabelNodeSourceLocation, new_pos: BabelNodePosition) {\n        let old_pos = smc.originalPositionFor({ line: new_pos.line, column: new_pos.column });\n        if (old_pos.source === null) return;\n        new_pos.line = old_pos.line;\n        new_pos.column = old_pos.column;\n        new_loc.source = old_pos.source;\n      }\n\n      function fixup_comments(comments: ?Array<BabelNodeComment>) {\n        if (!comments) return;\n        for (let c of comments) {\n          let cloc = c.loc;\n          if (!cloc) continue;\n          fixup(cloc, cloc.start);\n          fixup(cloc, cloc.end);\n        }\n      }\n    });\n  }\n\n  fixup_filenames(ast: BabelNode) {\n    traverseFast(ast, node => {\n      let loc = node.loc;\n      if (!loc || !loc.source) {\n        node.leadingComments = null;\n        node.innerComments = null;\n        node.trailingComments = null;\n        node.loc = null;\n      } else {\n        let filename = loc.source;\n        (loc: any).filename = filename;\n        fixup_comments(node.leadingComments, filename);\n        fixup_comments(node.innerComments, filename);\n        fixup_comments(node.trailingComments, filename);\n      }\n      return false;\n\n      function fixup_comments(comments: ?Array<BabelNodeComment>, filename: string) {\n        if (!comments) return;\n        for (let c of comments) {\n          if (c.loc) {\n            (c.loc: any).filename = filename;\n            c.loc.source = filename;\n          }\n        }\n      }\n    });\n  }\n\n  evaluate(ast: BabelNode, strictCode: boolean, metadata?: any): Value | Reference {\n    if (this.realm.debuggerInstance) {\n      this.realm.debuggerInstance.checkForActions(ast);\n    }\n    let res = this.evaluateAbstract(ast, strictCode, metadata);\n    invariant(res instanceof Value || res instanceof Reference, ast.type);\n    return res;\n  }\n\n  evaluateAbstract(ast: BabelNode, strictCode: boolean, metadata?: any): Value | Reference {\n    this.realm.currentLocation = ast.loc;\n    this.realm.testTimeout();\n\n    let evaluator = this.realm.evaluators[(ast.type: string)];\n    if (evaluator) {\n      let result = evaluator(ast, strictCode, this, this.realm, metadata);\n      return result;\n    }\n\n    throw new TypeError(`Unsupported node type ${ast.type}`);\n  }\n\n  partiallyEvaluate(\n    ast: BabelNode,\n    strictCode: boolean,\n    metadata?: any\n  ): [Completion | Reference | Value, BabelNode, Array<BabelNodeStatement>] {\n    let partialEvaluator = this.realm.partialEvaluators[(ast.type: string)];\n    if (partialEvaluator) {\n      return partialEvaluator(ast, strictCode, this, this.realm, metadata);\n    }\n\n    let err = new TypeError(`Unsupported node type ${ast.type}`);\n    throw err;\n  }\n}\n\n// ECMA262 6.2.3\n// A Reference is a resolved name or property binding. A Reference consists of three components, the base value,\n// the referenced name and the Boolean valued strict reference flag. The base value is either undefined, an Object,\n// a Boolean, a String, a Symbol, a Number, or an Environment Record. A base value of undefined indicates that the\n// Reference could not be resolved to a binding. The referenced name is a String or Symbol value.\nexport type BaseValue = void | ObjectValue | BooleanValue | StringValue | SymbolValue | NumberValue | EnvironmentRecord;\nexport type ReferenceName = string | SymbolValue;\n\nexport function canBecomeAnObject(base: Value): boolean {\n  let type = base.getType();\n  return type === BooleanValue || type === StringValue || type === SymbolValue || type === NumberValue;\n}\n\nexport class Reference {\n  base: BaseValue | AbstractValue;\n  referencedName: ReferenceName | AbstractValue;\n  strict: boolean;\n  thisValue: void | Value;\n\n  constructor(\n    base: BaseValue | AbstractValue,\n    refName: ReferenceName | AbstractValue,\n    strict: boolean,\n    thisValue?: void | Value\n  ) {\n    invariant(\n      base instanceof AbstractObjectValue ||\n        base === undefined ||\n        base instanceof ObjectValue ||\n        base instanceof EnvironmentRecord ||\n        canBecomeAnObject(base)\n    );\n    this.base = base;\n    this.referencedName = refName;\n    invariant(!(refName instanceof AbstractValue) || !refName.mightNotBeString());\n    this.strict = strict;\n    this.thisValue = thisValue;\n    invariant(thisValue === undefined || !(base instanceof EnvironmentRecord));\n  }\n}\n"]}