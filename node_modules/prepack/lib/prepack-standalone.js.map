{"version":3,"sources":["../src/prepack-standalone.js"],"names":["InitializationError","prepackSources","prepackString","prepack","prepackFromAst","t","self","Error","Object","setPrototypeOf","prototype","sources","options","debugChannel","undefined","realmOptions","errorHandler","realm","additionalGlobals","serialize","residual","serializer","serialized","init","sourceMaps","debuggerInstance","shutdown","residualSources","filePath","outputFilename","fileContents","code","sourceMapContents","JSON","stringify","map","result","$GlobalEnv","executePartialEvaluator","filename","sourceMap","ast","type","file","loc","source"],"mappings":"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","file":"prepack-standalone.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\n/* APIs for running Prepack for code where a model of the environment is supplied as part of the code. */\n\nimport Serializer from \"./serializer/index.js\";\nimport construct_realm from \"./construct_realm.js\";\nimport initializeGlobals from \"./globals.js\";\nimport * as t from \"babel-types\";\nimport { getRealmOptions, getSerializerOptions } from \"./prepack-options\";\nimport { FatalError } from \"./errors.js\";\nimport { SerializerStatistics, TimingStatistics } from \"./serializer/types.js\";\nimport type { SourceFile } from \"./types.js\";\nimport { AbruptCompletion } from \"./completions.js\";\nimport type { PrepackOptions } from \"./prepack-options\";\nimport { defaultOptions } from \"./options\";\nimport type { BabelNodeFile, BabelNodeProgram } from \"babel-types\";\nimport invariant from \"./invariant.js\";\nimport type { DebugChannel } from \"./debugger/channel/DebugChannel.js\";\n\n// IMPORTANT: This function is now deprecated and will go away in a future release.\n// Please use FatalError instead.\nexport function InitializationError() {\n  let self = new Error(\"An error occurred while prepacking. See the error logs.\");\n  Object.setPrototypeOf(self, InitializationError.prototype);\n  return self;\n}\nObject.setPrototypeOf(InitializationError, Error);\nObject.setPrototypeOf(InitializationError.prototype, Error.prototype);\nObject.setPrototypeOf(FatalError.prototype, InitializationError.prototype);\n\nexport function prepackSources(\n  sources: Array<SourceFile>,\n  options: PrepackOptions = defaultOptions,\n  debugChannel: DebugChannel | void = undefined\n): { code: string, map?: SourceMap, statistics?: SerializerStatistics, timingStats?: TimingStatistics } {\n  let realmOptions = getRealmOptions(options);\n  realmOptions.errorHandler = options.errorHandler;\n  let realm = construct_realm(realmOptions, debugChannel);\n  initializeGlobals(realm);\n  if (typeof options.additionalGlobals === \"function\") {\n    options.additionalGlobals(realm);\n  }\n\n  if (options.serialize || !options.residual) {\n    let serializer = new Serializer(realm, getSerializerOptions(options));\n    let serialized = serializer.init(sources, options.sourceMaps);\n\n    //Turn off the debugger if there is one\n    if (realm.debuggerInstance) {\n      realm.debuggerInstance.shutdown();\n    }\n\n    if (!serialized) {\n      throw new FatalError(\"serializer failed\");\n    }\n\n    if (!options.residual) return serialized;\n    let residualSources = [\n      {\n        filePath: options.outputFilename || \"unknown\",\n        fileContents: serialized.code,\n        sourceMapContents: JSON.stringify(serialized.map),\n      },\n    ];\n    let result = realm.$GlobalEnv.executePartialEvaluator(residualSources, options);\n    if (result instanceof AbruptCompletion) throw result;\n    // $FlowFixMe This looks like a Flow bug\n    return result;\n  } else {\n    invariant(options.residual);\n    let result = realm.$GlobalEnv.executePartialEvaluator(sources, options);\n    if (result instanceof AbruptCompletion) throw result;\n    // $FlowFixMe This looks like a Flow bug\n    return result;\n  }\n}\n\n/* deprecated: please use prepackSources instead. */\nexport function prepackString(\n  filename: string,\n  code: string,\n  sourceMap: string,\n  options: PrepackOptions = defaultOptions\n): { code: string, map?: SourceMap, statistics?: SerializerStatistics, timingStats?: TimingStatistics } {\n  return prepackSources([{ filePath: filename, fileContents: code, sourceMapContents: sourceMap }], options);\n}\n\n/* deprecated: please use prepackSources instead. */\nexport function prepack(code: string, options: PrepackOptions = defaultOptions) {\n  let filename = options.filename || \"unknown\";\n  let sources = [{ filePath: filename, fileContents: code }];\n\n  let realmOptions = getRealmOptions(options);\n  realmOptions.errorHandler = options.errorHandler;\n  let realm = construct_realm(realmOptions);\n  initializeGlobals(realm);\n\n  let serializer = new Serializer(realm, getSerializerOptions(options));\n  let serialized = serializer.init(sources, options.sourceMaps);\n  if (!serialized) {\n    throw new FatalError(\"serializer failed\");\n  }\n  return serialized;\n}\n\n/* deprecated: please use prepackSources instead. */\nexport function prepackFromAst(\n  ast: BabelNodeFile | BabelNodeProgram,\n  code: string,\n  options: PrepackOptions = defaultOptions\n) {\n  if (ast && ast.type === \"Program\") {\n    ast = t.file(ast, [], []);\n  }\n  invariant(ast && ast.type === \"File\");\n  let filename = options.filename || (ast.loc && ast.loc.source) || \"unknown\";\n  let sources = [{ filePath: filename, fileContents: code }];\n\n  let realm = construct_realm(getRealmOptions(options));\n  initializeGlobals(realm);\n  let serializer = new Serializer(realm, getSerializerOptions(options));\n  let serialized = serializer.init(sources, options.sourceMaps);\n  if (!serialized) {\n    throw new FatalError(\"serializer failed\");\n  }\n  return serialized;\n}\n"]}