"use strict";

var _prepackNode = require("../lib/prepack-node.js");

var _invariant = require("../lib/invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var chalk = require("chalk"); /**
                               * Copyright (c) 2017-present, Facebook, Inc.
                               * All rights reserved.
                               *
                               * This source code is licensed under the BSD-style license found in the
                               * LICENSE file in the root directory of this source tree. An additional grant
                               * of patent rights can be found in the PATENTS file in the same directory.
                               */

var path = require("path");
var fs = require("fs");

function search(dir, relative) {
  var tests = [];

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = fs.readdirSync(dir)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var name = _step.value;

      var loc = path.join(dir, name);
      var stat = fs.statSync(loc);

      if (stat.isFile()) {
        tests.push({
          file: fs.readFileSync(loc, "utf8"),
          path: path.join(relative, name),
          name: name
        });
      } else if (stat.isDirectory()) {
        tests = tests.concat(search(loc, path.join(relative, name)));
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return tests;
}

var tests = search(__dirname + "/../test/source-maps", "test/source-maps");

function errorHandler(diagnostic) {
  var loc = diagnostic.location;
  if (loc) console.log(loc.start.line + ":" + (loc.start.column + 1) + " " + diagnostic.errorCode + " " + diagnostic.message);else console.log("unknown location: " + diagnostic.errorCode + " " + diagnostic.message);
  return "Fail";
}

function generateTest(name, test_path, code) {
  console.log(chalk.inverse(name));
  var newCode1 = void 0,
      newMap1 = void 0,
      newCode2 = void 0,
      newMap2 = void 0;
  try {
    var s = (0, _prepackNode.prepackFileSync)([test_path], {
      internalDebug: true,
      errorHandler: errorHandler,
      sourceMaps: true,
      serialize: true
    });
    if (!s) {
      process.exit(1);
      (0, _invariant2.default)(false);
    }
    newCode1 = s.code;
    fs.writeFileSync(name + ".new1.js", newCode1);
    newMap1 = s.map;
    fs.writeFileSync(name + ".new1.js.map", JSON.stringify(newMap1));
    s = (0, _prepackNode.prepackFileSync)([name + ".new1.js"], {
      compatibility: "node-source-maps",
      inputSourceMapFilename: name + ".new1.js.map",
      internalDebug: true,
      errorHandler: errorHandler,
      sourceMaps: true,
      serialize: true
    });
    if (!s) {
      process.exit(1);
      (0, _invariant2.default)(false);
    }
    newCode2 = s.code + "\nf();\n\n//# sourceMappingURL=" + name + ".new2.js.map\n";
    fs.writeFileSync(name + ".new2.js", newCode2);
    newMap2 = s.map;
    fs.writeFileSync(name + ".new2.js.map", JSON.stringify(newMap2));
    return true;
  } catch (err) {
    console.log(err);
  }
  console.log(chalk.underline("original code"));
  console.log(code);
  console.log(chalk.underline("generated code 1"));
  console.log(newCode1);
  console.log(chalk.underline("newMap 1"));
  console.log(newMap1);
  console.log(chalk.underline("generated code 2"));
  console.log(newCode2);
  console.log(chalk.underline("newMap 2"));
  console.log(newMap2);

  return false;
}

function run() {
  var failed = 0;
  var passed = 0;
  var total = 0;

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = tests[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var test = _step2.value;

      // filter hidden files
      if (path.basename(test.name)[0] === ".") continue;
      if (test.name.endsWith("~")) continue;

      total++;
      if (generateTest(test.name, test.path, test.file)) passed++;else failed++;
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  console.log("Generated:", passed + "/" + total, (Math.round(passed / total * 100) || 0) + "%");
  return failed === 0;
}

if (!run()) process.exit(1);
//# sourceMappingURL=generate-sourcemaps-test.js.map