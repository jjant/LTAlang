"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PossiblyNormalCompletion = exports.JoinedAbruptCompletions = exports.ReturnCompletion = exports.BreakCompletion = exports.ContinueCompletion = exports.ThrowCompletion = exports.AbruptCompletion = exports.NormalCompletion = exports.Completion = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _invariant = require("./invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _index = require("./values/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
                                                                                                                                                           * Copyright (c) 2017-present, Facebook, Inc.
                                                                                                                                                           * All rights reserved.
                                                                                                                                                           *
                                                                                                                                                           * This source code is licensed under the BSD-style license found in the
                                                                                                                                                           * LICENSE file in the root directory of this source tree. An additional grant
                                                                                                                                                           * of patent rights can be found in the PATENTS file in the same directory.
                                                                                                                                                           */

var Completion = exports.Completion = function Completion(value, location, target) {
  _classCallCheck(this, Completion);

  this.value = value;
  this.target = target;
  this.location = location;
};

// Normal completions are returned just like spec completions


var NormalCompletion = exports.NormalCompletion = function (_Completion) {
  _inherits(NormalCompletion, _Completion);

  function NormalCompletion() {
    _classCallCheck(this, NormalCompletion);

    return _possibleConstructorReturn(this, (NormalCompletion.__proto__ || Object.getPrototypeOf(NormalCompletion)).apply(this, arguments));
  }

  return NormalCompletion;
}(Completion);

// Abrupt completions are thrown as exeptions, to make it a easier
// to quickly get to the matching high level construct.


var AbruptCompletion = exports.AbruptCompletion = function (_Completion2) {
  _inherits(AbruptCompletion, _Completion2);

  function AbruptCompletion() {
    _classCallCheck(this, AbruptCompletion);

    return _possibleConstructorReturn(this, (AbruptCompletion.__proto__ || Object.getPrototypeOf(AbruptCompletion)).apply(this, arguments));
  }

  return AbruptCompletion;
}(Completion);

var ThrowCompletion = exports.ThrowCompletion = function (_AbruptCompletion) {
  _inherits(ThrowCompletion, _AbruptCompletion);

  function ThrowCompletion(value, location, nativeStack) {
    _classCallCheck(this, ThrowCompletion);

    var _this3 = _possibleConstructorReturn(this, (ThrowCompletion.__proto__ || Object.getPrototypeOf(ThrowCompletion)).call(this, value, location));

    _this3.nativeStack = nativeStack || new Error().stack;
    return _this3;
  }

  return ThrowCompletion;
}(AbruptCompletion);

var ContinueCompletion = exports.ContinueCompletion = function (_AbruptCompletion2) {
  _inherits(ContinueCompletion, _AbruptCompletion2);

  function ContinueCompletion(value, location, target) {
    _classCallCheck(this, ContinueCompletion);

    return _possibleConstructorReturn(this, (ContinueCompletion.__proto__ || Object.getPrototypeOf(ContinueCompletion)).call(this, value, location, target));
  }

  return ContinueCompletion;
}(AbruptCompletion);

var BreakCompletion = exports.BreakCompletion = function (_AbruptCompletion3) {
  _inherits(BreakCompletion, _AbruptCompletion3);

  function BreakCompletion(value, location, target) {
    _classCallCheck(this, BreakCompletion);

    return _possibleConstructorReturn(this, (BreakCompletion.__proto__ || Object.getPrototypeOf(BreakCompletion)).call(this, value, location, target));
  }

  return BreakCompletion;
}(AbruptCompletion);

var ReturnCompletion = exports.ReturnCompletion = function (_AbruptCompletion4) {
  _inherits(ReturnCompletion, _AbruptCompletion4);

  function ReturnCompletion(value, location) {
    _classCallCheck(this, ReturnCompletion);

    return _possibleConstructorReturn(this, (ReturnCompletion.__proto__ || Object.getPrototypeOf(ReturnCompletion)).call(this, value, location));
  }

  return ReturnCompletion;
}(AbruptCompletion);

var JoinedAbruptCompletions = exports.JoinedAbruptCompletions = function (_AbruptCompletion5) {
  _inherits(JoinedAbruptCompletions, _AbruptCompletion5);

  function JoinedAbruptCompletions(realm, joinCondition, consequent, consequentEffects, alternate, alternateEffects) {
    _classCallCheck(this, JoinedAbruptCompletions);

    var _this7 = _possibleConstructorReturn(this, (JoinedAbruptCompletions.__proto__ || Object.getPrototypeOf(JoinedAbruptCompletions)).call(this, realm.intrinsics.empty, consequent.location));

    _this7.joinCondition = joinCondition;
    _this7.consequent = consequent;
    _this7.consequentEffects = consequentEffects;
    _this7.alternate = alternate;
    _this7.alternateEffects = alternateEffects;
    return _this7;
  }

  _createClass(JoinedAbruptCompletions, [{
    key: "containsBreakOrContinue",
    value: function containsBreakOrContinue() {
      if (this.consequent instanceof BreakCompletion || this.consequent instanceof ContinueCompletion) return true;
      if (this.alternate instanceof BreakCompletion || this.alternate instanceof ContinueCompletion) return true;
      if (this.consequent instanceof JoinedAbruptCompletions) {
        if (this.consequent.containsBreakOrContinue()) return true;
      }
      if (this.alternate instanceof JoinedAbruptCompletions) {
        if (this.alternate.containsBreakOrContinue()) return true;
      }
      return false;
    }
  }]);

  return JoinedAbruptCompletions;
}(AbruptCompletion);

// Possibly normal completions have to be treated like normal completions
// and are thus never thrown. At the end of a try block or loop body, however,
// action must be taken to deal with the possibly abrupt case of the completion.


var PossiblyNormalCompletion = exports.PossiblyNormalCompletion = function (_NormalCompletion) {
  _inherits(PossiblyNormalCompletion, _NormalCompletion);

  function PossiblyNormalCompletion(value, joinCondition, consequent, consequentEffects, alternate, alternateEffects) {
    var savedEffects = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : undefined;

    _classCallCheck(this, PossiblyNormalCompletion);

    (0, _invariant2.default)(consequent instanceof NormalCompletion || consequent instanceof _index.Value || alternate instanceof NormalCompletion || alternate instanceof _index.Value);
    (0, _invariant2.default)(consequent instanceof AbruptCompletion || alternate instanceof AbruptCompletion);
    (0, _invariant2.default)(value === consequent || consequent instanceof AbruptCompletion || consequent instanceof NormalCompletion && value === consequent.value);
    (0, _invariant2.default)(value === alternate || alternate instanceof AbruptCompletion || alternate instanceof NormalCompletion && value === alternate.value);
    var loc = consequent instanceof AbruptCompletion ? consequent.location : alternate instanceof Completion ? alternate.location : alternate.expressionLocation;

    var _this8 = _possibleConstructorReturn(this, (PossiblyNormalCompletion.__proto__ || Object.getPrototypeOf(PossiblyNormalCompletion)).call(this, value, loc));

    _this8.joinCondition = joinCondition;
    _this8.consequent = consequent;
    _this8.consequentEffects = consequentEffects;
    _this8.alternate = alternate;
    _this8.alternateEffects = alternateEffects;
    _this8.savedEffects = savedEffects;
    return _this8;
  }

  _createClass(PossiblyNormalCompletion, [{
    key: "containsBreakOrContinue",
    value: function containsBreakOrContinue() {
      if (this.consequent instanceof BreakCompletion || this.consequent instanceof ContinueCompletion) return true;
      if (this.alternate instanceof BreakCompletion || this.alternate instanceof ContinueCompletion) return true;
      if (this.consequent instanceof JoinedAbruptCompletions || this.consequent instanceof PossiblyNormalCompletion) {
        if (this.consequent.containsBreakOrContinue()) return true;
      }
      if (this.alternate instanceof JoinedAbruptCompletions || this.alternate instanceof PossiblyNormalCompletion) {
        if (this.alternate.containsBreakOrContinue()) return true;
      }
      return false;
    }
  }]);

  return PossiblyNormalCompletion;
}(NormalCompletion);
//# sourceMappingURL=completions.js.map