{"version":3,"sources":["../../../src/debugger/channel/MessagePackager.js"],"names":["LENGTH_SEPARATOR","MessagePackager","isAdapter","_isAdapter","contents","length","separatorIndex","indexOf","messageLength","parseInt","slice","isNaN","startIndex","endIndex","message"],"mappings":";;;;;;;qjBAAA;;;;;;;;;AAWA;;;;;;;;AAEA,IAAMA,mBAAmB,IAAzB;;AAEA;;IACaC,e,WAAAA,e;AACX,2BAAYC,SAAZ,EAAgC;AAAA;;AAC9B,SAAKC,UAAL,GAAkBD,SAAlB;AACD;;;;;;AAGD;6BACQE,Q,EAA0B;AAChC;AACA,aAAOA,SAASC,MAAT,GAAkBL,gBAAlB,GAAqCI,QAA5C;AACD;;AAED;AACA;AACA;;;;8BACUA,Q,EAAiC;AACzC;AACA,UAAIE,iBAAiBF,SAASG,OAAT,CAAiBP,gBAAjB,CAArB;AACA;AACA,UAAIM,mBAAmB,CAAC,CAAxB,EAA2B;AACzB,eAAO,IAAP;AACD;AACD,UAAIE,gBAAgBC,SAASL,SAASM,KAAT,CAAe,CAAf,EAAkBJ,cAAlB,CAAT,EAA4C,EAA5C,CAApB;AACA;AACA;AACA,+BAAU,CAACK,MAAMH,aAAN,CAAX;AACA,UAAII,aAAaN,iBAAiBN,iBAAiBK,MAAnD;AACA,UAAIQ,WAAWD,aAAaJ,aAA5B;AACA;AACA,+BAAUJ,SAASC,MAAT,IAAmBO,aAAaJ,aAA1C;AACA;AACA,UAAIJ,SAASC,MAAT,GAAkBQ,QAAtB,EAAgC;AAC9B,eAAO,IAAP;AACD;AACD,UAAIC,UAAUV,SAASM,KAAT,CAAeE,UAAf,EAA2BC,QAA3B,CAAd;AACA,aAAOC,OAAP;AACD","file":"MessagePackager.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport invariant from \"../../invariant.js\";\n\nconst LENGTH_SEPARATOR = \"--\";\n\n// Package a message sent or unpackage a message received\nexport class MessagePackager {\n  constructor(isAdapter: boolean) {\n    this._isAdapter = isAdapter;\n  }\n  _isAdapter: boolean;\n\n  // package a message to be sent\n  package(contents: string): string {\n    // format: <length>--<contents>\n    return contents.length + LENGTH_SEPARATOR + contents;\n  }\n\n  // unpackage a message received, verify it, and return it\n  // returns null if no message or the message is only partially read\n  // errors if the message violates the format\n  unpackage(contents: string): null | string {\n    // format: <length>--<contents>\n    let separatorIndex = contents.indexOf(LENGTH_SEPARATOR);\n    // if the separator is not written in yet --> partial read\n    if (separatorIndex === -1) {\n      return null;\n    }\n    let messageLength = parseInt(contents.slice(0, separatorIndex), 10);\n    // if the part before the separator is not a valid length, it is a\n    // violation of protocol\n    invariant(!isNaN(messageLength));\n    let startIndex = separatorIndex + LENGTH_SEPARATOR.length;\n    let endIndex = startIndex + messageLength;\n    // there should only be one message in the contents at a time\n    invariant(contents.length <= startIndex + messageLength);\n    // if we didn't read the whole message yet --> partial read\n    if (contents.length < endIndex) {\n      return null;\n    }\n    let message = contents.slice(startIndex, endIndex);\n    return message;\n  }\n}\n"]}