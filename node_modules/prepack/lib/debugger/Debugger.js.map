{"version":3,"sources":["../../src/debugger/Debugger.js"],"names":["DebugServer","channel","realm","_breakpoints","_previousExecutedLine","_previousExecutedCol","_lastRunRequestID","_channel","_realm","_variableManager","waitForRun","ast","keepRunning","request","readIn","processDebuggerCommand","checkForBreakpoint","loc","source","_previousExecutedFile","start","line","column","filePath","lineNum","colNum","breakpoint","getBreakpoint","enabled","location","findStoppableBreakpoint","sendBreakpointStopped","requestID","id","command","args","arguments","BREAKPOINT_ADD_COMMAND","kind","addBreakpointMulti","breakpoints","sendBreakpointsAcknowledge","BREAKPOINT_ADD_ACKNOWLEDGE","BREAKPOINT_REMOVE_COMMAND","removeBreakpointMulti","BREAKPOINT_REMOVE_ACKNOWLEDGE","BREAKPOINT_ENABLE_COMMAND","enableBreakpointMulti","BREAKPOINT_ENABLE_ACKNOWLEDGE","BREAKPOINT_DISABLE_COMMAND","disableBreakpointMulti","BREAKPOINT_DISABLE_ACKNOWLEDGE","PREPACK_RUN_COMMAND","_onDebuggeeResume","STACKFRAMES_COMMAND","processStackframesCommand","SCOPES_COMMAND","processScopesCommand","VARIABLES_COMMAND","processVariablesCommand","frameInfos","_getFrameLocation","fileName","i","contextStack","length","frame","functionName","function","__originalName","frameInfo","push","sendStackframeResponse","frameId","stackIndex","context","scopes","lexicalEnv","lexicalEnvironment","scope","name","_getScopeName","environmentRecord","variablesReference","getReferenceForValue","expensive","parent","sendScopesResponse","envRec","$FunctionObject","variables","getVariablesByReference","sendVariablesResponse","clean","sendPrepackFinish"],"mappings":"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","file":"Debugger.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { BreakpointManager } from \"./BreakpointManager.js\";\nimport type { BabelNode, BabelNodeSourceLocation } from \"babel-types\";\nimport { Breakpoint } from \"./Breakpoint.js\";\nimport invariant from \"../invariant.js\";\nimport type { DebugChannel } from \"./channel/DebugChannel.js\";\nimport { DebugMessage } from \"./channel/DebugMessage.js\";\nimport { DebuggerError } from \"./DebuggerError.js\";\nimport type {\n  DebuggerRequest,\n  StackframeArguments,\n  ScopesArguments,\n  Stackframe,\n  Scope,\n  VariablesArguments,\n} from \"./types.js\";\nimport type { Realm } from \"./../realm.js\";\nimport { ExecutionContext } from \"./../realm.js\";\nimport { VariableManager } from \"./VariableManager.js\";\nimport {\n  EnvironmentRecord,\n  GlobalEnvironmentRecord,\n  FunctionEnvironmentRecord,\n  DeclarativeEnvironmentRecord,\n  ObjectEnvironmentRecord,\n} from \"./../environment.js\";\n\nexport class DebugServer {\n  constructor(channel: DebugChannel, realm: Realm) {\n    this._breakpoints = new BreakpointManager();\n    this._previousExecutedLine = 0;\n    this._previousExecutedCol = 0;\n    this._lastRunRequestID = 0;\n    this._channel = channel;\n    this._realm = realm;\n    this._variableManager = new VariableManager(realm);\n    this.waitForRun();\n  }\n  // the collection of breakpoints\n  _breakpoints: BreakpointManager;\n  _previousExecutedFile: void | string;\n  _previousExecutedLine: number;\n  _previousExecutedCol: number;\n  // the channel to communicate with the adapter\n  _channel: DebugChannel;\n  _lastRunRequestID: number;\n  _realm: Realm;\n  _variableManager: VariableManager;\n  /* Block until adapter says to run\n  /* ast: the current ast node we are stopped on\n  */\n  waitForRun(ast: void | BabelNode) {\n    let keepRunning = false;\n    let request;\n    while (!keepRunning) {\n      request = this._channel.readIn();\n      keepRunning = this.processDebuggerCommand(request, ast);\n    }\n  }\n\n  // Checking if the debugger needs to take any action on reaching this ast node\n  checkForActions(ast: BabelNode) {\n    this.checkForBreakpoint(ast);\n\n    // last step: set the current location as the previously executed line\n    if (ast.loc && ast.loc.source !== null) {\n      this._previousExecutedFile = ast.loc.source;\n      this._previousExecutedLine = ast.loc.start.line;\n      this._previousExecutedCol = ast.loc.start.column;\n    }\n  }\n\n  // Try to find a breakpoint at the given location and check if we should stop on it\n  findStoppableBreakpoint(filePath: string, lineNum: number, colNum: number): null | Breakpoint {\n    let breakpoint = this._breakpoints.getBreakpoint(filePath, lineNum, colNum);\n    if (breakpoint && breakpoint.enabled) {\n      // checking if this is the same file and line we stopped at last time\n      // if so, we should skip it this time\n      // Note: for the case when the debugger is supposed to stop on the same\n      // breakpoint consecutively (e.g. the statement is in a loop), some other\n      // ast node (e.g. block, loop) must have been checked in between so\n      // previousExecutedFile and previousExecutedLine will have changed\n      if (breakpoint.column !== 0) {\n        // this is a column breakpoint\n        if (\n          filePath === this._previousExecutedFile &&\n          lineNum === this._previousExecutedLine &&\n          colNum === this._previousExecutedCol\n        ) {\n          return null;\n        }\n      } else {\n        // this is a line breakpoint\n        if (filePath === this._previousExecutedFile && lineNum === this._previousExecutedLine) {\n          return null;\n        }\n      }\n      return breakpoint;\n    }\n    return null;\n  }\n\n  checkForBreakpoint(ast: BabelNode) {\n    if (ast.loc && ast.loc.source) {\n      let location = ast.loc;\n      let filePath = location.source;\n      if (filePath === null) return;\n      let lineNum = location.start.line;\n      let colNum = location.start.column;\n      // Check whether there is a breakpoint we need to stop on here\n      let breakpoint = this.findStoppableBreakpoint(filePath, lineNum, colNum);\n      if (breakpoint === null) return;\n      // Tell the adapter that Prepack has stopped on this breakpoint\n      this._channel.sendBreakpointStopped(breakpoint.filePath, breakpoint.line, breakpoint.column);\n      // Wait for the adapter to tell us to run again\n      this.waitForRun(ast);\n    }\n  }\n\n  // Process a command from a debugger. Returns whether Prepack should unblock\n  // if it is blocked\n  processDebuggerCommand(request: DebuggerRequest, ast: void | BabelNode) {\n    let requestID = request.id;\n    let command = request.command;\n    let args = request.arguments;\n    switch (command) {\n      case DebugMessage.BREAKPOINT_ADD_COMMAND:\n        invariant(args.kind === \"breakpoint\");\n        this._breakpoints.addBreakpointMulti(args.breakpoints);\n        this._channel.sendBreakpointsAcknowledge(DebugMessage.BREAKPOINT_ADD_ACKNOWLEDGE, requestID, args);\n        break;\n      case DebugMessage.BREAKPOINT_REMOVE_COMMAND:\n        invariant(args.kind === \"breakpoint\");\n        this._breakpoints.removeBreakpointMulti(args.breakpoints);\n        this._channel.sendBreakpointsAcknowledge(DebugMessage.BREAKPOINT_REMOVE_ACKNOWLEDGE, requestID, args);\n        break;\n      case DebugMessage.BREAKPOINT_ENABLE_COMMAND:\n        invariant(args.kind === \"breakpoint\");\n        this._breakpoints.enableBreakpointMulti(args.breakpoints);\n        this._channel.sendBreakpointsAcknowledge(DebugMessage.BREAKPOINT_ENABLE_ACKNOWLEDGE, requestID, args);\n        break;\n      case DebugMessage.BREAKPOINT_DISABLE_COMMAND:\n        invariant(args.kind === \"breakpoint\");\n        this._breakpoints.disableBreakpointMulti(args.breakpoints);\n        this._channel.sendBreakpointsAcknowledge(DebugMessage.BREAKPOINT_DISABLE_ACKNOWLEDGE, requestID, args);\n        break;\n      case DebugMessage.PREPACK_RUN_COMMAND:\n        invariant(args.kind === \"run\");\n        this._onDebuggeeResume();\n        return true;\n      case DebugMessage.STACKFRAMES_COMMAND:\n        invariant(args.kind === \"stackframe\");\n        this.processStackframesCommand(requestID, args, ast);\n        break;\n      case DebugMessage.SCOPES_COMMAND:\n        invariant(args.kind === \"scopes\");\n        this.processScopesCommand(requestID, args);\n        break;\n      case DebugMessage.VARIABLES_COMMAND:\n        invariant(args.kind === \"variables\");\n        this.processVariablesCommand(requestID, args);\n        break;\n      default:\n        throw new DebuggerError(\"Invalid command\", \"Invalid command from adapter: \" + command);\n    }\n    return false;\n  }\n\n  processStackframesCommand(requestID: number, args: StackframeArguments, ast: void | BabelNode) {\n    let frameInfos: Array<Stackframe> = [];\n    let loc = this._getFrameLocation(ast ? ast.loc : null);\n    let fileName = loc.fileName;\n    let line = loc.line;\n    let column = loc.column;\n\n    // the UI displays the current frame as index 0, so we iterate backwards\n    // from the current frame\n    for (let i = this._realm.contextStack.length - 1; i >= 0; i--) {\n      let frame = this._realm.contextStack[i];\n      let functionName = \"(anonymous function)\";\n      if (frame.function && frame.function.__originalName) {\n        functionName = frame.function.__originalName;\n      }\n\n      let frameInfo: Stackframe = {\n        id: this._realm.contextStack.length - 1 - i,\n        functionName: functionName,\n        fileName: fileName,\n        line: line,\n        column: column,\n      };\n      frameInfos.push(frameInfo);\n      loc = this._getFrameLocation(frame.loc);\n      fileName = loc.fileName;\n      line = loc.line;\n      column = loc.column;\n    }\n    this._channel.sendStackframeResponse(requestID, frameInfos);\n  }\n\n  _getFrameLocation(loc: void | null | BabelNodeSourceLocation): { fileName: string, line: number, column: number } {\n    let fileName = \"unknown\";\n    let line = 0;\n    let column = 0;\n    if (loc && loc.source) {\n      fileName = loc.source;\n      line = loc.start.line;\n      column = loc.start.column;\n    }\n    return {\n      fileName: fileName,\n      line: line,\n      column: column,\n    };\n  }\n\n  processScopesCommand(requestID: number, args: ScopesArguments) {\n    // first check that frameId is in the valid range\n    if (args.frameId < 0 || args.frameId >= this._realm.contextStack.length) {\n      throw new DebuggerError(\"Invalid command\", \"Invalid frame id for scopes request: \" + args.frameId);\n    }\n    // here the frameId is in reverse order of the contextStack, ie frameId 0\n    // refers to last element of contextStack\n    let stackIndex = this._realm.contextStack.length - 1 - args.frameId;\n    let context = this._realm.contextStack[stackIndex];\n    invariant(context instanceof ExecutionContext);\n    let scopes = [];\n    let lexicalEnv = context.lexicalEnvironment;\n    while (lexicalEnv) {\n      let scope: Scope = {\n        name: this._getScopeName(lexicalEnv.environmentRecord),\n        // key used by UI to retrieve variables in this scope\n        variablesReference: this._variableManager.getReferenceForValue(lexicalEnv),\n        // the variables are easy to retrieve\n        expensive: false,\n      };\n      scopes.push(scope);\n      lexicalEnv = lexicalEnv.parent;\n    }\n    this._channel.sendScopesResponse(requestID, scopes);\n  }\n\n  _getScopeName(envRec: EnvironmentRecord): string {\n    if (envRec instanceof GlobalEnvironmentRecord) {\n      return \"Global\";\n    } else if (envRec instanceof DeclarativeEnvironmentRecord) {\n      if (envRec instanceof FunctionEnvironmentRecord) {\n        return \"Local: \" + (envRec.$FunctionObject.__originalName || \"anonymous function\");\n      } else {\n        return \"Block\";\n      }\n    } else if (envRec instanceof ObjectEnvironmentRecord) {\n      return \"With\";\n    } else {\n      invariant(false, \"Invalid type of environment record\");\n    }\n  }\n\n  processVariablesCommand(requestID: number, args: VariablesArguments) {\n    let variables = this._variableManager.getVariablesByReference(args.variablesReference);\n    this._channel.sendVariablesResponse(requestID, variables);\n  }\n\n  // actions that need to happen before Prepack can resume\n  _onDebuggeeResume() {\n    // resets the variable manager\n    this._variableManager.clean();\n  }\n\n  shutdown() {\n    //let the adapter know Prepack is done running\n    this._channel.sendPrepackFinish();\n  }\n}\n"]}