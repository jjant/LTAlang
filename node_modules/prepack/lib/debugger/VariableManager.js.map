{"version":3,"sources":["../../src/debugger/VariableManager.js"],"names":["VariableManager","realm","_containerCache","Map","_referenceMap","_realm","value","cachedRef","get","undefined","varRef","add","set","reference","container","_getVariablesFromEnv","_getVariablesFromObject","object","variables","names","properties","keys","name","binding","descriptor","variable","_getVariableFromValue","push","env","envRecord","environmentRecord","_getVariablesFromDeclarativeEnv","bindings","_getVariableFromConcreteValue","toDisplayString","variablesReference","getReferenceForValue","clean"],"mappings":"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","file":"VariableManager.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { VariableContainer, Variable } from \"./types.js\";\nimport { ReferenceMap } from \"./ReferenceMap.js\";\nimport { LexicalEnvironment, DeclarativeEnvironmentRecord } from \"./../environment.js\";\nimport { Value, ConcreteValue, PrimitiveValue, ObjectValue } from \"./../values/index.js\";\nimport invariant from \"./../invariant.js\";\nimport type { Realm } from \"./../realm.js\";\nimport { IsDataDescriptor } from \"./../methods/is.js\";\n\n// This class manages the handling of variable requests in the debugger\n// The DebugProtocol specifies collections of variables are to be fetched using a\n// unique reference ID called a variablesReference. This class can generate new\n// variablesReferences to pass to the UI and then perform lookups for those\n// variablesReferences when they are requested.\nexport class VariableManager {\n  constructor(realm: Realm) {\n    this._containerCache = new Map();\n    this._referenceMap = new ReferenceMap();\n    this._realm = realm;\n  }\n  // cache for created references\n  _containerCache: Map<VariableContainer, number>;\n  // map for looking up references\n  _referenceMap: ReferenceMap<VariableContainer>;\n  _realm: Realm;\n\n  // Given a container, either returns a cached reference for that container if\n  // it exists or return a new reference\n  getReferenceForValue(value: VariableContainer): number {\n    let cachedRef = this._containerCache.get(value);\n    if (cachedRef !== undefined) {\n      return cachedRef;\n    }\n\n    let varRef = this._referenceMap.add(value);\n    this._containerCache.set(value, varRef);\n    return varRef;\n  }\n\n  // The entry point for retrieving a collection of variables by a reference\n  getVariablesByReference(reference: number): Array<Variable> {\n    let container = this._referenceMap.get(reference);\n    if (!container) return [];\n    if (container instanceof LexicalEnvironment) {\n      return this._getVariablesFromEnv(container);\n    } else if (container instanceof ObjectValue) {\n      return this._getVariablesFromObject(container);\n    } else {\n      invariant(false, \"Invalid variable container\");\n    }\n  }\n\n  _getVariablesFromObject(object: ObjectValue): Array<Variable> {\n    let variables = [];\n    let names = object.properties.keys();\n    for (let name of names) {\n      let binding = object.properties.get(name);\n      invariant(binding !== undefined);\n      if (binding.descriptor) {\n        if (IsDataDescriptor(this._realm, binding.descriptor)) {\n          let value = binding.descriptor.value;\n          if (value instanceof Value) {\n            let variable = this._getVariableFromValue(name, value);\n            variables.push(variable);\n          }\n        }\n      }\n    }\n    return variables;\n  }\n\n  _getVariablesFromEnv(env: LexicalEnvironment): Array<Variable> {\n    let envRecord = env.environmentRecord;\n    if (envRecord instanceof DeclarativeEnvironmentRecord) {\n      return this._getVariablesFromDeclarativeEnv(envRecord);\n    }\n    // TODO: implement retrieving variables for other kinds of environment records\n    return [];\n  }\n\n  _getVariablesFromDeclarativeEnv(env: DeclarativeEnvironmentRecord): Array<Variable> {\n    let variables = [];\n    let bindings = env.bindings;\n    for (let name in bindings) {\n      let binding = bindings[name];\n      if (binding.value) {\n        let variable = this._getVariableFromValue(name, binding.value);\n        variables.push(variable);\n      }\n    }\n    return variables;\n  }\n\n  _getVariableFromValue(name: string, value: Value): Variable {\n    if (value instanceof ConcreteValue) {\n      return this._getVariableFromConcreteValue(name, value);\n    } else {\n      invariant(false, \"Unsupported type of: \" + name);\n    }\n    // TODO: implement variables request for abstract values\n  }\n\n  _getVariableFromConcreteValue(name: string, value: ConcreteValue): Variable {\n    if (value instanceof PrimitiveValue) {\n      let variable: Variable = {\n        name: name,\n        value: value.toDisplayString(),\n        variablesReference: 0,\n      };\n      return variable;\n    } else if (value instanceof ObjectValue) {\n      let variable: Variable = {\n        name: name,\n        value: \"Object\",\n        variablesReference: this.getReferenceForValue(value),\n      };\n      return variable;\n    } else {\n      invariant(false, \"Concrete value must be primitive or object\");\n    }\n  }\n\n  clean() {\n    this._containerCache = new Map();\n    this._referenceMap.clean();\n  }\n}\n"]}