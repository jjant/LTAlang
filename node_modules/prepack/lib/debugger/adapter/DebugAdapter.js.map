{"version":3,"sources":["../../../src/debugger/adapter/DebugAdapter.js"],"names":["DebugProtocol","PrepackDebugSession","setDebuggerLinesStartAt1","setDebuggerColumnsStartAt1","_adapterChannel","registerChannelEvent","PREPACK_READY_RESPONSE","response","sendEvent","PREPACK_THREAD_ID","BREAKPOINT_STOPPED_RESPONSE","result","kind","filePath","line","column","args","_clientID","clientID","body","supportsConfigurationDoneRequest","sendResponse","CLI_CLIENTID","run","DEFAULT_REQUEST_ID","runResponse","debugInFilePath","debugOutFilePath","_registerMessageCallbacks","launchArgs","outputCallback","data","outputEvent","toString","exitCallback","process","exit","launch","request_seq","dbgResponse","source","path","breakpoints","breakpointInfos","breakpoint","breakpointInfo","requestID","push","setBreakpoints","verified","getStackFrames","frameInfos","stackframes","frames","frameInfo","fileName","frame","id","name","functionName","stackFrames","thread","threads","getScopes","frameId","scopeInfos","scopes","scopeInfo","scope","variablesReference","expensive","getVariables","variableInfos","variables","varInfo","variable","value"],"mappings":"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","file":"DebugAdapter.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport {\n  DebugSession,\n  LoggingDebugSession,\n  InitializedEvent,\n  OutputEvent,\n  TerminatedEvent,\n  StoppedEvent,\n} from \"vscode-debugadapter\";\nimport * as DebugProtocol from \"vscode-debugprotocol\";\nimport { AdapterChannel } from \"./../channel/AdapterChannel.js\";\nimport invariant from \"./../../invariant.js\";\nimport { DebugMessage } from \"./../channel/DebugMessage.js\";\nimport type { Breakpoint, DebuggerResponse, LaunchRequestArguments, PrepackLaunchArguments } from \"./../types.js\";\nimport { DebuggerConstants } from \"./../DebuggerConstants.js\";\n\n/* An implementation of an debugger adapter adhering to the VSCode Debug protocol\n * The adapter is responsible for communication between the UI and Prepack\n*/\nclass PrepackDebugSession extends LoggingDebugSession {\n  /**\n   * Creates a new debug adapter that is used for one debug session.\n   * We configure the default implementation of a debug adapter here.\n   */\n  constructor() {\n    super(\"prepack\");\n    this.setDebuggerLinesStartAt1(true);\n    this.setDebuggerColumnsStartAt1(true);\n  }\n  _clientID: void | string;\n  _adapterChannel: AdapterChannel;\n\n  _registerMessageCallbacks() {\n    this._adapterChannel.registerChannelEvent(DebugMessage.PREPACK_READY_RESPONSE, (response: DebuggerResponse) => {\n      this.sendEvent(new StoppedEvent(\"entry\", DebuggerConstants.PREPACK_THREAD_ID));\n    });\n    this._adapterChannel.registerChannelEvent(\n      DebugMessage.BREAKPOINT_STOPPED_RESPONSE,\n      (response: DebuggerResponse) => {\n        let result = response.result;\n        invariant(result.kind === \"breakpoint-stopped\");\n        this.sendEvent(\n          new StoppedEvent(\n            \"breakpoint \" + `${result.filePath} ${result.line}:${result.column}`,\n            DebuggerConstants.PREPACK_THREAD_ID\n          )\n        );\n      }\n    );\n  }\n\n  /**\n   * The 'initialize' request is the first request called by the UI\n   * to interrogate the features the debug adapter provides.\n   */\n  initializeRequest(response: DebugProtocol.InitializeResponse, args: DebugProtocol.InitializeRequestArguments): void {\n    // Let the UI know that we can start accepting breakpoint requests.\n    // The UI will end the configuration sequence by calling 'configurationDone' request.\n    this.sendEvent(new InitializedEvent());\n\n    this._clientID = args.clientID;\n    response.body = response.body || {};\n    response.body.supportsConfigurationDoneRequest = true;\n    // Respond back to the UI with the configurations. Will add more configurations gradually as needed.\n    // Adapter can respond immediately here because no message is sent to Prepack\n    this.sendResponse(response);\n  }\n\n  configurationDoneRequest(\n    response: DebugProtocol.ConfigurationDoneResponse,\n    args: DebugProtocol.ConfigurationDoneArguments\n  ): void {\n    // initial handshake with UI is complete\n    if (this._clientID !== DebuggerConstants.CLI_CLIENTID) {\n      // for all ui except the CLI, autosend the first run request\n      this._adapterChannel.run(DebuggerConstants.DEFAULT_REQUEST_ID, (runResponse: DebuggerResponse) => {});\n    }\n    this.sendResponse(response);\n  }\n\n  launchRequest(response: DebugProtocol.LaunchResponse, args: LaunchRequestArguments): void {\n    // set up the communication channel\n    this._adapterChannel = new AdapterChannel(args.debugInFilePath, args.debugOutFilePath);\n    this._registerMessageCallbacks();\n    let launchArgs: PrepackLaunchArguments = {\n      kind: \"launch\",\n      ...args,\n      outputCallback: (data: Buffer) => {\n        let outputEvent = new OutputEvent(data.toString(), \"stdout\");\n        this.sendEvent(outputEvent);\n      },\n      exitCallback: () => {\n        this.sendEvent(new TerminatedEvent());\n        process.exit();\n      },\n    };\n    this._adapterChannel.launch(response.request_seq, launchArgs, (dbgResponse: DebuggerResponse) => {\n      this.sendResponse(response);\n    });\n  }\n\n  /**\n   * Request Prepack to continue running when it is stopped\n  */\n  continueRequest(response: DebugProtocol.ContinueResponse, args: DebugProtocol.ContinueArguments): void {\n    // send a Run request to Prepack and try to send the next request\n    this._adapterChannel.run(response.request_seq, (dbgResponse: DebuggerResponse) => {\n      this.sendResponse(response);\n    });\n  }\n\n  setBreakPointsRequest(\n    response: DebugProtocol.SetBreakpointsResponse,\n    args: DebugProtocol.SetBreakpointsArguments\n  ): void {\n    if (!args.source.path || !args.breakpoints) return;\n    let filePath = args.source.path;\n    let breakpointInfos = [];\n    for (const breakpoint of args.breakpoints) {\n      let line = breakpoint.line;\n      let column = 0;\n      if (breakpoint.column) {\n        column = breakpoint.column;\n      }\n      let breakpointInfo: Breakpoint = {\n        kind: \"breakpoint\",\n        requestID: response.request_seq,\n        filePath: filePath,\n        line: line,\n        column: column,\n      };\n      breakpointInfos.push(breakpointInfo);\n    }\n    this._adapterChannel.setBreakpoints(response.request_seq, breakpointInfos, (dbgResponse: DebuggerResponse) => {\n      let result = dbgResponse.result;\n      invariant(result.kind === \"breakpoint-add\");\n      let breakpoints: Array<DebugProtocol.Breakpoint> = [];\n      for (const breakpointInfo of result.breakpoints) {\n        let source: DebugProtocol.Source = {\n          path: breakpointInfo.filePath,\n        };\n        let breakpoint: DebugProtocol.Breakpoint = {\n          verified: true,\n          source: source,\n          line: breakpointInfo.line,\n          column: breakpointInfo.column,\n        };\n        breakpoints.push(breakpoint);\n      }\n      response.body = {\n        breakpoints: breakpoints,\n      };\n      this.sendResponse(response);\n    });\n  }\n\n  stackTraceRequest(response: DebugProtocol.StackTraceResponse, args: DebugProtocol.StackTraceArguments): void {\n    this._adapterChannel.getStackFrames(response.request_seq, (dbgResponse: DebuggerResponse) => {\n      let result = dbgResponse.result;\n      invariant(result.kind === \"stackframe\");\n      let frameInfos = result.stackframes;\n      let frames: Array<DebugProtocol.StackFrame> = [];\n      for (const frameInfo of frameInfos) {\n        let source: DebugProtocol.Source = {\n          path: frameInfo.fileName,\n        };\n        let frame: DebugProtocol.StackFrame = {\n          id: frameInfo.id,\n          name: frameInfo.functionName,\n          source: source,\n          line: frameInfo.line,\n          column: frameInfo.column,\n        };\n        frames.push(frame);\n      }\n      response.body = {\n        stackFrames: frames,\n      };\n      this.sendResponse(response);\n    });\n  }\n\n  threadsRequest(response: DebugProtocol.ThreadsResponse): void {\n    // There will only be 1 thread, so respond immediately\n    let thread: DebugProtocol.Thread = {\n      id: DebuggerConstants.PREPACK_THREAD_ID,\n      name: \"main\",\n    };\n    response.body = {\n      threads: [thread],\n    };\n    this.sendResponse(response);\n  }\n\n  scopesRequest(response: DebugProtocol.ScopesResponse, args: DebugProtocol.ScopesArguments): void {\n    this._adapterChannel.getScopes(response.request_seq, args.frameId, (dbgResponse: DebuggerResponse) => {\n      let result = dbgResponse.result;\n      invariant(result.kind === \"scopes\");\n      let scopeInfos = result.scopes;\n      let scopes: Array<DebugProtocol.Scope> = [];\n      for (const scopeInfo of scopeInfos) {\n        let scope: DebugProtocol.Scope = {\n          name: scopeInfo.name,\n          variablesReference: scopeInfo.variablesReference,\n          expensive: scopeInfo.expensive,\n        };\n        scopes.push(scope);\n      }\n      response.body = {\n        scopes: scopes,\n      };\n      this.sendResponse(response);\n    });\n  }\n\n  variablesRequest(response: DebugProtocol.VariablesResponse, args: DebugProtocol.VariablesArguments): void {\n    this._adapterChannel.getVariables(\n      response.request_seq,\n      args.variablesReference,\n      (dbgResponse: DebuggerResponse) => {\n        let result = dbgResponse.result;\n        invariant(result.kind === \"variables\");\n        let variableInfos = result.variables;\n        let variables: Array<DebugProtocol.Variable> = [];\n        for (const varInfo of variableInfos) {\n          let variable: DebugProtocol.Variable = {\n            name: varInfo.name,\n            value: varInfo.value,\n            variablesReference: varInfo.variablesReference,\n          };\n          variables.push(variable);\n        }\n        response.body = {\n          variables: variables,\n        };\n        this.sendResponse(response);\n      }\n    );\n  }\n}\n\nDebugSession.run(PrepackDebugSession);\n"]}