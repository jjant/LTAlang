"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

//separator for messages according to the protocol
var TWO_CRLF = "\r\n\r\n";

var DataHandler = exports.DataHandler = function () {
  function DataHandler() {
    _classCallCheck(this, DataHandler);

    this._rawData = new Buffer(0);
    this._contentLength = -1;
  }

  _createClass(DataHandler, [{
    key: "handleData",
    value: function handleData(data, messageProcessor) {
      this._rawData = Buffer.concat([this._rawData, data]);
      // the following code parses a message according to the protocol.
      while (this._rawData.length > 0) {
        // if we know what length we are expecting
        if (this._contentLength >= 0) {
          // we have enough data to check for the expected message
          if (this._rawData.byteLength >= this._contentLength) {
            // first get the expected message
            var _message = this._rawData.toString("utf8", 0, this._contentLength);
            // reduce the buffer by the message we got
            this._rawData = this._rawData.slice(this._contentLength);
            // reset the content length to ensure it is extracted for the next message
            this._contentLength = -1;
            // process the message
            messageProcessor(_message);
            continue; // there may be more complete messages to process
          }
        } else {
          // if we don't know the length to expect, we need to extract it first
          var idx = this._rawData.indexOf(TWO_CRLF);
          if (idx !== -1) {
            var header = this._rawData.toString("utf8", 0, idx);
            var lines = header.split("\r\n");
            for (var i = 0; i < lines.length; i++) {
              var pair = lines[i].split(/: +/);
              if (pair[0] === "Content-Length") {
                this._contentLength = parseInt(pair[1], 10);
                // reset the contentlength if it is invalid
                if (isNaN(this._contentLength)) this._contentLength = -1;
              }
            }
            this._rawData = this._rawData.slice(idx + TWO_CRLF.length);
            continue;
          }
          // if we don't find the length we fall through and break
        }
        break;
      }
    }
  }]);

  return DataHandler;
}();
//# sourceMappingURL=DataHandler.js.map