"use strict";

var _errors = require("../lib/errors.js");

var _prepackNode = require("../lib/prepack-node.js");

var _invariant = require("../lib/invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var chalk = require("chalk"); /**
                               * Copyright (c) 2017-present, Facebook, Inc.
                               * All rights reserved.
                               *
                               * This source code is licensed under the BSD-style license found in the
                               * LICENSE file in the root directory of this source tree. An additional grant
                               * of patent rights can be found in the PATENTS file in the same directory.
                               */

var path = require("path");
var fs = require("fs");

function search(dir, relative) {
  var tests = [];

  if (fs.existsSync(dir)) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = fs.readdirSync(dir)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var name = _step.value;

        var loc = path.join(dir, name);
        var stat = fs.statSync(loc);

        if (stat.isFile()) {
          tests.push({
            file: fs.readFileSync(loc, "utf8"),
            name: path.join(relative, name)
          });
        } else if (stat.isDirectory()) {
          tests = tests.concat(search(loc, path.join(relative, name)));
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  return tests;
}

var tests = search(__dirname + "/../test/error-handler", "test/error-handler");

function errorHandler(retval, errors, error) {
  errors.push(error);
  return retval;
}

function runTest(name, code) {
  console.log(chalk.inverse(name));

  var recover = code.includes("// recover-from-errors");
  var additionalFunctions = code.includes("// additional functions");
  var delayUnsupportedRequires = code.includes("// delay unsupported requires");

  var expectedErrors = code.match(/\/\/\s*expected errors:\s*(.*)/);
  (0, _invariant2.default)(expectedErrors);
  (0, _invariant2.default)(expectedErrors.length > 1);
  expectedErrors = expectedErrors[1];
  expectedErrors = eval(expectedErrors); // eslint-disable-line no-eval
  (0, _invariant2.default)(expectedErrors.constructor === Array);

  var errors = [];
  try {
    var options = {
      internalDebug: false,
      delayUnsupportedRequires: delayUnsupportedRequires,
      mathRandomSeed: "0",
      errorHandler: errorHandler.bind(null, recover ? "Recover" : "Fail", errors),
      serialize: true,
      initializeMoreModules: false
    };
    if (additionalFunctions) options.additionalFunctions = ["global.additional1", "global['additional2']"];
    (0, _prepackNode.prepackFileSync)([name], options);
    if (!recover) {
      console.log(chalk.red("Serialization succeeded though it should have failed"));
      return false;
    }
  } catch (e) {
    if (!(e instanceof _errors.FatalError)) {
      console.log(chalk.red("Unexpected error: " + e.message));
    }
  }
  if (errors.length !== expectedErrors.length) {
    console.log(chalk.red("Expected " + expectedErrors.length + " errors, but found " + errors.length));
    return false;
  }

  for (var i = 0; i < expectedErrors.length; ++i) {
    for (var prop in expectedErrors[i]) {
      var expected = expectedErrors[i][prop];
      var actual = errors[i][prop];
      if (prop === "location") {
        if (actual) delete actual.filename;
        actual = JSON.stringify(actual);
        expected = JSON.stringify(expected);
      }
      if (expected !== actual) {
        console.log(chalk.red("Error " + (i + 1) + ": Expected " + expected + " errors, but found " + actual));
        return false;
      }
    }
  }

  return true;
}

function run() {
  var failed = 0;
  var passed = 0;
  var total = 0;

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = tests[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var test = _step2.value;

      // filter hidden files
      if (path.basename(test.name)[0] === ".") continue;
      if (test.name.endsWith("~")) continue;

      total++;
      if (runTest(test.name, test.file)) passed++;else failed++;
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  console.log("Passed:", passed + "/" + total, (Math.round(passed / total * 100) || 0) + "%");
  return failed === 0;
}

if (!run()) process.exit(1);
//# sourceMappingURL=test-error-handler.js.map