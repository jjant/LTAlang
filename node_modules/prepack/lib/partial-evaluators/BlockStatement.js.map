{"version":3,"sources":["../../src/partial-evaluators/BlockStatement.js"],"names":["ast","strictCode","env","realm","oldEnv","getRunningContext","lexicalEnvironment","blockEnv","NewDeclarativeEnvironment","BlockDeclarationInstantiation","body","blockValue","directives","directive","value","PartiallyEvaluateStatements","res","bAst","length","t","emptyStatement","rAst","blockStatement"],"mappings":";;;;;;ypBAAA;;;;;;;;;AAsBA;;;kBACe,UACbA,GADa,EAEbC,UAFa,EAGbC,GAHa,EAIbC,KAJa,EAKwD;AACrE;AACA,MAAIC,SAASD,MAAME,iBAAN,GAA0BC,kBAAvC;;AAEA;AACA,MAAIC,WAAW,wBAAYC,yBAAZ,CAAsCL,KAAtC,EAA6CC,MAA7C,CAAf;;AAEA;AACA,0BAAYK,6BAAZ,CAA0CN,KAA1C,EAAiDF,UAAjD,EAA6DD,IAAIU,IAAjE,EAAuEH,QAAvE;;AAEA;AACAJ,QAAME,iBAAN,GAA0BC,kBAA1B,GAA+CC,QAA/C;;AAEA,MAAI;AACF;AACA,QAAII,mBAAJ;;AAEA,QAAIX,IAAIY,UAAR,EAAoB;AAAA;AAAA;AAAA;;AAAA;AAClB,6BAAsBZ,IAAIY,UAA1B,8HAAsC;AAAA,cAA7BC,SAA6B;;AACpCF,uBAAa,uBAAgBR,KAAhB,EAAuBU,UAAUC,KAAV,CAAgBA,KAAvC,CAAb;AACD;AAHiB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAInB;;AARC,gCAUgB,sBAAUC,2BAAV,CAAsCf,IAAIU,IAA1C,EAAgDC,UAAhD,EAA4DV,UAA5D,EAAwEM,QAAxE,EAAkFJ,KAAlF,CAVhB;AAAA;AAAA,QAUGa,GAVH;AAAA,QAUQC,IAVR;;AAWF,6BAAUA,KAAKC,MAAL,GAAc,CAAd,IAAmBF,gCAA7B;AACA,QAAIC,KAAKC,MAAL,KAAgB,CAApB,EAAuB,OAAO,CAACF,GAAD,EAAMG,EAAEC,cAAF,EAAN,EAA0B,EAA1B,CAAP;AACvB,QAAIC,OAAOF,EAAEG,cAAF,CAAiBL,IAAjB,EAAuBjB,IAAIY,UAA3B,CAAX;AACA,WAAO,CAACI,GAAD,EAAMK,IAAN,EAAY,EAAZ,CAAP;AACD,GAfD,SAeU;AACR;AACAlB,UAAME,iBAAN,GAA0BC,kBAA1B,GAA+CF,MAA/C;AACD;AACF,C;;AA7CD;;AACA;;AACA;;AAEA;;;;AACA;;IAAYe,C","file":"BlockStatement.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { BabelNodeBlockStatement, BabelNodeStatement } from \"babel-types\";\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\n\nimport { Completion, NormalCompletion } from \"../completions.js\";\nimport { EmptyValue, StringValue, Value } from \"../values/index.js\";\nimport { Environment, Functions } from \"../singletons.js\";\n\nimport invariant from \"../invariant.js\";\nimport * as t from \"babel-types\";\n\n// ECMA262 13.2.13\nexport default function(\n  ast: BabelNodeBlockStatement,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): [Completion | Value, BabelNodeStatement, Array<BabelNodeStatement>] {\n  // 1. Let oldEnv be the running execution context's LexicalEnvironment.\n  let oldEnv = realm.getRunningContext().lexicalEnvironment;\n\n  // 2. Let blockEnv be NewDeclarativeEnvironment(oldEnv).\n  let blockEnv = Environment.NewDeclarativeEnvironment(realm, oldEnv);\n\n  // 3. Perform BlockDeclarationInstantiation(StatementList, blockEnv).\n  Environment.BlockDeclarationInstantiation(realm, strictCode, ast.body, blockEnv);\n\n  // 4. Set the running execution context's LexicalEnvironment to blockEnv.\n  realm.getRunningContext().lexicalEnvironment = blockEnv;\n\n  try {\n    // 5. Let blockValue be the result of evaluating StatementList.\n    let blockValue: void | NormalCompletion | Value;\n\n    if (ast.directives) {\n      for (let directive of ast.directives) {\n        blockValue = new StringValue(realm, directive.value.value);\n      }\n    }\n\n    let [res, bAst] = Functions.PartiallyEvaluateStatements(ast.body, blockValue, strictCode, blockEnv, realm);\n    invariant(bAst.length > 0 || res instanceof EmptyValue);\n    if (bAst.length === 0) return [res, t.emptyStatement(), []];\n    let rAst = t.blockStatement(bAst, ast.directives);\n    return [res, rAst, []];\n  } finally {\n    // 6. Set the running execution context's LexicalEnvironment to oldEnv.\n    realm.getRunningContext().lexicalEnvironment = oldEnv;\n  }\n}\n"]}