{"version":3,"sources":["../../src/partial-evaluators/IfStatement.js"],"names":["ast","strictCode","env","realm","partiallyEvaluateCompletionDeref","test","exprValue","exprAst","exprIO","t","expressionStatement","completion","value","mightNotBeTrue","consequent","stmtCompletion","stmtAst","stmtIO","intrinsics","undefined","concat","mightNotBeFalse","alternate","emptyStatement","partiallyEvaluateNodeForEffects","consequentEffects","conAst","conIO","conCompl","gen1","bindings1","properties1","createdObj1","consequentAst","length","blockStatement","alternateEffects","altAst","altIO","altCompl","gen2","bindings2","properties2","createdObj2","alternateAst","joinedEffects","joinEffects","captureEffects","applyEffects","resultAst","ifStatement"],"mappings":"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","file":"IfStatement.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { BabelNodeIfStatement, BabelNodeStatement } from \"babel-types\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport type { Realm } from \"../realm.js\";\n\nimport { AbruptCompletion, Completion, PossiblyNormalCompletion } from \"../completions.js\";\nimport { Reference } from \"../environment.js\";\nimport { UpdateEmpty } from \"../methods/index.js\";\nimport { AbstractValue, Value } from \"../values/index.js\";\nimport { construct_empty_effects } from \"../realm.js\";\nimport { Join } from \"../singletons.js\";\n\nimport * as t from \"babel-types\";\nimport invariant from \"../invariant.js\";\n\nexport default function(\n  ast: BabelNodeIfStatement,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): [Completion | Value, BabelNodeStatement, Array<BabelNodeStatement>] {\n  let [exprValue, exprAst, exprIO] = env.partiallyEvaluateCompletionDeref(ast.test, strictCode);\n  if (exprValue instanceof AbruptCompletion) return [exprValue, t.expressionStatement((exprAst: any)), exprIO];\n  let completion;\n  if (exprValue instanceof PossiblyNormalCompletion) {\n    completion = exprValue;\n    exprValue = completion.value;\n  }\n  invariant(exprValue instanceof Value);\n\n  if (!exprValue.mightNotBeTrue()) {\n    // 3.a. Let stmtCompletion be the result of evaluating the first Statement\n    let [stmtCompletion, stmtAst, stmtIO] = env.partiallyEvaluateCompletionDeref(ast.consequent, strictCode);\n\n    // 5. Return Completion(UpdateEmpty(stmtCompletion, undefined)\n    stmtCompletion = UpdateEmpty(realm, stmtCompletion, realm.intrinsics.undefined);\n    return [stmtCompletion, (stmtAst: any), exprIO.concat(stmtIO)];\n  } else if (!exprValue.mightNotBeFalse()) {\n    let stmtCompletion, stmtAst, stmtIO;\n    if (ast.alternate)\n      // 4.a. Let stmtCompletion be the result of evaluating the second Statement\n      [stmtCompletion, stmtAst, stmtIO] = env.partiallyEvaluateCompletionDeref(ast.alternate, strictCode);\n    else {\n      // 3 (of the if only statement). Return NormalCompletion(undefined)\n      stmtCompletion = realm.intrinsics.undefined;\n      stmtAst = t.emptyStatement();\n      stmtIO = [];\n    }\n    // 5. Return Completion(UpdateEmpty(stmtCompletion, undefined)\n    stmtCompletion = UpdateEmpty(realm, stmtCompletion, realm.intrinsics.undefined);\n    return [stmtCompletion, (stmtAst: any), exprIO.concat(stmtIO)];\n  }\n  invariant(exprValue instanceof AbstractValue);\n\n  // Evaluate consequent and alternate in sandboxes and get their effects.\n  let [consequentEffects, conAst, conIO] = realm.partiallyEvaluateNodeForEffects(ast.consequent, strictCode, env);\n  let [conCompl, gen1, bindings1, properties1, createdObj1] = consequentEffects;\n  let consequentAst = (conAst: any);\n  if (conIO.length > 0) consequentAst = t.blockStatement(conIO.concat(consequentAst));\n\n  let [alternateEffects, altAst, altIO] = ast.alternate\n    ? realm.partiallyEvaluateNodeForEffects(ast.alternate, strictCode, env)\n    : [construct_empty_effects(realm), undefined, []];\n  let [altCompl, gen2, bindings2, properties2, createdObj2] = alternateEffects;\n  let alternateAst = (altAst: any);\n  if (altIO.length > 0) alternateAst = t.blockStatement(altIO.concat(alternateAst));\n\n  // Join the effects, creating an abstract view of what happened, regardless\n  // of the actual value of exprValue.\n  let joinedEffects = Join.joinEffects(\n    realm,\n    exprValue,\n    [conCompl, gen1, bindings1, properties1, createdObj1],\n    [altCompl, gen2, bindings2, properties2, createdObj2]\n  );\n  completion = joinedEffects[0];\n  if (completion instanceof PossiblyNormalCompletion) {\n    // in this case one of the branches may complete abruptly, which means that\n    // not all control flow branches join into one flow at this point.\n    // Consequently we have to continue tracking changes until the point where\n    // all the branches come together into one.\n    realm.captureEffects(completion);\n  }\n  // Note that the effects of (non joining) abrupt branches are not included\n  // in joinedEffects, but are tracked separately inside completion.\n  realm.applyEffects(joinedEffects);\n\n  let resultAst = t.ifStatement((exprAst: any), (consequentAst: any), (alternateAst: any));\n  invariant(!(completion instanceof Reference));\n  return [completion, resultAst, exprIO];\n}\n"]}