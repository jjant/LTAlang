{"version":3,"sources":["../../src/partial-evaluators/BinaryExpression.js"],"names":["ast","strictCode","env","realm","partiallyEvaluateCompletionDeref","left","lval","leftAst","leftIO","leftCompletion","unbundleNormalCompletion","right","rval","rightAst","rightIO","io","concat","t","binaryExpression","operator","rightCompletion","op","resultValue","resultAst","valueToNode","serialize","undefined","mightNotBeObject","createAbstractValueForBinary","loc","lloc","rloc","resultType","val","reportIntrospectionError","createFromBinaryOp","r","composeNormalCompletions"],"mappings":"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","file":"BinaryExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type {\n  BabelBinaryOperator,\n  BabelNodeBinaryExpression,\n  BabelNodeExpression,\n  BabelNodeStatement,\n  BabelNodeSourceLocation,\n} from \"babel-types\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport type { Realm } from \"../realm.js\";\n\nimport { computeBinary, getPureBinaryOperationResultType } from \"../evaluators/BinaryExpression.js\";\nimport { AbruptCompletion, Completion, NormalCompletion } from \"../completions.js\";\nimport { FatalError } from \"../errors.js\";\nimport { Join } from \"../singletons.js\";\nimport { AbstractValue, BooleanValue, ConcreteValue, NullValue, UndefinedValue, Value } from \"../values/index.js\";\n\nimport * as t from \"babel-types\";\nimport invariant from \"../invariant.js\";\n\nexport default function(\n  ast: BabelNodeBinaryExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): [Completion | Value, BabelNodeExpression, Array<BabelNodeStatement>] {\n  let [lval, leftAst, leftIO] = env.partiallyEvaluateCompletionDeref(ast.left, strictCode);\n  if (lval instanceof AbruptCompletion) return [lval, (leftAst: any), leftIO];\n  let leftCompletion;\n  [leftCompletion, lval] = Join.unbundleNormalCompletion(lval);\n  invariant(lval instanceof Value);\n\n  let [rval, rightAst, rightIO] = env.partiallyEvaluateCompletionDeref(ast.right, strictCode);\n  let io = leftIO.concat(rightIO);\n  if (rval instanceof AbruptCompletion) {\n    // todo: if leftCompletion is a PossiblyNormalCompletion, compose\n    return [rval, t.binaryExpression(ast.operator, (leftAst: any), (rightAst: any)), io];\n  }\n  let rightCompletion;\n  [rightCompletion, rval] = Join.unbundleNormalCompletion(rval);\n  invariant(rval instanceof Value);\n\n  let op = ast.operator;\n  let resultValue, resultAst;\n  if (lval instanceof ConcreteValue) {\n    if (rval instanceof ConcreteValue) {\n      resultValue = computeBinary(realm, op, lval, rval);\n      resultAst = t.valueToNode(resultValue.serialize());\n    }\n  }\n  // if resultValue is undefined, one or both operands are abstract.\n  if (resultValue === undefined && (op === \"==\" || op === \"===\" || op === \"!=\" || op === \"!==\")) {\n    // When comparing to null or undefined, we can return a compile time value if we know the\n    // other operand must be an object.\n    if (\n      (!lval.mightNotBeObject() && (rval instanceof NullValue || rval instanceof UndefinedValue)) ||\n      (!rval.mightNotBeObject() && (lval instanceof NullValue || lval instanceof UndefinedValue))\n    ) {\n      resultValue = new BooleanValue(realm, op[0] !== \"=\");\n      resultAst = t.valueToNode(resultValue.serialize());\n    }\n  }\n  // todo: special case if one result is known to be 0 or 1\n  if (resultAst === undefined) {\n    resultAst = t.binaryExpression(op, (leftAst: any), (rightAst: any));\n  }\n  return createAbstractValueForBinary(\n    op,\n    resultAst,\n    lval,\n    rval,\n    leftAst.loc,\n    rightAst.loc,\n    leftCompletion,\n    rightCompletion,\n    resultValue,\n    io,\n    realm\n  );\n}\n\nexport function createAbstractValueForBinary(\n  op: BabelBinaryOperator,\n  ast: BabelNodeExpression,\n  lval: Value,\n  rval: Value,\n  lloc: ?BabelNodeSourceLocation,\n  rloc: ?BabelNodeSourceLocation,\n  leftCompletion: void | NormalCompletion,\n  rightCompletion: void | NormalCompletion,\n  resultValue: void | Value,\n  io: Array<BabelNodeStatement>,\n  realm: Realm\n): [Completion | Value, BabelNodeExpression, Array<BabelNodeStatement>] {\n  if (resultValue === undefined) {\n    let resultType = getPureBinaryOperationResultType(realm, op, lval, rval, lloc, rloc);\n    if (resultType === undefined) {\n      // The operation may result in side effects that we cannot track.\n      // Since we have no idea what those effects are, we can either forget\n      // (havoc) everything we know at this stage, or we can fault the\n      // program and/or native model and stop evaluating.\n      // We choose to do the latter.\n      // TODO: report the error and carry on assuming no side effects.\n      let val = lval instanceof AbstractValue ? lval : rval;\n      AbstractValue.reportIntrospectionError((val: any));\n      throw new FatalError();\n    }\n    resultValue = AbstractValue.createFromBinaryOp(realm, op, lval, rval, ast.loc);\n  }\n  let r = Join.composeNormalCompletions(leftCompletion, rightCompletion, resultValue, realm);\n  return [r, ast, io];\n}\n"]}