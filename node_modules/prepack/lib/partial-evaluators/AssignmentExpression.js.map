{"version":3,"sources":["../../src/partial-evaluators/AssignmentExpression.js"],"names":["ast","strictCode","env","realm","LeftHandSideExpression","left","AssignmentExpression","right","AssignmentOperator","operator","type","partiallyEvaluateCompletion","lref","last","lio","leftCompletion","unbundleNormalCompletion","partiallyEvaluateCompletionDeref","rval","rast","rio","io","concat","t","assignmentExpression","rightCompletion","hasNameProperty","SetFunctionName","GetReferencedName","PutValue","resultAst","composeNormalCompletions","lval","GetValue","op","slice","resultValue","valueToNode","serialize","undefined","mightNotBeObject","loc"],"mappings":"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","file":"AssignmentExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type {\n  BabelBinaryOperator,\n  BabelNodeAssignmentExpression,\n  BabelNodeExpression,\n  BabelNodeStatement,\n} from \"babel-types\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport type { Realm } from \"../realm.js\";\n\nimport { computeBinary } from \"../evaluators/BinaryExpression.js\";\nimport { createAbstractValueForBinary } from \"../partial-evaluators/BinaryExpression.js\";\nimport { AbruptCompletion, Completion } from \"../completions.js\";\nimport { Reference } from \"../environment.js\";\nimport { FatalError } from \"../errors.js\";\nimport { BooleanValue, ConcreteValue, NullValue, ObjectValue, UndefinedValue, Value } from \"../values/index.js\";\nimport { IsAnonymousFunctionDefinition, IsIdentifierRef, HasOwnProperty } from \"../methods/index.js\";\nimport { Environment, Functions, Join, Properties } from \"../singletons.js\";\n\nimport * as t from \"babel-types\";\nimport invariant from \"../invariant.js\";\n\n// ECMA262 12.15 Assignment Operators\nexport default function(\n  ast: BabelNodeAssignmentExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): [Completion | Value, BabelNodeExpression, Array<BabelNodeStatement>] {\n  let LeftHandSideExpression = ast.left;\n  let AssignmentExpression = ast.right;\n  let AssignmentOperator = ast.operator;\n\n  // AssignmentExpression : LeftHandSideExpression = AssignmentExpression\n  if (AssignmentOperator === \"=\") {\n    // 1. If LeftHandSideExpression is neither an ObjectLiteral nor an ArrayLiteral, then\n    if (LeftHandSideExpression.type !== \"ObjectLiteral\" && LeftHandSideExpression.type !== \"ArrayLiteral\") {\n      // a. Let lref be the result of evaluating LeftHandSideExpression.\n      let [lref, last, lio] = env.partiallyEvaluateCompletion(LeftHandSideExpression, strictCode);\n\n      // b. ReturnIfAbrupt(lref).\n      if (lref instanceof AbruptCompletion) return [lref, (last: any), lio];\n      let leftCompletion;\n      [leftCompletion, lref] = Join.unbundleNormalCompletion(lref);\n\n      // c. Let rref be the result of evaluating AssignmentExpression.\n      // d. Let rval be ? GetValue(rref).\n      let [rval, rast, rio] = env.partiallyEvaluateCompletionDeref(AssignmentExpression, strictCode);\n      let io = lio.concat(rio);\n      if (rval instanceof AbruptCompletion) {\n        return [rval, t.assignmentExpression(ast.operator, (last: any), (rast: any)), io];\n      }\n      let rightCompletion;\n      [rightCompletion, rval] = Join.unbundleNormalCompletion(rval);\n      invariant(rval instanceof Value);\n\n      // e. If IsAnonymousFunctionDefinition(AssignmentExpression) and IsIdentifierRef of LeftHandSideExpression are both true, then\n      if (\n        IsAnonymousFunctionDefinition(realm, AssignmentExpression) &&\n        IsIdentifierRef(realm, LeftHandSideExpression)\n      ) {\n        invariant(rval instanceof ObjectValue);\n\n        // i. Let hasNameProperty be ? HasOwnProperty(rval, \"name\").\n        let hasNameProperty = HasOwnProperty(realm, rval, \"name\");\n\n        // ii. If hasNameProperty is false, perform SetFunctionName(rval, GetReferencedName(lref)).\n        if (!hasNameProperty) {\n          invariant(lref instanceof Reference);\n          Functions.SetFunctionName(realm, rval, Environment.GetReferencedName(realm, lref));\n        }\n      }\n\n      // f. Perform ? PutValue(lref, rval).\n      Properties.PutValue(realm, lref, rval);\n\n      // g. Return rval.\n      let resultAst = t.assignmentExpression(ast.operator, (last: any), (rast: any));\n      rval = Join.composeNormalCompletions(leftCompletion, rightCompletion, rval, realm);\n      return [rval, resultAst, io];\n    }\n    throw new FatalError(\"Patterns aren't supported yet\");\n    // 2. Let assignmentPattern be the parse of the source text corresponding to LeftHandSideExpression using AssignmentPattern[?Yield] as the goal symbol.\n    // 3. Let rref be the result of evaluating AssignmentExpression.\n    // 4. Let rval be ? GetValue(rref).\n    // 5. Let status be the result of performing DestructuringAssignmentEvaluation of assignmentPattern using rval as the argument.\n    // 6. ReturnIfAbrupt(status).\n    // 7. Return rval.\n  }\n\n  // AssignmentExpression : LeftHandSideExpression AssignmentOperator AssignmentExpression\n\n  // 1. Let lref be the result of evaluating LeftHandSideExpression.\n  let [lref, last, lio] = env.partiallyEvaluateCompletion(LeftHandSideExpression, strictCode);\n  if (lref instanceof AbruptCompletion) return [lref, (last: any), lio];\n  let leftCompletion;\n  [leftCompletion, lref] = Join.unbundleNormalCompletion(lref);\n\n  // 2. Let lval be ? GetValue(lref).\n  let lval = Environment.GetValue(realm, lref);\n\n  // 3. Let rref be the result of evaluating AssignmentExpression.\n  // 4. Let rval be ? GetValue(rref).\n  let [rval, rast, rio] = env.partiallyEvaluateCompletionDeref(AssignmentExpression, strictCode);\n  let io = lio.concat(rio);\n  if (rval instanceof AbruptCompletion) {\n    return [rval, t.assignmentExpression(ast.operator, (last: any), (rast: any)), io];\n  }\n  let rightCompletion;\n  [rightCompletion, rval] = Join.unbundleNormalCompletion(rval);\n  invariant(rval instanceof Value);\n\n  // 5. Let op be the @ where AssignmentOperator is @=.\n  let op = ((AssignmentOperator.slice(0, -1): any): BabelBinaryOperator);\n\n  // 6. Let r be the result of applying op to lval and rval as if evaluating the expression lval op rval.\n  let resultValue, resultAst;\n  if (lval instanceof ConcreteValue) {\n    if (rval instanceof ConcreteValue) {\n      resultValue = computeBinary(realm, op, lval, rval);\n      resultAst = t.assignmentExpression(ast.operator, (last: any), t.valueToNode(resultValue.serialize()));\n    }\n  }\n  // if resultValue is undefined, one or both operands are abstract.\n  if (resultValue === undefined && (op === \"==\" || op === \"===\" || op === \"!=\" || op === \"!==\")) {\n    // When comparing to null or undefined, we can return a compile time value if we know the\n    // other operand must be an object.\n    if (\n      (!lval.mightNotBeObject() && (rval instanceof NullValue || rval instanceof UndefinedValue)) ||\n      (!rval.mightNotBeObject() && (lval instanceof NullValue || lval instanceof UndefinedValue))\n    ) {\n      resultValue = new BooleanValue(realm, op[0] !== \"=\");\n      resultAst = t.assignmentExpression(ast.operator, (last: any), t.valueToNode(resultValue.serialize()));\n    }\n  }\n  // todo: special case if one result is known to be 0 or 1\n  if (resultAst === undefined) {\n    resultAst = t.assignmentExpression(ast.operator, (last: any), (rast: any));\n  }\n  return createAbstractValueForBinary(\n    op,\n    resultAst,\n    lval,\n    rval,\n    last.loc,\n    rast.loc,\n    leftCompletion,\n    rightCompletion,\n    resultValue,\n    io,\n    realm\n  );\n}\n"]}