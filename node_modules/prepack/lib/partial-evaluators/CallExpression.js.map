{"version":3,"sources":["../../src/partial-evaluators/CallExpression.js"],"names":["ast","strictCode","env","realm","setNextExecutionContextLocation","loc","partiallyEvaluateCompletion","callee","ref","calleeAst","calleeIO","completion","value","func","GetValue","io","partialArgs","argVals","arguments","arg","partiallyEvaluateCompletionDeref","argValue","argAst","argIO","concat","push","stopEffectCaptureJoinApplyAndReturnCompletion","resultAst","t","callExpression","composeNormalCompletions","callResult","EvaluateCall","callCompletion","unbundleNormalCompletion","undefined","captureEffects","callBothFunctionsAndJoinTheirEffects","funcs","cond","func1","func2","getType","isTypeCompatibleWith","evaluateForEffects","compl1","gen1","bindings1","properties1","createdObj1","compl2","gen2","bindings2","properties2","createdObj2","joinedEffects","joinEffects","joinedCompletion","composeWithSavedCompletion","applyEffects","argList","kind","args","createFromType","throwIfNotConcrete","IsPropertyReference","GetReferencedName","intrinsics","eval","length","evalText","strictCaller","evalRealm","PerformEval","thisValue","refEnv","GetBase","WithBaseObject","thisCall","tailCall","err"],"mappings":"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","file":"CallExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { BabelNodeCallExpression, BabelNodeExpression, BabelNodeStatement } from \"babel-types\";\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\n\nimport { AbruptCompletion, Completion, PossiblyNormalCompletion } from \"../completions.js\";\nimport { EnvironmentRecord, Reference } from \"../environment.js\";\nimport { EvaluateDirectCallWithArgList, GetThisValue, IsInTailPosition, SameValue } from \"../methods/index.js\";\nimport { Environment, Functions, Join } from \"../singletons.js\";\nimport { AbstractValue, BooleanValue, FunctionValue, Value } from \"../values/index.js\";\n\nimport * as t from \"babel-types\";\nimport invariant from \"../invariant.js\";\n\n// ECMA262 12.3.4.1\nexport default function(\n  ast: BabelNodeCallExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): [Completion | Value, BabelNodeExpression, Array<BabelNodeStatement>] {\n  realm.setNextExecutionContextLocation(ast.loc);\n\n  // 1. Let ref be the result of evaluating MemberExpression.\n  let [ref, calleeAst, calleeIO] = env.partiallyEvaluateCompletion(ast.callee, strictCode);\n  if (ref instanceof AbruptCompletion) return [ref, (calleeAst: any), calleeIO];\n  let completion;\n  if (ref instanceof PossiblyNormalCompletion) {\n    completion = ref;\n    ref = completion.value;\n  }\n  invariant(ref instanceof Value || ref instanceof Reference);\n\n  // 2. Let func be ? GetValue(ref).\n  let func = Environment.GetValue(realm, ref);\n\n  let io = calleeIO;\n  let partialArgs = [];\n  let argVals = [];\n  for (let arg of ast.arguments) {\n    let [argValue, argAst, argIO] = env.partiallyEvaluateCompletionDeref(arg, strictCode);\n    io = io.concat(argIO);\n    partialArgs.push((argAst: any));\n    if (argValue instanceof AbruptCompletion) {\n      if (completion instanceof PossiblyNormalCompletion)\n        completion = Join.stopEffectCaptureJoinApplyAndReturnCompletion(completion, argValue, realm);\n      else completion = argValue;\n      let resultAst = t.callExpression((calleeAst: any), partialArgs);\n      return [completion, resultAst, io];\n    }\n    if (argValue instanceof PossiblyNormalCompletion) {\n      argVals.push(argValue.value);\n      if (completion instanceof PossiblyNormalCompletion)\n        completion = Join.composeNormalCompletions(completion, argValue, argValue.value, realm);\n      else completion = argValue;\n    } else {\n      invariant(argValue instanceof Value);\n      argVals.push(argValue);\n    }\n  }\n\n  let callResult = EvaluateCall(ref, func, ast, argVals, strictCode, env, realm);\n  if (callResult instanceof AbruptCompletion) {\n    if (completion instanceof PossiblyNormalCompletion)\n      completion = Join.stopEffectCaptureJoinApplyAndReturnCompletion(completion, callResult, realm);\n    else completion = callResult;\n    let resultAst = t.callExpression((calleeAst: any), partialArgs);\n    return [completion, resultAst, io];\n  }\n  let callCompletion;\n  [callCompletion, callResult] = Join.unbundleNormalCompletion(callResult);\n  invariant(callResult instanceof Value);\n  invariant(completion === undefined || completion instanceof PossiblyNormalCompletion);\n  completion = Join.composeNormalCompletions(completion, callCompletion, callResult, realm);\n  if (completion instanceof PossiblyNormalCompletion) {\n    realm.captureEffects(completion);\n  }\n  return [completion, t.callExpression((calleeAst: any), partialArgs), io];\n}\n\nfunction callBothFunctionsAndJoinTheirEffects(\n  funcs: Array<Value>,\n  ast: BabelNodeCallExpression,\n  argVals: Array<Value>,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): AbruptCompletion | Value {\n  let [cond, func1, func2] = funcs;\n  invariant(cond instanceof AbstractValue && cond.getType() === BooleanValue);\n  invariant(Value.isTypeCompatibleWith(func1.getType(), FunctionValue));\n  invariant(Value.isTypeCompatibleWith(func2.getType(), FunctionValue));\n\n  let [compl1, gen1, bindings1, properties1, createdObj1] = realm.evaluateForEffects(() =>\n    EvaluateCall(func1, func1, ast, argVals, strictCode, env, realm)\n  );\n\n  let [compl2, gen2, bindings2, properties2, createdObj2] = realm.evaluateForEffects(() =>\n    EvaluateCall(func2, func2, ast, argVals, strictCode, env, realm)\n  );\n\n  let joinedEffects = Join.joinEffects(\n    realm,\n    cond,\n    [compl1, gen1, bindings1, properties1, createdObj1],\n    [compl2, gen2, bindings2, properties2, createdObj2]\n  );\n  let joinedCompletion = joinedEffects[0];\n  if (joinedCompletion instanceof PossiblyNormalCompletion) {\n    // in this case one of the branches may complete abruptly, which means that\n    // not all control flow branches join into one flow at this point.\n    // Consequently we have to continue tracking changes until the point where\n    // all the branches come together into one.\n    joinedCompletion = realm.composeWithSavedCompletion(joinedCompletion);\n  }\n\n  // Note that the effects of (non joining) abrupt branches are not included\n  // in joinedEffects, but are tracked separately inside joinedCompletion.\n  realm.applyEffects(joinedEffects);\n\n  // return or throw completion\n  invariant(joinedCompletion instanceof AbruptCompletion || joinedCompletion instanceof Value);\n  return joinedCompletion;\n}\n\nfunction EvaluateCall(\n  ref: Value | Reference,\n  func: Value,\n  ast: BabelNodeCallExpression,\n  argList: Array<Value>,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): AbruptCompletion | Value {\n  if (func instanceof AbstractValue && Value.isTypeCompatibleWith(func.getType(), FunctionValue)) {\n    if (func.kind === \"conditional\")\n      return callBothFunctionsAndJoinTheirEffects(func.args, ast, argList, strictCode, env, realm);\n\n    // The called function comes from the environmental model and we require that\n    // such functions have no visible side-effects. Hence we can carry on\n    // by returning a call node with the arguments updated with their partial counterparts.\n    // TODO: obtain the type of the return value from the abstract function.\n    return AbstractValue.createFromType(realm, Value);\n  }\n  // If func is abstract and not known to be a safe function, we can't safely continue.\n  func = func.throwIfNotConcrete();\n\n  // 3. If Type(ref) is Reference and IsPropertyReference(ref) is false and GetReferencedName(ref) is \"eval\", then\n  if (\n    ref instanceof Reference &&\n    !Environment.IsPropertyReference(realm, ref) &&\n    Environment.GetReferencedName(realm, ref) === \"eval\"\n  ) {\n    // a. If SameValue(func, %eval%) is true, then\n    if (SameValue(realm, func, realm.intrinsics.eval)) {\n      // i. Let argList be ? ArgumentListEvaluation(Arguments).\n\n      // ii. If argList has no elements, return undefined.\n      if (argList.length === 0) return realm.intrinsics.undefined;\n\n      // iii. Let evalText be the first element of argList.\n      let evalText = argList[0];\n\n      // iv. If the source code matching this CallExpression is strict code, let strictCaller be true. Otherwise let strictCaller be false.\n      let strictCaller = strictCode;\n\n      // v. Let evalRealm be the current Realm Record.\n      let evalRealm = realm;\n\n      // vi. Return ? PerformEval(evalText, evalRealm, strictCaller, true).\n      return Functions.PerformEval(realm, evalText, evalRealm, strictCaller, true);\n    }\n  }\n\n  let thisValue;\n\n  // 4. If Type(ref) is Reference, then\n  if (ref instanceof Reference) {\n    // a. If IsPropertyReference(ref) is true, then\n    if (Environment.IsPropertyReference(realm, ref)) {\n      // i. Let thisValue be GetThisValue(ref).\n      thisValue = GetThisValue(realm, ref);\n    } else {\n      // b. Else, the base of ref is an Environment Record\n      // i. Let refEnv be GetBase(ref).\n      let refEnv = Environment.GetBase(realm, ref);\n      invariant(refEnv instanceof EnvironmentRecord);\n\n      // ii. Let thisValue be refEnv.WithBaseObject().\n      thisValue = refEnv.WithBaseObject();\n    }\n  } else {\n    // 5. Else Type(ref) is not Reference,\n    // a. Let thisValue be undefined.\n    thisValue = realm.intrinsics.undefined;\n  }\n\n  // 6. Let thisCall be this CallExpression.\n  let thisCall = ast;\n\n  // 7. Let tailCall be IsInTailPosition(thisCall). (See 14.6.1)\n  let tailCall = IsInTailPosition(realm, thisCall);\n\n  // 8. Return ? EvaluateDirectCall(func, thisValue, Arguments, tailCall).\n\n  try {\n    return EvaluateDirectCallWithArgList(realm, strictCode, env, ref, func, thisValue, argList, tailCall);\n  } catch (err) {\n    if (err instanceof Completion) return err;\n    throw err;\n  }\n}\n"]}