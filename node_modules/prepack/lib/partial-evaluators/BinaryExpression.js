"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Copyright (c) 2017-present, Facebook, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * This source code is licensed under the BSD-style license found in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * LICENSE file in the root directory of this source tree. An additional grant
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * of patent rights can be found in the PATENTS file in the same directory.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */

exports.default = function (ast, strictCode, env, realm) {
  var _env$partiallyEvaluat = env.partiallyEvaluateCompletionDeref(ast.left, strictCode),
      _env$partiallyEvaluat2 = _slicedToArray(_env$partiallyEvaluat, 3),
      lval = _env$partiallyEvaluat2[0],
      leftAst = _env$partiallyEvaluat2[1],
      leftIO = _env$partiallyEvaluat2[2];

  if (lval instanceof _completions.AbruptCompletion) return [lval, leftAst, leftIO];
  var leftCompletion = void 0;

  var _Join$unbundleNormalC = _singletons.Join.unbundleNormalCompletion(lval);

  var _Join$unbundleNormalC2 = _slicedToArray(_Join$unbundleNormalC, 2);

  leftCompletion = _Join$unbundleNormalC2[0];
  lval = _Join$unbundleNormalC2[1];

  (0, _invariant2.default)(lval instanceof _index.Value);

  var _env$partiallyEvaluat3 = env.partiallyEvaluateCompletionDeref(ast.right, strictCode),
      _env$partiallyEvaluat4 = _slicedToArray(_env$partiallyEvaluat3, 3),
      rval = _env$partiallyEvaluat4[0],
      rightAst = _env$partiallyEvaluat4[1],
      rightIO = _env$partiallyEvaluat4[2];

  var io = leftIO.concat(rightIO);
  if (rval instanceof _completions.AbruptCompletion) {
    // todo: if leftCompletion is a PossiblyNormalCompletion, compose
    return [rval, t.binaryExpression(ast.operator, leftAst, rightAst), io];
  }
  var rightCompletion = void 0;

  var _Join$unbundleNormalC3 = _singletons.Join.unbundleNormalCompletion(rval);

  var _Join$unbundleNormalC4 = _slicedToArray(_Join$unbundleNormalC3, 2);

  rightCompletion = _Join$unbundleNormalC4[0];
  rval = _Join$unbundleNormalC4[1];

  (0, _invariant2.default)(rval instanceof _index.Value);

  var op = ast.operator;
  var resultValue = void 0,
      resultAst = void 0;
  if (lval instanceof _index.ConcreteValue) {
    if (rval instanceof _index.ConcreteValue) {
      resultValue = (0, _BinaryExpression.computeBinary)(realm, op, lval, rval);
      resultAst = t.valueToNode(resultValue.serialize());
    }
  }
  // if resultValue is undefined, one or both operands are abstract.
  if (resultValue === undefined && (op === "==" || op === "===" || op === "!=" || op === "!==")) {
    // When comparing to null or undefined, we can return a compile time value if we know the
    // other operand must be an object.
    if (!lval.mightNotBeObject() && (rval instanceof _index.NullValue || rval instanceof _index.UndefinedValue) || !rval.mightNotBeObject() && (lval instanceof _index.NullValue || lval instanceof _index.UndefinedValue)) {
      resultValue = new _index.BooleanValue(realm, op[0] !== "=");
      resultAst = t.valueToNode(resultValue.serialize());
    }
  }
  // todo: special case if one result is known to be 0 or 1
  if (resultAst === undefined) {
    resultAst = t.binaryExpression(op, leftAst, rightAst);
  }
  return createAbstractValueForBinary(op, resultAst, lval, rval, leftAst.loc, rightAst.loc, leftCompletion, rightCompletion, resultValue, io, realm);
};

exports.createAbstractValueForBinary = createAbstractValueForBinary;

var _BinaryExpression = require("../evaluators/BinaryExpression.js");

var _completions = require("../completions.js");

var _errors = require("../errors.js");

var _singletons = require("../singletons.js");

var _index = require("../values/index.js");

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function createAbstractValueForBinary(op, ast, lval, rval, lloc, rloc, leftCompletion, rightCompletion, resultValue, io, realm) {
  if (resultValue === undefined) {
    var resultType = (0, _BinaryExpression.getPureBinaryOperationResultType)(realm, op, lval, rval, lloc, rloc);
    if (resultType === undefined) {
      // The operation may result in side effects that we cannot track.
      // Since we have no idea what those effects are, we can either forget
      // (havoc) everything we know at this stage, or we can fault the
      // program and/or native model and stop evaluating.
      // We choose to do the latter.
      // TODO: report the error and carry on assuming no side effects.
      var val = lval instanceof _index.AbstractValue ? lval : rval;
      _index.AbstractValue.reportIntrospectionError(val);
      throw new _errors.FatalError();
    }
    resultValue = _index.AbstractValue.createFromBinaryOp(realm, op, lval, rval, ast.loc);
  }
  var r = _singletons.Join.composeNormalCompletions(leftCompletion, rightCompletion, resultValue, realm);
  return [r, ast, io];
}
//# sourceMappingURL=BinaryExpression.js.map