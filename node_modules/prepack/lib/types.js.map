{"version":3,"sources":["../src/types.js"],"names":["ElementSize","Float32","Float64","Int8","Int16","Int32","Uint8","Uint16","Uint32","Uint8Clamped"],"mappings":";;;;;;;AA4BA;;AAOA;;AACA;;AACA;;AAYO,IAAMA,oCAAc;AACzBC,WAAS,CADgB;AAEzBC,WAAS,CAFgB;AAGzBC,QAAM,CAHmB;AAIzBC,SAAO,CAJkB;AAKzBC,SAAO,CALkB;AAMzBC,SAAO,CANkB;AAOzBC,UAAQ,CAPiB;AAQzBC,UAAQ,CARiB;AASzBC,gBAAc;AATW,CAApB;;AA0CP;;AAOA;;AAIA;;AAmNA;;AAzTA","file":"types.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type {\n  AbstractObjectValue,\n  AbstractValue,\n  ArrayValue,\n  BooleanValue,\n  ECMAScriptFunctionValue,\n  ECMAScriptSourceFunctionValue,\n  EmptyValue,\n  FunctionValue,\n  NativeFunctionValue,\n  NullValue,\n  NumberValue,\n  StringValue,\n  SymbolValue,\n  UndefinedValue,\n  Value,\n} from \"./values/index.js\";\nimport {\n  AbruptCompletion,\n  Completion,\n  JoinedAbruptCompletions,\n  NormalCompletion,\n  PossiblyNormalCompletion,\n} from \"./completions.js\";\nimport { EnvironmentRecord, LexicalEnvironment, Reference } from \"./environment.js\";\nimport { Generator } from \"./utils/generator.js\";\nimport { ObjectValue } from \"./values/index.js\";\nimport type {\n  BabelNode,\n  BabelNodeBlockStatement,\n  BabelNodeClassMethod,\n  BabelNodeLVal,\n  BabelNodeObjectMethod,\n  BabelNodePattern,\n  BabelNodeVariableDeclaration,\n} from \"babel-types\";\nimport type { Bindings, Effects, EvaluationResult, PropertyBindings, CreatedObjects, Realm } from \"./realm.js\";\n\nexport const ElementSize = {\n  Float32: 4,\n  Float64: 8,\n  Int8: 1,\n  Int16: 2,\n  Int32: 4,\n  Uint8: 1,\n  Uint16: 2,\n  Uint32: 4,\n  Uint8Clamped: 1,\n};\n\nexport type IterationKind = \"key+value\" | \"value\" | \"key\";\n\nexport type SourceType = \"module\" | \"script\";\n\nexport type SourceFile = {\n  filePath: string,\n  fileContents: string,\n  sourceMapContents?: string,\n};\n\nexport type SourceMap = {\n  sources: Array<string>,\n  names: Array<string>,\n  mappings: string,\n  sourcesContent: Array<string>,\n};\n\nexport type AbstractTime = \"early\" | \"late\";\n\nexport type ElementType =\n  | \"Float32\"\n  | \"Float64\"\n  | \"Int8\"\n  | \"Int16\"\n  | \"Int32\"\n  | \"Uint8\"\n  | \"Uint16\"\n  | \"Uint32\"\n  | \"Uint8Clamped\";\n\n//\n\ndeclare class _CallableObjectValue extends ObjectValue {\n  $Call: void | ((thisArgument: Value, argsList: Array<Value>) => Value),\n}\nexport type CallableObjectValue = _CallableObjectValue | FunctionValue | NativeFunctionValue;\n\n//\n\nexport type DataBlock = Uint8Array;\n\n//\n\nexport type Descriptor = {\n  writable?: boolean,\n  enumerable?: boolean,\n  configurable?: boolean,\n\n  // If value.IsEmpty is true then this descriptor indicates that the\n  // corresponding property has been deleted.\n  // Only internal properties (those starting with $) will ever have array values.\n  value?: Value | Array<any>,\n\n  get?: UndefinedValue | CallableObjectValue | AbstractValue,\n  set?: UndefinedValue | CallableObjectValue | AbstractValue,\n\n  // Only used if the result of a join of two descriptors is not a data descriptor with identical attribute values.\n  // When present, any update to the property must produce effects that are the join of updating both desriptors,\n  // using joinCondition as the condition of the join.\n  joinCondition?: AbstractValue,\n  descriptor1?: Descriptor,\n  descriptor2?: Descriptor,\n};\n\nexport type FunctionBodyAstNode = {\n  // Function body ast node will have uniqueTag after interpreted.\n  uniqueTag?: number,\n};\n\nexport type PropertyBinding = {\n  descriptor?: Descriptor,\n  object: ObjectValue | AbstractObjectValue,\n  key: any,\n};\n\nexport type LexicalEnvironmentTypes = \"global\" | \"module\" | \"script\" | \"function\" | \"block\" | \"catch\" | \"loop\" | \"with\";\n\nexport type PropertyKeyValue = string | StringValue | SymbolValue;\n\nexport type Intrinsics = {\n  undefined: UndefinedValue,\n  empty: EmptyValue,\n  null: NullValue,\n  false: BooleanValue,\n  true: BooleanValue,\n  NaN: NumberValue,\n  Infinity: NumberValue,\n  negativeInfinity: NumberValue,\n  zero: NumberValue,\n  negativeZero: NumberValue,\n  emptyString: StringValue,\n\n  SymbolHasInstance: SymbolValue,\n  SymbolIsConcatSpreadable: SymbolValue,\n  SymbolSpecies: SymbolValue,\n  SymbolReplace: SymbolValue,\n  SymbolIterator: SymbolValue,\n  SymbolSplit: SymbolValue,\n  SymbolToPrimitive: SymbolValue,\n  SymbolToStringTag: SymbolValue,\n  SymbolMatch: SymbolValue,\n  SymbolSearch: SymbolValue,\n  SymbolUnscopables: SymbolValue,\n\n  ObjectPrototype: ObjectValue,\n  FunctionPrototype: NativeFunctionValue,\n  ArrayPrototype: ObjectValue,\n  RegExpPrototype: ObjectValue,\n  DatePrototype: ObjectValue,\n  Boolean: NativeFunctionValue,\n  BooleanPrototype: ObjectValue,\n\n  Error: NativeFunctionValue,\n  ErrorPrototype: ObjectValue,\n  ReferenceError: NativeFunctionValue,\n  ReferenceErrorPrototype: ObjectValue,\n  SyntaxError: NativeFunctionValue,\n  SyntaxErrorPrototype: ObjectValue,\n  TypeError: NativeFunctionValue,\n  TypeErrorPrototype: ObjectValue,\n  URIError: NativeFunctionValue,\n  URIErrorPrototype: ObjectValue,\n  EvalError: NativeFunctionValue,\n  EvalErrorPrototype: ObjectValue,\n  JSON: ObjectValue,\n  Reflect: ObjectValue,\n  Proxy: NativeFunctionValue,\n  RangeError: NativeFunctionValue,\n  RangeErrorPrototype: ObjectValue,\n  ArrayIteratorPrototype: ObjectValue,\n  StringIteratorPrototype: ObjectValue,\n  IteratorPrototype: ObjectValue,\n  SetIteratorPrototype: ObjectValue,\n  MapIteratorPrototype: ObjectValue,\n  Number: NativeFunctionValue,\n  NumberPrototype: ObjectValue,\n  Symbol: NativeFunctionValue,\n  SymbolPrototype: ObjectValue,\n  StringPrototype: ObjectValue,\n  Object: NativeFunctionValue,\n  Function: NativeFunctionValue,\n  Array: NativeFunctionValue,\n  RegExp: NativeFunctionValue,\n  Date: NativeFunctionValue,\n  String: NativeFunctionValue,\n  Math: ObjectValue,\n  isNaN: NativeFunctionValue,\n  parseInt: NativeFunctionValue,\n  parseFloat: NativeFunctionValue,\n  isFinite: NativeFunctionValue,\n  decodeURI: NativeFunctionValue,\n  decodeURIComponent: NativeFunctionValue,\n  encodeURI: NativeFunctionValue,\n  encodeURIComponent: NativeFunctionValue,\n  ThrowTypeError: NativeFunctionValue,\n  ArrayProto_values: NativeFunctionValue,\n  ArrayProto_toString: NativeFunctionValue,\n  ObjectProto_toString: NativeFunctionValue,\n  TypedArrayProto_values: NativeFunctionValue,\n  eval: NativeFunctionValue,\n  console: ObjectValue,\n  document: ObjectValue,\n  process: ObjectValue,\n\n  DataView: NativeFunctionValue,\n  DataViewPrototype: ObjectValue,\n  TypedArray: NativeFunctionValue,\n  TypedArrayPrototype: ObjectValue,\n  Float32Array: NativeFunctionValue,\n  Float32ArrayPrototype: ObjectValue,\n  Float64Array: NativeFunctionValue,\n  Float64ArrayPrototype: ObjectValue,\n  Int8Array: NativeFunctionValue,\n  Int8ArrayPrototype: ObjectValue,\n  Int16Array: NativeFunctionValue,\n  Int16ArrayPrototype: ObjectValue,\n  Int32Array: NativeFunctionValue,\n  Int32ArrayPrototype: ObjectValue,\n  Map: NativeFunctionValue,\n  MapPrototype: ObjectValue,\n  WeakMap: NativeFunctionValue,\n  WeakMapPrototype: ObjectValue,\n  Set: NativeFunctionValue,\n  SetPrototype: ObjectValue,\n  Promise: NativeFunctionValue,\n  PromisePrototype: ObjectValue,\n  Uint8Array: NativeFunctionValue,\n  Uint8ArrayPrototype: ObjectValue,\n  Uint8ClampedArray: NativeFunctionValue,\n  Uint8ClampedArrayPrototype: ObjectValue,\n  Uint16Array: NativeFunctionValue,\n  Uint16ArrayPrototype: ObjectValue,\n  Uint32Array: NativeFunctionValue,\n  Uint32ArrayPrototype: ObjectValue,\n  WeakSet: NativeFunctionValue,\n  WeakSetPrototype: ObjectValue,\n  ArrayBuffer: NativeFunctionValue,\n  ArrayBufferPrototype: ObjectValue,\n\n  Generator: ObjectValue,\n  GeneratorPrototype: ObjectValue,\n  GeneratorFunction: NativeFunctionValue,\n\n  __IntrospectionError: NativeFunctionValue,\n  __IntrospectionErrorPrototype: ObjectValue,\n};\n\nexport type PromiseCapability = {\n  promise: ObjectValue | UndefinedValue,\n  resolve: Value,\n  reject: Value,\n};\n\nexport type PromiseReaction = {\n  capabilities: PromiseCapability,\n  handler: Value,\n};\n\nexport type ResolvingFunctions = {\n  resolve: Value,\n  reject: Value,\n};\n\nexport type TypedArrayKind =\n  | \"Float32Array\"\n  | \"Float64Array\"\n  | \"Int8Array\"\n  | \"Int16Array\"\n  | \"Int32Array\"\n  | \"Uint8Array\"\n  | \"Uint16Array\"\n  | \"Uint32Array\"\n  | \"Uint8ClampedArray\";\n\nexport type ObjectKind =\n  | \"Object\"\n  | \"Array\"\n  | \"Function\"\n  | \"Symbol\"\n  | \"String\"\n  | \"Number\"\n  | \"Boolean\"\n  | \"Date\"\n  | \"RegExp\"\n  | \"Set\"\n  | \"Map\"\n  | \"DataView\"\n  | \"ArrayBuffer\"\n  | \"WeakMap\"\n  | \"WeakSet\"\n  | TypedArrayKind\n  | \"ReactElement\";\n// TODO #26 #712: Promises. All kinds of iterators. Generators.\n\nexport type DebugServerType = {\n  checkForActions: BabelNode => void,\n  shutdown: () => void,\n};\n\nexport type PathType = {\n  implies(condition: AbstractValue): boolean,\n  impliesNot(condition: AbstractValue): boolean,\n  withCondition<T>(condition: AbstractValue, evaluate: () => T): T,\n  withInverseCondition<T>(condition: AbstractValue, evaluate: () => T): T,\n};\n\nexport type PropertiesType = {\n  // ECMA262 9.1.9.1\n  OrdinarySet(realm: Realm, O: ObjectValue, P: PropertyKeyValue, V: Value, Receiver: Value): boolean,\n\n  // ECMA262 6.2.4.4\n  FromPropertyDescriptor(realm: Realm, Desc: ?Descriptor): Value,\n\n  //\n  OrdinaryDelete(realm: Realm, O: ObjectValue, P: PropertyKeyValue): boolean,\n\n  // ECMA262 7.3.8\n  DeletePropertyOrThrow(realm: Realm, O: ObjectValue, P: PropertyKeyValue): boolean,\n\n  // ECMA262 6.2.4.6\n  CompletePropertyDescriptor(realm: Realm, Desc: Descriptor): Descriptor,\n\n  // ECMA262 9.1.6.2\n  IsCompatiblePropertyDescriptor(realm: Realm, extensible: boolean, Desc: Descriptor, current: ?Descriptor): boolean,\n\n  // ECMA262 9.1.6.3\n  ValidateAndApplyPropertyDescriptor(\n    realm: Realm,\n    O: void | ObjectValue,\n    P: void | PropertyKeyValue,\n    extensible: boolean,\n    Desc: Descriptor,\n    current: ?Descriptor\n  ): boolean,\n\n  // ECMA262 9.1.6.1\n  OrdinaryDefineOwnProperty(realm: Realm, O: ObjectValue, P: PropertyKeyValue, Desc: Descriptor): boolean,\n\n  // ECMA262 19.1.2.3.1\n  ObjectDefineProperties(realm: Realm, O: Value, Properties: Value): ObjectValue | AbstractObjectValue,\n\n  // ECMA262 7.3.3\n  Set(realm: Realm, O: ObjectValue | AbstractObjectValue, P: PropertyKeyValue, V: Value, Throw: boolean): boolean,\n\n  // ECMA262 7.3.7\n  DefinePropertyOrThrow(\n    realm: Realm,\n    O: ObjectValue | AbstractObjectValue,\n    P: PropertyKeyValue,\n    desc: Descriptor\n  ): boolean,\n\n  // ECMA262 6.2.3.2\n  PutValue(realm: Realm, V: Value | Reference, W: Value): void | boolean | Value,\n\n  // ECMA262 9.4.2.4\n  ArraySetLength(realm: Realm, A: ArrayValue, Desc: Descriptor): boolean,\n\n  // ECMA262 9.1.5.1\n  OrdinaryGetOwnProperty(realm: Realm, O: ObjectValue, P: PropertyKeyValue): Descriptor | void,\n\n  // ECMA262 9.1.2.1\n  OrdinarySetPrototypeOf(realm: Realm, O: ObjectValue, V: ObjectValue | NullValue): boolean,\n\n  // ECMA262 13.7.5.15\n  EnumerateObjectProperties(realm: Realm, O: ObjectValue): ObjectValue,\n\n  ThrowIfMightHaveBeenDeleted(\n    value: void | Value | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>\n  ): void,\n\n  ThrowIfInternalSlotNotWritable<T: ObjectValue>(realm: Realm, object: T, key: string): T,\n\n  // ECMA 14.3.9\n  PropertyDefinitionEvaluation(\n    realm: Realm,\n    MethodDefinition: BabelNodeObjectMethod | BabelNodeClassMethod,\n    object: ObjectValue,\n    env: LexicalEnvironment,\n    strictCode: boolean,\n    enumerable: boolean\n  ): boolean,\n};\n\nexport type FunctionType = {\n  FindVarScopedDeclarations(ast_node: BabelNode): Array<BabelNode>,\n\n  // ECMA262 9.2.12\n  FunctionDeclarationInstantiation(\n    realm: Realm,\n    func: ECMAScriptSourceFunctionValue,\n    argumentsList: Array<Value>\n  ): EmptyValue,\n\n  // ECMA262 9.2.11\n  SetFunctionName(realm: Realm, F: ObjectValue, name: PropertyKeyValue | AbstractValue, prefix?: string): boolean,\n\n  // ECMA262 9.2.3\n  FunctionInitialize(\n    realm: Realm,\n    F: ECMAScriptSourceFunctionValue,\n    kind: \"normal\" | \"method\" | \"arrow\",\n    ParameterList: Array<BabelNodeLVal>,\n    Body: BabelNodeBlockStatement,\n    Scope: LexicalEnvironment\n  ): ECMAScriptSourceFunctionValue,\n\n  // ECMA262 9.2.6\n  GeneratorFunctionCreate(\n    realm: Realm,\n    kind: \"normal\" | \"method\",\n    ParameterList: Array<BabelNodeLVal>,\n    Body: BabelNodeBlockStatement,\n    Scope: LexicalEnvironment,\n    Strict: boolean\n  ): ECMAScriptSourceFunctionValue,\n\n  // ECMA262 9.2.7\n  AddRestrictedFunctionProperties(F: FunctionValue, realm: Realm): boolean,\n\n  // ECMA262 9.2.1\n  $Call(realm: Realm, F: ECMAScriptFunctionValue, thisArgument: Value, argsList: Array<Value>): Value,\n\n  // ECMA262 9.2.2\n  $Construct(\n    realm: Realm,\n    F: ECMAScriptFunctionValue,\n    argumentsList: Array<Value>,\n    newTarget: ObjectValue\n  ): ObjectValue,\n\n  // ECMA262 9.2.3\n  FunctionAllocate(\n    realm: Realm,\n    functionPrototype: ObjectValue,\n    strict: boolean,\n    functionKind: \"normal\" | \"non-constructor\" | \"generator\"\n  ): ECMAScriptSourceFunctionValue,\n\n  // ECMA262 9.4.1.3\n  BoundFunctionCreate(\n    realm: Realm,\n    targetFunction: ObjectValue,\n    boundThis: Value,\n    boundArgs: Array<Value>\n  ): ObjectValue,\n\n  // ECMA262 18.2.1.1\n  PerformEval(realm: Realm, x: Value, evalRealm: Realm, strictCaller: boolean, direct: boolean): Value,\n\n  // If c is an abrupt completion and realm.savedCompletion is defined, the result is an instance of\n  // JoinedAbruptCompletions and the effects that have been captured since the PossiblyNormalCompletion instance\n  // in realm.savedCompletion has been created, becomes the effects of the branch that terminates in c.\n  // If c is a normal completion, the result is realm.savedCompletion, with its value updated to c.\n  // If c is undefined, the result is just realm.savedCompletion.\n  // Call this only when a join point has been reached.\n  incorporateSavedCompletion(realm: Realm, c: void | AbruptCompletion | Value): void | Completion | Value,\n\n  EvaluateStatements(\n    body: Array<BabelNodeStatement>,\n    initialBlockValue: void | Value,\n    strictCode: boolean,\n    blockEnv: LexicalEnvironment,\n    realm: Realm\n  ): Value,\n\n  PartiallyEvaluateStatements(\n    body: Array<BabelNodeStatement>,\n    blockValue: void | NormalCompletion | Value,\n    strictCode: boolean,\n    blockEnv: LexicalEnvironment,\n    realm: Realm\n  ): [Completion | Value, Array<BabelNodeStatement>],\n\n  // ECMA262 9.2.5\n  FunctionCreate(\n    realm: Realm,\n    kind: \"normal\" | \"arrow\" | \"method\",\n    ParameterList: Array<BabelNodeLVal>,\n    Body: BabelNodeBlockStatement,\n    Scope: LexicalEnvironment,\n    Strict: boolean,\n    prototype?: ObjectValue\n  ): ECMAScriptSourceFunctionValue,\n\n  // ECMA262 18.2.1.2\n  EvalDeclarationInstantiation(\n    realm: Realm,\n    body: BabelNodeBlockStatement,\n    varEnv: LexicalEnvironment,\n    lexEnv: LexicalEnvironment,\n    strict: boolean\n  ): Value,\n\n  // ECMA 9.2.10\n  MakeMethod(realm: Realm, F: ECMAScriptSourceFunctionValue, homeObject: ObjectValue): Value,\n\n  // ECMA 14.3.8\n  DefineMethod(\n    realm: Realm,\n    prop: BabelNodeObjectMethod | BabelNodeClassMethod,\n    obj: ObjectValue,\n    env: LexicalEnvironment,\n    strictCode: boolean,\n    functionPrototype?: ObjectValue\n  ): { $Key: PropertyKeyValue, $Closure: ECMAScriptSourceFunctionValue },\n};\n\nexport type EnvironmentType = {\n  // ECMA262 6.2.3\n  // IsSuperReference(V). Returns true if this reference has a thisValue component.\n  IsSuperReference(realm: Realm, V: Reference): boolean,\n\n  // ECMA262 6.2.3\n  // HasPrimitiveBase(V). Returns true if Type(base) is Boolean, String, Symbol, or Number.\n  HasPrimitiveBase(realm: Realm, V: Reference): boolean,\n\n  // ECMA262 6.2.3\n  // GetReferencedName(V). Returns the referenced name component of the reference V.\n  GetReferencedName(realm: Realm, V: Reference): string | SymbolValue,\n\n  GetReferencedNamePartial(realm: Realm, V: Reference): AbstractValue | string | SymbolValue,\n\n  // ECMA262 6.2.3.1\n  GetValue(realm: Realm, V: Reference | Value): Value,\n  GetConditionValue(realm: Realm, V: Reference | Value): Value,\n\n  // ECMA262 6.2.3\n  // IsStrictReference(V). Returns the strict reference flag component of the reference V.\n  IsStrictReference(realm: Realm, V: Reference): boolean,\n\n  // ECMA262 6.2.3\n  // IsPropertyReference(V). Returns true if either the base value is an object or HasPrimitiveBase(V) is true; otherwise returns false.\n  IsPropertyReference(realm: Realm, V: Reference): boolean,\n\n  // ECMA262 6.2.3\n  // GetBase(V). Returns the base value component of the reference V.\n  GetBase(realm: Realm, V: Reference): void | Value | EnvironmentRecord,\n\n  // ECMA262 6.2.3\n  // IsUnresolvableReference(V). Returns true if the base value is undefined and false otherwise.\n  IsUnresolvableReference(realm: Realm, V: Reference): boolean,\n\n  // ECMA262 8.1.2.2\n  NewDeclarativeEnvironment(realm: Realm, E: LexicalEnvironment): LexicalEnvironment,\n\n  BoundNames(realm: Realm, node: BabelNode): Array<string>,\n\n  // ECMA262 13.3.3.2\n  ContainsExpression(realm: Realm, node: ?BabelNode): boolean,\n\n  // ECMA262 8.3.2\n  ResolveBinding(realm: Realm, name: string, strict: boolean, env?: ?LexicalEnvironment): Reference,\n\n  // ECMA262 8.1.2.1\n  GetIdentifierReference(realm: Realm, lex: ?LexicalEnvironment, name: string, strict: boolean): Reference,\n\n  // ECMA262 6.2.3.4\n  InitializeReferencedBinding(realm: Realm, V: Reference, W: Value): Value,\n\n  // ECMA262 13.2.14\n  BlockDeclarationInstantiation(\n    realm: Realm,\n    strictCode: boolean,\n    body: Array<BabelNodeStatement>,\n    env: LexicalEnvironment\n  ): void,\n\n  // ECMA262 8.1.2.5\n  NewGlobalEnvironment(\n    realm: Realm,\n    G: ObjectValue | AbstractObjectValue,\n    thisValue: ObjectValue | AbstractObjectValue\n  ): void,\n\n  // ECMA262 8.1.2.3\n  NewObjectEnvironment(realm: Realm, O: ObjectValue | AbstractObjectValue, E: LexicalEnvironment): LexicalEnvironment,\n\n  // ECMA262 8.1.2.4\n  NewFunctionEnvironment(realm: Realm, F: ECMAScriptFunctionValue, newTarget?: ObjectValue): LexicalEnvironment,\n\n  // ECMA262 8.3.1\n  GetActiveScriptOrModule(realm: Realm): any,\n\n  // ECMA262 8.3.3\n  GetThisEnvironment(realm: Realm): EnvironmentRecord,\n\n  // ECMA262 8.3.4\n  ResolveThisBinding(realm: Realm): NullValue | ObjectValue | AbstractObjectValue | UndefinedValue,\n\n  BindingInitialization(\n    realm: Realm,\n    node: BabelNodeLVal | BabelNodeVariableDeclaration,\n    value: Value,\n    strictCode: boolean,\n    environment: void | LexicalEnvironment\n  ): void | boolean | Value,\n\n  // ECMA262 13.3.3.6\n  // ECMA262 14.1.19\n  IteratorBindingInitialization(\n    realm: Realm,\n    formals: $ReadOnlyArray<BabelNodeLVal | null>,\n    iteratorRecord: { $Iterator: ObjectValue, $Done: boolean },\n    strictCode: boolean,\n    environment: void | LexicalEnvironment\n  ): void,\n\n  // ECMA262 12.1.5.1\n  InitializeBoundName(\n    realm: Realm,\n    name: string,\n    value: Value,\n    environment: void | LexicalEnvironment\n  ): void | boolean | Value,\n\n  // ECMA262 12.3.1.3 and 13.7.5.6\n  IsDestructuring(ast: BabelNode): boolean,\n\n  // ECMA262 13.3.3.7\n  KeyedBindingInitialization(\n    realm: Realm,\n    node: BabelNodeIdentifier | BabelNodePattern,\n    value: Value,\n    strictCode: boolean,\n    environment: ?LexicalEnvironment,\n    propertyName: PropertyKeyValue\n  ): void | boolean | Value,\n};\n\nexport type JoinType = {\n  stopEffectCaptureJoinApplyAndReturnCompletion(\n    c1: PossiblyNormalCompletion,\n    c2: AbruptCompletion,\n    realm: Realm\n  ): AbruptCompletion,\n\n  unbundleNormalCompletion(\n    completionOrValue: Completion | Value | Reference\n  ): [void | NormalCompletion, Value | Reference],\n\n  composeNormalCompletions(\n    leftCompletion: void | NormalCompletion,\n    rightCompletion: void | NormalCompletion,\n    resultValue: Value,\n    realm: Realm\n  ): PossiblyNormalCompletion | Value,\n\n  composePossiblyNormalCompletions(\n    realm: Realm,\n    pnc: PossiblyNormalCompletion,\n    c: PossiblyNormalCompletion\n  ): PossiblyNormalCompletion,\n\n  updatePossiblyNormalCompletionWithSubsequentEffects(\n    realm: Realm,\n    pnc: PossiblyNormalCompletion,\n    subsequentEffects: Effects\n  ): void,\n\n  updatePossiblyNormalCompletionWithValue(realm: Realm, pnc: PossiblyNormalCompletion, v: Value): void,\n\n  // Returns the joined effects of all of the paths in pnc.\n  // The normal path in pnc is modified to become terminated by ac,\n  // so the overall completion will always be an instance of JoinedAbruptCompletions\n  joinPossiblyNormalCompletionWithAbruptCompletion(\n    realm: Realm,\n    // a forked path with a non abrupt (normal) component\n    pnc: PossiblyNormalCompletion,\n    // an abrupt completion that completes the normal path\n    ac: AbruptCompletion,\n    // effects collected after pnc was constructed\n    e: Effects\n  ): Effects,\n\n  joinPossiblyNormalCompletionWithValue(\n    realm: Realm,\n    joinCondition: AbstractValue,\n    pnc: PossiblyNormalCompletion,\n    v: Value\n  ): void,\n\n  joinValueWithPossiblyNormalCompletion(\n    realm: Realm,\n    joinCondition: AbstractValue,\n    pnc: PossiblyNormalCompletion,\n    v: Value\n  ): void,\n\n  joinAndRemoveNestedReturnCompletions(\n    realm: Realm,\n    c: AbruptCompletion\n  ): AbruptCompletion | PossiblyNormalCompletion | Value,\n\n  joinEffectsAndPromoteNestedReturnCompletions(\n    realm: Realm,\n    c: Completion | Value,\n    e: Effects,\n    nested_effects?: Effects\n  ): Effects,\n\n  unbundleReturnCompletion(realm: Realm, c: JoinedAbruptCompletions): [Effects, PossiblyNormalCompletion],\n\n  removeNormalEffects(realm: Realm, c: PossiblyNormalCompletion): Effects,\n\n  joinEffects(realm: Realm, joinCondition: AbstractValue, e1: Effects, e2: Effects): Effects,\n\n  joinResults(\n    realm: Realm,\n    joinCondition: AbstractValue,\n    result1: EvaluationResult,\n    result2: EvaluationResult,\n    e1: Effects,\n    e2: Effects\n  ): AbruptCompletion | PossiblyNormalCompletion | Value,\n\n  composeGenerators(realm: Realm, generator1: Generator, generator2: Generator): Generator,\n\n  // Creates a single map that joins together maps m1 and m2 using the given join\n  // operator. If an entry is present in one map but not the other, the missing\n  // entry is treated as if it were there and its value were undefined.\n  joinMaps<K, V>(m1: Map<K, void | V>, m2: Map<K, void | V>, join: (K, void | V, void | V) => V): Map<K, void | V>,\n\n  // Creates a single map that has an key, value pair for the union of the key\n  // sets of m1 and m2. The value of a pair is the join of m1[key] and m2[key]\n  // where the join is defined to be just m1[key] if m1[key] === m2[key] and\n  // and abstract value with expression \"joinCondition ? m1[key] : m2[key]\" if not.\n  joinBindings(realm: Realm, joinCondition: AbstractValue, m1: Bindings, m2: Bindings): Bindings,\n\n  // If v1 is known and defined and v1 === v2 return v1,\n  // otherwise return getAbstractValue(v1, v2)\n  joinValues(\n    realm: Realm,\n    v1: void | Value | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>,\n    v2: void | Value | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>,\n    getAbstractValue: (void | Value, void | Value) => Value\n  ): Value | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>,\n\n  joinValuesAsConditional(realm: Realm, condition: AbstractValue, v1: void | Value, v2: void | Value): Value,\n\n  joinPropertyBindings(\n    realm: Realm,\n    joinCondition: AbstractValue,\n    m1: PropertyBindings,\n    m2: PropertyBindings,\n    c1: CreatedObjects,\n    c2: CreatedObjects\n  ): PropertyBindings,\n\n  // Returns a field by field join of two descriptors.\n  // Descriptors with get/set are not yet supported.\n  joinDescriptors(\n    realm: Realm,\n    joinCondition: AbstractValue,\n    d1: void | Descriptor,\n    d2: void | Descriptor\n  ): void | Descriptor,\n};\n"]}