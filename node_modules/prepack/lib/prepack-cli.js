"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Copyright (c) 2017-present, Facebook, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * This source code is licensed under the BSD-style license found in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * LICENSE file in the root directory of this source tree. An additional grant
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * of patent rights can be found in the PATENTS file in the same directory.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */

/* eslint-disable no-shadow */

var _errors = require("./errors.js");

var _options = require("./options.js");

var _prepackNode = require("./prepack-node.js");

var _fs = require("fs");

var _fs2 = _interopRequireDefault(_fs);

var _v = require("v8");

var _v2 = _interopRequireDefault(_v);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Prepack helper
function run(Object, Array, console, JSON, process, prepackStdin, prepackFileSync, FatalError, CompatibilityValues, fs) {
  var HELP_STR = "\n    input                    The name of the file to run Prepack over (for web please provide the single js bundle file)\n    --out                    The name of the output file\n    --compatibility          The target environment for Prepack [" + CompatibilityValues.map(function (v) {
    return "\"" + v + "\"";
  }).join(", ") + "]\n    --mathRandomSeed         If you want Prepack to evaluate Math.random() calls, please provide a seed.\n    --srcmapIn               The input sourcemap filename. If present, Prepack will output a sourcemap that maps from\n                             the original file (pre-input sourcemap) to Prepack's output\n    --srcmapOut              The output sourcemap filename.\n    --maxStackDepth          Specify the maximum call stack depth.\n    --timeout                The amount of time in seconds until Prepack should time out.\n    --additionalFunctions    Additional functions that should be prepacked (comma separated).\n    --lazyObjectsRuntime     Enable lazy objects feature and specify the JS runtime that support this feature.\n    --debugNames             Changes the output of Prepack so that for named functions and variables that get emitted into\n                             Prepack's output, the original name is appended as a suffix to Prepack's generated identifier.\n    --speculate              Enable speculative initialization of modules (for the module system Prepack has builtin\n                             knowledge about). Prepack will try to execute all factory functions it is able to.\n    --trace                  Traces the order of module initialization.\n    --serialize              Serializes the partially evaluated global environment as a program that recreates it.\n                             (default = true)\n    --residual               Produces the residual program that results after constant folding.\n    --profile                Enables console logging of profile information of different phases of prepack.\n    --statsFile              The name of the output file where statistics will be written to.\n    --inlineExpressions      When generating code, tells prepack to avoid naming expressions when they are only used once,\n                             and instead inline them where they are used.\n    --omitInvariants         When generating code, tells prepack to omit writing invariants. (Invariants generated by default.)\n  ";
  var args = Array.from(process.argv);
  args.splice(0, 2);
  var inputFilenames = [];
  var outputFilename = void 0;
  var compatibility = void 0;
  var mathRandomSeed = void 0;
  var inputSourceMap = void 0;
  var outputSourceMap = void 0;
  var statsFileName = void 0;
  var maxStackDepth = void 0;
  var timeout = void 0;
  var additionalFunctions = void 0;
  var lazyObjectsRuntime = void 0;
  var debugInFilePath = void 0;
  var debugOutFilePath = void 0;
  var flags = {
    initializeMoreModules: false,
    trace: false,
    debugNames: false,
    omitInvariants: false,
    inlineExpressions: false,
    logStatistics: false,
    logModules: false,
    delayInitializations: false,
    delayUnsupportedRequires: false,
    internalDebug: false,
    debugScopes: false,
    serialize: false,
    residual: false,
    profile: false,
    reactEnabled: false
  };

  while (args.length) {
    var arg = args.shift();
    if (!arg.startsWith("--")) {
      inputFilenames.push(arg);
    } else {
      arg = arg.slice(2);
      switch (arg) {
        case "out":
          arg = args.shift();
          outputFilename = arg;
          break;
        case "compatibility":
          arg = args.shift();
          if (!CompatibilityValues.includes(arg)) {
            console.error("Unsupported compatibility: " + arg);
            process.exit(1);
          }
          compatibility = arg;
          break;
        case "mathRandomSeed":
          mathRandomSeed = args.shift();
          break;
        case "srcmapIn":
          inputSourceMap = args.shift();
          break;
        case "srcmapOut":
          outputSourceMap = args.shift();
          break;
        case "statsFile":
          statsFileName = args.shift();
          break;
        case "maxStackDepth":
          var value = args.shift();
          if (isNaN(value)) {
            console.error("Stack depth value must be a number");
            process.exit(1);
          }
          maxStackDepth = parseInt(value, 10);
          break;
        case "timeout":
          var seconds = args.shift();
          if (isNaN(seconds)) {
            console.error("Timeout must be a number");
            process.exit(1);
          }
          timeout = parseInt(seconds, 10) * 1000;
          break;
        case "additionalFunctions":
          var line = args.shift();
          additionalFunctions = line.split(",");
          break;
        case "debugInFilePath":
          debugInFilePath = args.shift();
          break;
        case "debugOutFilePath":
          debugOutFilePath = args.shift();
          break;
        case "lazyObjectsRuntime":
          lazyObjectsRuntime = args.shift();
          break;
        case "help":
          console.log("Usage: prepack.js [ -- | input.js ] [ --out output.js ] [ --compatibility jsc ] [ --mathRandomSeed seedvalue ] [ --srcmapIn inputMap ] [ --srcmapOut outputMap ] [ --maxStackDepth depthValue ] [ --timeout seconds ] [ --additionalFunctions fnc1,fnc2,... ] [ --lazyObjectsRuntime lazyObjectsRuntimeName]" + Object.keys(flags).map(function (s) {
            return "[ --" + s + "]";
          }).join(" ") + "\n" + HELP_STR);
          return;
        default:
          if (arg in flags) {
            flags[arg] = true;
          } else {
            console.error("Unknown option: " + arg);
            process.exit(1);
          }
      }
    }
  }
  if (!flags.serialize && !flags.residual) flags.serialize = true;

  var resolvedOptions = Object.assign({}, {
    compatibility: compatibility,
    mathRandomSeed: mathRandomSeed,
    inputSourceMapFilename: inputSourceMap,
    errorHandler: errorHandler,
    sourceMaps: !!outputSourceMap,
    maxStackDepth: maxStackDepth,
    timeout: timeout,
    additionalFunctions: additionalFunctions,
    lazyObjectsRuntime: lazyObjectsRuntime,
    enableDebugger: false, //always turn off debugger until debugger is fully built
    debugInFilePath: debugInFilePath,
    debugOutFilePath: debugOutFilePath
  }, flags);
  if (lazyObjectsRuntime && (resolvedOptions.additionalFunctions || resolvedOptions.delayInitializations || resolvedOptions.inlineExpressions)) {
    console.error("lazy objects feature is incompatible with additionalFunctions, delayInitializations and inlineExpressions options");
    process.exit(1);
  }

  var errors = new Map();
  function errorHandler(diagnostic) {
    if (diagnostic.location) errors.set(diagnostic.location, diagnostic);
    return "Recover";
  }

  try {
    if (inputFilenames.length === 0) {
      prepackStdin(resolvedOptions, processSerializedCode);
      return;
    }
    var serialized = prepackFileSync(inputFilenames, resolvedOptions);
    processSerializedCode(null, serialized);
  } catch (x) {
    console.log(x.message);
    console.log(x.stack);
    if (errors.size === 0) process.exit(1);
  } finally {
    if (errors.size > 0) {
      var foundFatal = false;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = errors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _ref = _step.value;

          var _ref2 = _slicedToArray(_ref, 2);

          var loc = _ref2[0];
          var error = _ref2[1];

          foundFatal = foundFatal || error.severity === "FatalError";
          console.log((loc.source || "") + "(" + loc.start.line + ":" + (loc.start.column + 1) + ") " + error.severity + " " + error.errorCode + ": " + error.message + (" (https://github.com/facebook/prepack/wiki/" + error.errorCode + ")"));
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      if (foundFatal) process.exit(1);
    }
  }

  function processSerializedCode(err, serialized) {
    if (err) {
      console.error(err);
      process.exit(1);
    }
    if (errors.size > 0) {
      console.log("Errors found while prepacking");
      var _foundFatal = false;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = errors[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _ref3 = _step2.value;

          var _ref4 = _slicedToArray(_ref3, 2);

          var _loc = _ref4[0];
          var _error = _ref4[1];

          _foundFatal = _foundFatal || _error.severity === "FatalError";
          console.log((_loc.source || "") + "(" + _loc.start.line + ":" + (_loc.start.column + 1) + ") " + _error.severity + " " + _error.errorCode + ": " + _error.message);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      if (_foundFatal) process.exit(1);
    }
    if (serialized) {
      if (serialized.code === "") {
        console.log("No source code to prepack.");
        return;
      }
      if (outputFilename) {
        console.log("Prepacked source code written to " + outputFilename + ".");
        fs.writeFileSync(outputFilename, serialized.code);
      } else {
        console.log(serialized.code);
      }
      if (statsFileName) {
        if (serialized.statistics === undefined || serialized.timingStats === undefined) {
          return;
        }
        var stats = {
          SerializerStatistics: serialized.statistics,
          TimingStatistics: serialized.timingStats,
          MemoryStatistics: _v2.default.getHeapStatistics()
        };
        fs.writeFileSync(statsFileName, JSON.stringify(stats));
      }
      if (outputSourceMap) {
        fs.writeFileSync(outputSourceMap, serialized.map ? JSON.stringify(serialized.map) : "");
      }
    }
  }

  return true;
}

if (typeof __residual === "function") {
  // If we're running inside of Prepack. This is the residual function we'll
  // want to leave untouched in the final program.
  __residual("boolean", run, Object, Array, console, JSON, process, _prepackNode.prepackStdin, _prepackNode.prepackFileSync, _errors.FatalError, _options.CompatibilityValues, _fs2.default);
} else {
  run(Object, Array, console, JSON, process, _prepackNode.prepackStdin, _prepackNode.prepackFileSync, _errors.FatalError, _options.CompatibilityValues, _fs2.default);
}
//# sourceMappingURL=prepack-cli.js.map