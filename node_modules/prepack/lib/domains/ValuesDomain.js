"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright (c) 2017-present, Facebook, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * This source code is licensed under the BSD-style license found in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * LICENSE file in the root directory of this source tree. An additional grant
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * of patent rights can be found in the PATENTS file in the same directory.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _completions = require("../completions.js");

var _errors = require("../errors.js");

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _index = require("../methods/index.js");

var _index2 = require("../values/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* An abstract domain that collects together a set of concrete values
   that might be the value of a variable at runtime.
   Initially, every variable has the value undefined.
   A property that has been weakly deleted will have more than
   one value, one of which will by the EmptyValue.  */

var ValuesDomain = function () {
  function ValuesDomain(values) {
    _classCallCheck(this, ValuesDomain);

    if (values instanceof _index2.ConcreteValue) {
      var valueSet = new Set();
      valueSet.add(values);
      values = valueSet;
    }
    this._elements = values;
  }

  _createClass(ValuesDomain, [{
    key: "isTop",
    value: function isTop() {
      return this._elements === undefined;
    }
  }, {
    key: "getElements",
    value: function getElements() {
      (0, _invariant2.default)(this._elements !== undefined);
      return this._elements;
    }

    // return a set of values that may be result of performing the given operation on each pair in the
    // Cartesian product of the value sets of the operands.

  }, {
    key: "includesValueNotOfType",
    value: function includesValueNotOfType(type) {
      (0, _invariant2.default)(!this.isTop());
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.getElements()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var cval = _step.value;

          if (!(cval instanceof type)) return true;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return false;
    }
  }, {
    key: "includesValueOfType",
    value: function includesValueOfType(type) {
      (0, _invariant2.default)(!this.isTop());
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.getElements()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var cval = _step2.value;

          if (cval instanceof type) return true;
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return false;
    }
  }, {
    key: "mightBeFalse",
    value: function mightBeFalse() {
      (0, _invariant2.default)(!this.isTop());
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this.getElements()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var cval = _step3.value;

          if (cval.mightBeFalse()) return true;
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      return false;
    }
  }, {
    key: "mightNotBeFalse",
    value: function mightNotBeFalse() {
      (0, _invariant2.default)(!this.isTop());
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = this.getElements()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var cval = _step4.value;

          if (cval.mightNotBeFalse()) return true;
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      return false;
    }
  }, {
    key: "joinWith",
    value: function joinWith(y) {
      if (this.isTop()) return this;
      var union = new Set(this.getElements());
      if (y instanceof _index2.AbstractValue) {
        if (y.values.isTop()) return y.values;
        y.values.getElements().forEach(function (v) {
          return union.add(v);
        });
      } else {
        (0, _invariant2.default)(y instanceof _index2.ConcreteValue);
        union.add(y);
      }
      return new ValuesDomain(union);
    }
  }, {
    key: "meetWith",
    value: function meetWith(y) {
      var intersection = new Set();
      var elements = this._elements;
      if (y instanceof _index2.AbstractValue) {
        if (y.values.isTop()) return this;
        y.values.getElements().forEach(function (v) {
          if (elements === undefined || elements.has(v)) intersection.add(v);
        });
      } else {
        (0, _invariant2.default)(y instanceof _index2.ConcreteValue);
        if (elements === undefined || elements.has(y)) intersection.add(y);
      }
      return new ValuesDomain(intersection);
    }
  }, {
    key: "promoteEmptyToUndefined",
    value: function promoteEmptyToUndefined() {
      if (this.isTop()) return this;
      var newSet = new Set();
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = this.getElements()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var cval = _step5.value;

          if (cval instanceof _index2.EmptyValue) newSet.add(cval.$Realm.intrinsics.undefined);else newSet.add(cval);
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      return new ValuesDomain(newSet);
    }
  }], [{
    key: "binaryOp",
    value: function binaryOp(realm, op, left, right) {
      var leftElements = left._elements;
      var rightElements = right._elements;
      // Return top if left and/or right are top or if the size of the value set would get to be quite large.
      // Note: the larger the set of values, the less we know and therefore the less we get value from computing
      // all of these values. TODO #1000: probably the upper bound can be quite a bit smaller.
      if (!leftElements || !rightElements || leftElements.size > 100 || rightElements.size > 100) return ValuesDomain.topVal;
      var resultSet = new Set();
      var savedHandler = realm.errorHandler;
      var savedIsReadOnly = realm.isReadOnly;
      realm.isReadOnly = true;
      try {
        realm.errorHandler = function () {
          throw new _errors.FatalError();
        };
        var _iteratorNormalCompletion6 = true;
        var _didIteratorError6 = false;
        var _iteratorError6 = undefined;

        try {
          for (var _iterator6 = leftElements[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
            var leftElem = _step6.value;
            var _iteratorNormalCompletion7 = true;
            var _didIteratorError7 = false;
            var _iteratorError7 = undefined;

            try {
              for (var _iterator7 = rightElements[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                var rightElem = _step7.value;

                var result = ValuesDomain.computeBinary(realm, op, leftElem, rightElem);
                (0, _invariant2.default)(result instanceof _index2.ConcreteValue);
                resultSet.add(result);
              }
            } catch (err) {
              _didIteratorError7 = true;
              _iteratorError7 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion7 && _iterator7.return) {
                  _iterator7.return();
                }
              } finally {
                if (_didIteratorError7) {
                  throw _iteratorError7;
                }
              }
            }
          }
        } catch (err) {
          _didIteratorError6 = true;
          _iteratorError6 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion6 && _iterator6.return) {
              _iterator6.return();
            }
          } finally {
            if (_didIteratorError6) {
              throw _iteratorError6;
            }
          }
        }
      } catch (e) {
        if (e instanceof _completions.AbruptCompletion) return ValuesDomain.topVal;
      } finally {
        realm.errorHandler = savedHandler;
        realm.isReadOnly = savedIsReadOnly;
      }
      return new ValuesDomain(resultSet);
    }

    // Note that calling this can result in user code running, which can side-effect the heap.
    // If that is not the desired behavior, mark the realm as read-only for the duration of the call.

  }, {
    key: "computeBinary",
    value: function computeBinary(realm, op, lval, rval) {
      if (op === "+") {
        // ECMA262 12.8.3 The Addition Operator
        var lprim = (0, _index.ToPrimitiveOrAbstract)(realm, lval);
        var rprim = (0, _index.ToPrimitiveOrAbstract)(realm, rval);

        if (lprim instanceof _index2.AbstractValue || rprim instanceof _index2.AbstractValue) {
          return _index2.AbstractValue.createFromBinaryOp(realm, op, lprim, rprim);
        }

        if (lprim instanceof _index2.StringValue || rprim instanceof _index2.StringValue) {
          var lstr = (0, _index.ToString)(realm, lprim);
          var rstr = (0, _index.ToString)(realm, rprim);
          return new _index2.StringValue(realm, lstr + rstr);
        }

        var lnum = (0, _index.ToNumber)(realm, lprim);
        var rnum = (0, _index.ToNumber)(realm, rprim);
        return (0, _index.Add)(realm, lnum, rnum);
      } else if (op === "<" || op === ">" || op === ">=" || op === "<=") {
        // ECMA262 12.10.3
        if (op === "<") {
          var r = (0, _index.AbstractRelationalComparison)(realm, lval, rval, true);
          if (r instanceof _index2.UndefinedValue) {
            return realm.intrinsics.false;
          } else {
            return r;
          }
        } else if (op === "<=") {
          var _r = (0, _index.AbstractRelationalComparison)(realm, rval, lval, false);
          if (_r instanceof _index2.UndefinedValue || _r instanceof _index2.BooleanValue && _r.value) {
            return realm.intrinsics.false;
          } else {
            return realm.intrinsics.true;
          }
        } else if (op === ">") {
          var _r2 = (0, _index.AbstractRelationalComparison)(realm, rval, lval, false);
          if (_r2 instanceof _index2.UndefinedValue) {
            return realm.intrinsics.false;
          } else {
            return _r2;
          }
        } else if (op === ">=") {
          var _r3 = (0, _index.AbstractRelationalComparison)(realm, lval, rval, true);
          if (_r3 instanceof _index2.UndefinedValue || _r3 instanceof _index2.BooleanValue && _r3.value) {
            return realm.intrinsics.false;
          } else {
            return realm.intrinsics.true;
          }
        }
      } else if (op === ">>>") {
        // ECMA262 12.9.5.1
        var _lnum = (0, _index.ToUint32)(realm, lval);
        var _rnum = (0, _index.ToUint32)(realm, rval);

        return new _index2.NumberValue(realm, _lnum >>> _rnum);
      } else if (op === "<<" || op === ">>") {
        var _lnum2 = (0, _index.ToInt32)(realm, lval);
        var _rnum2 = (0, _index.ToUint32)(realm, rval);

        if (op === "<<") {
          // ECMA262 12.9.3.1
          return new _index2.NumberValue(realm, _lnum2 << _rnum2);
        } else if (op === ">>") {
          // ECMA262 12.9.4.1
          return new _index2.NumberValue(realm, _lnum2 >> _rnum2);
        }
      } else if (op === "**") {
        // ECMA262 12.6.3

        // 5. Let base be ? ToNumber(leftValue).
        var base = (0, _index.ToNumber)(realm, lval);

        // 6. Let exponent be ? ToNumber(rightValue).
        var exponent = (0, _index.ToNumber)(realm, rval);

        // 7. Return the result of Applying the ** operator with base and exponent as specified in 12.7.3.4.
        return new _index2.NumberValue(realm, Math.pow(base, exponent));
      } else if (op === "%" || op === "/" || op === "*" || op === "-") {
        // ECMA262 12.7.3
        var _lnum3 = (0, _index.ToNumber)(realm, lval);
        var _rnum3 = (0, _index.ToNumber)(realm, rval);

        if (isNaN(_rnum3)) return realm.intrinsics.NaN;
        if (isNaN(_lnum3)) return realm.intrinsics.NaN;

        if (op === "-") {
          return (0, _index.Add)(realm, _lnum3, _rnum3, true);
        } else if (op === "%") {
          // The sign of the result equals the sign of the dividend.
          // If the dividend is an infinity, or the divisor is a zero, or both, the result is NaN.
          // If the dividend is finite and the divisor is an infinity, the result equals the dividend.
          // If the dividend is a zero and the divisor is nonzero and finite, the result is the same as the dividend.
          return new _index2.NumberValue(realm, _lnum3 % _rnum3);
        } else if (op === "/") {
          // The sign of the result is positive if both operands have the same sign, negative if the operands have different signs.
          // Division of an infinity by an infinity results in NaN.
          // Division of an infinity by a zero results in an infinity. The sign is determined by the rule already stated above.
          // Division of an infinity by a nonzero finite value results in a signed infinity. The sign is determined by the rule already stated above.
          // Division of a finite value by an infinity results in zero. The sign is determined by the rule already stated above.
          // Division of a zero by a zero results in NaN; division of zero by any other finite value results in zero, with the sign determined by the rule already stated above.
          // Division of a nonzero finite value by a zero results in a signed infinity. The sign is determined by the rule already stated above.
          return new _index2.NumberValue(realm, _lnum3 / _rnum3);
        } else if (op === "*") {
          // The sign of the result is positive if both operands have the same sign, negative if the operands have different signs.
          // Multiplication of an infinity by a zero results in NaN.
          // Multiplication of an infinity by an infinity results in an infinity. The sign is determined by the rule already stated above.
          // Multiplication of an infinity by a finite nonzero value results in a signed infinity. The sign is determined by the rule already stated above.
          return new _index2.NumberValue(realm, _lnum3 * _rnum3);
        }
      } else if (op === "!==") {
        return new _index2.BooleanValue(realm, !(0, _index.StrictEqualityComparison)(realm, lval, rval));
      } else if (op === "===") {
        return new _index2.BooleanValue(realm, (0, _index.StrictEqualityComparison)(realm, lval, rval));
      } else if (op === "!=") {
        return new _index2.BooleanValue(realm, !(0, _index.AbstractEqualityComparison)(realm, lval, rval));
      } else if (op === "==") {
        return new _index2.BooleanValue(realm, (0, _index.AbstractEqualityComparison)(realm, lval, rval));
      } else if (op === "&" || op === "|" || op === "^") {
        // ECMA262 12.12.3

        var _lnum4 = (0, _index.ToInt32)(realm, lval);

        // 6. Let rnum be ? ToInt32(rval).
        var _rnum4 = (0, _index.ToInt32)(realm, rval);

        // 7. Return the result of applying the bitwise operator @ to lnum and rnum. The result is a signed 32 bit integer.
        if (op === "&") {
          return new _index2.NumberValue(realm, _lnum4 & _rnum4);
        } else if (op === "|") {
          return new _index2.NumberValue(realm, _lnum4 | _rnum4);
        } else if (op === "^") {
          return new _index2.NumberValue(realm, _lnum4 ^ _rnum4);
        }
      } else if (op === "in") {
        // ECMA262 12.10.3

        // 5. If Type(rval) is not Object, throw a TypeError exception.
        if (!(rval instanceof _index2.ObjectValue)) {
          throw new _errors.FatalError();
        }

        // 6. Return ? HasProperty(rval, ToPropertyKey(lval)).
        return new _index2.BooleanValue(realm, (0, _index.HasProperty)(realm, rval, (0, _index.ToPropertyKey)(realm, lval)));
      } else if (op === "instanceof") {
        // ECMA262 12.10.3

        // 5. Return ? InstanceofOperator(lval, rval).;
        return new _index2.BooleanValue(realm, (0, _index.InstanceofOperator)(realm, lval, rval));
      }

      (0, _invariant2.default)(false, "unimplemented " + op);
    }
  }, {
    key: "logicalOp",
    value: function logicalOp(realm, op, left, right) {
      var leftElements = left._elements;
      var rightElements = right._elements;
      // Return top if left and/or right are top or if the size of the value set would get to be quite large.
      // Note: the larger the set of values, the less we know and therefore the less we get value from computing
      // all of these values. TODO #1000: probably the upper bound can be quite a bit smaller.
      if (!leftElements || !rightElements || leftElements.size > 100 || rightElements.size > 100) return ValuesDomain.topVal;
      var resultSet = new Set();
      var savedHandler = realm.errorHandler;
      var savedIsReadOnly = realm.isReadOnly;
      realm.isReadOnly = true;
      try {
        realm.errorHandler = function () {
          throw new _errors.FatalError();
        };
        var _iteratorNormalCompletion8 = true;
        var _didIteratorError8 = false;
        var _iteratorError8 = undefined;

        try {
          for (var _iterator8 = leftElements[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var leftElem = _step8.value;
            var _iteratorNormalCompletion9 = true;
            var _didIteratorError9 = false;
            var _iteratorError9 = undefined;

            try {
              for (var _iterator9 = rightElements[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
                var rightElem = _step9.value;

                var result = ValuesDomain.computeLogical(realm, op, leftElem, rightElem);
                (0, _invariant2.default)(result instanceof _index2.ConcreteValue);
                resultSet.add(result);
              }
            } catch (err) {
              _didIteratorError9 = true;
              _iteratorError9 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion9 && _iterator9.return) {
                  _iterator9.return();
                }
              } finally {
                if (_didIteratorError9) {
                  throw _iteratorError9;
                }
              }
            }
          }
        } catch (err) {
          _didIteratorError8 = true;
          _iteratorError8 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion8 && _iterator8.return) {
              _iterator8.return();
            }
          } finally {
            if (_didIteratorError8) {
              throw _iteratorError8;
            }
          }
        }
      } catch (e) {
        if (e instanceof _completions.AbruptCompletion) return ValuesDomain.topVal;
      } finally {
        realm.errorHandler = savedHandler;
        realm.isReadOnly = savedIsReadOnly;
      }
      return new ValuesDomain(resultSet);
    }

    // Note that calling this can result in user code running, which can side-effect the heap.
    // If that is not the desired behavior, mark the realm as read-only for the duration of the call.

  }, {
    key: "computeLogical",
    value: function computeLogical(realm, op, lval, rval) {
      var lbool = (0, _index.ToBoolean)(realm, lval);

      if (op === "&&") {
        // ECMA262 12.13.3
        if (lbool === false) return lval;
      } else if (op === "||") {
        // ECMA262 12.13.3
        if (lbool === true) return lval;
      }
      return rval;
    }

    // Note that calling this can result in user code running, which can side-effect the heap.
    // If that is not the desired behavior, mark the realm as read-only for the duration of the call.

  }, {
    key: "computeUnary",
    value: function computeUnary(realm, op, value) {
      if (op === "+") {
        // ECMA262 12.5.6.1
        // 1. Let expr be the result of evaluating UnaryExpression.
        // 2. Return ? ToNumber(? GetValue(expr)).
        return new _index2.NumberValue(realm, (0, _index.ToNumber)(realm, value));
      } else if (op === "-") {
        // ECMA262 12.5.7.1
        // 1. Let expr be the result of evaluating UnaryExpression.
        // 2. Let oldValue be ? ToNumber(? GetValue(expr)).
        var oldValue = (0, _index.ToNumber)(realm, value);

        // 3. If oldValue is NaN, return NaN.
        if (isNaN(oldValue)) {
          return realm.intrinsics.NaN;
        }

        // 4. Return the result of negating oldValue; that is, compute a Number with the same magnitude but opposite sign.
        return new _index2.NumberValue(realm, -oldValue);
      } else if (op === "~") {
        // ECMA262 12.5.8
        // 1. Let expr be the result of evaluating UnaryExpression.
        // 2. Let oldValue be ? ToInt32(? GetValue(expr)).
        var _oldValue = (0, _index.ToInt32)(realm, value);

        // 3. Return the result of applying bitwise complement to oldValue. The result is a signed 32-bit integer.
        return new _index2.NumberValue(realm, ~_oldValue);
      } else if (op === "!") {
        // ECMA262 12.6.9
        // 1. Let expr be the result of evaluating UnaryExpression.
        // 2. Let oldValue be ToBoolean(? GetValue(expr)).
        var _oldValue2 = (0, _index.ToBoolean)(realm, value);

        // 3. If oldValue is true, return false.
        if (_oldValue2 === true) return realm.intrinsics.false;

        // 4. Return true.
        return realm.intrinsics.true;
      } else if (op === "void") {
        // 1. Let expr be the result of evaluating UnaryExpression.
        // 2. Perform ? GetValue(expr).
        // 3. Return undefined.
        return realm.intrinsics.undefined;
      } else if (op === "typeof") {
        var isInstance = function isInstance(proto, Constructor) {
          return proto instanceof Constructor || proto === Constructor.prototype;
        };
        // ECMA262 12.6.5
        // 1. Let val be the result of evaluating UnaryExpression.
        // 2. If Type(val) is Reference, then
        // 3. Let val be ? GetValue(val).


        var val = value;
        // 4. Return a String according to Table 35.
        var proto = val.getType().prototype;
        if (isInstance(proto, _index2.UndefinedValue)) {
          return new _index2.StringValue(realm, "undefined");
        } else if (isInstance(proto, _index2.NullValue)) {
          return new _index2.StringValue(realm, "object");
        } else if (isInstance(proto, _index2.StringValue)) {
          return new _index2.StringValue(realm, "string");
        } else if (isInstance(proto, _index2.BooleanValue)) {
          return new _index2.StringValue(realm, "boolean");
        } else if (isInstance(proto, _index2.NumberValue)) {
          return new _index2.StringValue(realm, "number");
        } else if (isInstance(proto, _index2.SymbolValue)) {
          return new _index2.StringValue(realm, "symbol");
        } else if (isInstance(proto, _index2.ObjectValue)) {
          if ((0, _index.IsCallable)(realm, val)) {
            return new _index2.StringValue(realm, "function");
          }
          return new _index2.StringValue(realm, "object");
        } else {
          (0, _invariant2.default)(false);
        }
      } else {
        (0, _invariant2.default)(op === "delete");
        // ECMA262 12.5.3.2
        // 1. Let ref be the result of evaluating UnaryExpression.
        // 2. ReturnIfAbrupt(ref).
        // 3. If Type(ref) is not Reference, return true.
        return realm.intrinsics.true;
      }
    }
  }, {
    key: "unaryOp",
    value: function unaryOp(realm, op, operandValues) {
      var operandElements = operandValues._elements;
      if (operandElements === undefined) return ValuesDomain.topVal;
      var resultSet = new Set();
      var savedHandler = realm.errorHandler;
      var savedIsReadOnly = realm.isReadOnly;
      realm.isReadOnly = true;
      try {
        realm.errorHandler = function () {
          throw new _errors.FatalError();
        };
        var _iteratorNormalCompletion10 = true;
        var _didIteratorError10 = false;
        var _iteratorError10 = undefined;

        try {
          for (var _iterator10 = operandElements[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
            var operandElem = _step10.value;

            var result = ValuesDomain.computeUnary(realm, op, operandElem);
            (0, _invariant2.default)(result instanceof _index2.ConcreteValue);
            resultSet.add(result);
          }
        } catch (err) {
          _didIteratorError10 = true;
          _iteratorError10 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion10 && _iterator10.return) {
              _iterator10.return();
            }
          } finally {
            if (_didIteratorError10) {
              throw _iteratorError10;
            }
          }
        }
      } catch (e) {
        if (e instanceof _completions.AbruptCompletion) return ValuesDomain.topVal;
      } finally {
        realm.errorHandler = savedHandler;
        realm.isReadOnly = savedIsReadOnly;
      }
      return new ValuesDomain(resultSet);
    }
  }, {
    key: "joinValues",
    value: function joinValues(realm, v1, v2) {
      if (v1 === undefined) v1 = realm.intrinsics.undefined;
      if (v2 === undefined) v2 = realm.intrinsics.undefined;
      if (v1 instanceof _index2.AbstractValue) return v1.values.joinWith(v2);
      if (v2 instanceof _index2.AbstractValue) return v2.values.joinWith(v1);
      var union = new Set();
      (0, _invariant2.default)(v1 instanceof _index2.ConcreteValue);
      union.add(v1);
      (0, _invariant2.default)(v2 instanceof _index2.ConcreteValue);
      union.add(v2);
      return new ValuesDomain(union);
    }
  }, {
    key: "meetValues",
    value: function meetValues(realm, v1, v2) {
      if (v1 === undefined) v1 = realm.intrinsics.undefined;
      if (v2 === undefined) v2 = realm.intrinsics.undefined;
      if (v1 instanceof _index2.AbstractValue) return v1.values.meetWith(v2);
      if (v2 instanceof _index2.AbstractValue) return v2.values.meetWith(v1);
      var intersection = new Set();
      (0, _invariant2.default)(v1 instanceof _index2.ConcreteValue);
      (0, _invariant2.default)(v2 instanceof _index2.ConcreteValue);
      if (v1 === v2) intersection.add(v1);
      return new ValuesDomain(intersection);
    }
  }]);

  return ValuesDomain;
}();

ValuesDomain.topVal = new ValuesDomain(undefined);
exports.default = ValuesDomain;
//# sourceMappingURL=ValuesDomain.js.map