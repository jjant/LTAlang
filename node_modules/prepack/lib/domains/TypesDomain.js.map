{"version":3,"sources":["../../src/domains/TypesDomain.js"],"names":["TypesDomain","type","_type","undefined","t","getType","isTypeCompatibleWith","topVal","op","left","right","lType","rType","resultType","v1","v2","types","joinWith"],"mappings":"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","file":"TypesDomain.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport invariant from \"../invariant.js\";\nimport type { BabelBinaryOperator, BabelNodeLogicalOperator, BabelUnaryOperator } from \"babel-types\";\nimport {\n  AbstractValue,\n  BooleanValue,\n  ConcreteValue,\n  FunctionValue,\n  NumberValue,\n  ObjectValue,\n  PrimitiveValue,\n  StringValue,\n  UndefinedValue,\n  Value,\n} from \"../values/index.js\";\n\n/* An abstract domain for the type of value a variable might have.  */\n\nexport default class TypesDomain {\n  constructor(type: void | typeof Value) {\n    invariant(type !== ConcreteValue, \"Concrete values must be specific\");\n    this._type = type === Value ? undefined : type;\n  }\n\n  static topVal: TypesDomain = new TypesDomain(undefined);\n\n  _type: void | typeof Value;\n\n  getType(): typeof Value {\n    return this._type || Value;\n  }\n\n  // return the type of the result in the case where there is no exception\n  static binaryOp(op: BabelBinaryOperator, left: TypesDomain, right: TypesDomain): TypesDomain {\n    //todo #999: goto top only if op === \"+\"\n    let lType = left._type;\n    let rType = right._type;\n    if (lType === undefined || rType === undefined) return TypesDomain.topVal;\n    let resultType = Value;\n    switch (op) {\n      case \"+\":\n        if (Value.isTypeCompatibleWith(lType, StringValue) || Value.isTypeCompatibleWith(rType, StringValue))\n          resultType = StringValue;\n        else if (Value.isTypeCompatibleWith(lType, NumberValue) && Value.isTypeCompatibleWith(rType, NumberValue))\n          resultType = NumberValue;\n        break;\n      case \"<\":\n      case \">\":\n      case \">=\":\n      case \"<=\":\n      case \"!=\":\n      case \"==\":\n      case \"!==\":\n      case \"===\":\n      case \"in\":\n      case \"instanceof\":\n        resultType = BooleanValue;\n        break;\n      case \">>>\":\n      case \"<<\":\n      case \">>\":\n      case \"&\":\n      case \"|\":\n      case \"^\":\n      case \"**\":\n      case \"%\":\n      case \"/\":\n      case \"*\":\n      case \"-\":\n        resultType = NumberValue;\n        break;\n      default:\n        invariant(false);\n    }\n    return new TypesDomain(resultType);\n  }\n\n  static joinValues(v1: void | Value, v2: void | Value): TypesDomain {\n    if (v1 === undefined && v2 === undefined) return new TypesDomain(UndefinedValue);\n    if (v1 === undefined || v2 === undefined) return TypesDomain.topVal;\n    if (v1 instanceof AbstractValue) return v1.types.joinWith(v2.getType());\n    if (v2 instanceof AbstractValue) return v2.types.joinWith(v1.getType());\n    return new TypesDomain(v1.getType()).joinWith(v2.getType());\n  }\n\n  joinWith(t: typeof Value): TypesDomain {\n    let type = this.getType();\n    if (type === t) return this;\n    if (Value.isTypeCompatibleWith(type, FunctionValue) && Value.isTypeCompatibleWith(t, FunctionValue)) {\n      return new TypesDomain(FunctionValue);\n    }\n    if (Value.isTypeCompatibleWith(type, ObjectValue) && Value.isTypeCompatibleWith(t, ObjectValue)) {\n      return new TypesDomain(ObjectValue);\n    }\n    if (Value.isTypeCompatibleWith(type, PrimitiveValue) && Value.isTypeCompatibleWith(t, PrimitiveValue)) {\n      return new TypesDomain(PrimitiveValue);\n    }\n    return TypesDomain.topVal;\n  }\n\n  static logicalOp(op: BabelNodeLogicalOperator, left: TypesDomain, right: TypesDomain): TypesDomain {\n    return left.joinWith(right.getType());\n  }\n\n  // return the type of the result in the case where there is no exception\n  // note that the type of the operand has no influence on the type of the non exceptional result\n  static unaryOp(op: BabelUnaryOperator): TypesDomain {\n    let resultType = Value;\n    switch (op) {\n      case \"-\":\n      case \"+\":\n      case \"~\":\n        resultType = NumberValue;\n        break;\n      case \"!\":\n      case \"delete\":\n        resultType = BooleanValue;\n        break;\n      case \"typeof\":\n        resultType = StringValue;\n        break;\n      case \"void\":\n        resultType = UndefinedValue;\n        break;\n      default:\n        invariant(false);\n    }\n    return new TypesDomain(resultType);\n  }\n}\n"]}