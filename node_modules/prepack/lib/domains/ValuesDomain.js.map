{"version":3,"sources":["../../src/domains/ValuesDomain.js"],"names":["ValuesDomain","values","valueSet","Set","add","_elements","undefined","type","isTop","getElements","cval","mightBeFalse","mightNotBeFalse","y","union","forEach","v","intersection","elements","has","newSet","$Realm","intrinsics","realm","op","left","right","leftElements","rightElements","size","topVal","resultSet","savedHandler","errorHandler","savedIsReadOnly","isReadOnly","leftElem","rightElem","result","computeBinary","e","lval","rval","lprim","rprim","createFromBinaryOp","lstr","rstr","lnum","rnum","r","false","value","true","base","exponent","Math","pow","isNaN","NaN","computeLogical","lbool","oldValue","isInstance","proto","Constructor","prototype","val","getType","operandValues","operandElements","operandElem","computeUnary","v1","v2","joinWith","meetWith"],"mappings":"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","file":"ValuesDomain.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { BabelBinaryOperator, BabelNodeLogicalOperator, BabelUnaryOperator } from \"babel-types\";\nimport { AbruptCompletion } from \"../completions.js\";\nimport { FatalError } from \"../errors.js\";\nimport invariant from \"../invariant.js\";\nimport {\n  AbstractEqualityComparison,\n  AbstractRelationalComparison,\n  Add,\n  HasProperty,\n  InstanceofOperator,\n  IsCallable,\n  StrictEqualityComparison,\n  ToBoolean,\n  ToInt32,\n  ToNumber,\n  ToPrimitiveOrAbstract,\n  ToPropertyKey,\n  ToString,\n  ToUint32,\n} from \"../methods/index.js\";\nimport type { Realm } from \"../realm.js\";\nimport {\n  AbstractValue,\n  BooleanValue,\n  ConcreteValue,\n  EmptyValue,\n  NullValue,\n  NumberValue,\n  ObjectValue,\n  StringValue,\n  SymbolValue,\n  UndefinedValue,\n  Value,\n} from \"../values/index.js\";\n\n/* An abstract domain that collects together a set of concrete values\n   that might be the value of a variable at runtime.\n   Initially, every variable has the value undefined.\n   A property that has been weakly deleted will have more than\n   one value, one of which will by the EmptyValue.  */\n\nexport default class ValuesDomain {\n  constructor(values: void | Set<ConcreteValue> | ConcreteValue) {\n    if (values instanceof ConcreteValue) {\n      let valueSet = new Set();\n      valueSet.add(values);\n      values = valueSet;\n    }\n    this._elements = values;\n  }\n\n  static topVal = new ValuesDomain(undefined);\n\n  _elements: void | Set<ConcreteValue>;\n\n  isTop() {\n    return this._elements === undefined;\n  }\n\n  getElements() {\n    invariant(this._elements !== undefined);\n    return this._elements;\n  }\n\n  // return a set of values that may be result of performing the given operation on each pair in the\n  // Cartesian product of the value sets of the operands.\n  static binaryOp(realm: Realm, op: BabelBinaryOperator, left: ValuesDomain, right: ValuesDomain): ValuesDomain {\n    let leftElements = left._elements;\n    let rightElements = right._elements;\n    // Return top if left and/or right are top or if the size of the value set would get to be quite large.\n    // Note: the larger the set of values, the less we know and therefore the less we get value from computing\n    // all of these values. TODO #1000: probably the upper bound can be quite a bit smaller.\n    if (!leftElements || !rightElements || leftElements.size > 100 || rightElements.size > 100)\n      return ValuesDomain.topVal;\n    let resultSet = new Set();\n    let savedHandler = realm.errorHandler;\n    let savedIsReadOnly = realm.isReadOnly;\n    realm.isReadOnly = true;\n    try {\n      realm.errorHandler = () => {\n        throw new FatalError();\n      };\n      for (let leftElem of leftElements) {\n        for (let rightElem of rightElements) {\n          let result = ValuesDomain.computeBinary(realm, op, leftElem, rightElem);\n          invariant(result instanceof ConcreteValue);\n          resultSet.add(result);\n        }\n      }\n    } catch (e) {\n      if (e instanceof AbruptCompletion) return ValuesDomain.topVal;\n    } finally {\n      realm.errorHandler = savedHandler;\n      realm.isReadOnly = savedIsReadOnly;\n    }\n    return new ValuesDomain(resultSet);\n  }\n\n  // Note that calling this can result in user code running, which can side-effect the heap.\n  // If that is not the desired behavior, mark the realm as read-only for the duration of the call.\n  static computeBinary(realm: Realm, op: BabelBinaryOperator, lval: ConcreteValue, rval: ConcreteValue): Value {\n    if (op === \"+\") {\n      // ECMA262 12.8.3 The Addition Operator\n      let lprim = ToPrimitiveOrAbstract(realm, lval);\n      let rprim = ToPrimitiveOrAbstract(realm, rval);\n\n      if (lprim instanceof AbstractValue || rprim instanceof AbstractValue) {\n        return AbstractValue.createFromBinaryOp(realm, op, lprim, rprim);\n      }\n\n      if (lprim instanceof StringValue || rprim instanceof StringValue) {\n        let lstr = ToString(realm, lprim);\n        let rstr = ToString(realm, rprim);\n        return new StringValue(realm, lstr + rstr);\n      }\n\n      let lnum = ToNumber(realm, lprim);\n      let rnum = ToNumber(realm, rprim);\n      return Add(realm, lnum, rnum);\n    } else if (op === \"<\" || op === \">\" || op === \">=\" || op === \"<=\") {\n      // ECMA262 12.10.3\n      if (op === \"<\") {\n        let r = AbstractRelationalComparison(realm, lval, rval, true);\n        if (r instanceof UndefinedValue) {\n          return realm.intrinsics.false;\n        } else {\n          return r;\n        }\n      } else if (op === \"<=\") {\n        let r = AbstractRelationalComparison(realm, rval, lval, false);\n        if (r instanceof UndefinedValue || (r instanceof BooleanValue && r.value)) {\n          return realm.intrinsics.false;\n        } else {\n          return realm.intrinsics.true;\n        }\n      } else if (op === \">\") {\n        let r = AbstractRelationalComparison(realm, rval, lval, false);\n        if (r instanceof UndefinedValue) {\n          return realm.intrinsics.false;\n        } else {\n          return r;\n        }\n      } else if (op === \">=\") {\n        let r = AbstractRelationalComparison(realm, lval, rval, true);\n        if (r instanceof UndefinedValue || (r instanceof BooleanValue && r.value)) {\n          return realm.intrinsics.false;\n        } else {\n          return realm.intrinsics.true;\n        }\n      }\n    } else if (op === \">>>\") {\n      // ECMA262 12.9.5.1\n      let lnum = ToUint32(realm, lval);\n      let rnum = ToUint32(realm, rval);\n\n      return new NumberValue(realm, lnum >>> rnum);\n    } else if (op === \"<<\" || op === \">>\") {\n      let lnum = ToInt32(realm, lval);\n      let rnum = ToUint32(realm, rval);\n\n      if (op === \"<<\") {\n        // ECMA262 12.9.3.1\n        return new NumberValue(realm, lnum << rnum);\n      } else if (op === \">>\") {\n        // ECMA262 12.9.4.1\n        return new NumberValue(realm, lnum >> rnum);\n      }\n    } else if (op === \"**\") {\n      // ECMA262 12.6.3\n\n      // 5. Let base be ? ToNumber(leftValue).\n      let base = ToNumber(realm, lval);\n\n      // 6. Let exponent be ? ToNumber(rightValue).\n      let exponent = ToNumber(realm, rval);\n\n      // 7. Return the result of Applying the ** operator with base and exponent as specified in 12.7.3.4.\n      return new NumberValue(realm, Math.pow(base, exponent));\n    } else if (op === \"%\" || op === \"/\" || op === \"*\" || op === \"-\") {\n      // ECMA262 12.7.3\n      let lnum = ToNumber(realm, lval);\n      let rnum = ToNumber(realm, rval);\n\n      if (isNaN(rnum)) return realm.intrinsics.NaN;\n      if (isNaN(lnum)) return realm.intrinsics.NaN;\n\n      if (op === \"-\") {\n        return Add(realm, lnum, rnum, true);\n      } else if (op === \"%\") {\n        // The sign of the result equals the sign of the dividend.\n        // If the dividend is an infinity, or the divisor is a zero, or both, the result is NaN.\n        // If the dividend is finite and the divisor is an infinity, the result equals the dividend.\n        // If the dividend is a zero and the divisor is nonzero and finite, the result is the same as the dividend.\n        return new NumberValue(realm, lnum % rnum);\n      } else if (op === \"/\") {\n        // The sign of the result is positive if both operands have the same sign, negative if the operands have different signs.\n        // Division of an infinity by an infinity results in NaN.\n        // Division of an infinity by a zero results in an infinity. The sign is determined by the rule already stated above.\n        // Division of an infinity by a nonzero finite value results in a signed infinity. The sign is determined by the rule already stated above.\n        // Division of a finite value by an infinity results in zero. The sign is determined by the rule already stated above.\n        // Division of a zero by a zero results in NaN; division of zero by any other finite value results in zero, with the sign determined by the rule already stated above.\n        // Division of a nonzero finite value by a zero results in a signed infinity. The sign is determined by the rule already stated above.\n        return new NumberValue(realm, lnum / rnum);\n      } else if (op === \"*\") {\n        // The sign of the result is positive if both operands have the same sign, negative if the operands have different signs.\n        // Multiplication of an infinity by a zero results in NaN.\n        // Multiplication of an infinity by an infinity results in an infinity. The sign is determined by the rule already stated above.\n        // Multiplication of an infinity by a finite nonzero value results in a signed infinity. The sign is determined by the rule already stated above.\n        return new NumberValue(realm, lnum * rnum);\n      }\n    } else if (op === \"!==\") {\n      return new BooleanValue(realm, !StrictEqualityComparison(realm, lval, rval));\n    } else if (op === \"===\") {\n      return new BooleanValue(realm, StrictEqualityComparison(realm, lval, rval));\n    } else if (op === \"!=\") {\n      return new BooleanValue(realm, !AbstractEqualityComparison(realm, lval, rval));\n    } else if (op === \"==\") {\n      return new BooleanValue(realm, AbstractEqualityComparison(realm, lval, rval));\n    } else if (op === \"&\" || op === \"|\" || op === \"^\") {\n      // ECMA262 12.12.3\n\n      // 5. Let lnum be ? ToInt32(lval).\n      let lnum: number = ToInt32(realm, lval);\n\n      // 6. Let rnum be ? ToInt32(rval).\n      let rnum: number = ToInt32(realm, rval);\n\n      // 7. Return the result of applying the bitwise operator @ to lnum and rnum. The result is a signed 32 bit integer.\n      if (op === \"&\") {\n        return new NumberValue(realm, lnum & rnum);\n      } else if (op === \"|\") {\n        return new NumberValue(realm, lnum | rnum);\n      } else if (op === \"^\") {\n        return new NumberValue(realm, lnum ^ rnum);\n      }\n    } else if (op === \"in\") {\n      // ECMA262 12.10.3\n\n      // 5. If Type(rval) is not Object, throw a TypeError exception.\n      if (!(rval instanceof ObjectValue)) {\n        throw new FatalError();\n      }\n\n      // 6. Return ? HasProperty(rval, ToPropertyKey(lval)).\n      return new BooleanValue(realm, HasProperty(realm, rval, ToPropertyKey(realm, lval)));\n    } else if (op === \"instanceof\") {\n      // ECMA262 12.10.3\n\n      // 5. Return ? InstanceofOperator(lval, rval).;\n      return new BooleanValue(realm, InstanceofOperator(realm, lval, rval));\n    }\n\n    invariant(false, \"unimplemented \" + op);\n  }\n\n  static logicalOp(realm: Realm, op: BabelNodeLogicalOperator, left: ValuesDomain, right: ValuesDomain): ValuesDomain {\n    let leftElements = left._elements;\n    let rightElements = right._elements;\n    // Return top if left and/or right are top or if the size of the value set would get to be quite large.\n    // Note: the larger the set of values, the less we know and therefore the less we get value from computing\n    // all of these values. TODO #1000: probably the upper bound can be quite a bit smaller.\n    if (!leftElements || !rightElements || leftElements.size > 100 || rightElements.size > 100)\n      return ValuesDomain.topVal;\n    let resultSet = new Set();\n    let savedHandler = realm.errorHandler;\n    let savedIsReadOnly = realm.isReadOnly;\n    realm.isReadOnly = true;\n    try {\n      realm.errorHandler = () => {\n        throw new FatalError();\n      };\n      for (let leftElem of leftElements) {\n        for (let rightElem of rightElements) {\n          let result = ValuesDomain.computeLogical(realm, op, leftElem, rightElem);\n          invariant(result instanceof ConcreteValue);\n          resultSet.add(result);\n        }\n      }\n    } catch (e) {\n      if (e instanceof AbruptCompletion) return ValuesDomain.topVal;\n    } finally {\n      realm.errorHandler = savedHandler;\n      realm.isReadOnly = savedIsReadOnly;\n    }\n    return new ValuesDomain(resultSet);\n  }\n\n  // Note that calling this can result in user code running, which can side-effect the heap.\n  // If that is not the desired behavior, mark the realm as read-only for the duration of the call.\n  static computeLogical(realm: Realm, op: BabelNodeLogicalOperator, lval: ConcreteValue, rval: ConcreteValue): Value {\n    let lbool = ToBoolean(realm, lval);\n\n    if (op === \"&&\") {\n      // ECMA262 12.13.3\n      if (lbool === false) return lval;\n    } else if (op === \"||\") {\n      // ECMA262 12.13.3\n      if (lbool === true) return lval;\n    }\n    return rval;\n  }\n\n  // Note that calling this can result in user code running, which can side-effect the heap.\n  // If that is not the desired behavior, mark the realm as read-only for the duration of the call.\n  static computeUnary(realm: Realm, op: BabelUnaryOperator, value: ConcreteValue): Value {\n    if (op === \"+\") {\n      // ECMA262 12.5.6.1\n      // 1. Let expr be the result of evaluating UnaryExpression.\n      // 2. Return ? ToNumber(? GetValue(expr)).\n      return new NumberValue(realm, ToNumber(realm, value));\n    } else if (op === \"-\") {\n      // ECMA262 12.5.7.1\n      // 1. Let expr be the result of evaluating UnaryExpression.\n      // 2. Let oldValue be ? ToNumber(? GetValue(expr)).\n      let oldValue = ToNumber(realm, value);\n\n      // 3. If oldValue is NaN, return NaN.\n      if (isNaN(oldValue)) {\n        return realm.intrinsics.NaN;\n      }\n\n      // 4. Return the result of negating oldValue; that is, compute a Number with the same magnitude but opposite sign.\n      return new NumberValue(realm, -oldValue);\n    } else if (op === \"~\") {\n      // ECMA262 12.5.8\n      // 1. Let expr be the result of evaluating UnaryExpression.\n      // 2. Let oldValue be ? ToInt32(? GetValue(expr)).\n      let oldValue = ToInt32(realm, value);\n\n      // 3. Return the result of applying bitwise complement to oldValue. The result is a signed 32-bit integer.\n      return new NumberValue(realm, ~oldValue);\n    } else if (op === \"!\") {\n      // ECMA262 12.6.9\n      // 1. Let expr be the result of evaluating UnaryExpression.\n      // 2. Let oldValue be ToBoolean(? GetValue(expr)).\n      let oldValue = ToBoolean(realm, value);\n\n      // 3. If oldValue is true, return false.\n      if (oldValue === true) return realm.intrinsics.false;\n\n      // 4. Return true.\n      return realm.intrinsics.true;\n    } else if (op === \"void\") {\n      // 1. Let expr be the result of evaluating UnaryExpression.\n      // 2. Perform ? GetValue(expr).\n      // 3. Return undefined.\n      return realm.intrinsics.undefined;\n    } else if (op === \"typeof\") {\n      function isInstance(proto, Constructor): boolean {\n        return proto instanceof Constructor || proto === Constructor.prototype;\n      }\n      // ECMA262 12.6.5\n      // 1. Let val be the result of evaluating UnaryExpression.\n      // 2. If Type(val) is Reference, then\n      // 3. Let val be ? GetValue(val).\n      let val = value;\n      // 4. Return a String according to Table 35.\n      let proto = val.getType().prototype;\n      if (isInstance(proto, UndefinedValue)) {\n        return new StringValue(realm, \"undefined\");\n      } else if (isInstance(proto, NullValue)) {\n        return new StringValue(realm, \"object\");\n      } else if (isInstance(proto, StringValue)) {\n        return new StringValue(realm, \"string\");\n      } else if (isInstance(proto, BooleanValue)) {\n        return new StringValue(realm, \"boolean\");\n      } else if (isInstance(proto, NumberValue)) {\n        return new StringValue(realm, \"number\");\n      } else if (isInstance(proto, SymbolValue)) {\n        return new StringValue(realm, \"symbol\");\n      } else if (isInstance(proto, ObjectValue)) {\n        if (IsCallable(realm, val)) {\n          return new StringValue(realm, \"function\");\n        }\n        return new StringValue(realm, \"object\");\n      } else {\n        invariant(false);\n      }\n    } else {\n      invariant(op === \"delete\");\n      // ECMA262 12.5.3.2\n      // 1. Let ref be the result of evaluating UnaryExpression.\n      // 2. ReturnIfAbrupt(ref).\n      // 3. If Type(ref) is not Reference, return true.\n      return realm.intrinsics.true;\n    }\n  }\n\n  static unaryOp(realm: Realm, op: BabelUnaryOperator, operandValues: ValuesDomain): ValuesDomain {\n    let operandElements = operandValues._elements;\n    if (operandElements === undefined) return ValuesDomain.topVal;\n    let resultSet = new Set();\n    let savedHandler = realm.errorHandler;\n    let savedIsReadOnly = realm.isReadOnly;\n    realm.isReadOnly = true;\n    try {\n      realm.errorHandler = () => {\n        throw new FatalError();\n      };\n      for (let operandElem of operandElements) {\n        let result = ValuesDomain.computeUnary(realm, op, operandElem);\n        invariant(result instanceof ConcreteValue);\n        resultSet.add(result);\n      }\n    } catch (e) {\n      if (e instanceof AbruptCompletion) return ValuesDomain.topVal;\n    } finally {\n      realm.errorHandler = savedHandler;\n      realm.isReadOnly = savedIsReadOnly;\n    }\n    return new ValuesDomain(resultSet);\n  }\n\n  includesValueNotOfType(type: typeof Value): boolean {\n    invariant(!this.isTop());\n    for (let cval of this.getElements()) {\n      if (!(cval instanceof type)) return true;\n    }\n    return false;\n  }\n\n  includesValueOfType(type: typeof Value): boolean {\n    invariant(!this.isTop());\n    for (let cval of this.getElements()) {\n      if (cval instanceof type) return true;\n    }\n    return false;\n  }\n\n  mightBeFalse(): boolean {\n    invariant(!this.isTop());\n    for (let cval of this.getElements()) {\n      if (cval.mightBeFalse()) return true;\n    }\n    return false;\n  }\n\n  mightNotBeFalse(): boolean {\n    invariant(!this.isTop());\n    for (let cval of this.getElements()) {\n      if (cval.mightNotBeFalse()) return true;\n    }\n    return false;\n  }\n\n  static joinValues(realm: Realm, v1: void | Value, v2: void | Value): ValuesDomain {\n    if (v1 === undefined) v1 = realm.intrinsics.undefined;\n    if (v2 === undefined) v2 = realm.intrinsics.undefined;\n    if (v1 instanceof AbstractValue) return v1.values.joinWith(v2);\n    if (v2 instanceof AbstractValue) return v2.values.joinWith(v1);\n    let union = new Set();\n    invariant(v1 instanceof ConcreteValue);\n    union.add(v1);\n    invariant(v2 instanceof ConcreteValue);\n    union.add(v2);\n    return new ValuesDomain(union);\n  }\n\n  joinWith(y: Value): ValuesDomain {\n    if (this.isTop()) return this;\n    let union = new Set(this.getElements());\n    if (y instanceof AbstractValue) {\n      if (y.values.isTop()) return y.values;\n      y.values.getElements().forEach(v => union.add(v));\n    } else {\n      invariant(y instanceof ConcreteValue);\n      union.add(y);\n    }\n    return new ValuesDomain(union);\n  }\n\n  static meetValues(realm: Realm, v1: void | Value, v2: void | Value): ValuesDomain {\n    if (v1 === undefined) v1 = realm.intrinsics.undefined;\n    if (v2 === undefined) v2 = realm.intrinsics.undefined;\n    if (v1 instanceof AbstractValue) return v1.values.meetWith(v2);\n    if (v2 instanceof AbstractValue) return v2.values.meetWith(v1);\n    let intersection = new Set();\n    invariant(v1 instanceof ConcreteValue);\n    invariant(v2 instanceof ConcreteValue);\n    if (v1 === v2) intersection.add(v1);\n    return new ValuesDomain(intersection);\n  }\n\n  meetWith(y: Value): ValuesDomain {\n    let intersection = new Set();\n    let elements = this._elements;\n    if (y instanceof AbstractValue) {\n      if (y.values.isTop()) return this;\n      y.values.getElements().forEach(v => {\n        if (elements === undefined || elements.has(v)) intersection.add(v);\n      });\n    } else {\n      invariant(y instanceof ConcreteValue);\n      if (elements === undefined || elements.has(y)) intersection.add(y);\n    }\n    return new ValuesDomain(intersection);\n  }\n\n  promoteEmptyToUndefined(): ValuesDomain {\n    if (this.isTop()) return this;\n    let newSet = new Set();\n    for (let cval of this.getElements()) {\n      if (cval instanceof EmptyValue) newSet.add(cval.$Realm.intrinsics.undefined);\n      else newSet.add(cval);\n    }\n    return new ValuesDomain(newSet);\n  }\n}\n"]}