{"version":3,"sources":["../../src/methods/json.js"],"names":["InternalizeJSONProperty","realm","reviver","holder","name","val","isArray","I","len","newElement","$Delete","throwIfNotConcrete","keys","P"],"mappings":";;;;;QAuBgBA,uB,GAAAA,uB;;AAXhB;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;;;;;;AAEA;AACO,SAASA,uBAAT,CACLC,KADK,EAELC,OAFK,EAGLC,MAHK,EAILC,IAJK,EAKE;AACP;AACA,MAAIC,MAAM,cAAIJ,KAAJ,EAAWE,MAAX,EAAmBC,IAAnB,CAAV;AACA;AACA,MAAIC,iCAAJ,EAAgC;AAC9B;AACA,QAAIC,UAAU,iBAAQL,KAAR,EAAeI,GAAf,CAAd;;AAEA;AACA,QAAIC,YAAY,IAAhB,EAAsB;AACpB;AACA,UAAIC,IAAI,CAAR;;AAEA;AACA,UAAIC,MAAM,kBAASP,KAAT,EAAgB,cAAIA,KAAJ,EAAWI,GAAX,EAAgB,QAAhB,CAAhB,CAAV;;AAEA;AACA,aAAOE,IAAIC,GAAX,EAAgB;AACd;AACA,YAAIC,aAAaT,wBAAwBC,KAAxB,EAA+BC,OAA/B,EAAwCG,GAAxC,EAA6C,kBAASJ,KAAT,EAAgB,uBAAgBA,KAAhB,EAAuBM,CAAvB,CAAhB,CAA7C,CAAjB;;AAEA;AACA,YAAIE,2CAAJ,EAA0C;AACxC;AACAJ,cAAIK,OAAJ,CAAY,kBAAST,KAAT,EAAgB,uBAAgBA,KAAhB,EAAuBM,CAAvB,CAAhB,CAAZ;AACD,SAHD,MAGO;AACL;AACA;AACA,0CAAmBN,KAAnB,EAA0BI,GAA1B,EAA+B,kBAASJ,KAAT,EAAgB,uBAAgBA,KAAhB,EAAuBM,CAAvB,CAAhB,CAA/B,EAA2EE,WAAWE,kBAAX,EAA3E;;AAEA;AACD;;AAED;AACAJ,aAAK,CAAL;AACD;AACF,KA3BD,MA2BO;AACL;AACA;AACA,UAAIK,OAAO,kCAAwBX,KAAxB,EAA+BI,GAA/B,EAAoC,KAApC,CAAX;;AAEA;AALK;AAAA;AAAA;;AAAA;AAML,6BAAcO,IAAd,8HAAoB;AAAA,cAAXC,CAAW;;AAClB,mCAAUA,+BAAV;;AAEA;AACA,cAAIJ,cAAaT,wBAAwBC,KAAxB,EAA+BC,OAA/B,EAAwCG,GAAxC,EAA6CQ,CAA7C,CAAjB;;AAEA;AACA,cAAIJ,4CAAJ,EAA0C;AACxC;AACAJ,gBAAIK,OAAJ,CAAYG,CAAZ;AACD,WAHD,MAGO;AACL;AACA;AACA,4CAAmBZ,KAAnB,EAA0BI,GAA1B,EAA+BQ,CAA/B,EAAkCJ,WAAlC;;AAEA;AACD;AACF;AAvBI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAwBN;AACF;;AAED;AACA,SAAO,gBAAKR,KAAL,EAAYC,OAAZ,EAAqBC,MAArB,EAA6B,CAAC,OAAOC,IAAP,KAAgB,QAAhB,GAA2B,uBAAgBH,KAAhB,EAAuBG,IAAvB,CAA3B,GAA0DA,IAA3D,EAAiEC,GAAjE,CAA7B,CAAP;AACD,C,CA7FD","file":"json.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport { Value, ObjectValue, NumberValue, UndefinedValue, StringValue } from \"../values/index.js\";\nimport { CreateDataProperty } from \"../methods/create.js\";\nimport { Get } from \"../methods/get.js\";\nimport { Call } from \"../methods/call.js\";\nimport { IsArray } from \"../methods/is.js\";\nimport { ToLength, ToString } from \"../methods/to.js\";\nimport { EnumerableOwnProperties } from \"../methods/own.js\";\nimport type { PropertyKeyValue } from \"../types.js\";\nimport invariant from \"../invariant.js\";\n\n// ECMA262 24.3.1.1\nexport function InternalizeJSONProperty(\n  realm: Realm,\n  reviver: ObjectValue,\n  holder: ObjectValue,\n  name: PropertyKeyValue\n): Value {\n  // 1. Let val be ? Get(holder, name).\n  let val = Get(realm, holder, name);\n  // 2. If Type(val) is Object, then\n  if (val instanceof ObjectValue) {\n    // a. Let isArray be ? IsArray(val).\n    let isArray = IsArray(realm, val);\n\n    // b. If isArray is true, then\n    if (isArray === true) {\n      // i. Set I to 0.\n      let I = 0;\n\n      // ii. Let len be ? ToLength(? Get(val, \"length\")).\n      let len = ToLength(realm, Get(realm, val, \"length\"));\n\n      // iii. Repeat while I < len,\n      while (I < len) {\n        // 1. Let newElement be ? InternalizeJSONProperty(val, ! ToString(I)).\n        let newElement = InternalizeJSONProperty(realm, reviver, val, ToString(realm, new NumberValue(realm, I)));\n\n        // 2. If newElement is undefined, then\n        if (newElement instanceof UndefinedValue) {\n          // a. Perform ? val.[[Delete]](! ToString(I)).\n          val.$Delete(ToString(realm, new NumberValue(realm, I)));\n        } else {\n          // 3. Else,\n          // a. Perform ? CreateDataProperty(val, ! ToString(I), newElement).\n          CreateDataProperty(realm, val, ToString(realm, new NumberValue(realm, I)), newElement.throwIfNotConcrete());\n\n          // b. NOTE This algorithm intentionally does not throw an exception if CreateDataProperty returns false.\n        }\n\n        // 4. Add 1 to I.\n        I += 1;\n      }\n    } else {\n      // c. Else,\n      // i. Let keys be ? EnumerableOwnProperties(val, \"key\").\n      let keys = EnumerableOwnProperties(realm, val, \"key\");\n\n      // ii. For each String P in keys do,\n      for (let P of keys) {\n        invariant(P instanceof StringValue);\n\n        // 1. Let newElement be ? InternalizeJSONProperty(val, P).\n        let newElement = InternalizeJSONProperty(realm, reviver, val, P);\n\n        // 2. If newElement is undefined, then\n        if (newElement instanceof UndefinedValue) {\n          // a. Perform ? val.[[Delete]](P).\n          val.$Delete(P);\n        } else {\n          // 3. Else,\n          // a. Perform ? CreateDataProperty(val, P, newElement).\n          CreateDataProperty(realm, val, P, newElement);\n\n          // b. NOTE This algorithm intentionally does not throw an exception if CreateDataProperty returns false.\n        }\n      }\n    }\n  }\n\n  // 3. Return ? Call(reviver, holder, « name, val »).\n  return Call(realm, reviver, holder, [typeof name === \"string\" ? new StringValue(realm, name) : name, val]);\n}\n"]}