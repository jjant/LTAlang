{"version":3,"sources":["../../src/methods/generator.js"],"names":["GeneratorStart","GeneratorValidate","GeneratorResume","GeneratorResumeAbrupt","GeneratorYield","realm","generator","generatorBody","isNewObject","$GeneratorState","undefined","genContext","getRunningContext","$GeneratorContext","intrinsics","createErrorThrowCompletion","SyntaxError","state","value","methodContext","suspend","ThrowIfInternalSlotNotWritable","pushContext","result","resume","abruptCompletion","iterNextObj"],"mappings":"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","file":"generator.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport { AbruptCompletion } from \"../completions.js\";\nimport { Value, ObjectValue, UndefinedValue } from \"../values/index.js\";\nimport { CreateIterResultObject } from \"../methods/create.js\";\nimport { Properties } from \"../singletons.js\";\nimport invariant from \"../invariant.js\";\nimport type { BabelNodeBlockStatement } from \"babel-types\";\n\n// ECMA26225.3.3.1\nexport function GeneratorStart(\n  realm: Realm,\n  generator: ObjectValue,\n  generatorBody: BabelNodeBlockStatement\n): UndefinedValue {\n  // Note that generator is a new object, and we can thus write to internal slots\n  invariant(realm.isNewObject(generator));\n\n  // 1. Assert: The value of generator.[[GeneratorState]] is undefined.\n  invariant(\n    generator instanceof ObjectValue && generator.$GeneratorState === undefined,\n    \"The value of generator.[[GeneratorState]] is undefined\"\n  );\n\n  // 2. Let genContext be the running execution context.\n  let genContext = realm.getRunningContext();\n\n  // 3. Set the Generator component of genContext to generator.\n\n  // 4. Set the code evaluation state of genContext such that when evaluation is resumed for that execution context the following steps will be performed:\n  // a. Let result be the result of evaluating generatorBody.\n  // b. Assert: If we return here, the generator either threw an exception or performed either an implicit or explicit return.\n  // c. Remove genContext from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.\n  // d. Set generator.[[GeneratorState]] to \"completed\".\n  // e. Once a generator enters the \"completed\" state it never leaves it and its associated execution context is never resumed. Any execution state associated with generator can be discarded at this point.\n  // f. If result is a normal completion, let resultValue be undefined.\n  // g. Else,\n  // i. If result.[[Type]] is return, let resultValue be result.[[Value]].\n  // ii. Else, return Completion(result).\n  // h. Return CreateIterResultObject(resultValue, true).\n\n  // 5. Set generator.[[GeneratorContext]] to genContext.\n  generator.$GeneratorContext = genContext;\n\n  // 6. Set generator.[[GeneratorState]] to \"suspendedStart\".\n  generator.$GeneratorState = \"suspendedStart\";\n\n  // 7. Return NormalCompletion(undefined).\n  return realm.intrinsics.undefined;\n}\n\n// ECMA26225.3.3.2\nexport function GeneratorValidate(realm: Realm, generator: Value) {\n  // 1. If Type(generator) is not Object, throw a TypeError exception.\n  if (!(generator instanceof ObjectValue)) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, \"Type(generator) is not Object\");\n  }\n\n  // 2. If generator does not have a [[GeneratorState]] internal slot, throw a TypeError exception.\n  if (!(\"$GeneratorState\" in generator)) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, \"Type(generator) is not Object\");\n  }\n\n  // 3. Assert: generator also has a [[GeneratorContext]] internal slot.\n  invariant(\"$GeneratorContext\" in generator);\n\n  // 4. Let state be generator.[[GeneratorState]].\n  let state = generator.$GeneratorState;\n\n  // 5. If state is \"executing\", throw a TypeError exception.\n  if (state === \"executing\") {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, \"Type(generator) is not Object\");\n  }\n\n  // 6. Return state.\n  return state;\n}\n\n// ECMA26225.3.3.3\nexport function GeneratorResume(realm: Realm, generator: Value, value: Value): Value {\n  // 1. Let state be ? GeneratorValidate(generator).\n  let state = GeneratorValidate(realm, generator);\n  invariant(generator instanceof ObjectValue);\n\n  // 2. If state is \"completed\", return CreateIterResultObject(undefined, true).\n  if (state === \"completed\") return CreateIterResultObject(realm, realm.intrinsics.undefined, true);\n\n  // 3. Assert: state is either \"suspendedStart\" or \"suspendedYield\".\n  invariant(\n    state === \"suspendedStart\" || state === \"suspendedYield\",\n    \"state is either 'suspendedStart' or 'suspendedYield'\"\n  );\n\n  // 4. Let genContext be generator.[[GeneratorContext]].\n  let genContext = generator.$GeneratorContext;\n  invariant(genContext);\n\n  // 5. Let methodContext be the running execution context.\n  let methodContext = realm.getRunningContext();\n\n  // 6. Suspend methodContext.\n  methodContext.suspend();\n\n  // 7. Set generator.[[GeneratorState]] to \"executing\".\n  Properties.ThrowIfInternalSlotNotWritable(realm, generator, \"$GeneratorState\").$GeneratorState = \"executing\";\n\n  // 8. Push genContext onto the execution context stack; genContext is now the running execution context.\n  realm.pushContext(genContext);\n\n  // 9. Resume the suspended evaluation of genContext using NormalCompletion(value) as the result of the operation that suspended it. Let result be the value returned by the resumed computation.\n  let result = genContext.resume();\n\n  // 10. Assert: When we return here, genContext has already been removed from the execution context stack and methodContext is the currently running execution context.\n  invariant(realm.getRunningContext() === methodContext);\n\n  // 11. Return Completion(result).\n  return result;\n}\n\n// ECMA26225.3.3.4\nexport function GeneratorResumeAbrupt(realm: Realm, generator: Value, abruptCompletion: AbruptCompletion): Value {\n  // 1. Let state be ? GeneratorValidate(generator).\n  // 2. If state is \"suspendedStart\", then\n  // a. Set generator.[[GeneratorState]] to \"completed\".\n  // b. Once a generator enters the \"completed\" state it never leaves it and its associated execution context is never resumed. Any execution state associated with generator can be discarded at this point.\n  // c. Let state be \"completed\".\n  // 3. If state is \"completed\", then\n  // a. If abruptCompletion.[[Type]] is return, then\n  // i. Return CreateIterResultObject(abruptCompletion.[[Value]], true).\n  // b. Return Completion(abruptCompletion).\n  // 4. Assert: state is \"suspendedYield\".\n  // 5. Let genContext be generator.[[GeneratorContext]].\n  // 6. Let methodContext be the running execution context.\n  // 7. Suspend methodContext.\n  // 8. Set generator.[[GeneratorState]] to \"executing\".\n  // 9. Push genContext onto the execution context stack; genContext is now the running execution context.\n  // 10. Resume the suspended evaluation of genContext using abruptCompletion as the result of the operation that suspended it. Let result be the completion record returned by the resumed computation.\n  // 11. Assert: When we return here, genContext has already been removed from the execution context stack and methodContext is the currently running execution context.\n  // 12. Return Completion(result).\n  return realm.intrinsics.undefined;\n}\n\n// ECMA26225.3.3.5\nexport function GeneratorYield(realm: Realm, iterNextObj: ObjectValue): Value {\n  // 1. Assert: iterNextObj is an Object that implements the IteratorResult interface.\n\n  // 2. Let genContext be the running execution context.\n  // 3. Assert: genContext is the execution context of a generator.\n  // 4. Let generator be the value of the Generator component of genContext.\n  // 5. Set generator.[[GeneratorState]] to \"suspendedYield\".\n  // 6. Remove genContext from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.\n  // 7. Set the code evaluation state of genContext such that when evaluation is resumed with a Completion resumptionValue the following steps will be performed:\n  // a.  Return resumptionValue.\n  // b. NOTE: This returns to the evaluation of the YieldExpression production that originally called this abstract operation.\n  // 8. Return NormalCompletion(iterNextObj).\n  return realm.intrinsics.undefined;\n\n  // 9. NOTE: This returns to the evaluation of the operation that had most previously resumed evaluation of genContext.\n}\n"]}