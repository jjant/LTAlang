{"version":3,"sources":["../../src/methods/regexp.js"],"names":["RegExpCreate","RegExpAlloc","RegExpInitialize","RegExpExec","RegExpBuiltinExec","AdvanceStringIndex","EscapeRegExpPattern","realm","P","F","obj","intrinsics","RegExp","newTarget","$RegExpMatcher","undefined","$OriginalSource","$OriginalFlags","DefinePropertyOrThrow","writable","enumerable","configurable","pattern","flags","isNewObject","i","length","indexOf","charAt","createErrorThrowCompletion","SyntaxError","j","BMP","computedFlags","matcher","S","lastIndex","match","exec","endIndex","index","captures","e","Set","zero","R","result","TypeError","throwIfNotConcrete","global","sticky","fullUnicode","matchSucceeded","r","null","n","A","lengthOfA","value","matchIndex","matchedSubstr","substr","captureI","capturedValue","unicode","Math","pow","first","charCodeAt","second","replace"],"mappings":"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","file":"regexp.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport invariant from \"../invariant.js\";\nimport { NullValue, NumberValue, ObjectValue, StringValue, UndefinedValue, Value } from \"../values/index.js\";\nimport { ArrayCreate, OrdinaryCreateFromConstructor, CreateDataProperty } from \"./create.js\";\nimport { ToString, ToStringPartial, ToLength } from \"./to.js\";\nimport { Get } from \"./get.js\";\nimport { IsCallable } from \"./is.js\";\nimport { Call } from \"./call.js\";\nimport { HasCompatibleType, HasSomeCompatibleType } from \"./has.js\";\nimport { Properties } from \"../singletons.js\";\n\n// ECMA262 21.2.3.2.3\nexport function RegExpCreate(realm: Realm, P: ?Value, F: ?Value): ObjectValue {\n  // 1. Let obj be ? RegExpAlloc(%RegExp%).\n  let obj = RegExpAlloc(realm, realm.intrinsics.RegExp);\n\n  // 2. Return ? RegExpInitialize(obj, P, F).\n  return RegExpInitialize(realm, obj, P, F);\n}\n\n// ECMA262 21.2.3.2.1\nexport function RegExpAlloc(realm: Realm, newTarget: ObjectValue): ObjectValue {\n  // 1. Let obj be ? OrdinaryCreateFromConstructor(newTarget, \"%RegExpPrototype%\", « [[RegExpMatcher]],\n  //    [[OriginalSource]], [[OriginalFlags]] »).\n  let obj = OrdinaryCreateFromConstructor(realm, newTarget, \"RegExpPrototype\", {\n    $RegExpMatcher: undefined, // always initialized to not undefined before use\n    $OriginalSource: undefined, // ditto\n    $OriginalFlags: undefined, // ditto\n  });\n\n  // 2. Perform ! DefinePropertyOrThrow(obj, \"lastIndex\", PropertyDescriptor {[[Writable]]: true,\n  //    [[Enumerable]]: false, [[Configurable]]: false}).\n  Properties.DefinePropertyOrThrow(realm, obj, \"lastIndex\", {\n    writable: true,\n    enumerable: false,\n    configurable: false,\n  });\n\n  // 3. Return obj.\n  return obj;\n}\n\n// ECMA262 21.2.3.2.2\nexport function RegExpInitialize(realm: Realm, obj: ObjectValue, pattern: ?Value, flags: ?Value): ObjectValue {\n  // Note that obj is a new object, and we can thus write to internal slots\n  invariant(realm.isNewObject(obj));\n\n  // 1. If pattern is undefined, let P be the empty String.\n  let P;\n  if (!pattern || HasCompatibleType(pattern, UndefinedValue)) {\n    P = \"\";\n  } else {\n    // 2. Else, let P be ? ToString(pattern).\n    P = ToStringPartial(realm, pattern);\n  }\n\n  // 3. If flags is undefined, let F be the empty String.\n  let F;\n  if (!flags || HasCompatibleType(flags, UndefinedValue)) {\n    F = \"\";\n  } else {\n    // 4. Else, let F be ? ToString(flags).\n    F = ToStringPartial(realm, flags);\n  }\n\n  // 5. If F contains any code unit other than \"g\", \"i\", \"m\", \"u\", or \"y\" or if it contains the same code unit more than once, throw a SyntaxError exception.\n  for (let i = 0; i < F.length; ++i) {\n    if (\"gimuy\".indexOf(F.charAt(i)) < 0) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, \"invalid RegExp flag\");\n    }\n    for (let j = i + 1; j < F.length; ++j) {\n      if (F.charAt(i) === F.charAt(j)) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, \"duplicate RegExp flag\");\n      }\n    }\n  }\n\n  // 6. If F contains \"u\", let BMP be false; else let BMP be true.\n  let BMP = F.indexOf(\"u\") >= 0 ? false : true;\n\n  // 7. If BMP is true, then\n  if (BMP) {\n    // a. Parse P using the grammars in 21.2.1 and interpreting each of its 16-bit elements as a Unicode BMP\n    //    code point. UTF-16 decoding is not applied to the elements. The goal symbol for the parse is\n    //    Pattern. Throw a SyntaxError exception if P did not conform to the grammar, if any elements of P\n    //    were not matched by the parse, or if any Early Error conditions exist.\n    // b. Let patternCharacters be a List whose elements are the code unit elements of P.\n  } else {\n    // 8. Else,\n    // a. Parse P using the grammars in 21.2.1 and interpreting P as UTF-16 encoded Unicode code points\n    //    (6.1.4). The goal symbol for the parse is Pattern[U]. Throw a SyntaxError exception if P did not\n    //    conform to the grammar, if any elements of P were not matched by the parse, or if any Early Error\n    //    conditions exist.\n    // b. Let patternCharacters be a List whose elements are the code points resulting from applying UTF-16\n    //    decoding to P's sequence of elements.\n  }\n\n  // 9. Set the value of obj's [[OriginalSource]] internal slot to P.\n  obj.$OriginalSource = P;\n\n  // 10. Set the value of obj's [[OriginalFlags]] internal slot to F.\n  obj.$OriginalFlags = F;\n\n  // 11. Set obj's [[RegExpMatcher]] internal slot to the internal procedure that evaluates the above parse of\n  //     P by applying the semantics provided in 21.2.2 using patternCharacters as the pattern's List of\n  //     SourceCharacter values and F as the flag parameters.\n  try {\n    let computedFlags = \"y\";\n    if (F.indexOf(\"i\") >= 0) computedFlags += \"i\";\n    if (F.indexOf(\"u\") >= 0) computedFlags += \"u\";\n    if (F.indexOf(\"m\") >= 0) computedFlags += \"m\";\n    let matcher = new RegExp(P, (computedFlags: any));\n\n    obj.$RegExpMatcher = (S: string, lastIndex: number) => {\n      matcher.lastIndex = lastIndex;\n      let match = matcher.exec(S);\n      if (!match) {\n        return null;\n      }\n      return {\n        endIndex: match.index + match[0].length,\n        captures: match,\n      };\n    };\n  } catch (e) {\n    if (e instanceof SyntaxError) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, \"invalid RegExp\");\n    } else throw e;\n  }\n\n  // 12. Perform ? Set(obj, \"lastIndex\", 0, true).\n  Properties.Set(realm, obj, \"lastIndex\", realm.intrinsics.zero, true);\n\n  // 13. Return obj.\n  return obj;\n}\n\n// ECMA262 21.2.5.2.1\nexport function RegExpExec(realm: Realm, R: ObjectValue, S: string): ObjectValue | NullValue {\n  // 1. Assert: Type(R) is Object.\n  invariant(R instanceof ObjectValue, \"Type(R) is Object\");\n\n  // 2. Assert: Type(S) is String.\n  invariant(typeof S === \"string\", \"Type(S) is String\");\n\n  // 3. Let exec be ? Get(R, \"exec\").\n  let exec = Get(realm, R, \"exec\");\n\n  // 4. If IsCallable(exec) is true, then\n  if (IsCallable(realm, exec)) {\n    // a. Let result be ? Call(exec, R, « S »).\n    let result = Call(realm, exec, R, [new StringValue(realm, S)]);\n\n    // b. If Type(result) is neither Object or Null, throw a TypeError exception.\n    if (!HasSomeCompatibleType(result, ObjectValue, NullValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(result) is neither Object or Null\");\n    }\n\n    // c. Return result.\n    return ((result.throwIfNotConcrete(): any): ObjectValue | NullValue);\n  }\n\n  // 5. If R does not have a [[RegExpMatcher]] internal slot, throw a TypeError exception.\n  if (R.$RegExpMatcher === undefined) {\n    throw realm.createErrorThrowCompletion(\n      realm.intrinsics.TypeError,\n      \"R does not have a [[RegExpMatcher]] internal slot\"\n    );\n  }\n\n  // 6. Return ? RegExpBuiltinExec(R, S).\n  return RegExpBuiltinExec(realm, R, S);\n}\n\n// ECMA262 21.2.5.2.2\nexport function RegExpBuiltinExec(realm: Realm, R: ObjectValue, S: string): ObjectValue | NullValue {\n  // 1. Assert: R is an initialized RegExp instance.\n  invariant(\n    R.$RegExpMatcher !== undefined && R.$OriginalSource !== undefined && R.$OriginalFlags !== undefined,\n    \"R is an initialized RegExp instance\"\n  );\n\n  // 2. Assert: Type(S) is String.\n  invariant(typeof S === \"string\", \"Type(S) is String\");\n\n  // 3. Let length be the number of code units in S.\n  let length = S.length;\n\n  // 4. Let lastIndex be ? ToLength(? Get(R, \"lastIndex\")).\n  let lastIndex = ToLength(realm, Get(realm, R, \"lastIndex\"));\n\n  // 5. Let flags be R.[[OriginalFlags]].\n  let flags = R.$OriginalFlags;\n  invariant(typeof flags === \"string\");\n\n  // 6 .If flags contains \"g\", let global be true, else let global be false.\n  let global = flags.indexOf(\"g\") >= 0 ? true : false;\n\n  // 7. If flags contains \"y\", let sticky be true, else let sticky be false.\n  let sticky = flags.indexOf(\"y\") >= 0 ? true : false;\n\n  // 8. If global is false and sticky is false, let lastIndex be 0.\n  if (global === false && sticky === false) lastIndex = 0;\n\n  // 9. Let matcher be the value of R's [[RegExpMatcher]] internal slot.\n  let matcher = R.$RegExpMatcher;\n  invariant(matcher !== undefined);\n\n  // 10. If flags contains \"u\", let fullUnicode be true, else let fullUnicode be false.\n  let fullUnicode = flags.indexOf(\"u\") >= 0 ? true : false;\n\n  // 11. Let matchSucceeded be false.\n  let matchSucceeded = false;\n\n  let r = null;\n  // 12. Repeat, while matchSucceeded is false\n  while (!matchSucceeded) {\n    // a. If lastIndex > length, then\n    if (lastIndex > length) {\n      // i. Perform ? Set(R, \"lastIndex\", 0, true).\n      Properties.Set(realm, R, \"lastIndex\", realm.intrinsics.zero, true);\n      // ii. Return null.\n      return realm.intrinsics.null;\n    }\n\n    // b. Let r be matcher(S, lastIndex).\n    r = matcher(S, lastIndex);\n\n    // c. If r is failure, then\n    if (r == null) {\n      // i. If sticky is true, then\n      if (sticky) {\n        // 1. Perform ? Set(R, \"lastIndex\", 0, true).\n        Properties.Set(realm, R, \"lastIndex\", realm.intrinsics.zero, true);\n\n        // 2. Return null.\n        return realm.intrinsics.null;\n      }\n      // ii. Let lastIndex be AdvanceStringIndex(S, lastIndex, fullUnicode).\n      lastIndex = AdvanceStringIndex(realm, S, lastIndex, fullUnicode);\n    } else {\n      // d. Else,\n      // i. Assert: r is a State.\n      invariant(r, \"r is a State\");\n\n      // ii. Set matchSucceeded to true.\n      matchSucceeded = true;\n\n      // (not in standard) Let lastIndex be the index of the captures\n      lastIndex = (r.captures: any).index;\n    }\n  }\n  invariant(r != null);\n\n  // 13. Let e be r's endIndex value.\n  let e = r.endIndex;\n\n  // 14. If fullUnicode is true, then\n  if (fullUnicode) {\n    // TODO #1018 a. e is an index into the Input character list, derived from S, matched by matcher. Let eUTF be the smallest index into S that corresponds to the character at element e of Input. If e is greater than or equal to the length of Input, then eUTF is the number of code units in S.\n    // b. Let e be eUTF.\n  }\n\n  // 15. If global is true or sticky is true, then\n  if (global === true || sticky === true) {\n    // a. Perform ? Set(R, \"lastIndex\", e, true).\n    Properties.Set(realm, R, \"lastIndex\", new NumberValue(realm, e), true);\n  }\n\n  // 16. Let n be the length of r's captures List. (This is the same value as 21.2.2.1's NcapturingParens.)\n  let n = r.captures.length - 1;\n\n  // 17. Let A be ArrayCreate(n + 1).\n  let A = ArrayCreate(realm, n + 1);\n\n  // 18. Assert: The value of A's \"length\" property is n + 1.\n  let lengthOfA = Get(realm, A, \"length\").throwIfNotConcrete();\n  invariant(lengthOfA instanceof NumberValue);\n  invariant(lengthOfA.value === n + 1, 'The value of A\\'s \"length\" property is n + 1');\n\n  // 19. Let matchIndex be lastIndex.\n  let matchIndex = lastIndex;\n\n  // 20. Perform ! CreateDataProperty(A, \"index\", matchIndex).\n  CreateDataProperty(realm, A, \"index\", new NumberValue(realm, matchIndex));\n\n  // 21. Perform ! CreateDataProperty(A, \"input\", S).\n  CreateDataProperty(realm, A, \"input\", new StringValue(realm, S));\n\n  // 22. Let matchedSubstr be the matched substring (i.e. the portion of S between offset lastIndex inclusive and offset e exclusive).\n  let matchedSubstr = S.substr(lastIndex, e - lastIndex);\n\n  // 23. Perform ! CreateDataProperty(A, \"0\", matchedSubstr).\n  CreateDataProperty(realm, A, \"0\", new StringValue(realm, matchedSubstr));\n\n  // 24. For each integer i such that i > 0 and i ≤ n\n  for (let i = 1; i <= n; ++i) {\n    // a. Let captureI be ith element of r's captures List.\n    let captureI = r.captures[i];\n\n    let capturedValue;\n    // b. If captureI is undefined, let capturedValue be undefined.\n    if (captureI === undefined) {\n      capturedValue = realm.intrinsics.undefined;\n    } else if (fullUnicode) {\n      // c. Else if fullUnicode is true, then\n      // TODO #1018: i. Assert: captureI is a List of code points.\n      // ii. Let capturedValue be a string whose code units are the UTF16Encoding of the code points of captureI.\n      capturedValue = realm.intrinsics.undefined;\n    } else {\n      // d. Else, fullUnicode is false,\n      // i. Assert: captureI is a List of code units.\n      invariant(typeof captureI === \"string\");\n\n      // ii. Let capturedValue be a string consisting of the code units of captureI.\n      capturedValue = new StringValue(realm, captureI);\n    }\n\n    // e. Perform ! CreateDataProperty(A, ! ToString(i), capturedValue).\n    CreateDataProperty(realm, A, ToString(realm, new NumberValue(realm, i)), capturedValue);\n  }\n\n  // 25. Return A.\n  return A;\n}\n\nexport function AdvanceStringIndex(realm: Realm, S: string, index: number, unicode: boolean): number {\n  // 1. Assert: Type(S) is String.\n  invariant(typeof S === \"string\", \"Type(S) is String\");\n\n  // 2. Assert: index is an integer such that 0≤index≤253-1.\n  invariant(index >= 0 && index <= Math.pow(2, 53) - 1, \"index is an integer such that 0≤index≤253-1\");\n\n  // 3. Assert: Type(unicode) is Boolean.\n  invariant(typeof unicode === \"boolean\", \"Type(unicode) is Boolean\");\n\n  // 4. If unicode is false, return index+1.\n  if (unicode === false) return index + 1;\n\n  // 5. Let length be the number of code units in S.\n  let length = S.length;\n\n  // 6. If index+1 ≥ length, return index+1.\n  if (index + 1 >= length) return index + 1;\n\n  // 7. Let first be the code unit value at index index in S.\n  let first = S.charCodeAt(index);\n\n  // 8. If first < 0xD800 or first > 0xDBFF, return index+1.\n  if (first < 0xd800 || first > 0xdbff) return index + 1;\n\n  // 9. Let second be the code unit value at index index+1 in S.\n  let second = S.charCodeAt(index + 1);\n\n  // 10. If second < 0xDC00 or second > 0xDFFF, return index+1.\n  if (second < 0xdc00 || second > 0xdfff) return index + 1;\n\n  // 11. Return index+2.\n  return index + 2;\n}\n\nexport function EscapeRegExpPattern(realm: Realm, P: string, F: string): string {\n  return P.replace(\"/\", \"/\");\n}\n"]}