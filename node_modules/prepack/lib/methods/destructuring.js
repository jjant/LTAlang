"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DestructuringAssignmentEvaluation = DestructuringAssignmentEvaluation;
exports.IteratorDestructuringAssignmentEvaluation = IteratorDestructuringAssignmentEvaluation;
exports.KeyedDestructuringAssignmentEvaluation = KeyedDestructuringAssignmentEvaluation;

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _environment = require("../environment.js");

var _index = require("../values/index.js");

var _completions = require("../completions.js");

var _ObjectExpression = require("../evaluators/ObjectExpression.js");

var _index2 = require("./index.js");

var _singletons = require("../singletons.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// ECMA262 12.15.5.2
function DestructuringAssignmentEvaluation(realm, pattern, value, strictCode, env) {
  if (pattern.type === "ObjectPattern") {
    // 1. Perform ? RequireObjectCoercible(value).
    (0, _index2.RequireObjectCoercible)(realm, value);

    // 2. Return the result of performing DestructuringAssignmentEvaluation for AssignmentPropertyList using value as the argument.

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = pattern.properties[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var property = _step.value;

        // 1. Let name be the result of evaluating PropertyName.
        var name = (0, _ObjectExpression.EvalPropertyName)(property, env, realm, strictCode);

        // 2. ReturnIfAbrupt(name).

        // 3. Return the result of performing KeyedDestructuringAssignmentEvaluation of AssignmentElement with value and name as the arguments.
        KeyedDestructuringAssignmentEvaluation(realm, property.value, value, name, strictCode, env);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  } else if (pattern.type === "ArrayPattern") {
    // 1. Let iterator be ? GetIterator(value).
    var iterator = (0, _index2.GetIterator)(realm, value);

    // 2. Let iteratorRecord be Record {[[Iterator]]: iterator, [[Done]]: false}.
    var iteratorRecord = {
      $Iterator: iterator,
      $Done: false
    };

    // 3. Let result be the result of performing IteratorDestructuringAssignmentEvaluation of AssignmentElementList using iteratorRecord as the argument.
    var result = void 0;
    try {
      result = IteratorDestructuringAssignmentEvaluation(realm, pattern.elements, iteratorRecord, strictCode, env);
    } catch (error) {
      // 4. If iteratorRecord.[[Done]] is false, return ? IteratorClose(iterator, result).
      if (iteratorRecord.$Done === false && error instanceof _completions.AbruptCompletion) {
        throw (0, _index2.IteratorClose)(realm, iterator, error);
      }
      throw error;
    }

    // 4. If iteratorRecord.[[Done]] is false, return ? IteratorClose(iterator, result).
    if (iteratorRecord.$Done === false) {
      var completion = (0, _index2.IteratorClose)(realm, iterator, new _completions.NormalCompletion(realm.intrinsics.undefined));
      if (completion instanceof _completions.AbruptCompletion) {
        throw completion;
      }
    }

    // 5. Return result.
    return result;
  }
}

// ECMA262 12.15.5.3
/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

function IteratorDestructuringAssignmentEvaluation(realm, elements, iteratorRecord, strictCode, env) {
  // Check if the last element is a rest element. If so then we want to save the
  // element and handle it separately after we iterate through the other
  // formals. This also enforces that a rest element may only ever be in the
  // last position.
  var restEl = void 0;
  if (elements.length > 0) {
    var lastEl = elements[elements.length - 1];
    if (lastEl !== null && lastEl.type === "RestElement") {
      restEl = lastEl;
      elements = elements.slice(0, -1);
    }
  }

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = elements[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var element = _step2.value;

      if (element === null) {
        // Elision handling

        // 1. If iteratorRecord.[[Done]] is false, then
        if (iteratorRecord.$Done === false) {
          // a. Let next be IteratorStep(iteratorRecord.[[Iterator]]).
          var _next = void 0;
          try {
            _next = (0, _index2.IteratorStep)(realm, iteratorRecord.$Iterator);
          } catch (e) {
            // b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.
            if (e instanceof _completions.AbruptCompletion) {
              iteratorRecord.$Done = true;
            }
            // c. ReturnIfAbrupt(next).
            throw e;
          }
          // d. If next is false, set iteratorRecord.[[Done]] to true.
          if (_next === false) {
            iteratorRecord.$Done = true;
          }
        }
        // 2. Return NormalCompletion(empty).
        continue;
      }

      // AssignmentElement : DestructuringAssignmentTarget Initializer

      var DestructuringAssignmentTarget = void 0;
      var Initializer = void 0;

      if (element.type === "AssignmentPattern") {
        Initializer = element.right;
        DestructuringAssignmentTarget = element.left;
      } else {
        DestructuringAssignmentTarget = element;
      }

      var lref = void 0;

      // 1. If DestructuringAssignmentTarget is neither an ObjectLiteral nor an ArrayLiteral, then
      //
      // The spec assumes we haven't yet distinguished between literals and
      // patterns, but our parser does that work for us. That means we check for
      // "*Pattern" instead of "*Literal" like the spec text suggests.
      if (DestructuringAssignmentTarget.type !== "ObjectPattern" && DestructuringAssignmentTarget.type !== "ArrayPattern") {
        // a. Let lref be the result of evaluating DestructuringAssignmentTarget.
        lref = env.evaluate(DestructuringAssignmentTarget, strictCode);

        // b. ReturnIfAbrupt(lref).
      }

      var value = void 0;

      // 2. If iteratorRecord.[[Done]] is false, then
      if (iteratorRecord.$Done === false) {
        // a. Let next be IteratorStep(iteratorRecord.[[Iterator]]).
        var _next2 = void 0;
        try {
          _next2 = (0, _index2.IteratorStep)(realm, iteratorRecord.$Iterator);
        } catch (e) {
          // b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.
          if (e instanceof _completions.AbruptCompletion) {
            iteratorRecord.$Done = true;
          }
          // c. ReturnIfAbrupt(next).
          throw e;
        }

        // d. If next is false, set iteratorRecord.[[Done]] to true.
        if (_next2 === false) {
          iteratorRecord.$Done = true;
          // Normally this assignment would be done in step 3, but we do it
          // here so that Flow knows `value` will always be initialized by step 4.
          value = realm.intrinsics.undefined;
        } else {
          // e. Else,
          // i. Let value be IteratorValue(next).
          try {
            value = (0, _index2.IteratorValue)(realm, _next2);
          } catch (e) {
            // ii. If value is an abrupt completion, set iteratorRecord.[[Done]] to true.
            if (e instanceof _completions.AbruptCompletion) {
              iteratorRecord.$Done = true;
            }
            // iii. ReturnIfAbrupt(v).
            throw e;
          }
        }
      } else {
        // 3. If iteratorRecord.[[Done]] is true, let value be undefined.
        value = realm.intrinsics.undefined;
      }

      var v = void 0;

      // 4. If Initializer is present and value is undefined, then
      if (Initializer && value instanceof _index.UndefinedValue) {
        // a. Let defaultValue be the result of evaluating Initializer.
        var defaultValue = env.evaluate(Initializer, strictCode);

        // b. Let v be ? GetValue(defaultValue).
        v = _singletons.Environment.GetValue(realm, defaultValue);
      } else {
        // 5. Else, let v be value.
        v = value;
      }

      // 6. If DestructuringAssignmentTarget is an ObjectLiteral or an ArrayLiteral, then
      //
      // The spec assumes we haven't yet distinguished between literals and
      // patterns, but our parser does that work for us. That means we check for
      // "*Pattern" instead of "*Literal" like the spec text suggests.
      if (DestructuringAssignmentTarget.type === "ObjectPattern" || DestructuringAssignmentTarget.type === "ArrayPattern") {
        // a. Let nestedAssignmentPattern be the parse of the source text corresponding to DestructuringAssignmentTarget using either AssignmentPattern or AssignmentPattern[Yield] as the goal symbol depending upon whether this AssignmentElement has the [Yield] parameter.
        var _nestedAssignmentPattern = DestructuringAssignmentTarget;

        // b. Return the result of performing DestructuringAssignmentEvaluation of nestedAssignmentPattern with v as the argument.
        DestructuringAssignmentEvaluation(realm, _nestedAssignmentPattern, v, strictCode, env);
        continue;
      }

      // We know `lref` exists because of how the algorithm is setup, but tell
      // Flow that `lref` exists with an `invariant()`.
      (0, _invariant2.default)(lref);

      // 7. If Initializer is present and value is undefined and IsAnonymousFunctionDefinition(Initializer) and IsIdentifierRef of DestructuringAssignmentTarget are both true, then
      if (Initializer && value instanceof _index.UndefinedValue && (0, _index2.IsAnonymousFunctionDefinition)(realm, Initializer) && (0, _index2.IsIdentifierRef)(realm, DestructuringAssignmentTarget) && v instanceof _index.ObjectValue) {
        // a. Let hasNameProperty be ? HasOwnProperty(v, "name").
        var hasNameProperty = (0, _index2.HasOwnProperty)(realm, v, "name");

        // b. If hasNameProperty is false, perform SetFunctionName(v, GetReferencedName(lref)).
        if (hasNameProperty === false) {
          // All of the nodes that may be evaluated to produce lref create
          // references. Assert this with an invariant as GetReferencedName may
          // not be called with a value.
          (0, _invariant2.default)(lref instanceof _environment.Reference);

          _singletons.Functions.SetFunctionName(realm, v, _singletons.Environment.GetReferencedName(realm, lref));
        }
      }

      // 8. Return ? PutValue(lref, v).
      _singletons.Properties.PutValue(realm, lref, v);
      continue;
    }

    // Handle the rest element if we have one.
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  if (restEl) {
    // AssignmentRestElement : ...DestructuringAssignmentTarget
    var DestructuringAssignmentTarget = restEl.argument;

    var lref = void 0;

    // 1. If DestructuringAssignmentTarget is neither an ObjectLiteral nor an ArrayLiteral, then
    //
    // The spec assumes we haven't yet distinguished between literals and
    // patterns, but our parser does that work for us. That means we check for
    // "*Pattern" instead of "*Literal" like the spec text suggests.
    if (DestructuringAssignmentTarget.type !== "ObjectPattern" && DestructuringAssignmentTarget.type !== "ArrayPattern") {
      // a. Let lref be the result of evaluating DestructuringAssignmentTarget.
      lref = env.evaluate(DestructuringAssignmentTarget, strictCode);

      // b. ReturnIfAbrupt(lref).
    }

    // 2. Let A be ArrayCreate(0).
    var A = (0, _index2.ArrayCreate)(realm, 0);

    // 3. Let n be 0.
    var n = 0;

    // 4. Repeat while iteratorRecord.[[Done]] is false,
    while (iteratorRecord.$Done === false) {
      // a. Let next be IteratorStep(iteratorRecord.[[Iterator]]).
      var next = void 0;
      try {
        next = (0, _index2.IteratorStep)(realm, iteratorRecord.$Iterator);
      } catch (e) {
        // b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.
        if (e instanceof _completions.AbruptCompletion) {
          iteratorRecord.$Done = true;
        }
        // c. ReturnIfAbrupt(next).
        throw e;
      }

      // d. If next is false, set iteratorRecord.[[Done]] to true.
      if (next === false) {
        iteratorRecord.$Done = true;
      } else {
        // e. Else,
        // i. Let nextValue be IteratorValue(next).
        var nextValue = void 0;
        try {
          nextValue = (0, _index2.IteratorValue)(realm, next);
        } catch (e) {
          // ii. If nextValue is an abrupt completion, set iteratorRecord.[[Done]] to true.
          if (e instanceof _completions.AbruptCompletion) {
            iteratorRecord.$Done = true;
          }
          // iii. ReturnIfAbrupt(nextValue).
          throw e;
        }

        // iv. Let status be CreateDataProperty(A, ! ToString(n), nextValue).
        var status = (0, _index2.CreateDataProperty)(realm, A, n.toString(), nextValue);

        // v. Assert: status is true.
        (0, _invariant2.default)(status, "expected to create data property");

        // vi. Increment n by 1.
        n += 1;
      }
    }

    // 5. If DestructuringAssignmentTarget is neither an ObjectLiteral nor an ArrayLiteral, then
    if (DestructuringAssignmentTarget.type !== "ObjectPattern" && DestructuringAssignmentTarget.type !== "ArrayPattern") {
      // `lref` will always be defined at this point. Let Flow know with an
      // invariant.
      (0, _invariant2.default)(lref);

      // a. Return ? PutValue(lref, A).
      _singletons.Properties.PutValue(realm, lref, A);
    } else {
      // 6. Let nestedAssignmentPattern be the parse of the source text corresponding to DestructuringAssignmentTarget using either AssignmentPattern or AssignmentPattern[Yield] as the goal symbol depending upon whether this AssignmentElement has the [Yield] parameter.
      var nestedAssignmentPattern = DestructuringAssignmentTarget;

      // 7. Return the result of performing DestructuringAssignmentEvaluation of nestedAssignmentPattern with A as the argument.
      DestructuringAssignmentEvaluation(realm, nestedAssignmentPattern, A, strictCode, env);
    }
  }
}

// ECMA262 12.15.5.4
function KeyedDestructuringAssignmentEvaluation(realm, node, value, propertyName, strictCode, env) {
  var DestructuringAssignmentTarget = void 0;
  var Initializer = void 0;

  if (node.type === "AssignmentPattern") {
    Initializer = node.right;
    DestructuringAssignmentTarget = node.left;
  } else {
    DestructuringAssignmentTarget = node;
  }

  var lref = void 0;

  // 1. If DestructuringAssignmentTarget is neither an ObjectLiteral nor an ArrayLiteral, then
  //
  // The spec assumes we haven't yet distinguished between literals and
  // patterns, but our parser does that work for us. That means we check for
  // "*Pattern" instead of "*Literal" like the spec text suggests.
  if (DestructuringAssignmentTarget.type !== "ObjectPattern" && DestructuringAssignmentTarget.type !== "ArrayPattern") {
    // a. Let lref be the result of evaluating DestructuringAssignmentTarget.
    lref = env.evaluate(DestructuringAssignmentTarget, strictCode);

    // b. ReturnIfAbrupt(lref).
  }

  var rhsValue = void 0;

  // 2. Let v be ? GetV(value, propertyName).
  var v = (0, _index2.GetV)(realm, value, propertyName);

  // 3. If Initializer is present and v is undefined, then
  if (Initializer && v instanceof _index.UndefinedValue) {
    // a. Let defaultValue be the result of evaluating Initializer.
    var defaultValue = env.evaluate(Initializer, strictCode);

    // b. Let rhsValue be ? GetValue(defaultValue).
    rhsValue = _singletons.Environment.GetValue(realm, defaultValue);
  } else {
    // 4. Else, let rhsValue be v.
    rhsValue = v;
  }

  // 5. If DestructuringAssignmentTarget is an ObjectLiteral or an ArrayLiteral, then
  //
  // The spec assumes we haven't yet distinguished between literals and
  // patterns, but our parser does that work for us. That means we check for
  // "*Pattern" instead of "*Literal" like the spec text suggests.
  if (DestructuringAssignmentTarget.type === "ObjectPattern" || DestructuringAssignmentTarget.type === "ArrayPattern") {
    // a. Let assignmentPattern be the parse of the source text corresponding to DestructuringAssignmentTarget using either AssignmentPattern or AssignmentPattern[Yield] as the goal symbol depending upon whether this AssignmentElement has the [Yield] parameter.
    var assignmentPattern = DestructuringAssignmentTarget;

    // b. Return the result of performing DestructuringAssignmentEvaluation of assignmentPattern with rhsValue as the argument.
    return DestructuringAssignmentEvaluation(realm, assignmentPattern, rhsValue, strictCode, env);
  }

  // `lref` will always be defined at this point. Let Flow know with an
  // invariant.
  (0, _invariant2.default)(lref);

  // 6. If Initializer is present and v is undefined and IsAnonymousFunctionDefinition(Initializer) and IsIdentifierRef of DestructuringAssignmentTarget are both true, then
  if (Initializer && v instanceof _index.UndefinedValue && (0, _index2.IsAnonymousFunctionDefinition)(realm, Initializer) && (0, _index2.IsIdentifierRef)(realm, DestructuringAssignmentTarget) && rhsValue instanceof _index.ObjectValue) {
    // a. Let hasNameProperty be ? HasOwnProperty(rhsValue, "name").
    var hasNameProperty = (0, _index2.HasOwnProperty)(realm, rhsValue, "name");

    // b. If hasNameProperty is false, perform SetFunctionName(rhsValue, GetReferencedName(lref)).
    if (hasNameProperty === false) {
      // All of the nodes that may be evaluated to produce lref create
      // references. Assert this with an invariant as GetReferencedName may
      // not be called with a value.
      (0, _invariant2.default)(lref instanceof _environment.Reference);

      _singletons.Functions.SetFunctionName(realm, rhsValue, _singletons.Environment.GetReferencedName(realm, lref));
    }
  }

  // 7. Return ? PutValue(lref, rhsValue).
  return _singletons.Properties.PutValue(realm, lref, rhsValue);
}
//# sourceMappingURL=destructuring.js.map