"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.msPerDay = exports.msPerHour = exports.msPerMinute = exports.msPerSecond = exports.HoursPerDay = exports.MinutesPerHour = exports.SecondsPerMinute = undefined;
exports.Day = Day;
exports.TimeWithinDay = TimeWithinDay;
exports.DaysInYear = DaysInYear;
exports.DayFromYear = DayFromYear;
exports.TimeFromYear = TimeFromYear;
exports.YearFromTime = YearFromTime;
exports.InLeapYear = InLeapYear;
exports.MonthFromTime = MonthFromTime;
exports.DayWithinYear = DayWithinYear;
exports.DateFromTime = DateFromTime;
exports.WeekDay = WeekDay;
exports.DaylightSavingTA = DaylightSavingTA;
exports.LocalTime = LocalTime;
exports.UTC = UTC;
exports.HourFromTime = HourFromTime;
exports.MinFromTime = MinFromTime;
exports.SecFromTime = SecFromTime;
exports.msFromTime = msFromTime;
exports.MakeTime = MakeTime;
exports.MakeDay = MakeDay;
exports.MakeDate = MakeDate;
exports.TimeClip = TimeClip;
exports.thisTimeValue = thisTimeValue;
exports.ToDateString = ToDateString;

var _index = require("../values/index.js");

var _to = require("./to.js");

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Constants
var SecondsPerMinute = exports.SecondsPerMinute = 60; /**
                                                       * Copyright (c) 2017-present, Facebook, Inc.
                                                       * All rights reserved.
                                                       *
                                                       * This source code is licensed under the BSD-style license found in the
                                                       * LICENSE file in the root directory of this source tree. An additional grant
                                                       * of patent rights can be found in the PATENTS file in the same directory.
                                                       */

var MinutesPerHour = exports.MinutesPerHour = 60;
var HoursPerDay = exports.HoursPerDay = 24;
var msPerSecond = exports.msPerSecond = 1000;
var msPerMinute = exports.msPerMinute = msPerSecond * SecondsPerMinute;
var msPerHour = exports.msPerHour = msPerMinute * MinutesPerHour;
var msPerDay = exports.msPerDay = msPerHour * HoursPerDay;

var LocalTZA = -new Date(0).getTimezoneOffset() * msPerMinute;

// ECMA262 20.3.1.2
function Day(realm, t) {
  return Math.floor(t / msPerDay);
}

// ECMA262 20.3.1.2
function TimeWithinDay(realm, t) {
  return t % msPerDay;
}

// ECMA262 20.3.1.3
function DaysInYear(realm, y) {
  if (y % 4 !== 0) return 365;
  if (y % 4 === 0 && y % 100 !== 0) return 366;
  if (y % 100 === 0 && y % 400 !== 0) return 365;
  if (y % 400 === 0) return 366;

  (0, _invariant2.default)(false, "Invalid condition");
}

// ECMA262 20.3.1.3
function DayFromYear(realm, y) {
  return 365 * (y - 1970) + Math.floor((y - 1969) / 4) - Math.floor((y - 1901) / 100) + Math.floor((y - 1601) / 400);
}

// ECMA262 20.3.1.3
function TimeFromYear(realm, y) {
  return msPerDay * DayFromYear(realm, y);
}

// ECMA262 20.3.1.3
function YearFromTime(realm, t) {
  var y = Math.floor(t / (msPerDay * 365.2425)) + 1970;
  var t2 = TimeFromYear(realm, y);

  if (t2 > t) {
    y--;
  } else {
    if (t2 + msPerDay * DaysInYear(realm, y) <= t) {
      y++;
    }
  }
  return y;
}

// ECMA262 20.3.1.3
function InLeapYear(realm, t) {
  var daysInYear = DaysInYear(realm, YearFromTime(realm, t));
  if (daysInYear === 365) return 0;
  if (daysInYear === 366) return 1;
  (0, _invariant2.default)(false, "invalid condition");
}

// ECMA262 20.3.1.4
function MonthFromTime(realm, t) {
  var step = void 0;
  var d = DayWithinYear(realm, t);

  if (d < (step = 31)) return 0;

  step += InLeapYear(realm, t) ? 29 : 28;
  if (d < step) return 1;
  if (d < (step += 31)) return 2;
  if (d < (step += 30)) return 3;
  if (d < (step += 31)) return 4;
  if (d < (step += 30)) return 5;
  if (d < (step += 31)) return 6;
  if (d < (step += 31)) return 7;
  if (d < (step += 30)) return 8;
  if (d < (step += 31)) return 9;
  if (d < (step += 30)) return 10;
  return 11;
}

// ECMA262 20.3.1.4
function DayWithinYear(realm, t) {
  return Day(realm, t) - DayFromYear(realm, YearFromTime(realm, t));
}

// ECMA262 20.3.1.5
function DateFromTime(realm, t) {
  var step = void 0;
  var next = void 0;
  var d = DayWithinYear(realm, t);

  if (d <= (next = 30)) return d + 1;

  step = next;
  next += InLeapYear(realm, t) ? 29 : 28;
  if (d <= next) return d - step;

  step = next;
  if (d <= (next += 31)) return d - step;

  step = next;
  if (d <= (next += 30)) return d - step;

  step = next;
  if (d <= (next += 31)) return d - step;

  step = next;
  if (d <= (next += 30)) return d - step;

  step = next;
  if (d <= (next += 31)) return d - step;

  step = next;
  if (d <= (next += 31)) return d - step;

  step = next;
  if (d <= (next += 30)) return d - step;

  step = next;
  if (d <= (next += 31)) return d - step;

  step = next;
  if (d <= (next += 30)) return d - step;

  step = next;
  return d - step;
}

// ECMA262 20.3.1.6
function WeekDay(realm, t) {
  return (Day(realm, t) + 4) % 7;
}

// ECMA262 20.3.1.7
function DaylightSavingTA(realm, t) {
  // TODO #1014: Implement DaylightSavingTA
  return 0;
}

// ECMA262 20.3.1.9
function LocalTime(realm, t) {
  // 1. Return t + LocalTZA + DaylightSavingTA(t).
  return t + LocalTZA + DaylightSavingTA(realm, t);
}

// ECMA262 20.3.1.10
function UTC(realm, t) {
  if (t instanceof _index.Value) t = t.throwIfNotConcreteNumber().value;

  // 1. Return t - LocalTZA - DaylightSavingTA(t - LocalTZA).
  return new _index.NumberValue(realm, t - LocalTZA - DaylightSavingTA(realm, t - LocalTZA));
}

// ECMA262 20.3.1.11
function HourFromTime(realm, t) {
  return Math.floor(t / msPerHour) % HoursPerDay;
}

// ECMA262 20.3.1.11
function MinFromTime(realm, t) {
  return Math.floor(t / msPerMinute) % MinutesPerHour;
}

// ECMA262 20.3.1.11
function SecFromTime(realm, t) {
  return Math.floor(t / msPerSecond) % SecondsPerMinute;
}

// ECMA262 20.3.1.11
function msFromTime(realm, t) {
  return t % msPerSecond;
}

// ECMA262 20.3.1.12
function MakeTime(realm, hour, min, sec, ms) {
  // 1. If hour is not finite or min is not finite or sec is not finite or ms is not finite, return NaN.
  if (!isFinite(hour) || !isFinite(min) || !isFinite(sec) || !isFinite(ms)) return NaN;

  // 2. Let h be ToInteger(hour).
  var h = (0, _to.ToInteger)(realm, new _index.NumberValue(realm, hour));

  // 3. Let m be ToInteger(min).
  var m = (0, _to.ToInteger)(realm, new _index.NumberValue(realm, min));

  // 4. Let s be ToInteger(sec).
  var s = (0, _to.ToInteger)(realm, new _index.NumberValue(realm, sec));

  // 5. Let milli be ToInteger(ms).
  var milli = (0, _to.ToInteger)(realm, new _index.NumberValue(realm, ms));

  // 6. Let t be h * msPerHour + m * msPerMinute + s * msPerSecond + milli, performing the arithmetic
  //    according to IEEE 754-2008 rules (that is, as if using the ECMAScript operators * and +).
  var t = h * msPerHour + m * msPerMinute + s * msPerSecond + milli;

  // 7. Return t.
  return t;
}

// ECMA262 20.3.1.13
function MakeDay(realm, year, month, date) {
  // 1. If year is not finite or month is not finite or date is not finite, return NaN.
  if (!isFinite(year) || !isFinite(month) || !isFinite(date)) return NaN;

  // 2. Let y be ToInteger(year).
  var y = (0, _to.ToInteger)(realm, new _index.NumberValue(realm, year));

  // 3. Let m be ToInteger(month).
  var m = (0, _to.ToInteger)(realm, new _index.NumberValue(realm, month));

  // 4. Let dt be ToInteger(date).
  var dt = (0, _to.ToInteger)(realm, new _index.NumberValue(realm, date));

  // 5. Let ym be y + floor(m / 12).
  var ym = y + Math.floor(m / 12);

  // 6. Let mn be m modulo 12.
  var mn = m < 0 ? m % 12 + 12 : m % 12;

  // 7. Find a value t such that YearFromTime(t) is ym and MonthFromTime(t) is mn and DateFromTime(t) is 1;
  //    but if this is not possible (because some argument is out of range), return NaN.
  //    Inspired by the V8 implementation.
  if (Math.abs(ym) >= 1000000.0 || Math.abs(mn) >= 1000000.0) {
    return NaN;
  }
  var yearDelta = 399999;
  var baseDay = 365 * (1970 + yearDelta) + Math.floor((1970 + yearDelta) / 4) - Math.floor((1970 + yearDelta) / 100) + Math.floor((1970 + yearDelta) / 400);
  var t = 365 * (ym + yearDelta) + Math.floor((ym + yearDelta) / 4) - Math.floor((ym + yearDelta) / 100) + Math.floor((ym + yearDelta) / 400) - baseDay;

  if (ym % 4 !== 0 || ym % 100 === 0 && ym % 400 !== 0) {
    t += [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334][mn];
  } else {
    t += [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335][mn];
  }

  // 8. Return Day(t) + dt - 1.
  return t + dt - 1;
}

// ECMA262 20.3.1.14
function MakeDate(realm, day, time) {
  // 1. If day is not finite or time is not finite, return NaN.
  if (!isFinite(day) || !isFinite(time)) return NaN;

  // 2. Return day × msPerDay + time.
  return day * msPerDay + time;
}

// ECMA262 20.3.1.15
function TimeClip(realm, time) {
  if (time instanceof _index.Value) time = time.throwIfNotConcreteNumber().value;
  // 1. If time is not finite, return NaN.
  if (!isFinite(time)) return realm.intrinsics.NaN;

  // 2. If abs(time) > 8.64 × 10^15, return NaN.
  if (Math.abs(time) > 8640000000000000) {
    return realm.intrinsics.NaN;
  }

  // 3. Let clippedTime be ToInteger(time).
  var clippedTime = (0, _to.ToInteger)(realm, new _index.NumberValue(realm, time));

  // 4. If clippedTime is -0, let clippedTime be +0.
  if (Object.is(clippedTime, -0)) clippedTime = +0;

  // 5. Return clippedTime.
  return new _index.NumberValue(realm, clippedTime);
}

// ECMA262 20.3.4
function thisTimeValue(realm, value) {
  // 1. If Type(value) is Object and value has a [[DateValue]] internal slot, then
  if (value instanceof _index.ObjectValue && value.$DateValue !== undefined) {
    // a. Return the value of value's [[DateValue]] internal slot.
    return value.$DateValue;
  }

  // 2. Throw a TypeError exception.
  throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
}

// ECMA262 20.3.4.41.1
function ToDateString(realm, tv) {
  // 1. Assert: Type(tv) is Number.
  (0, _invariant2.default)(typeof tv === "number", "expected tv to be a number");

  // 2. If tv is NaN, return "Invalid Date".
  if (isNaN(tv)) return "Invalid Date";

  // 3. Return an implementation-dependent String value that represents tv as a date and time in the current
  //    time zone using a convenient, human-readable form.
  return new Date(tv).toString();
}
//# sourceMappingURL=date.js.map