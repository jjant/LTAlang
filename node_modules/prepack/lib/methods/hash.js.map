{"version":3,"sources":["../../src/methods/hash.js"],"names":["hashBinary","hashCall","hashTernary","hashString","hashUnary","op","x","y","xHash","getHash","yHash","commutative","mightBeObject","mightBeString","hash","calleeName","args","a","z","value","i","length","charCodeAt","HashSet","expectedEntries","initialSize","_entries","Array","_count","e","entries","n","key","entry","undefined","expand","equals","oldEntries","m","oldEntry","j"],"mappings":";;;;;;;;;QAgBgBA,U,GAAAA,U;QAmCAC,Q,GAAAA,Q;QAMAC,W,GAAAA,W;QAKAC,U,GAAAA,U;QAQAC,S,GAAAA,S;;AA1DhB;;;;;;;;AAZA;;;;;;;;;AAgBO,SAASJ,UAAT,CAAiCK,EAAjC,EAA0DC,CAA1D,EAAgEC,CAAhE,EAA0F;AAC/F,MAAIC,QAAQF,EAAEG,OAAF,EAAZ;AACA,MAAIC,QAAQH,EAAEE,OAAF,EAAZ;AACA,MAAIC,QAAQF,KAAZ,EAAmB;AACjB;AACA,QAAIG,oBAAJ;AACA,YAAQN,EAAR;AACE,WAAK,GAAL;AACA,WAAK,IAAL;AACA,WAAK,IAAL;AACA,WAAK,KAAL;AACA,WAAK,KAAL;AACE;AACA;AACA;AACAM,sBAAc,EAAEL,EAAEM,aAAF,MAAqBL,EAAEK,aAAF,EAAvB,CAAd;AACA;AACF,WAAK,GAAL;AACE;AACAD,sBAAc,EAAEL,EAAEM,aAAF,MAAqBL,EAAEK,aAAF,EAAvB,KAA6C,EAAEN,EAAEO,aAAF,MAAqBN,EAAEM,aAAF,EAAvB,CAA3D;AACA;AACF;AACE;AACAF,sBAAc,KAAd;AACA;AAlBJ;AAoBA,QAAIA,WAAJ,EAAiB;AAAA,iBACN,CAACJ,CAAD,EAAID,CAAJ,CADM;AACdA,OADc;AACXC,OADW;AAAA,kBAEE,CAACG,KAAD,EAAQF,KAAR,CAFF;AAEdA,WAFc;AAEPE,WAFO;AAGhB;AACF;AACD,MAAII,OAAQ,CAAEX,WAAWE,EAAX,IAAiB,EAAlB,GAAwBG,KAAzB,IAAkC,EAAnC,GAAyCE,KAApD;AACA,SAAO,CAACI,IAAD,EAAO,CAACR,CAAD,EAAIC,CAAJ,CAAP,CAAP;AACD;;AAEM,SAASN,QAAT,CAA+Bc,UAA/B,EAA0F;AAC/F,MAAID,OAAOX,WAAWY,UAAX,CAAX;;AAD+F,oCAApCC,IAAoC;AAApCA,QAAoC;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAE/F,yBAAcA,IAAd;AAAA,UAASC,CAAT;AAAoBH,aAAQA,OAAO,EAAR,GAAcG,EAAER,OAAF,EAArB;AAApB;AAF+F;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAG/F,SAAO,CAACK,IAAD,EAAOE,IAAP,CAAP;AACD;;AAEM,SAASd,WAAT,CAAkCI,CAAlC,EAAwCC,CAAxC,EAA8CW,CAA9C,EAAwE;AAC7E,MAAIJ,OAAQ,CAAER,EAAEG,OAAF,KAAc,EAAf,GAAqBF,EAAEE,OAAF,EAAtB,IAAqC,EAAtC,GAA4CS,EAAET,OAAF,EAAvD;AACA,SAAO,CAACK,IAAD,EAAO,CAACR,CAAD,EAAIC,CAAJ,EAAOW,CAAP,CAAP,CAAP;AACD;;AAEM,SAASf,UAAT,CAAoBgB,KAApB,EAA2C;AAChD,MAAIL,OAAO,IAAX;AACA,OAAK,IAAIM,IAAID,MAAME,MAAN,GAAe,CAA5B,EAA+BD,KAAK,CAApC,EAAuCA,GAAvC,EAA4C;AAC1CN,WAAQA,OAAO,EAAR,GAAcK,MAAMG,UAAN,CAAiBF,CAAjB,CAArB;AACD;AACD,SAAON,IAAP;AACD;;AAEM,SAASV,SAAT,CAAmBC,EAAnB,EAA2CC,CAA3C,EAAgE;AACrE,SAAQH,WAAWE,EAAX,IAAiB,EAAlB,GAAwBC,EAAEG,OAAF,EAA/B;AACD;;IAIYc,O,WAAAA,O;AACX,qBAAkD;AAAA,QAAtCC,eAAsC,uEAAX,KAAK,IAAM;;AAAA;;AAChD,QAAIC,cAAc,EAAlB;AACAD,uBAAmB,CAAnB;AACA,WAAOC,cAAcD,eAArB;AAAsCC,qBAAe,CAAf;AAAtC,KACA,KAAKC,QAAL,GAAgB,IAAIC,KAAJ,CAAUF,WAAV,CAAhB;AACA,SAAKG,MAAL,GAAc,CAAd;AACD;;;;wBAKGC,C,EAAS;AACX,UAAIC,UAAU,KAAKJ,QAAnB;AACA,UAAIK,IAAID,QAAQT,MAAhB;AACA,UAAIW,MAAMH,EAAEpB,OAAF,EAAV;AACA,UAAIW,IAAIY,MAAOD,IAAI,CAAnB;AACA,aAAO,IAAP,EAAa;AACX,YAAIE,QAAQH,QAAQV,CAAR,CAAZ;AACA,YAAIa,UAAUC,SAAd,EAAyB;AACvBJ,kBAAQV,CAAR,IAAaS,CAAb;AACA,cAAI,EAAE,KAAKD,MAAP,GAAgBG,IAAI,CAAxB,EAA2B,KAAKI,MAAL;AAC3B,iBAAON,CAAP;AACD,SAJD,MAIO,IAAIA,EAAEO,MAAF,CAASH,KAAT,CAAJ,EAAqB;AAC1B,iBAAOA,KAAP;AACD;AACD,YAAI,EAAEb,CAAF,IAAOW,CAAX,EAAcX,IAAI,CAAJ;AACf;AACD,+BAAU,KAAV,EAhBW,CAgBO;AACnB;;;6BAEQ;AACP,UAAIiB,aAAa,KAAKX,QAAtB;AACA,UAAIK,IAAIM,WAAWhB,MAAnB;AACA,UAAIiB,IAAIP,IAAI,CAAZ;AACA,UAAIO,KAAK,CAAT,EAAY;AACZ,UAAIR,UAAU,IAAIH,KAAJ,CAAUW,CAAV,CAAd;AACA,WAAK,IAAIlB,IAAI,CAAb,EAAgBA,IAAIW,CAApB,EAAuBX,GAAvB,EAA4B;AAC1B,YAAImB,WAAWF,WAAWjB,CAAX,CAAf;AACA,YAAImB,aAAaL,SAAjB,EAA4B;AAC5B,YAAIF,MAAMO,SAAS9B,OAAT,EAAV;AACA,YAAI+B,IAAIR,MAAOM,IAAI,CAAnB;AACA,eAAO,IAAP,EAAa;AACX,cAAIL,QAAQH,QAAQU,CAAR,CAAZ;AACA,cAAIP,UAAUC,SAAd,EAAyB;AACvBJ,oBAAQU,CAAR,IAAaD,QAAb;AACA;AACD;AACD,cAAI,EAAEC,CAAF,IAAOF,CAAX,EAAcE,IAAI,CAAJ;AACf;AACF;AACD,WAAKd,QAAL,GAAgBI,OAAhB;AACD","file":"hash.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { BabelBinaryOperator, BabelUnaryOperator } from \"babel-types\";\nimport invariant from \"../invariant.js\";\n\ninterface Hashable { getHash(): number, mightBeString(): boolean, mightBeObject(): boolean }\n\nexport function hashBinary<T: Hashable>(op: BabelBinaryOperator, x: T, y: T): [number, Array<T>] {\n  let xHash = x.getHash();\n  let yHash = y.getHash();\n  if (yHash < xHash) {\n    // Check if the operation is commutative so that we can normalize the arguments on hash value order.\n    let commutative;\n    switch (op) {\n      case \"*\":\n      case \"==\":\n      case \"!=\":\n      case \"===\":\n      case \"!==\":\n        // If both operands might be objects, the operation does not commute because of the possibility\n        // that arbitrary code can run on both operands while converting them, in which case the order of the\n        // operands must be maintained to make sure any side-effects happen in the right order.\n        commutative = !(x.mightBeObject() && y.mightBeObject());\n        break;\n      case \"+\":\n        // As above, but in addition, if one of the operands might be a string the operation does not commute\n        commutative = !(x.mightBeObject() && y.mightBeObject()) && !(x.mightBeString() || y.mightBeString());\n        break;\n      default:\n        // The operation itself is not commutative\n        commutative = false;\n        break;\n    }\n    if (commutative) {\n      [x, y] = [y, x];\n      [xHash, yHash] = [yHash, xHash];\n    }\n  }\n  let hash = (((hashString(op) * 13) ^ xHash) * 13) ^ yHash;\n  return [hash, [x, y]];\n}\n\nexport function hashCall<T: Hashable>(calleeName: string, ...args: Array<T>): [number, Array<T>] {\n  let hash = hashString(calleeName);\n  for (let a of args) hash = (hash * 13) ^ a.getHash();\n  return [hash, args];\n}\n\nexport function hashTernary<T: Hashable>(x: T, y: T, z: T): [number, Array<T>] {\n  let hash = (((x.getHash() * 13) ^ y.getHash()) * 13) ^ z.getHash();\n  return [hash, [x, y, z]];\n}\n\nexport function hashString(value: string): number {\n  let hash = 5381;\n  for (let i = value.length - 1; i >= 0; i--) {\n    hash = (hash * 33) ^ value.charCodeAt(i);\n  }\n  return hash;\n}\n\nexport function hashUnary(op: BabelUnaryOperator, x: Hashable): number {\n  return (hashString(op) * 13) ^ x.getHash();\n}\n\ninterface Equatable { equals(x: any): boolean }\n\nexport class HashSet<T: Equatable & Hashable> {\n  constructor(expectedEntries?: number = 32 * 1024) {\n    let initialSize = 16;\n    expectedEntries *= 2;\n    while (initialSize < expectedEntries) initialSize *= 2;\n    this._entries = new Array(initialSize);\n    this._count = 0;\n  }\n\n  _count: number;\n  _entries: Array<void | T>;\n\n  add(e: T): T {\n    let entries = this._entries;\n    let n = entries.length;\n    let key = e.getHash();\n    let i = key & (n - 1);\n    while (true) {\n      let entry = entries[i];\n      if (entry === undefined) {\n        entries[i] = e;\n        if (++this._count > n / 2) this.expand();\n        return e;\n      } else if (e.equals(entry)) {\n        return entry;\n      }\n      if (++i >= n) i = 0;\n    }\n    invariant(false); // otherwise Flow thinks this method can return undefined\n  }\n\n  expand() {\n    let oldEntries = this._entries;\n    let n = oldEntries.length;\n    let m = n * 2;\n    if (m <= 0) return;\n    let entries = new Array(m);\n    for (let i = 0; i < n; i++) {\n      let oldEntry = oldEntries[i];\n      if (oldEntry === undefined) continue;\n      let key = oldEntry.getHash();\n      let j = key & (m - 1);\n      while (true) {\n        let entry = entries[j];\n        if (entry === undefined) {\n          entries[j] = oldEntry;\n          break;\n        }\n        if (++j >= m) j = 0;\n      }\n    }\n    this._entries = entries;\n  }\n}\n"]}