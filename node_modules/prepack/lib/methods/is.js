"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IsConcatSpreadable = IsConcatSpreadable;
exports.IsGenericDescriptor = IsGenericDescriptor;
exports.IsAccessorDescriptor = IsAccessorDescriptor;
exports.IsDataDescriptor = IsDataDescriptor;
exports.OrdinaryIsExtensible = OrdinaryIsExtensible;
exports.IsExtensible = IsExtensible;
exports.IsCallable = IsCallable;
exports.IsConstructor = IsConstructor;
exports.IsInteger = IsInteger;
exports.IsPropertyKey = IsPropertyKey;
exports.IsArray = IsArray;
exports.IsInTailPosition = IsInTailPosition;
exports.IsRegExp = IsRegExp;
exports.IsIdentifierRef = IsIdentifierRef;
exports.IsFunctionDefinition = IsFunctionDefinition;
exports.IsAnonymousFunctionDefinition = IsAnonymousFunctionDefinition;
exports.IsArrayIndex = IsArrayIndex;
exports.IsPromise = IsPromise;
exports.IsDetachedBuffer = IsDetachedBuffer;
exports.IsIntrospectionError = IsIntrospectionError;
exports.IsStatic = IsStatic;

var _errors = require("../errors.js");

var _to = require("./to.js");

var _get = require("./get.js");

var _index = require("../values/index.js");

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _has = require("./has.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// ECMA262 22.1.3.1.1
function IsConcatSpreadable(realm, O) {
  // 1. If Type(O) is not Object, return false.
  if (!O.mightBeObject()) return false;
  O = O.throwIfNotObject();

  // 2. Let spreadable be ? Get(O, @@isConcatSpreadable).
  var spreadable = (0, _get.Get)(realm, O, realm.intrinsics.SymbolIsConcatSpreadable);

  // 3. If spreadable is not undefined, return ToBoolean(spreadable).
  if (!spreadable.mightBeUndefined()) return (0, _to.ToBooleanPartial)(realm, spreadable);
  spreadable.throwIfNotConcrete();

  // 4. Return ? IsArray(O).
  return IsArray(realm, O);
}

// ECMA262 6.2.4.3
/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

function IsGenericDescriptor(realm, Desc) {
  // 1. If Desc is undefined, return false.
  if (!Desc) return false;

  // 2. If IsAccessorDescriptor(Desc) and IsDataDescriptor(Desc) are both false, return true.
  if (!IsAccessorDescriptor(realm, Desc) && !IsDataDescriptor(realm, Desc)) return true;

  // 3. Return false.
  return false;
}

// ECMA262 6.2.4.1
function IsAccessorDescriptor(realm, Desc) {
  // 1. If Desc is undefined, return false.
  if (!Desc) return false;

  // 2. If both Desc.[[Get]] and Desc.[[Set]] are absent, return false.
  if (!("get" in Desc) && !("set" in Desc)) return false;

  // 3. Return true.
  return true;
}

// ECMA262 6.2.4.2
function IsDataDescriptor(realm, Desc) {
  // If Desc is undefined, return false.
  if (!Desc) return false;

  // If both Desc.[[Value]] and Desc.[[Writable]] are absent, return false.
  if (!("value" in Desc) && !("writable" in Desc)) return false;

  // Return true.
  return true;
}

// ECMA262 9.1.3.1
function OrdinaryIsExtensible(realm, O) {
  // 1. Return the value of the [[Extensible]] internal slot of O.
  return O.getExtensible();
}

// ECMA262 7.2.5
function IsExtensible(realm, O) {
  // 1. Assert: Type(O) is Object.

  // 2. Return ? O.[[IsExtensible]]().
  return O.$IsExtensible();
}

// ECMA262 7.2.3
function IsCallable(realm, func) {
  // 1. If Type(argument) is not Object, return false.
  if (!func.mightBeObject()) return false;
  if ((0, _has.HasCompatibleType)(func, _index.FunctionValue)) return true;

  // 2. If argument has a [[Call]] internal method, return true.
  func = func.throwIfNotConcreteObject();
  if (func.$Call) return true;

  // 3. Return false.
  return false;
}

// ECMA262 7.2.4
function IsConstructor(realm, argument) {
  // 1. If Type(argument) is not Object, return false.
  if (!argument.mightBeObject()) return false;

  // 2. If argument has a [[Construct]] internal method, return true.
  argument = argument.throwIfNotConcreteObject();
  if (argument.$Construct) return true;

  // 3. Return false.
  return false;
}

// ECMA262 7.2.6
function IsInteger(realm, argument) {
  // 1. If Type(argument) is not Number, return false.
  (0, _invariant2.default)(typeof argument === "number", "Type(argument) is not number");

  // 2. If argument is NaN, +∞, or -∞, return false.
  if (isNaN(argument) || argument === +Infinity || argument === -Infinity) return false;

  // 3. If floor(abs(argument)) ≠ abs(argument), return false.
  if (Math.floor(Math.abs(argument)) !== Math.abs(argument)) return false;

  // 4. Return true.
  return true;
}

// ECMA262 7.2.7
function IsPropertyKey(realm, arg) {
  // We allow native strings to be passed around to avoid constructing a StringValue
  if (typeof arg === "string") return true;

  // 1. If Type(argument) is String, return true.
  if (arg instanceof _index.StringValue) return true;

  // 2. If Type(argument) is Symbol, return true.
  if (arg instanceof _index.SymbolValue) return true;

  if (arg instanceof _index.AbstractValue) {
    _index.AbstractValue.reportIntrospectionError(arg);
    throw new _errors.FatalError();
  }

  // 3. Return false.
  return false;
}

// ECMA262 7.2.2
function IsArray(realm, argument) {
  // 1. If Type(argument) is not Object, return false.
  if (!argument.mightBeObject()) return false;

  // 2. If argument is an Array exotic object, return true.
  if (argument instanceof _index.ArrayValue || argument === realm.intrinsics.ArrayPrototype) return true;

  // 3. If argument is a Proxy exotic object, then
  if (argument instanceof _index.ProxyValue) {
    // a. If the value of the [[ProxyHandler]] internal slot of argument is null, throw a TypeError exception.
    if (!argument.$ProxyHandler || argument.$ProxyHandler instanceof _index.NullValue) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    }

    // b. Let target be the value of the [[ProxyTarget]] internal slot of argument.
    var target = argument.$ProxyTarget;

    // c. Return ? IsArray(target).
    return IsArray(realm, target);
  }

  // 4. Return false.
  argument.throwIfNotConcrete();
  return false;
}

// ECMA262 14.6.1
function IsInTailPosition(realm, node) {
  // TODO #1008: implement tail calls
  return false;
}

// ECMA262 7.2.8
function IsRegExp(realm, argument) {
  // 1. If Type(argument) is not Object, return false.
  if (!argument.mightBeObject()) return false;
  argument = argument.throwIfNotObject();

  // 2. Let isRegExp be ? Get(argument, @@match).
  var isRegExp = (0, _get.Get)(realm, argument, realm.intrinsics.SymbolMatch);

  // 3. If isRegExp is not undefined, return ToBoolean(isRegExp).
  if (isRegExp !== undefined) return (0, _to.ToBooleanPartial)(realm, isRegExp) === true;

  // 4. If argument has a [[RegExpMatcher]] internal slot, return true.
  if (argument.$RegExpMatcher) return true;

  // 5. Return false.
  return false;
}

// ECMA262 12.2.1.4 Static Semantics: IsIdentifierRef
// ECMA262 12.3.1.4 Static Semantics: IsIdentifierRef
function IsIdentifierRef(realm, node) {
  switch (node.type) {
    // ECMA262 12.2.1.4 Static Semantics: IsIdentifierRef
    case "Identifier":
      return true;
    // ECMA262 12.3.1.4 Static Semantics: IsIdentifierRef
    case "MemberExpression":
      return false;
    default:
      throw Error("Unexpected AST form : " + node.type);
  }
}

// 12.2.1.3 Static Semantics: IsFunctionDefinition
// 12.2.1.3 Static Semantics: IsFunctionDefinition
// 12.13 Binary Logical Operators
// 12.3.1.2 Static Semantics: IsFunctionDefinition
// 12.15.2 Static Semantics: IsFunctionDefinition
function IsFunctionDefinition(realm, node) {
  switch (node.type) {
    // 12.2.1.3 Static Semantics: IsFunctionDefinition
    case "ThisExpression":
    case "Identifier":
    case "StringLiteral":
    case "NumericLiteral":
    case "BooleanLiteral":
    case "NullLiteral":
    case "RegExpLiteral":
    case "ArrayExpression":
    case "ObjectExpression":
    case "TemplateLiteral":
    case "ConditionalExpression":
      return false;
    // 12.2.1.3 Static Semantics: IsFunctionDefinition
    case "UpdateExpression":
      return false;
    // 12.13 Binary Logical Operators
    case "BinaryExpression":
    case "LogicalExpression":
      return false;
    // 12.3.1.2 Static Semantics: IsFunctionDefinition
    case "MemberExpression":
    case "CallExpression":
    case "NewExpression":
    case "MetaProperty":
    case "TaggedTemplateExpression":
      return false;
    //12.5.1 Static Semantics: IsFunctionDefinition
    case "UnaryExpression":
      return false;
    //12.15.2 Static Semantics: IsFunctionDefinition
    case "AssignmentExpression":
      return false;
    //12.16.1 Static Semantics: IsFunctionDefinition
    case "SequenceExpression":
      return false;
    case "ArrowFunctionExpression":
    case "FunctionExpression":
      return true;
    // 14.5.8 Static Semantics: IsFunctionDefinition
    case "ClassExpression":
      return true;
    // JSX Extensions: http://facebook.github.io/jsx/
    case "JSXElement":
      return false;
    default:
      throw Error("Unexpected AST form : " + node.type);
  }
}

// ECMA262 14.1.10
function IsAnonymousFunctionDefinition(realm, node) {
  // 1. If IsFunctionDefinition of production is false, return false.
  if (!IsFunctionDefinition(realm, node)) return false;

  // 2. Let hasName be the result of HasName of production.
  var hasName = (0, _has.HasName)(realm, node);

  // 3. If hasName is true, return false.
  if (hasName === true) return false;

  // 4. Return true.
  return true;
}

// ECMA262 9.4.2
function IsArrayIndex(realm, P) {
  var key = void 0;
  if (typeof P === "string") {
    key = P;
  } else if (P instanceof _index.StringValue) {
    key = P.value;
  } else {
    return false;
  }

  var i = (0, _to.ToUint32)(realm, new _index.StringValue(realm, key));
  return i !== Math.pow(2, 32) - 1 && (0, _to.ToString)(realm, new _index.NumberValue(realm, i)) === key;
}

// ECMA262 25.4.1.6
function IsPromise(realm, x) {
  // 1. If Type(x) is not Object, return false.
  if (!x.mightBeObject()) return false;

  // 2. If x does not have a [[PromiseState]] internal slot, return false.
  x = x.throwIfNotConcreteObject();
  if (!x.$PromiseState) return false;

  // 3. Return true.
  return true;
}

// ECMA262 24.1.1.2
function IsDetachedBuffer(realm, arrayBuffer) {
  // 1. Assert: Type(arrayBuffer) is Object and it has an [[ArrayBufferData]] internal slot.
  (0, _invariant2.default)(arrayBuffer instanceof _index.ObjectValue && "$ArrayBufferData" in arrayBuffer);

  // 2. If arrayBuffer's [[ArrayBufferData]] internal slot is null, return true.
  if (arrayBuffer.$ArrayBufferData === null) return true;

  // 3. Return false.
  return false;
}

function IsIntrospectionError(realm, value) {
  if (!value.mightBeObject()) return false;
  value = value.throwIfNotConcreteObject();
  return value.$GetPrototypeOf() === realm.intrinsics.__IntrospectionErrorPrototype;
}

function IsStatic(classElement) {
  // $FlowFixMe need to backport static property to BabelNodeClassMethod
  return classElement.static;
}
//# sourceMappingURL=is.js.map