{"version":3,"sources":["../../src/methods/get.js"],"names":["GetFunctionRealm","OrdinaryGet","GetGlobalObject","GetSubstitution","GetMethod","GetPrototypeFromConstructor","Get","GetV","GetThisValue","GetNewTarget","GetTemplateObject","realm","obj","$Realm","target","$BoundTargetFunction","$ProxyHandler","createErrorThrowCompletion","intrinsics","TypeError","$ProxyTarget","proxyTarget","O","P","Receiver","dataOnly","desc","$GetOwnProperty","undefined","joinCondition","descriptor2","descriptor1","withCondition","evaluateForEffects","OrdinaryGetHelper","compl1","gen1","bindings1","properties1","createdObj1","withInverseCondition","compl2","gen2","bindings2","properties2","createdObj2","joinedEffects","joinEffects","completion","composeWithSavedCompletion","applyEffects","descValue","value","mightHaveBeenDeleted","parent","$GetPrototypeOf","parentVal","cond","createFromBinaryOp","empty","joinValuesAsConditional","$Get","reportIntrospectionError","getter","get","ctx","getRunningContext","currentRealm","$GlobalObject","matched","str","position","captures","replacement","matchLength","length","stringLength","Array","isArray","tailPos","m","result","i","ch","charAt","peek","substr","idx","charCodeAt","peek2","newIdx","V","func","constructor","intrinsicDefaultProto","proto","IsPropertyReference","IsSuperReference","thisValue","GetBase","envRec","GetThisEnvironment","SyntaxError","$NewTarget","templateLiteral","rawStrings","quasis","map","quasi","raw","templateRegistry","$TemplateMap","e","same","$Strings","$Array","cookedStrings","cooked","count","template","rawObj","index","prop","cookedValue","$DefineOwnProperty","writable","enumerable","configurable","rawValue","push"],"mappings":"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","file":"get.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { AbruptCompletion, PossiblyNormalCompletion } from \"../completions.js\";\nimport { construct_empty_effects, type Realm } from \"../realm.js\";\nimport type { PropertyKeyValue, CallableObjectValue } from \"../types.js\";\nimport {\n  AbstractObjectValue,\n  AbstractValue,\n  BoundFunctionValue,\n  EmptyValue,\n  NullValue,\n  NumberValue,\n  ObjectValue,\n  ProxyValue,\n  StringValue,\n  UndefinedValue,\n  Value,\n} from \"../values/index.js\";\nimport { Reference } from \"../environment.js\";\nimport { FatalError } from \"../errors.js\";\nimport { ArrayCreate } from \"./create.js\";\nimport { SetIntegrityLevel } from \"./integrity.js\";\nimport { ToString } from \"./to.js\";\nimport {\n  Call,\n  HasSomeCompatibleType,\n  IsAccessorDescriptor,\n  IsCallable,\n  IsDataDescriptor,\n  IsPropertyKey,\n  ToObjectPartial,\n} from \"./index.js\";\nimport { Environment, Join, Path } from \"../singletons.js\";\nimport invariant from \"../invariant.js\";\nimport type { BabelNodeTemplateLiteral } from \"babel-types\";\n\n// ECMA262 7.3.22\nexport function GetFunctionRealm(realm: Realm, obj: ObjectValue): Realm {\n  // 1. Assert: obj is a callable object.\n  invariant(IsCallable(realm, obj), \"expected callable object\");\n\n  // 2. If obj has a [[Realm]] internal slot, then\n  if (obj.$Realm) {\n    // a. Return obj's [[Realm]] internal slot.\n    return obj.$Realm;\n  }\n\n  // 3. If obj is a Bound Function exotic object, then\n  if (obj instanceof BoundFunctionValue) {\n    // a. Let target be obj's [[BoundTargetFunction]] internal slot.\n    let target = obj.$BoundTargetFunction;\n\n    // b. Return ? GetFunctionRealm(target).\n    return GetFunctionRealm(realm, target);\n  }\n\n  // 4. If obj is a Proxy exotic object, then\n  if (obj instanceof ProxyValue) {\n    // a. If the value of the [[ProxyHandler]] internal slot of obj is null, throw a TypeError exception.\n    if (obj.$ProxyHandler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"proxy handler is null\");\n    }\n    invariant(obj.$ProxyTarget instanceof ObjectValue);\n\n    // b. Let proxyTarget be the value of obj's [[ProxyTarget]] internal slot.\n    let proxyTarget = obj.$ProxyTarget;\n\n    // c. Return ? GetFunctionRealm(proxyTarget).\n    return GetFunctionRealm(realm, proxyTarget);\n  }\n\n  // 5. Return the current Realm Record.\n  return realm;\n}\n\n// ECMA262 9.1.8.1\nexport function OrdinaryGet(\n  realm: Realm,\n  O: ObjectValue,\n  P: PropertyKeyValue,\n  Receiver: Value,\n  dataOnly?: boolean\n): Value {\n  // 1. Assert: IsPropertyKey(P) is true.\n  invariant(IsPropertyKey(realm, P), \"expected property key\");\n\n  // 2. Let desc be ? O.[[GetOwnProperty]](P).\n  let desc = O.$GetOwnProperty(P);\n  if (desc !== undefined && desc.joinCondition !== undefined) {\n    // joined descriptors need special treatment\n    let joinCondition = desc.joinCondition;\n    if (joinCondition !== undefined) {\n      let descriptor2 = desc.descriptor2;\n      desc = desc.descriptor1;\n      let [compl1, gen1, bindings1, properties1, createdObj1] = Path.withCondition(joinCondition, () => {\n        return desc !== undefined\n          ? realm.evaluateForEffects(() => OrdinaryGetHelper())\n          : construct_empty_effects(realm);\n      });\n      desc = descriptor2;\n      let [compl2, gen2, bindings2, properties2, createdObj2] = Path.withInverseCondition(joinCondition, () => {\n        return desc !== undefined\n          ? realm.evaluateForEffects(() => OrdinaryGetHelper())\n          : construct_empty_effects(realm);\n      });\n\n      // Join the effects, creating an abstract view of what happened, regardless\n      // of the actual value of ownDesc.joinCondition.\n      let joinedEffects = Join.joinEffects(\n        realm,\n        joinCondition,\n        [compl1, gen1, bindings1, properties1, createdObj1],\n        [compl2, gen2, bindings2, properties2, createdObj2]\n      );\n      let completion = joinedEffects[0];\n      if (completion instanceof PossiblyNormalCompletion) {\n        // in this case one of the branches may complete abruptly, which means that\n        // not all control flow branches join into one flow at this point.\n        // Consequently we have to continue tracking changes until the point where\n        // all the branches come together into one.\n        completion = realm.composeWithSavedCompletion(completion);\n      }\n      // Note that the effects of (non joining) abrupt branches are not included\n      // in joinedEffects, but are tracked separately inside completion.\n      realm.applyEffects(joinedEffects);\n\n      // return or throw completion\n      if (completion instanceof AbruptCompletion) throw completion;\n      invariant(completion instanceof Value);\n      return completion;\n    }\n  }\n\n  return OrdinaryGetHelper();\n\n  function OrdinaryGetHelper() {\n    let descValue = !desc\n      ? realm.intrinsics.undefined\n      : desc.value === undefined ? realm.intrinsics.undefined : desc.value;\n    invariant(descValue instanceof Value);\n\n    // 3. If desc is undefined, then\n    if (!desc || descValue.mightHaveBeenDeleted()) {\n      // a. Let parent be ? O.[[GetPrototypeOf]]().\n      let parent = O.$GetPrototypeOf();\n\n      // b. If parent is null, return undefined.\n      if (parent instanceof NullValue) {\n        // Return the property value since it is now known to be the right value\n        // even in the case when it is empty.\n        return descValue;\n      }\n\n      // c. Return ? parent.[[Get]](P, Receiver).\n      if (descValue.mightHaveBeenDeleted() && descValue instanceof AbstractValue) {\n        // We don't know for sure that O.P does not exist.\n        let parentVal = OrdinaryGet(realm, parent, P, descValue, true);\n        if (parentVal instanceof UndefinedValue)\n          // even O.P returns undefined it is still the right value.\n          return descValue;\n        // Join with parent value with descValue because the actual value will be\n        // descValue unless it is empty.\n        // Only get the parent value if it does not involve a getter call.\n        // Use a property get for the joined value since it does the check for empty.\n        let cond = AbstractValue.createFromBinaryOp(realm, \"!==\", descValue, realm.intrinsics.empty);\n        return Join.joinValuesAsConditional(realm, cond, descValue, parentVal);\n      }\n      invariant(!desc || descValue instanceof EmptyValue);\n      return parent.$Get(P, Receiver);\n    }\n\n    // 4. If IsDataDescriptor(desc) is true, return desc.[[Value]].\n    if (IsDataDescriptor(realm, desc)) return descValue;\n    if (dataOnly) {\n      invariant(descValue instanceof AbstractValue);\n      AbstractValue.reportIntrospectionError(descValue);\n      throw new FatalError();\n    }\n\n    // 5. Assert: IsAccessorDescriptor(desc) is true.\n    invariant(IsAccessorDescriptor(realm, desc), \"expected accessor descriptor\");\n\n    // 6. Let getter be desc.[[Get]].\n    let getter = desc.get;\n\n    // 7. If getter is undefined, return undefined.\n    if (!getter || getter instanceof UndefinedValue) return realm.intrinsics.undefined;\n\n    // 8. Return ? Call(getter, Receiver).\n    return Call(realm, getter, Receiver);\n  }\n}\n\n// ECMA262 8.3.6\nexport function GetGlobalObject(realm: Realm): ObjectValue | AbstractObjectValue {\n  // 1. Let ctx be the running execution context.\n  let ctx = realm.getRunningContext();\n\n  // 2. Let currentRealm be ctx's Realm.\n  let currentRealm = ctx.realm;\n\n  // 3. Return currentRealm.[[GlobalObject]].\n  return currentRealm.$GlobalObject;\n}\n\n// ECMA262 21.1.3.14.1\nexport function GetSubstitution(\n  realm: Realm,\n  matched: string,\n  str: string,\n  position: number,\n  captures: Array<string | void>,\n  replacement: string\n): string {\n  // 1. Assert: Type(matched) is String.\n  invariant(typeof matched === \"string\", \"expected matched to be a stirng\");\n\n  // 2. Let matchLength be the number of code units in matched.\n  let matchLength = matched.length;\n\n  // 3. Assert: Type(str) is String.\n  invariant(typeof str === \"string\", \"expected matched to be a stirng\");\n\n  // 4. Let stringLength be the number of code units in str.\n  let stringLength = str.length;\n\n  // 5. Assert: position is a nonnegative integer.\n  invariant(position >= 0, \"expected position to be a nonegative integer\");\n\n  // 6. Assert: position ≤ stringLength.\n  invariant(position <= stringLength, \"expected position to be less than string length\");\n\n  // 7. Assert: captures is a possibly empty List of Strings.\n  invariant(Array.isArray(captures), \"expected captures to be an array\");\n\n  // 8. Assert: Type(replacement) is String.\n  invariant(typeof replacement === \"string\", \"expected replacement to be a stirng\");\n\n  // 9. Let tailPos be position + matchLength.\n  let tailPos = position + matchLength;\n\n  // 10. Let m be the number of elements in captures.\n  let m = captures.length;\n\n  // 11. Let result be a String value derived from replacement by copying code unit elements\n  //     from replacement to result while performing replacements as specified in Table 46.\n  //     These $ replacements are done left-to-right, and, once such a replacement is performed,\n  //     the new replacement text is not subject to further replacements.\n  let result = \"\";\n  for (let i = 0; i < replacement.length; ++i) {\n    let ch = replacement.charAt(i);\n    if (ch !== \"$\" || i + 1 >= replacement.length) {\n      result += ch;\n      continue;\n    }\n    let peek = replacement.charAt(i + 1);\n    if (peek === \"&\") {\n      result += matched;\n    } else if (peek === \"$\") {\n      result += \"$\";\n    } else if (peek === \"`\") {\n      result += str.substr(0, position);\n    } else if (peek === \"'\") {\n      result += str.substr(tailPos);\n    } else if (peek >= \"0\" && peek <= \"9\") {\n      let idx = peek.charCodeAt(0) - \"0\".charCodeAt(0);\n      if (i + 2 < replacement.length) {\n        let peek2 = replacement.charAt(i + 2);\n        if (peek2 >= \"0\" && peek2 <= \"9\") {\n          let newIdx = idx * 10 + (peek2.charCodeAt(0) - \"0\".charCodeAt(0));\n          if (newIdx <= m) {\n            idx = newIdx;\n            i += 1;\n          }\n        }\n      }\n      if (idx > 0 && idx <= m) {\n        result += captures[idx - 1] || \"\";\n      } else {\n        result += \"$\" + idx;\n      }\n    } else {\n      result += \"$\" + peek;\n    }\n    i += 1;\n  }\n\n  // 12. Return result.\n  return result;\n}\n\n// ECMA262 7.3.9\nexport function GetMethod(realm: Realm, V: Value, P: PropertyKeyValue): UndefinedValue | CallableObjectValue {\n  // 1. Assert: IsPropertyKey(P) is true.\n  invariant(IsPropertyKey(realm, P), \"expected property key\");\n\n  // 2. Let func be ? GetV(V, P).\n  let func = GetV(realm, V, P);\n\n  // 3. If func is either undefined or null, return undefined.\n  if (HasSomeCompatibleType(func, NullValue, UndefinedValue)) {\n    return realm.intrinsics.undefined;\n  }\n\n  // 4. If IsCallable(func) is false, throw a TypeError exception.\n  if (!IsCallable(realm, func)) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not callable\");\n  }\n\n  // 5. Return func.\n  return ((func: any): CallableObjectValue);\n}\n\n// ECMA262 9.1.14\nexport function GetPrototypeFromConstructor(\n  realm: Realm,\n  constructor: ObjectValue,\n  intrinsicDefaultProto: string\n): ObjectValue {\n  // 1. Assert: intrinsicDefaultProto is a String value that is this specification's name of an intrinsic\n  //   object. The corresponding object must be an intrinsic that is intended to be used as the [[Prototype]]\n  //   value of an object.\n  invariant(realm.intrinsics[intrinsicDefaultProto], \"not a valid proto ref\");\n\n  // 2. Assert: IsCallable(constructor) is true.\n  invariant(IsCallable(realm, constructor) === true, \"expected constructor to be callable\");\n\n  // 3. Let proto be ? Get(constructor, \"prototype\").\n  let proto = Get(realm, constructor, new StringValue(realm, \"prototype\"));\n\n  // 4. If Type(proto) is not Object, then\n  if (!(proto instanceof ObjectValue)) {\n    // a. Let realm be ? GetFunctionRealm(constructor).\n    realm = GetFunctionRealm(realm, constructor);\n\n    // b. Let proto be realm's intrinsic object named intrinsicDefaultProto.\n    proto = realm.intrinsics[intrinsicDefaultProto];\n  }\n\n  // 5. Return proto.\n  return proto;\n}\n\n// ECMA262 7.3.1\nexport function Get(realm: Realm, O: ObjectValue | AbstractObjectValue, P: PropertyKeyValue): Value {\n  // 1. Assert: Type(O) is Object.\n  invariant(O instanceof ObjectValue || O instanceof AbstractObjectValue, \"Not an object value\");\n\n  // 2. Assert: IsPropertyKey(P) is true.\n  invariant(IsPropertyKey(realm, P), \"Not a valid property key\");\n\n  // 3. Return ? O.[[Get]](P, O).\n  return O.$Get(P, O);\n}\n\n// ECMA262 7.3.2\nexport function GetV(realm: Realm, V: Value, P: PropertyKeyValue): Value {\n  // 1. Assert: IsPropertyKey(P) is true.\n  invariant(IsPropertyKey(realm, P), \"Not a valid property key\");\n\n  // 2. Let O be ? ToObject(V).\n  let O = ToObjectPartial(realm, V);\n\n  // 3. Return ? O.[[Get]](P, V).\n  return O.$Get(P, V);\n}\n\n// ECMA262 6.2.3.3\nexport function GetThisValue(realm: Realm, V: Reference): Value {\n  // 1. Assert: IsPropertyReference(V) is true.\n  invariant(Environment.IsPropertyReference(realm, V), \"expected property reference\");\n\n  // 2. If IsSuperReference(V) is true, then\n  if (Environment.IsSuperReference(realm, V)) {\n    invariant(V.thisValue !== undefined);\n    // a. Return the value of the thisValue component of the reference V.\n    return V.thisValue;\n  }\n\n  // 3. Return GetBase(V).\n  let result = Environment.GetBase(realm, V);\n  invariant(result instanceof Value);\n  return result;\n}\n\n// ECMA262 8.3.5\nexport function GetNewTarget(realm: Realm): UndefinedValue | ObjectValue {\n  // 1. Let envRec be GetThisEnvironment( ).\n  let envRec = Environment.GetThisEnvironment(realm);\n\n  // 2. Assert: envRec has a [[NewTarget]] field.\n  if (!(\"$NewTarget\" in envRec)) {\n    // In the spec we should not get here because earlier static checks are supposed to prevent it.\n    // However, we do not have an appropriate place to do this check earlier.\n    throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, \"new.target not allowed here\");\n  }\n\n  // 3. Return envRec.[[NewTarget]].\n  return envRec.$NewTarget || realm.intrinsics.undefined;\n}\n\nexport function GetTemplateObject(realm: Realm, templateLiteral: BabelNodeTemplateLiteral): ObjectValue {\n  // 1. Let rawStrings be TemplateStrings of templateLiteral with argument true.\n  let rawStrings = templateLiteral.quasis.map(quasi => quasi.value.raw);\n\n  // 2. Let realm be the current Realm Record.\n  realm;\n\n  // 3. Let templateRegistry be realm.[[TemplateMap]].\n  let templateRegistry = realm.$TemplateMap;\n\n  // 4. For each element e of templateRegistry, do\n  for (let e of templateRegistry) {\n    let same;\n    if (e.$Strings.length === rawStrings.length) {\n      same = true;\n      for (let i = 0; i < rawStrings.length; ++i) {\n        if (e.$Strings[i] !== rawStrings[i]) {\n          same = false;\n          break;\n        }\n      }\n    } else {\n      same = false;\n    }\n\n    // a. If e.[[Strings]] and rawStrings contain the same values in the same order, then\n    if (same) {\n      // i. Return e.[[Array]].\n      return e.$Array;\n    }\n  }\n\n  // 5. Let cookedStrings be TemplateStrings of templateLiteral with argument false.\n  let cookedStrings = templateLiteral.quasis.map(quasi => quasi.value.cooked);\n\n  // 6. Let count be the number of elements in the List cookedStrings.\n  let count = cookedStrings.length;\n\n  // 7. Let template be ArrayCreate(count).\n  let template = ArrayCreate(realm, count);\n\n  // 8. Let rawObj be ArrayCreate(count).\n  let rawObj = ArrayCreate(realm, count);\n\n  // 9. Let index be 0.\n  let index = 0;\n\n  // 10. Repeat while index < count\n  while (index < count) {\n    // a. Let prop be ! ToString(index).\n    let prop = ToString(realm, new NumberValue(realm, index));\n\n    // b. Let cookedValue be the String value cookedStrings[index].\n    let cookedValue = new StringValue(realm, cookedStrings[index]);\n\n    // c. Call template.[[DefineOwnProperty]](prop, PropertyDescriptor{[[Value]]: cookedValue, [[Writable]]: false, [[Enumerable]]: true, [[Configurable]]: false}).\n    template.$DefineOwnProperty(prop, {\n      value: cookedValue,\n      writable: false,\n      enumerable: true,\n      configurable: false,\n    });\n\n    // d. Let rawValue be the String value rawStrings[index].\n    let rawValue = new StringValue(realm, rawStrings[index]);\n\n    // e. Call rawObj.[[DefineOwnProperty]](prop, PropertyDescriptor{[[Value]]: rawValue, [[Writable]]: false, [[Enumerable]]: true, [[Configurable]]: false}).\n    rawObj.$DefineOwnProperty(prop, {\n      value: rawValue,\n      writable: false,\n      enumerable: true,\n      configurable: false,\n    });\n\n    // f. Let index be index+1.\n    index = index + 1;\n  }\n\n  // 11. Perform SetIntegrityLevel(rawObj, \"frozen\").\n  SetIntegrityLevel(realm, rawObj, \"frozen\");\n\n  // 12. Call template.[[DefineOwnProperty]](\"raw\", PropertyDescriptor{[[Value]]: rawObj, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false}).\n  template.$DefineOwnProperty(\"raw\", {\n    value: rawObj,\n    writable: false,\n    enumerable: false,\n    configurable: false,\n  });\n\n  // 13. Perform SetIntegrityLevel(template, \"frozen\").\n  SetIntegrityLevel(realm, template, \"frozen\");\n\n  // 14. Append the Record{[[Strings]]: rawStrings, [[Array]]: template} to templateRegistry.\n  templateRegistry.push({ $Strings: rawStrings, $Array: template });\n\n  // 15. Return template.\n  return template;\n}\n"]}