"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OrdinaryPreventExtensions = OrdinaryPreventExtensions;
exports.SetIntegrityLevel = SetIntegrityLevel;
exports.TestIntegrityLevel = TestIntegrityLevel;

var _index = require("../values/index.js");

var _index2 = require("./index.js");

var _singletons = require("../singletons.js");

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// ECMA262 9.1.4.1
function OrdinaryPreventExtensions(realm, O) {
  // 1. Set the value of the [[Extensible]] internal slot of O to false.
  O.setExtensible(false);

  // 2. Return true.
  return true;
}

// ECMA262 7.3.14
/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

function SetIntegrityLevel(realm, O, level) {
  // 1. Assert: Type(O) is Object.
  (0, _invariant2.default)(O instanceof _index.ObjectValue, "expected an object");

  // 2. Assert: level is either "sealed" or "frozen".
  (0, _invariant2.default)(level === "sealed" || level === "frozen", "invalid level");

  // 3. Let status be ? O.[[PreventExtensions]]().
  var status = O.$PreventExtensions();

  // 4. If status is false, return false.
  if (status === false) return false;

  // 5. Let keys be ? O.[[OwnPropertyKeys]]().
  var keys = O.$OwnPropertyKeys();

  // 6. If level is "sealed", then
  if (level === "sealed") {
    // a. Repeat for each element k of keys,
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var k = _step.value;

        // i. Perform ? DefinePropertyOrThrow(O, k, PropertyDescriptor{[[Configurable]]: false}).
        _singletons.Properties.DefinePropertyOrThrow(realm, O, k, {
          configurable: false
        });
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  } else if (level === "frozen") {
    // 7. Else level is "frozen",
    // a. Repeat for each element k of keys,
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = keys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var _k = _step2.value;

        // i. Let currentDesc be ? O.[[GetOwnProperty]](k).
        var currentDesc = O.$GetOwnProperty(_k);

        // ii. If currentDesc is not undefined, then
        if (currentDesc) {
          _singletons.Properties.ThrowIfMightHaveBeenDeleted(currentDesc.value);
          var desc = void 0;

          // 1. If IsAccessorDescriptor(currentDesc) is true, then
          if ((0, _index2.IsAccessorDescriptor)(realm, currentDesc)) {
            // a. Let desc be the PropertyDescriptor{[[Configurable]]: false}.
            desc = { configurable: false };
          } else {
            // 2. Else,
            // b. Let desc be the PropertyDescriptor { [[Configurable]]: false, [[Writable]]: false }.
            desc = { configurable: false, writable: false };
          }

          // 3. Perform ? DefinePropertyOrThrow(O, k, desc).
          _singletons.Properties.DefinePropertyOrThrow(realm, O, _k, desc);
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  }

  // 8. Return true.
  return true;
}

// ECMA262 7.3.15
function TestIntegrityLevel(realm, O, level) {
  // 1. Assert: Type(O) is Object.
  (0, _invariant2.default)(O instanceof _index.ObjectValue, "expected an object");

  // 2. Assert: level is either "sealed" or "frozen".
  (0, _invariant2.default)(level === "sealed" || level === "frozen", "invalid level");

  // 3. Let status be ? IsExtensible(O).
  var status = (0, _index2.IsExtensible)(realm, O);

  // 4. If status is true, return false.
  if (status === true) return false;

  // 5. NOTE If the object is extensible, none of its properties are examined.

  // 6. Let keys be ? O.[[OwnPropertyKeys]]().
  var keys = O.$OwnPropertyKeys();

  // 7. Repeat for each element k of keys,
  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = keys[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var k = _step3.value;

      // a. Let currentDesc be ? O.[[GetOwnProperty]](k).
      var currentDesc = O.$GetOwnProperty(k);

      // b. If currentDesc is not undefined, then
      if (currentDesc) {
        _singletons.Properties.ThrowIfMightHaveBeenDeleted(currentDesc.value);

        // i. If currentDesc.[[Configurable]] is true, return false.
        if (currentDesc.configurable === true) return false;

        // ii. If level is "frozen" and IsDataDescriptor(currentDesc) is true, then
        if (level === "frozen" && (0, _index2.IsDataDescriptor)(realm, currentDesc) === true) {
          // 1. If currentDesc.[[Writable]] is true, return false.
          if (currentDesc.writable === true) return false;
        }
      }
    }

    // 8. Return true.
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3.return) {
        _iterator3.return();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  return true;
}
//# sourceMappingURL=integrity.js.map