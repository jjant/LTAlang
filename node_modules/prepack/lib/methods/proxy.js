"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ProxyCall = ProxyCall;
exports.ProxyConstruct = ProxyConstruct;
exports.ProxyCreate = ProxyCreate;

var _index = require("../values/index.js");

var _is = require("./is.js");

var _get = require("./get.js");

var _construct = require("./construct.js");

var _call = require("./call.js");

var _create = require("./create.js");

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// ECMA262 9.5.12
/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

function ProxyCall(realm, O, thisArgument, argumentsList) {
  // 1. Let handler be the value of the [[ProxyHandler]] internal slot of O.
  var handler = O.$ProxyHandler;

  // 2. If handler is null, throw a TypeError exception.
  if (handler instanceof _index.NullValue) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
  }

  // 3. Assert: Type(handler) is Object.
  (0, _invariant2.default)(handler instanceof _index.ObjectValue, "expected an object");

  // 4. Let target be the value of the [[ProxyTarget]] internal slot of O.
  var target = O.$ProxyTarget;

  // 5. Let trap be ? GetMethod(handler, "apply").
  var trap = (0, _get.GetMethod)(realm, handler, "apply");

  // 6. If trap is undefined, then
  if (trap instanceof _index.UndefinedValue) {
    // a. Return ? Call(target, thisArgument, argumentsList).
    return (0, _call.Call)(realm, target, thisArgument, argumentsList);
  }

  // 7. Let argArray be CreateArrayFromList(argumentsList).
  var argArray = (0, _create.CreateArrayFromList)(realm, argumentsList);

  // 8. Return ? Call(trap, handler, « target, thisArgument, argArray »).
  return (0, _call.Call)(realm, trap.throwIfNotConcrete(), handler, [target, thisArgument, argArray]);
}

// ECMA262 9.5.13
function ProxyConstruct(realm, O, argumentsList, newTarget) {
  // 1. Let handler be the value of the [[ProxyHandler]] internal slot of O.
  var handler = O.$ProxyHandler;

  // 2. If handler is null, throw a TypeError exception.
  if (handler instanceof _index.NullValue) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
  }

  // 3. Assert: Type(handler) is Object.
  (0, _invariant2.default)(handler instanceof _index.ObjectValue, "expected an object");

  // 4. Let target be the value of the [[ProxyTarget]] internal slot of O.
  var target = O.$ProxyTarget;
  (0, _invariant2.default)(target instanceof _index.ObjectValue);

  // 5. Let trap be ? GetMethod(handler, "construct").
  var trap = (0, _get.GetMethod)(realm, handler, "construct");

  // 6. If trap is undefined, then
  if (trap instanceof _index.UndefinedValue) {
    // a. Assert: target has a [[Construct]] internal method.
    (0, _invariant2.default)(target.$Construct, "expected construct method");

    // b. Return ? Construct(target, argumentsList, newTarget).
    return (0, _construct.Construct)(realm, target, argumentsList, newTarget);
  }

  // 7. Let argArray be CreateArrayFromList(argumentsList).
  var argArray = (0, _create.CreateArrayFromList)(realm, argumentsList);

  // 8. Let newObj be ? Call(trap, handler, « target, argArray, newTarget »).
  var newObj = (0, _call.Call)(realm, trap.throwIfNotConcrete(), handler, [target, argArray, newTarget]).throwIfNotConcrete();

  // 9. If Type(newObj) is not Object, throw a TypeError exception.
  if (!(newObj instanceof _index.ObjectValue)) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
  }

  // 10. Return newObj.
  return newObj;
}

// ECMA262 9.5.14
function ProxyCreate(realm, target, handler) {
  target = target.throwIfNotConcrete();

  // 1. If Type(target) is not Object, throw a TypeError exception.
  if (!(target instanceof _index.ObjectValue)) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
  }

  // 2. If target is a Proxy exotic object and the value of the [[ProxyHandler]] internal slot of target is null, throw a TypeError exception.
  if (target instanceof _index.ProxyValue && (!target.$ProxyHandler || target.$ProxyHandler instanceof _index.NullValue)) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
  }

  handler = handler.throwIfNotConcrete();
  // 3. If Type(handler) is not Object, throw a TypeError exception.
  if (!(handler instanceof _index.ObjectValue)) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
  }

  // 4. If handler is a Proxy exotic object and the value of the [[ProxyHandler]] internal slot of handler is null, throw a TypeError exception.
  if (handler instanceof _index.ProxyValue && (!handler.$ProxyHandler || handler.$ProxyHandler instanceof _index.NullValue)) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
  }

  // 5. Let P be a newly created object.
  // 6. Set P's essential internal methods (except for [[Call]] and [[Construct]]) to the definitions specified in 9.5.
  var P = new _index.ProxyValue(realm);

  // 7. If IsCallable(target) is true, then
  if ((0, _is.IsCallable)(realm, target)) {
    // a. Set the [[Call]] internal method of P as specified in 9.5.12.
    P.$Call = function (thisArgument, argsList) {
      return ProxyCall(realm, P, thisArgument, argsList);
    };

    // b. If target has a [[Construct]] internal method, then
    if (target.$Construct) {
      // i. Set the [[Construct]] internal method of P as specified in 9.5.13.
      P.$Construct = function (argumentsList, newTarget) {
        return ProxyConstruct(realm, P, argumentsList, newTarget);
      };
    }
  }

  // 8. Set the [[ProxyTarget]] internal slot of P to target.
  P.$ProxyTarget = target;

  // 9. Set the [[ProxyHandler]] internal slot of P to handler.
  P.$ProxyHandler = handler;

  // 10. Return P.
  return P;
}
//# sourceMappingURL=proxy.js.map