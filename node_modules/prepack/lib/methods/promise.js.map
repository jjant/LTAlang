{"version":3,"sources":["../../src/methods/promise.js"],"names":["EnqueueJob","NewPromiseCapability","PerformPromiseAll","PerformPromiseRace","PerformPromiseThen","PromiseReactionJob","CreateResolvingFunctions","FulfillPromise","RejectPromise","TriggerPromiseReactions","HostPromiseRejectionTracker","PromiseResolveThenableJob","realm","queueName","job","args","C","createErrorThrowCompletion","intrinsics","TypeError","promiseCapability","promise","undefined","resolve","reject","executor","context","$Capability","mightBeUndefined","throwIfNotConcrete","createResolveElementFunction","resolveElement","x","alreadyCalled","$AlreadyCalled","value","myIndex","$Index","values","$Values","Array","$Capabilities","remainingElementsCount","$RemainingElements","valuesArray","iteratorRecord","constructor","resultCapability","index","next","$Iterator","e","$Done","nextValue","push","nextPromise","onFulfilled","onRejected","fulfillReaction","capabilities","handler","rejectReaction","$PromiseState","ThrowIfInternalSlotNotWritable","$PromiseFulfillReactions","$PromiseRejectReactions","$PromiseResult","reason","$PromiseIsHandled","reaction","argument","createResolveFunction","resolution","$Promise","alreadyResolved","$AlreadyResolved","selfResolutionError","then","thenAction","createRejectFunction","reactions","operation","promiseToResolve","thenable"],"mappings":";;;;;;ypBAAA;;;;;;;;;QA0BgBA,U,GAAAA,U;QAGAC,oB,GAAAA,oB;QAoJAC,iB,GAAAA,iB;QAgHAC,kB,GAAAA,kB;QA8DAC,kB,GAAAA,kB;QAuEAC,kB,GAAAA,kB;QA6GAC,wB,GAAAA,wB;QA2BAC,c,GAAAA,c;QAiCAC,a,GAAAA,a;QAoCAC,uB,GAAAA,uB;QAWAC,2B,GAAAA,2B;QAGAC,yB,GAAAA,yB;;AApnBhB;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;;;;;AAEA;AACO,SAASX,UAAT,CAAoBY,KAApB,EAAkCC,SAAlC,EAAqDC,GAArD,EAAoEC,IAApE,EAAsF,CAAE;;AAE/F;AACO,SAASd,oBAAT,CAA8BW,KAA9B,EAA4CI,CAA5C,EAAyE;AAC9E;AACA,MAAI,uBAAcJ,KAAd,EAAqBI,CAArB,MAA4B,KAAhC,EAAuC;AACrC,UAAMJ,MAAMK,0BAAN,CAAiCL,MAAMM,UAAN,CAAiBC,SAAlD,EAA6D,2BAA7D,CAAN;AACD;AACD,2BAAUH,+BAAV;;AAEA;;AAEA;AACA,MAAII,oBAAoB;AACtBC,aAAST,MAAMM,UAAN,CAAiBI,SADJ;AAEtBC,aAASX,MAAMM,UAAN,CAAiBI,SAFJ;AAGtBE,YAAQZ,MAAMM,UAAN,CAAiBI;AAHH,GAAxB;;AAMA;AACA,MAAIG,WAAW,+BACbb,KADa,EAEbU,SAFa,EAGbA,SAHa,EAIb,CAJa,EAKb,UAACI,OAAD,QAAgC;AAAA;AAAA,QAArBH,OAAqB;AAAA,QAAZC,MAAY;;AAC9B;AACA,6BAAUC,SAASE,WAAnB,EAAgC,gFAAhC;;AAEA;AACA,6BAAUP,sBAAsBK,SAASE,WAAzC;;AAEA;AACA,QAAI,CAACP,kBAAkBG,OAAlB,CAA0BK,gBAA1B,EAAL,EAAmD;AACjD,YAAMhB,MAAMK,0BAAN,CACJL,MAAMM,UAAN,CAAiBC,SADb,EAEJ,gDAFI,CAAN;AAID;AACDC,sBAAkBG,OAAlB,CAA0BM,kBAA1B;;AAEA;AACA,QAAI,CAACT,kBAAkBI,MAAlB,CAAyBI,gBAAzB,EAAL,EAAkD;AAChD,YAAMhB,MAAMK,0BAAN,CACJL,MAAMM,UAAN,CAAiBC,SADb,EAEJ,+CAFI,CAAN;AAID;AACDC,sBAAkBI,MAAlB,CAAyBK,kBAAzB;;AAEA;AACAT,sBAAkBG,OAAlB,GAA4BA,OAA5B;;AAEA;AACAH,sBAAkBI,MAAlB,GAA2BA,MAA3B;;AAEA;AACA,WAAOZ,MAAMM,UAAN,CAAiBI,SAAxB;AACD,GAtCY,EAuCb,KAvCa,CAAf;;AA0CA;AACAG,WAASE,WAAT,GAAuBP,iBAAvB;;AAEA;AACA,MAAIC,UAAU,0BAAUT,KAAV,EAAiBI,CAAjB,EAAoB,CAACS,QAAD,CAApB,CAAd;;AAEA;AACA,MAAI,oBAAWb,KAAX,EAAkBQ,kBAAkBG,OAApC,MAAiD,KAArD,EAA4D;AAC1D,UAAMX,MAAMK,0BAAN,CACJL,MAAMM,UAAN,CAAiBC,SADb,EAEJ,oDAFI,CAAN;AAID;;AAED;AACA,MAAI,oBAAWP,KAAX,EAAkBQ,kBAAkBI,MAApC,MAAgD,KAApD,EAA2D;AACzD,UAAMZ,MAAMK,0BAAN,CACJL,MAAMM,UAAN,CAAiBC,SADb,EAEJ,mDAFI,CAAN;AAID;;AAED;AACAC,oBAAkBC,OAAlB,GAA4BA,OAA5B;;AAEA;AACA,SAAOD,iBAAP;AACD;;AAED;AACA,SAASU,4BAAT,CAAsClB,KAAtC,EAA6C;AAC3C,MAAImB,iBAAiB,+BACnBnB,KADmB,EAEnBU,SAFmB,EAGnBA,SAHmB,EAInB,CAJmB,EAKnB,UAACI,OAAD,SAAkB;AAAA;AAAA,QAAPM,CAAO;;AAChB;AACA,QAAIC,gBAAgBF,eAAeG,cAAnC;AACA,6BAAUD,aAAV;;AAEA;AACA,QAAIA,cAAcE,KAAd,KAAwB,IAA5B,EAAkC;AAChC,aAAOvB,MAAMM,UAAN,CAAiBI,SAAxB;AACD;;AAED;AACAW,kBAAcE,KAAd,GAAsB,IAAtB;;AAEA;AACA,QAAIC,UAAUL,eAAeM,MAA7B;AACA,6BAAU,OAAOD,OAAP,KAAmB,QAA7B;;AAEA;AACA,QAAIE,SAASP,eAAeQ,OAA5B;AACA,6BAAUD,kBAAkBE,KAA5B;;AAEA;AACA,QAAIpB,oBAAoBW,eAAeU,aAAvC;AACA,6BAAUrB,iBAAV;;AAEA;AACA,QAAIsB,yBAAyBX,eAAeY,kBAA5C;AACA,6BAAUD,sBAAV;;AAEA;AACAJ,WAAOF,OAAP,IAAkBJ,CAAlB;;AAEA;AACAU,2BAAuBP,KAAvB,GAA+BO,uBAAuBP,KAAvB,GAA+B,CAA9D;;AAEA;AACA,QAAIO,uBAAuBP,KAAvB,KAAiC,CAArC,EAAwC;AACtC;AACA,UAAIS,cAAc,iCAAoBhC,KAApB,EAA2B0B,MAA3B,CAAlB;;AAEA;AACA,sBAAK1B,KAAL,EAAYQ,kBAAkBG,OAA9B,EAAuCX,MAAMM,UAAN,CAAiBI,SAAxD,EAAmE,CAACsB,WAAD,CAAnE;AACD;;AAED;AACA,WAAOhC,MAAMM,UAAN,CAAiBI,SAAxB;AACD,GAnDkB,EAoDnB,KApDmB,CAArB;AAsDA,SAAOS,cAAP;AACD;;AAED;AACO,SAAS7B,iBAAT,CACLU,KADK,EAELiC,cAFK,EAGLC,WAHK,EAILC,gBAJK,EAKE;AACP;AACA,2BACED,+CAAwC,uBAAclC,KAAd,EAAqBkC,WAArB,CAD1C,EAEE,uCAFF;;AAKA;AACAC;;AAEA;AACA,MAAIT,SAAS,EAAb;;AAEA;AACA,MAAII,yBAAyB,EAAEP,OAAO,CAAT,EAA7B;;AAEA;AACA,MAAIa,QAAQ,CAAZ;;AAEA;AACA,SAAO,IAAP,EAAa;AACX;AACA,QAAIC,aAAJ;AACA,QAAI;AACFA,aAAO,6BAAarC,KAAb,EAAoBiC,eAAeK,SAAnC,CAAP;AACD,KAFD,CAEE,OAAOC,CAAP,EAAU;AACV,UAAIA,0CAAJ,EAAmC;AACjC;AACAN,uBAAeO,KAAf,GAAuB,IAAvB;AACD;;AAED;AACA,YAAMD,CAAN;AACD;;AAED;AACA,QAAIF,SAAS,KAAb,EAAoB;AAClB;AACAJ,qBAAeO,KAAf,GAAuB,IAAvB;;AAEA;AACAV,6BAAuBP,KAAvB,GAA+BO,uBAAuBP,KAAvB,GAA+B,CAA9D;;AAEA;AACA,UAAIO,uBAAuBP,KAAvB,KAAiC,CAArC,EAAwC;AACtC;AACA,YAAIS,cAAc,iCAAoBhC,KAApB,EAA2B0B,MAA3B,CAAlB;;AAEA;AACA,wBAAK1B,KAAL,EAAYmC,iBAAiBxB,OAA7B,EAAsCX,MAAMM,UAAN,CAAiBI,SAAvD,EAAkE,CAACsB,WAAD,CAAlE;AACD;;AAED;AACA,aAAOG,iBAAiB1B,OAAxB;AACD;;AAED;AACA,QAAIgC,kBAAJ;AACA,QAAI;AACFA,kBAAY,8BAAczC,KAAd,EAAqBqC,IAArB,CAAZ;AACD,KAFD,CAEE,OAAOE,CAAP,EAAU;AACV,UAAIA,0CAAJ,EAAmC;AACjC;AACAN,uBAAeO,KAAf,GAAuB,IAAvB;AACD;;AAED;AACA,YAAMD,CAAN;AACD;;AAED;AACAb,WAAOgB,IAAP,CAAY1C,MAAMM,UAAN,CAAiBI,SAA7B;;AAEA;AACA,QAAIiC,cAAc,kBAAO3C,KAAP,EAAckC,WAAd,EAA2B,SAA3B,EAAsC,CAACO,SAAD,CAAtC,CAAlB;;AAEA;AACA,QAAItB,iBAAiBD,6BAA6BlB,KAA7B,CAArB;;AAEA;AACAmB,mBAAeG,cAAf,GAAgC,EAAEC,OAAO,KAAT,EAAhC;;AAEA;AACAJ,mBAAeM,MAAf,GAAwBW,KAAxB;;AAEA;AACAjB,mBAAeQ,OAAf,GAAyBD,MAAzB;;AAEA;AACAP,mBAAeU,aAAf,GAA+BM,gBAA/B;;AAEA;AACAhB,mBAAeY,kBAAf,GAAoCD,sBAApC;;AAEA;AACAA,2BAAuBP,KAAvB,GAA+BO,uBAAuBP,KAAvB,GAA+B,CAA9D;;AAEA;AACA,sBAAOvB,KAAP,EAAc2C,WAAd,EAA2B,MAA3B,EAAmC,CAACxB,cAAD,EAAiBgB,iBAAiBvB,MAAlC,CAAnC;;AAEA;AACAwB,YAAQA,QAAQ,CAAhB;AACD;AACD,2BAAU,KAAV;AACD;;AAED;AACO,SAAS7C,kBAAT,CACLS,KADK,EAELiC,cAFK,EAGLE,gBAHK,EAIL/B,CAJK,EAKQ;AACb;AACA,2BAAU,uBAAcJ,KAAd,EAAqBI,CAArB,CAAV,EAAmC,uCAAnC;;AAEA;AACA+B;;AAEA;AACA,SAAO,IAAP,EAAa;AACX;AACA,QAAIE,aAAJ;AACA,QAAI;AACFA,aAAO,6BAAarC,KAAb,EAAoBiC,eAAeK,SAAnC,CAAP;AACD,KAFD,CAEE,OAAOC,CAAP,EAAU;AACV,UAAIA,0CAAJ,EAAmC;AACjC;AACAN,uBAAeO,KAAf,GAAuB,IAAvB;AACD;;AAED;AACA,YAAMD,CAAN;AACD;;AAED;AACA,QAAIF,SAAS,KAAb,EAAoB;AAClB;AACAJ,qBAAeO,KAAf,GAAuB,IAAvB;;AAEA;AACA,+BAAUL,iBAAiB1B,OAAjB,8BAAV;AACA,aAAO0B,iBAAiB1B,OAAxB;AACD;;AAED;AACA,QAAIgC,kBAAJ;AACA,QAAI;AACFA,kBAAY,8BAAczC,KAAd,EAAqBqC,IAArB,CAAZ;AACD,KAFD,CAEE,OAAOE,CAAP,EAAU;AACV,UAAIA,0CAAJ,EAAmC;AACjC;AACAN,uBAAeO,KAAf,GAAuB,IAAvB;AACD;;AAED;AACA,YAAMD,CAAN;AACD;;AAED;AACA,QAAII,cAAc,kBAAO3C,KAAP,EAAcI,CAAd,EAAiB,SAAjB,EAA4B,CAACqC,SAAD,CAA5B,CAAlB;;AAEA;AACA,sBAAOzC,KAAP,EAAc2C,WAAd,EAA2B,MAA3B,EAAmC,CAACR,iBAAiBxB,OAAlB,EAA2BwB,iBAAiBvB,MAA5C,CAAnC;AACD;AACD,2BAAU,KAAV;AACD;;AAED;AACO,SAASpB,kBAAT,CACLQ,KADK,EAELS,OAFK,EAGLmC,WAHK,EAILC,UAJK,EAKLV,gBALK,EAMQ;AACb;AACA,2BAAU,mBAAUnC,KAAV,EAAiBS,OAAjB,CAAV,EAAqC,4BAArC;;AAEA;AACA0B;;AAEA;AACA,MAAI,oBAAWnC,KAAX,EAAkB4C,WAAlB,MAAmC,KAAvC,EAA8C;AAC5C;AACAA,kBAAc,uBAAgB5C,KAAhB,EAAuB,UAAvB,CAAd;AACD;;AAED;AACA,MAAI,oBAAWA,KAAX,EAAkB6C,UAAlB,CAAJ,EAAmC;AACjC;AACAA,iBAAa,uBAAgB7C,KAAhB,EAAuB,SAAvB,CAAb;AACD;;AAED;AACA,MAAI8C,kBAAkB,EAAEC,cAAcZ,gBAAhB,EAAkCa,SAASJ,WAA3C,EAAtB;;AAEA;AACA,MAAIK,iBAAiB,EAAEF,cAAcZ,gBAAhB,EAAkCa,SAASH,UAA3C,EAArB;;AAEA;AACA,MAAIpC,QAAQyC,aAAR,KAA0B,SAA9B,EAAyC;AACvC;AACA,2BAAWC,8BAAX,CAA0CnD,KAA1C,EAAiDS,OAAjD,EAA0D,0BAA1D;AACA,6BAAUA,QAAQ2C,wBAAlB;AACA3C,YAAQ2C,wBAAR,CAAiCV,IAAjC,CAAsCI,eAAtC;AACA;AACA,2BAAWK,8BAAX,CAA0CnD,KAA1C,EAAiDS,OAAjD,EAA0D,yBAA1D;AACA,6BAAUA,QAAQ4C,uBAAlB;AACA5C,YAAQ4C,uBAAR,CAAgCX,IAAhC,CAAqCO,cAArC;AACD,GATD,MASO,IAAIxC,QAAQyC,aAAR,KAA0B,WAA9B,EAA2C;AAChD;AACA;AACA,QAAI3B,QAAQd,QAAQ6C,cAApB;AACA;AACAlE,eAAWY,KAAX,EAAkB,aAAlB,EAAiCP,kBAAjC,EAAqD,CAACqD,eAAD,EAAkBvB,KAAlB,CAArD;AACD,GANM,MAMA;AACL;AACA;AACA,6BAAUd,QAAQyC,aAAR,KAA0B,UAApC;;AAEA;AACA,QAAIK,SAAS9C,QAAQ6C,cAArB;;AAEA;AACA,QAAI7C,QAAQ+C,iBAAR,KAA8B,KAAlC,EAAyC1D,4BAA4BE,KAA5B,EAAmCS,OAAnC,EAA4C,QAA5C;;AAEzC;AACArB,eAAWY,KAAX,EAAkB,aAAlB,EAAiCP,kBAAjC,EAAqD,CAACwD,cAAD,EAAiBM,MAAjB,CAArD;AACD;;AAED;AACA,yBAAWJ,8BAAX,CAA0CnD,KAA1C,EAAiDS,OAAjD,EAA0D,mBAA1D,EAA+E+C,iBAA/E,GAAmG,IAAnG;;AAEA;AACA,2BAAUrB,iBAAiB1B,OAAjB,8BAAV;AACA,SAAO0B,iBAAiB1B,OAAxB;AACD;;AAED;AACO,SAAShB,kBAAT,CAA4BO,KAA5B,EAA0CyD,QAA1C,EAA8DC,QAA9D,EAAsF;AAC3F,SAAO1D,MAAMM,UAAN,CAAiBI,SAAxB;AACD;;AAED;AACA,SAASiD,qBAAT,CAA+B3D,KAA/B,EAAsC;AACpC;AACA,MAAIW,UAAU,+BACZX,KADY,EAEZU,SAFY,EAGZA,SAHY,EAIZ,CAJY,EAKZ,UAACI,OAAD,SAA2B;AAAA;AAAA,QAAhB8C,UAAgB;;AACzB;AACA,6BAAUjD,QAAQkD,QAAR,8BAAV,EAAmD,4DAAnD;;AAEA;AACA,QAAIpD,UAAUE,QAAQkD,QAAtB;;AAEA;AACA,QAAIC,kBAAkBnD,QAAQoD,gBAA9B;AACA,6BAAUD,oBAAoBpD,SAA9B;;AAEA;AACA,QAAIoD,gBAAgBvC,KAAhB,KAA0B,IAA9B,EAAoC,OAAOvB,MAAMM,UAAN,CAAiBI,SAAxB;;AAEpC;AACAoD,oBAAgBvC,KAAhB,GAAwB,IAAxB;;AAEA;AACA,QAAI,yBAAUvB,KAAV,EAAiB4D,WAAW3C,kBAAX,EAAjB,EAAkDR,OAAlD,CAAJ,EAAgE;AAC9D;AACA,UAAIuD,sBAAsB,0BAAUhE,KAAV,EAAiBA,MAAMM,UAAN,CAAiBC,SAAlC,EAA6C,CAAC,uBAAgBP,KAAhB,EAAuB,SAAvB,CAAD,CAA7C,CAA1B;;AAEA;AACA,aAAOJ,cAAcI,KAAd,EAAqBS,OAArB,EAA8BuD,mBAA9B,CAAP;AACD;AACD;AACA,QAAI,EAAEJ,wCAAF,CAAJ,EAA0C;AACxC;AACA,aAAOjE,eAAeK,KAAf,EAAsBS,OAAtB,EAA+BmD,UAA/B,CAAP;AACD;;AAED;AACA,QAAIK,aAAJ;AACA,QAAI;AACFA,aAAO,cAAIjE,KAAJ,EAAW4D,UAAX,EAAuB,MAAvB,CAAP;AACD,KAFD,CAEE,OAAOrB,CAAP,EAAU;AACV;AACA,UAAIA,0CAAJ,EAAmC;AACjC;AACA,eAAO3C,cAAcI,KAAd,EAAqBS,OAArB,EAA8B8B,CAA9B,CAAP;AACD,OAHD,MAGO,MAAMA,CAAN;AACR;;AAED;AACA,QAAI2B,aAAaD,IAAjB;;AAEA;AACA,QAAI,oBAAWjE,KAAX,EAAkBkE,UAAlB,CAAJ,EAAmC;AACjC;AACA,aAAOvE,eAAeK,KAAf,EAAsBS,OAAtB,EAA+BmD,UAA/B,CAAP;AACD;;AAED;AACAxE,eAAWY,KAAX,EAAkB,aAAlB,EAAiCD,yBAAjC,EAA4D,CAACU,OAAD,EAAUmD,UAAV,EAAsBM,UAAtB,CAA5D;;AAEA;AACA,WAAOlE,MAAMM,UAAN,CAAiBI,SAAxB;AACD,GA9DW,EA+DZ,KA/DY,CAAd;AAiEA,SAAOC,OAAP;AACD;;AAED;AACA,SAASwD,oBAAT,CAA8BnE,KAA9B,EAAqC;AACnC;AACA,MAAIY,SAAS,+BACXZ,KADW,EAEXU,SAFW,EAGXA,SAHW,EAIX,CAJW,EAKX,UAACI,OAAD,SAAuB;AAAA;AAAA,QAAZyC,MAAY;;AACrB;AACA,6BAAU3C,OAAOiD,QAAP,8BAAV,EAAkD,4DAAlD;;AAEA;AACA,QAAIpD,UAAUG,OAAOiD,QAArB;;AAEA;AACA,QAAIC,kBAAkBlD,OAAOmD,gBAA7B;AACA,6BAAUD,oBAAoBpD,SAA9B;;AAEA;AACA,QAAIoD,gBAAgBvC,KAAhB,KAA0B,IAA9B,EAAoC,OAAOvB,MAAMM,UAAN,CAAiBI,SAAxB;;AAEpC;AACAoD,oBAAgBvC,KAAhB,GAAwB,IAAxB;;AAEA;AACA,WAAO3B,cAAcI,KAAd,EAAqBS,OAArB,EAA8B8C,MAA9B,CAAP;AACD,GAxBU,EAyBX,KAzBW,CAAb;AA2BA,SAAO3C,MAAP;AACD;;AAED;AACO,SAASlB,wBAAT,CAAkCM,KAAlC,EAAgDS,OAAhD,EAA0F;AAC/F;AACA,MAAIqD,kBAAkB,EAAEvC,OAAO,KAAT,EAAtB;;AAEA;AACA,MAAIZ,UAAUgD,sBAAsB3D,KAAtB,CAAd;;AAEA;AACAW,UAAQkD,QAAR,GAAmBpD,OAAnB;;AAEA;AACAE,UAAQoD,gBAAR,GAA2BD,eAA3B;;AAEA;AACA,MAAIlD,SAASuD,qBAAqBnE,KAArB,CAAb;;AAEA;AACAY,SAAOiD,QAAP,GAAkBpD,OAAlB;;AAEA;AACAG,SAAOmD,gBAAP,GAA0BD,eAA1B;;AAEA;AACA,SAAO,EAAEnD,SAASA,OAAX,EAAoBC,QAAQA,MAA5B,EAAP;AACD;;AAED;AACO,SAASjB,cAAT,CAAwBK,KAAxB,EAAsCS,OAAtC,EAA4Dc,KAA5D,EAAiF;AACtF;AACA,2BAAUd,QAAQyC,aAAR,KAA0B,SAApC;;AAEA;AACA,MAAIkB,YAAY3D,QAAQ2C,wBAAxB;AACA,2BAAUgB,SAAV;;AAEA;AACA,yBAAWjB,8BAAX,CAA0CnD,KAA1C,EAAiDS,OAAjD,EAA0D,gBAA1D,EAA4E6C,cAA5E,GAA6F/B,KAA7F;;AAEA;AACA,yBAAW4B,8BAAX,CACEnD,KADF,EAEES,OAFF,EAGE,0BAHF,EAIE2C,wBAJF,GAI6B1C,SAJ7B;;AAMA;AACA,yBAAWyC,8BAAX,CACEnD,KADF,EAEES,OAFF,EAGE,yBAHF,EAIE4C,uBAJF,GAI4B3C,SAJ5B;;AAMA;AACA,yBAAWyC,8BAAX,CAA0CnD,KAA1C,EAAiDS,OAAjD,EAA0D,eAA1D,EAA2EyC,aAA3E,GAA2F,WAA3F;;AAEA;AACA,SAAOrD,wBAAwBG,KAAxB,EAA+BoE,SAA/B,EAA0C7C,KAA1C,CAAP;AACD;;AAED;AACO,SAAS3B,aAAT,CAAuBI,KAAvB,EAAqCS,OAArC,EAA2D8C,MAA3D,EAAiF;AACtF;AACA,2BAAU9C,QAAQyC,aAAR,KAA0B,SAApC;;AAEA;AACA,MAAIkB,YAAY3D,QAAQ2C,wBAAxB;AACA,2BAAUgB,SAAV;;AAEA;AACA,yBAAWjB,8BAAX,CAA0CnD,KAA1C,EAAiDS,OAAjD,EAA0D,gBAA1D,EAA4E6C,cAA5E,GAA6FC,MAA7F;;AAEA;AACA,yBAAWJ,8BAAX,CACEnD,KADF,EAEES,OAFF,EAGE,0BAHF,EAIE2C,wBAJF,GAI6B1C,SAJ7B;;AAMA;AACA,yBAAWyC,8BAAX,CACEnD,KADF,EAEES,OAFF,EAGE,yBAHF,EAIE4C,uBAJF,GAI4B3C,SAJ5B;;AAMA;AACA,yBAAWyC,8BAAX,CAA0CnD,KAA1C,EAAiDS,OAAjD,EAA0D,eAA1D,EAA2EyC,aAA3E,GAA2F,UAA3F;;AAEA;AACA,MAAIzC,QAAQ+C,iBAAR,KAA8B,KAAlC,EAAyC1D,4BAA4BE,KAA5B,EAAmCS,OAAnC,EAA4C,QAA5C;;AAEzC;AACA,SAAOZ,wBAAwBG,KAAxB,EAA+BoE,SAA/B,EAA0Cb,MAA1C,CAAP;AACD;;AAED;AACO,SAAS1D,uBAAT,CAAiCG,KAAjC,EAA+CoE,SAA/C,EAAkFV,QAAlF,EAAmG;AACxG;AADwG;AAAA;AAAA;;AAAA;AAExG,yBAAqBU,SAArB,8HAAgC;AAAA,UAAvBX,QAAuB;;AAC9B;AACArE,iBAAWY,KAAX,EAAkB,aAAlB,EAAiCP,kBAAjC,EAAqD,CAACgE,QAAD,EAAWC,QAAX,CAArD;AACD;AACD;AANwG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAOxG,SAAO1D,MAAMM,UAAN,CAAiBI,SAAxB;AACD;;AAED;AACO,SAASZ,2BAAT,CAAqCE,KAArC,EAAmDS,OAAnD,EAAyE4D,SAAzE,EAAyG,CAAE;;AAElH;AACO,SAAStE,yBAAT,CAAmCC,KAAnC,EAAiDsE,gBAAjD,EAAgFC,QAAhF,EAAiGN,IAAjG,EAA8G,CAAE","file":"promise.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { ResolvingFunctions, PromiseCapability, PromiseReaction } from \"../types.js\";\nimport { AbruptCompletion } from \"../completions.js\";\nimport { Value, ObjectValue, StringValue, NativeFunctionValue, FunctionValue } from \"../values/index.js\";\nimport { SameValue } from \"../methods/abstract.js\";\nimport { Construct } from \"../methods/construct.js\";\nimport { Get } from \"../methods/get.js\";\nimport { Invoke, Call } from \"../methods/call.js\";\nimport { CreateArrayFromList } from \"../methods/create.js\";\nimport { IsCallable, IsConstructor, IsPromise } from \"../methods/is.js\";\nimport { IteratorStep, IteratorValue } from \"../methods/iterator.js\";\nimport { Properties } from \"../singletons.js\";\nimport invariant from \"../invariant.js\";\n\n// ECMA262 8.4.1\nexport function EnqueueJob(realm: Realm, queueName: string, job: Function, args: Array<any>) {}\n\n// ECMA262 25.4.1.5\nexport function NewPromiseCapability(realm: Realm, C: Value): PromiseCapability {\n  // 1. If IsConstructor(C) is false, throw a TypeError exception.\n  if (IsConstructor(realm, C) === false) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsConstructor(C) is false\");\n  }\n  invariant(C instanceof ObjectValue);\n\n  // 2. NOTE C is assumed to be a constructor function that supports the parameter conventions of the Promise constructor (see 25.4.3.1).\n\n  // 3. Let promiseCapability be a new PromiseCapability { [[Promise]]: undefined, [[Resolve]]: undefined, [[Reject]]: undefined }.\n  let promiseCapability = {\n    promise: realm.intrinsics.undefined,\n    resolve: realm.intrinsics.undefined,\n    reject: realm.intrinsics.undefined,\n  };\n\n  // 4. Let executor be a new built-in function object as defined in GetCapabilitiesExecutor Functions (25.4.1.5.1).\n  let executor = new NativeFunctionValue(\n    realm,\n    undefined,\n    undefined,\n    2,\n    (context, [resolve, reject]) => {\n      // 1. Assert: F has a [[Capability]] internal slot whose value is a PromiseCapability Record.\n      invariant(executor.$Capability, \"F has a [[Capability]] internal slot whose value is a PromiseCapability Record\");\n\n      // 2. Let promiseCapability be the value of F's [[Capability]] internal slot.\n      invariant(promiseCapability === executor.$Capability);\n\n      // 3. If promiseCapability.[[Resolve]] is not undefined, throw a TypeError exception.\n      if (!promiseCapability.resolve.mightBeUndefined()) {\n        throw realm.createErrorThrowCompletion(\n          realm.intrinsics.TypeError,\n          \"promiseCapability.[[Resolve]] is not undefined\"\n        );\n      }\n      promiseCapability.resolve.throwIfNotConcrete();\n\n      // 4. If promiseCapability.[[Reject]] is not undefined, throw a TypeError exception.\n      if (!promiseCapability.reject.mightBeUndefined()) {\n        throw realm.createErrorThrowCompletion(\n          realm.intrinsics.TypeError,\n          \"promiseCapability.[[Reject]] is not undefined\"\n        );\n      }\n      promiseCapability.reject.throwIfNotConcrete();\n\n      // 5. Set promiseCapability.[[Resolve]] to resolve.\n      promiseCapability.resolve = resolve;\n\n      // 6. Set promiseCapability.[[Reject]] to reject.\n      promiseCapability.reject = reject;\n\n      // 7. Return undefined.\n      return realm.intrinsics.undefined;\n    },\n    false\n  );\n\n  // 5. Set the [[Capability]] internal slot of executor to promiseCapability.\n  executor.$Capability = promiseCapability;\n\n  // 6. Let promise be ? Construct(C, « executor »).\n  let promise = Construct(realm, C, [executor]);\n\n  // 7. If IsCallable(promiseCapability.[[Resolve]]) is false, throw a TypeError exception.\n  if (IsCallable(realm, promiseCapability.resolve) === false) {\n    throw realm.createErrorThrowCompletion(\n      realm.intrinsics.TypeError,\n      \"IsCallable(promiseCapability.[[Resolve]]) is false\"\n    );\n  }\n\n  // 8. If IsCallable(promiseCapability.[[Reject]]) is false, throw a TypeError exception.\n  if (IsCallable(realm, promiseCapability.reject) === false) {\n    throw realm.createErrorThrowCompletion(\n      realm.intrinsics.TypeError,\n      \"IsCallable(promiseCapability.[[Reject]]) is false\"\n    );\n  }\n\n  // 9. Set promiseCapability.[[Promise]] to promise.\n  promiseCapability.promise = promise;\n\n  // 10. Return promiseCapability.\n  return promiseCapability;\n}\n\n// ECMA262 25.4.4.1.1j\nfunction createResolveElementFunction(realm) {\n  let resolveElement = new NativeFunctionValue(\n    realm,\n    undefined,\n    undefined,\n    1,\n    (context, [x]) => {\n      // 1. Let alreadyCalled be the value of F's [[AlreadyCalled]] internal slot.\n      let alreadyCalled = resolveElement.$AlreadyCalled;\n      invariant(alreadyCalled);\n\n      // 2. If alreadyCalled.[[Value]] is true, return undefined.\n      if (alreadyCalled.value === true) {\n        return realm.intrinsics.undefined;\n      }\n\n      // 3. Set alreadyCalled.[[Value]] to true.\n      alreadyCalled.value = true;\n\n      // 4. Let index be the value of F's [[Index]] internal slot.\n      let myIndex = resolveElement.$Index;\n      invariant(typeof myIndex === \"number\");\n\n      // 5. Let values be the value of F's [[Values]] internal slot.\n      let values = resolveElement.$Values;\n      invariant(values instanceof Array);\n\n      // 6. Let promiseCapability be the value of F's [[Capabilities]] internal slot.\n      let promiseCapability = resolveElement.$Capabilities;\n      invariant(promiseCapability);\n\n      // 7. Let remainingElementsCount be the value of F's [[RemainingElements]] internal slot.\n      let remainingElementsCount = resolveElement.$RemainingElements;\n      invariant(remainingElementsCount);\n\n      // 8. Set values[index] to x.\n      values[myIndex] = x;\n\n      // 9. Set remainingElementsCount.[[Value]] to remainingElementsCount.[[Value]] - 1.\n      remainingElementsCount.value = remainingElementsCount.value - 1;\n\n      // 10. If remainingElementsCount.[[Value]] is 0, then\n      if (remainingElementsCount.value === 0) {\n        // a. Let valuesArray be CreateArrayFromList(values).\n        let valuesArray = CreateArrayFromList(realm, values);\n\n        // b. Return ? Call(promiseCapability.[[Resolve]], undefined, « valuesArray »).\n        Call(realm, promiseCapability.resolve, realm.intrinsics.undefined, [valuesArray]);\n      }\n\n      // 11. Return undefined.\n      return realm.intrinsics.undefined;\n    },\n    false\n  );\n  return resolveElement;\n}\n\n// ECMA262 25.4.4.1.1\nexport function PerformPromiseAll(\n  realm: Realm,\n  iteratorRecord: { $Iterator: ObjectValue, $Done: boolean },\n  constructor: FunctionValue,\n  resultCapability: PromiseCapability\n): Value {\n  // 1. Assert: constructor is a constructor function.\n  invariant(\n    constructor instanceof FunctionValue && IsConstructor(realm, constructor),\n    \"constructor is a constructor function\"\n  );\n\n  // 2. Assert: resultCapability is a PromiseCapability record.\n  resultCapability;\n\n  // 3. Let values be a new empty List.\n  let values = [];\n\n  // 4. Let remainingElementsCount be a new Record { [[Value]]: 1 }.\n  let remainingElementsCount = { value: 1 };\n\n  // 5. Let index be 0.\n  let index = 0;\n\n  // 6. Repeat\n  while (true) {\n    // a. Let next be IteratorStep(iteratorRecord.[[Iterator]]).\n    let next;\n    try {\n      next = IteratorStep(realm, iteratorRecord.$Iterator);\n    } catch (e) {\n      if (e instanceof AbruptCompletion) {\n        // b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.\n        iteratorRecord.$Done = true;\n      }\n\n      // c. ReturnIfAbrupt(next).\n      throw e;\n    }\n\n    // d. If next is false, then\n    if (next === false) {\n      // i. Set iteratorRecord.[[Done]] to true.\n      iteratorRecord.$Done = true;\n\n      // ii. Set remainingElementsCount.[[Value]] to remainingElementsCount.[[Value]] - 1.\n      remainingElementsCount.value = remainingElementsCount.value - 1;\n\n      // iii. If remainingElementsCount.[[Value]] is 0, then\n      if (remainingElementsCount.value === 0) {\n        // 1. Let valuesArray be CreateArrayFromList(values).\n        let valuesArray = CreateArrayFromList(realm, values);\n\n        // 2. Perform ? Call(resultCapability.[[Resolve]], undefined, « valuesArray »).\n        Call(realm, resultCapability.resolve, realm.intrinsics.undefined, [valuesArray]);\n      }\n\n      // iv. Return resultCapability.[[Promise]].\n      return resultCapability.promise;\n    }\n\n    // e. Let nextValue be IteratorValue(next).\n    let nextValue;\n    try {\n      nextValue = IteratorValue(realm, next);\n    } catch (e) {\n      if (e instanceof AbruptCompletion) {\n        // f. If nextValue is an abrupt completion, set iteratorRecord.[[Done]] to true.\n        iteratorRecord.$Done = true;\n      }\n\n      // g. ReturnIfAbrupt(nextValue).\n      throw e;\n    }\n\n    // h. Append undefined to values.\n    values.push(realm.intrinsics.undefined);\n\n    // i. Let nextPromise be ? Invoke(constructor, \"resolve\", « nextValue »).\n    let nextPromise = Invoke(realm, constructor, \"resolve\", [nextValue]);\n\n    // j. Let resolveElement be a new built-in function object as defined in Promise.all Resolve Element Functions.\n    let resolveElement = createResolveElementFunction(realm);\n\n    // k. Set the [[AlreadyCalled]] internal slot of resolveElement to a new Record {[[Value]]: false }.\n    resolveElement.$AlreadyCalled = { value: false };\n\n    // l. Set the [[Index]] internal slot of resolveElement to index.\n    resolveElement.$Index = index;\n\n    // m. Set the [[Values]] internal slot of resolveElement to values.\n    resolveElement.$Values = values;\n\n    // n. Set the [[Capabilities]] internal slot of resolveElement to resultCapability.\n    resolveElement.$Capabilities = resultCapability;\n\n    // o. Set the [[RemainingElements]] internal slot of resolveElement to remainingElementsCount.\n    resolveElement.$RemainingElements = remainingElementsCount;\n\n    // p. Set remainingElementsCount.[[Value]] to remainingElementsCount.[[Value]] + 1.\n    remainingElementsCount.value = remainingElementsCount.value + 1;\n\n    // q. Perform ? Invoke(nextPromise, \"then\", « resolveElement, resultCapability.[[Reject]] »).\n    Invoke(realm, nextPromise, \"then\", [resolveElement, resultCapability.reject]);\n\n    // r. Set index to index + 1.\n    index = index + 1;\n  }\n  invariant(false);\n}\n\n// ECMA262 25.4.4.3.1\nexport function PerformPromiseRace(\n  realm: Realm,\n  iteratorRecord: { $Iterator: ObjectValue, $Done: boolean },\n  resultCapability: PromiseCapability,\n  C: ObjectValue\n): ObjectValue {\n  // 1. Assert: constructor is a constructor function.\n  invariant(IsConstructor(realm, C), \"constructor is a constructor function\");\n\n  // 2. Assert: resultCapability is a PromiseCapability Record.\n  resultCapability;\n\n  // 3. Repeat\n  while (true) {\n    // a. Let next be IteratorStep(iteratorRecord.[[Iterator]]).\n    let next;\n    try {\n      next = IteratorStep(realm, iteratorRecord.$Iterator);\n    } catch (e) {\n      if (e instanceof AbruptCompletion) {\n        // b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.\n        iteratorRecord.$Done = true;\n      }\n\n      // c. ReturnIfAbrupt(next).\n      throw e;\n    }\n\n    // d. If next is false, then\n    if (next === false) {\n      // i. Set iteratorRecord.[[Done]] to true.\n      iteratorRecord.$Done = true;\n\n      // ii. Return resultCapability.[[Promise]].\n      invariant(resultCapability.promise instanceof ObjectValue);\n      return resultCapability.promise;\n    }\n\n    // e. Let nextValue be IteratorValue(next).\n    let nextValue;\n    try {\n      nextValue = IteratorValue(realm, next);\n    } catch (e) {\n      if (e instanceof AbruptCompletion) {\n        // f. If nextValue is an abrupt completion, set iteratorRecord.[[Done]] to true.\n        iteratorRecord.$Done = true;\n      }\n\n      // g. ReturnIfAbrupt(nextValue).\n      throw e;\n    }\n\n    // h. Let nextPromise be ? Invoke(C, \"resolve\", « nextValue »).\n    let nextPromise = Invoke(realm, C, \"resolve\", [nextValue]);\n\n    // i. Perform ? Invoke(nextPromise, \"then\", « resultCapability.[[Resolve]], resultCapability.[[Reject]] »).\n    Invoke(realm, nextPromise, \"then\", [resultCapability.resolve, resultCapability.reject]);\n  }\n  invariant(false);\n}\n\n// ECMA262 25.4.5.3.1\nexport function PerformPromiseThen(\n  realm: Realm,\n  promise: ObjectValue,\n  onFulfilled: Value,\n  onRejected: Value,\n  resultCapability: PromiseCapability\n): ObjectValue {\n  // 1. Assert: IsPromise(promise) is true.\n  invariant(IsPromise(realm, promise), \"IsPromise(promise) is true\");\n\n  // 2. Assert: resultCapability is a PromiseCapability record.\n  resultCapability;\n\n  // 3. If IsCallable(onFulfilled) is false, then\n  if (IsCallable(realm, onFulfilled) === false) {\n    // a. Let onFulfilled be \"Identity\".\n    onFulfilled = new StringValue(realm, \"Identity\");\n  }\n\n  // 4. If IsCallable(onRejected) is false, then\n  if (IsCallable(realm, onRejected)) {\n    // a. Let onRejected be \"Thrower\".\n    onRejected = new StringValue(realm, \"Thrower\");\n  }\n\n  // 5. Let fulfillReaction be the PromiseReaction { [[Capabilities]]: resultCapability, [[Handler]]: onFulfilled }.\n  let fulfillReaction = { capabilities: resultCapability, handler: onFulfilled };\n\n  // 6. Let rejectReaction be the PromiseReaction { [[Capabilities]]: resultCapability, [[Handler]]: onRejected}.\n  let rejectReaction = { capabilities: resultCapability, handler: onRejected };\n\n  // 7. If the value of promise's [[PromiseState]] internal slot is \"pending\", then\n  if (promise.$PromiseState === \"pending\") {\n    // a. Append fulfillReaction as the last element of the List that is the value of promise's [[PromiseFulfillReactions]] internal slot.\n    Properties.ThrowIfInternalSlotNotWritable(realm, promise, \"$PromiseFulfillReactions\");\n    invariant(promise.$PromiseFulfillReactions);\n    promise.$PromiseFulfillReactions.push(fulfillReaction);\n    // b. Append rejectReaction as the last element of the List that is the value of promise's [[PromiseRejectReactions]] internal slot.\n    Properties.ThrowIfInternalSlotNotWritable(realm, promise, \"$PromiseRejectReactions\");\n    invariant(promise.$PromiseRejectReactions);\n    promise.$PromiseRejectReactions.push(rejectReaction);\n  } else if (promise.$PromiseState === \"fulfilled\") {\n    // 8. Else if the value of promise's [[PromiseState]] internal slot is \"fulfilled\", then\n    // a. Let value be the value of promise's [[PromiseResult]] internal slot.\n    let value = promise.$PromiseResult;\n    // b. Perform EnqueueJob(\"PromiseJobs\", PromiseReactionJob, « fulfillReaction, value »).\n    EnqueueJob(realm, \"PromiseJobs\", PromiseReactionJob, [fulfillReaction, value]);\n  } else {\n    // 9. Else,\n    // a. Assert: The value of promise's [[PromiseState]] internal slot is \"rejected\".\n    invariant(promise.$PromiseState === \"rejected\");\n\n    // b. Let reason be the value of promise's [[PromiseResult]] internal slot.\n    let reason = promise.$PromiseResult;\n\n    // c. If the value of promise's [[PromiseIsHandled]] internal slot is false, perform HostPromiseRejectionTracker(promise, \"handle\").\n    if (promise.$PromiseIsHandled === false) HostPromiseRejectionTracker(realm, promise, \"handle\");\n\n    // d. Perform EnqueueJob(\"PromiseJobs\", PromiseReactionJob, « rejectReaction, reason »).\n    EnqueueJob(realm, \"PromiseJobs\", PromiseReactionJob, [rejectReaction, reason]);\n  }\n\n  // 10. Set promise's [[PromiseIsHandled]] internal slot to true.\n  Properties.ThrowIfInternalSlotNotWritable(realm, promise, \"$PromiseIsHandled\").$PromiseIsHandled = true;\n\n  // 11. Return resultCapability.[[Promise]].\n  invariant(resultCapability.promise instanceof ObjectValue);\n  return resultCapability.promise;\n}\n\n// ECMA262 25.4.2.1\nexport function PromiseReactionJob(realm: Realm, reaction: Function, argument: Value): Value {\n  return realm.intrinsics.undefined;\n}\n\n// ECMA262 25.4.1.3.2\nfunction createResolveFunction(realm) {\n  // 2. Let resolve be a new built-in function object as defined in Promise Resolve Functions (25.4.1.3.2).\n  let resolve = new NativeFunctionValue(\n    realm,\n    undefined,\n    undefined,\n    1,\n    (context, [resolution]) => {\n      // 1. Assert: F has a [[Promise]] internal slot whose value is an Object.\n      invariant(resolve.$Promise instanceof ObjectValue, \"F has a [[Promise]] internal slot whose value is an Object\");\n\n      // 2. Let promise be the value of F's [[Promise]] internal slot.\n      let promise = resolve.$Promise;\n\n      // 3. Let alreadyResolved be the value of F's [[AlreadyResolved]] internal slot.\n      let alreadyResolved = resolve.$AlreadyResolved;\n      invariant(alreadyResolved !== undefined);\n\n      // 4. If alreadyResolved.[[Value]] is true, return undefined.\n      if (alreadyResolved.value === true) return realm.intrinsics.undefined;\n\n      // 5. Set alreadyResolved.[[Value]] to true.\n      alreadyResolved.value = true;\n\n      // 6. If SameValue(resolution, promise) is true, then\n      if (SameValue(realm, resolution.throwIfNotConcrete(), promise)) {\n        // a. Let selfResolutionError be a newly created TypeError object.\n        let selfResolutionError = Construct(realm, realm.intrinsics.TypeError, [new StringValue(realm, \"resolve\")]);\n\n        // b. Return RejectPromise(promise, selfResolutionError).\n        return RejectPromise(realm, promise, selfResolutionError);\n      }\n      // 7. If Type(resolution) is not Object, then\n      if (!(resolution instanceof ObjectValue)) {\n        // a. Return FulfillPromise(promise, resolution).\n        return FulfillPromise(realm, promise, resolution);\n      }\n\n      // 8. Let then be Get(resolution, \"then\").\n      let then;\n      try {\n        then = Get(realm, resolution, \"then\");\n      } catch (e) {\n        // 9. If then is an abrupt completion, then\n        if (e instanceof AbruptCompletion) {\n          // a. Return RejectPromise(promise, then.[[Value]]).\n          return RejectPromise(realm, promise, e);\n        } else throw e;\n      }\n\n      // 10. Let thenAction be then.[[Value]].\n      let thenAction = then;\n\n      // 11. If IsCallable(thenAction) is false, then\n      if (IsCallable(realm, thenAction)) {\n        // a. Return FulfillPromise(promise, resolution).\n        return FulfillPromise(realm, promise, resolution);\n      }\n\n      // 12. Perform EnqueueJob(\"PromiseJobs\", PromiseResolveThenableJob, « promise, resolution, thenAction »).\n      EnqueueJob(realm, \"PromiseJobs\", PromiseResolveThenableJob, [promise, resolution, thenAction]);\n\n      // 13. Return undefined.\n      return realm.intrinsics.undefined;\n    },\n    false\n  );\n  return resolve;\n}\n\n// ECMA262 25.4.1.3.1\nfunction createRejectFunction(realm) {\n  // 5. Let reject be a new built-in function object as defined in Promise Reject Functions (25.4.1.3.1).\n  let reject = new NativeFunctionValue(\n    realm,\n    undefined,\n    undefined,\n    1,\n    (context, [reason]) => {\n      // 1. Assert: F has a [[Promise]] internal slot whose value is an Object.\n      invariant(reject.$Promise instanceof ObjectValue, \"F has a [[Promise]] internal slot whose value is an Object\");\n\n      // 2. Let promise be the value of F's [[Promise]] internal slot.\n      let promise = reject.$Promise;\n\n      // 3. Let alreadyResolved be the value of F's [[AlreadyResolved]] internal slot.\n      let alreadyResolved = reject.$AlreadyResolved;\n      invariant(alreadyResolved !== undefined);\n\n      // 4. If alreadyResolved.[[Value]] is true, return undefined.\n      if (alreadyResolved.value === true) return realm.intrinsics.undefined;\n\n      // 5. Set alreadyResolved.[[Value]] to true.\n      alreadyResolved.value = true;\n\n      // 6. Return RejectPromise(promise, reason).\n      return RejectPromise(realm, promise, reason);\n    },\n    false\n  );\n  return reject;\n}\n\n// ECMA262 25.4.1.3\nexport function CreateResolvingFunctions(realm: Realm, promise: ObjectValue): ResolvingFunctions {\n  // 1. Let alreadyResolved be a new Record { [[Value]]: false }.\n  let alreadyResolved = { value: false };\n\n  // 2. Let resolve be a new built-in function object as defined in Promise Resolve Functions (25.4.1.3.2).\n  let resolve = createResolveFunction(realm);\n\n  // 3. Set the [[Promise]] internal slot of resolve to promise.\n  resolve.$Promise = promise;\n\n  // 4. Set the [[AlreadyResolved]] internal slot of resolve to alreadyResolved.\n  resolve.$AlreadyResolved = alreadyResolved;\n\n  // 5. Let reject be a new built-in function object as defined in Promise Reject Functions (25.4.1.3.1).\n  let reject = createRejectFunction(realm);\n\n  // 6. Set the [[Promise]] internal slot of reject to promise.\n  reject.$Promise = promise;\n\n  // 7. Set the [[AlreadyResolved]] internal slot of reject to alreadyResolved.\n  reject.$AlreadyResolved = alreadyResolved;\n\n  // 8. Return a new Record { [[Resolve]]: resolve, [[Reject]]: reject }.\n  return { resolve: resolve, reject: reject };\n}\n\n// ECMA262 25.4.1.4\nexport function FulfillPromise(realm: Realm, promise: ObjectValue, value: Value): Value {\n  // 1. Assert: The value of promise.[[PromiseState]] is \"pending\".\n  invariant(promise.$PromiseState === \"pending\");\n\n  // 2. Let reactions be promise.[[PromiseFulfillReactions]].\n  let reactions = promise.$PromiseFulfillReactions;\n  invariant(reactions);\n\n  // 3. Set promise.[[PromiseResult]] to value.\n  Properties.ThrowIfInternalSlotNotWritable(realm, promise, \"$PromiseResult\").$PromiseResult = value;\n\n  // 4. Set promise.[[PromiseFulfillReactions]] to undefined.\n  Properties.ThrowIfInternalSlotNotWritable(\n    realm,\n    promise,\n    \"$PromiseFulfillReactions\"\n  ).$PromiseFulfillReactions = undefined;\n\n  // 5. Set promise.[[PromiseRejectReactions]] to undefined.\n  Properties.ThrowIfInternalSlotNotWritable(\n    realm,\n    promise,\n    \"$PromiseRejectReactions\"\n  ).$PromiseRejectReactions = undefined;\n\n  // 6. Set promise.[[PromiseState]] to \"fulfilled\".\n  Properties.ThrowIfInternalSlotNotWritable(realm, promise, \"$PromiseState\").$PromiseState = \"fulfilled\";\n\n  // 7. Return TriggerPromiseReactions(reactions, value).\n  return TriggerPromiseReactions(realm, reactions, value);\n}\n\n// ECMA262 25.4.1.7\nexport function RejectPromise(realm: Realm, promise: ObjectValue, reason: Value): Value {\n  // 1. Assert: The value of promise.[[PromiseState]] is \"pending\".\n  invariant(promise.$PromiseState === \"pending\");\n\n  // 2. Let reactions be promise.[[PromiseRejectReactions]].\n  let reactions = promise.$PromiseFulfillReactions;\n  invariant(reactions);\n\n  // 3. Set promise.[[PromiseResult]] to reason.\n  Properties.ThrowIfInternalSlotNotWritable(realm, promise, \"$PromiseResult\").$PromiseResult = reason;\n\n  // 4. Set promise.[[PromiseFulfillReactions]] to undefined.\n  Properties.ThrowIfInternalSlotNotWritable(\n    realm,\n    promise,\n    \"$PromiseFulfillReactions\"\n  ).$PromiseFulfillReactions = undefined;\n\n  // 5. Set promise.[[PromiseRejectReactions]] to undefined.\n  Properties.ThrowIfInternalSlotNotWritable(\n    realm,\n    promise,\n    \"$PromiseRejectReactions\"\n  ).$PromiseRejectReactions = undefined;\n\n  // 6. Set promise.[[PromiseState]] to \"rejected\".\n  Properties.ThrowIfInternalSlotNotWritable(realm, promise, \"$PromiseState\").$PromiseState = \"rejected\";\n\n  // 7. If promise.[[PromiseIsHandled]] is false, perform HostPromiseRejectionTracker(promise, \"reject\").\n  if (promise.$PromiseIsHandled === false) HostPromiseRejectionTracker(realm, promise, \"reject\");\n\n  // 8. Return TriggerPromiseReactions(reactions, reason).\n  return TriggerPromiseReactions(realm, reactions, reason);\n}\n\n// ECMA262 25.4.1.8\nexport function TriggerPromiseReactions(realm: Realm, reactions: Array<PromiseReaction>, argument: Value) {\n  // 1. Repeat for each reaction in reactions, in original insertion order\n  for (let reaction of reactions) {\n    // a. Perform EnqueueJob(\"PromiseJobs\", PromiseReactionJob, « reaction, argument »).\n    EnqueueJob(realm, \"PromiseJobs\", PromiseReactionJob, [reaction, argument]);\n  }\n  // 2. Return undefined.\n  return realm.intrinsics.undefined;\n}\n\n// ECMA262 25.4.1.9\nexport function HostPromiseRejectionTracker(realm: Realm, promise: ObjectValue, operation: \"reject\" | \"handle\") {}\n\n// ECMA262 25.4.2.2\nexport function PromiseResolveThenableJob(realm: Realm, promiseToResolve: ObjectValue, thenable: Value, then: Value) {}\n"]}