"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ArrayElementType = exports.ArrayElementSize = undefined;
exports.IntegerIndexedObjectCreate = IntegerIndexedObjectCreate;
exports.IntegerIndexedElementGet = IntegerIndexedElementGet;
exports.IntegerIndexedElementSet = IntegerIndexedElementSet;
exports.ValidateTypedArray = ValidateTypedArray;
exports.AllocateTypedArray = AllocateTypedArray;
exports.AllocateTypedArrayBuffer = AllocateTypedArrayBuffer;
exports.TypedArrayCreate = TypedArrayCreate;
exports.TypedArraySpeciesCreate = TypedArraySpeciesCreate;

var _errors = require("../errors.js");

var _index = require("../values/index.js");

var _get = require("../methods/get.js");

var _arraybuffer = require("../methods/arraybuffer.js");

var _is = require("../methods/is.js");

var _construct = require("../methods/construct.js");

var _to = require("../methods/to.js");

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ArrayElementSize = exports.ArrayElementSize = {
  Float32Array: 4,
  Float64Array: 8,
  Int8Array: 1,
  Int16Array: 2,
  Int32Array: 4,
  Uint8Array: 1,
  Uint16Array: 2,
  Uint32Array: 4,
  Uint8ClampedArray: 1
}; /**
    * Copyright (c) 2017-present, Facebook, Inc.
    * All rights reserved.
    *
    * This source code is licensed under the BSD-style license found in the
    * LICENSE file in the root directory of this source tree. An additional grant
    * of patent rights can be found in the PATENTS file in the same directory.
    */

var ArrayElementType = exports.ArrayElementType = {
  Float32Array: "Float32",
  Float64Array: "Float64",
  Int8Array: "Int8",
  Int16Array: "Int16",
  Int32Array: "Int32",
  Uint8Array: "Uint8",
  Uint16Array: "Uint16",
  Uint32Array: "Uint32",
  Uint8ClampedArray: "Uint8Clamped"
};

// ECMA262 9.4.5.7
function IntegerIndexedObjectCreate(realm, prototype, internalSlotsList) {
  // 1. Assert: internalSlotsList contains the names [[ViewedArrayBuffer]], [[ArrayLength]], [[ByteOffset]], and [[TypedArrayName]].
  (0, _invariant2.default)("$ViewedArrayBuffer" in internalSlotsList && "$ArrayLength" in internalSlotsList && "$ByteOffset" in internalSlotsList && "$TypedArrayName" in internalSlotsList);

  // 2. Let A be a newly created object with an internal slot for each name in internalSlotsList.
  var A = new _index.IntegerIndexedExotic(realm);
  Object.assign(A, internalSlotsList);

  // 3. Set A's essential internal methods to the default ordinary object definitions specified in 9.1.
  // 4. Set the [[GetOwnProperty]] internal method of A as specified in 9.4.5.1.
  // 5. Set the [[HasProperty]] internal method of A as specified in 9.4.5.2.
  // 6. Set the [[DefineOwnProperty]] internal method of A as specified in 9.4.5.3.
  // 7. Set the [[Get]] internal method of A as specified in 9.4.5.4.
  // 8. Set the [[Set]] internal method of A as specified in 9.4.5.5.
  // 9. Set the [[OwnPropertyKeys]] internal method of A as specified in 9.4.5.6.

  // 10. Set A.[[Prototype]] to prototype.
  A.$Prototype = prototype;

  // 11. Set A.[[Extensible]] to true.
  A.setExtensible(true);

  // 12. Return A.
  return A;
}

// ECMA262 9.4.5.8
function IntegerIndexedElementGet(realm, O, index) {
  // 1. Assert: Type(index) is Number.
  (0, _invariant2.default)(typeof index === "number", "Type(index) is Number");

  // 2. Assert: O is an Object that has [[ViewedArrayBuffer]], [[ArrayLength]], [[ByteOffset]], and [[TypedArrayName]] internal slots.
  (0, _invariant2.default)(O instanceof _index.ObjectValue && O.$ViewedArrayBuffer && O.$ArrayLength !== undefined && O.$ByteOffset !== undefined && O.$TypedArrayName);

  // 3. Let buffer be O.[[ViewedArrayBuffer]].
  var buffer = O.$ViewedArrayBuffer;

  // 4. If IsDetachedBuffer(buffer) is true, throw a TypeError exception.
  if ((0, _is.IsDetachedBuffer)(realm, buffer) === true) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "IsDetachedBuffer(buffer) is true");
  }

  // 5. If IsInteger(index) is false, return undefined.
  if ((0, _is.IsInteger)(realm, index) === false) return realm.intrinsics.undefined;

  // 6. If index = -0, return undefined.
  if (Object.is(index, -0)) return realm.intrinsics.undefined;

  // 7. Let length be O.[[ArrayLength]].
  var length = O.$ArrayLength;
  (0, _invariant2.default)(typeof length === "number");

  // 8. If index < 0 or index ≥ length, return undefined.
  if (index < 0 || index >= length) return realm.intrinsics.undefined;

  // 9. Let offset be O.[[ByteOffset]].
  var offset = O.$ByteOffset;
  (0, _invariant2.default)(typeof offset === "number");

  // 10. Let arrayTypeName be the String value of O.[[TypedArrayName]].
  var arrayTypeName = O.$TypedArrayName;
  (0, _invariant2.default)(typeof arrayTypeName === "string");

  // 11. Let elementSize be the Number value of the Element Size value specified in Table 50 for arrayTypeName.
  var elementSize = ArrayElementSize[arrayTypeName];

  // 12. Let indexedPosition be (index × elementSize) + offset.
  var indexedPosition = index * elementSize + offset;

  // 13. Let elementType be the String value of the Element Type value in Table 50 for arrayTypeName.
  var elementType = ArrayElementType[arrayTypeName];

  // 14. Return GetValueFromBuffer(buffer, indexedPosition, elementType).
  return (0, _arraybuffer.GetValueFromBuffer)(realm, buffer, indexedPosition, elementType);
}

// ECMA262 9.4.5.9
function IntegerIndexedElementSet(realm, O, index, value) {
  // 1. Assert: Type(index) is Number.
  (0, _invariant2.default)(typeof index === "number", "Type(index) is Number");

  // 2. Assert: O is an Object that has [[ViewedArrayBuffer]], [[ArrayLength]], [[ByteOffset]], and [[TypedArrayName]] internal slots.
  (0, _invariant2.default)(O instanceof _index.ObjectValue && O.$ViewedArrayBuffer && O.$ArrayLength !== undefined && O.$ByteOffset !== undefined && O.$TypedArrayName);

  // 3. Let numValue be ? ToNumber(value).
  var numValue = (0, _to.ToNumber)(realm, value);

  // 4. Let buffer be O.[[ViewedArrayBuffer]].
  var buffer = O.$ViewedArrayBuffer;
  (0, _invariant2.default)(buffer);

  // 5. If IsDetachedBuffer(buffer) is true, throw a TypeError exception.
  if ((0, _is.IsDetachedBuffer)(realm, buffer) === true) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "IsDetachedBuffer(buffer) is true");
  }

  // 6. If IsInteger(index) is false, return false.
  if ((0, _is.IsInteger)(realm, index) === false) return false;

  // 7. If index = -0, return false.
  if (Object.is(index, -0)) return false;

  // 8. Let length be O.[[ArrayLength]].
  var length = O.$ArrayLength;
  (0, _invariant2.default)(typeof length === "number");

  // 9. If index < 0 or index ≥ length, return false.
  if (index < 0 || index >= length) return false;

  // 10. Let offset be O.[[ByteOffset]].
  var offset = O.$ByteOffset;
  (0, _invariant2.default)(typeof offset === "number");

  // 11. Let arrayTypeName be the String value of O.[[TypedArrayName]].
  var arrayTypeName = O.$TypedArrayName;
  (0, _invariant2.default)(typeof arrayTypeName === "string");

  // 12. Let elementSize be the Number value of the Element Size value specified in Table 50 for arrayTypeName.
  var elementSize = ArrayElementSize[arrayTypeName];

  // 13. Let indexedPosition be (index × elementSize) + offset.
  var indexedPosition = index * elementSize + offset;

  // 14. Let elementType be the String value of the Element Type value in Table 50 for arrayTypeName.
  var elementType = ArrayElementType[arrayTypeName];

  // 15. Perform SetValueInBuffer(buffer, indexedPosition, elementType, numValue).
  (0, _arraybuffer.SetValueInBuffer)(realm, buffer, indexedPosition, elementType, numValue);

  // 16. Return true.
  return true;
}

// ECMA262 22.2.3.5.1
function ValidateTypedArray(realm, O) {
  O = O.throwIfNotConcrete();

  // 1. If Type(O) is not Object, throw a TypeError exception.
  if (!(O instanceof _index.ObjectValue)) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(O) is not Object");
  }

  // 2. If O does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.
  if (!O.$TypedArrayName) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(O) is not Object");
  }

  // 3. Assert: O has a [[ViewedArrayBuffer]] internal slot.
  (0, _invariant2.default)(O.$ViewedArrayBuffer, "O has a [[ViewedArrayBuffer]] internal slot");

  // 4. Let buffer be O.[[ViewedArrayBuffer]].
  var buffer = O.$ViewedArrayBuffer;

  // 5. If IsDetachedBuffer(buffer) is true, throw a TypeError exception.
  if ((0, _is.IsDetachedBuffer)(realm, buffer) === true) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "IsDetachedBuffer(buffer) is true");
  }

  // 6. Return buffer.
  return buffer;
}

// ECMA262 22.2.4.2.1
function AllocateTypedArray(realm, constructorName, newTarget, defaultProto, length) {
  // 1. Let proto be ? GetPrototypeFromConstructor(newTarget, defaultProto).
  var proto = (0, _get.GetPrototypeFromConstructor)(realm, newTarget, defaultProto);

  // 2. Let obj be IntegerIndexedObjectCreate(proto, « [[ViewedArrayBuffer]], [[TypedArrayName]], [[ByteLength]], [[ByteOffset]], [[ArrayLength]] »).
  var obj = IntegerIndexedObjectCreate(realm, proto, {
    $ViewedArrayBuffer: undefined,
    $TypedArrayName: undefined,
    $ByteLength: undefined,
    $ByteOffset: undefined,
    $ArrayLength: undefined
  });

  // 3. Assert: obj.[[ViewedArrayBuffer]] is undefined.
  (0, _invariant2.default)(obj.$ViewedArrayBuffer === undefined);

  // 4. Set obj.[[TypedArrayName]] to constructorName.
  obj.$TypedArrayName = constructorName;

  // 5. If length was not passed, then
  if (length === undefined) {
    // a. Set obj.[[ByteLength]] to 0.
    obj.$ByteLength = 0;

    // b. Set obj.[[ByteOffset]] to 0.
    obj.$ByteOffset = 0;

    // c. Set obj.[[ArrayLength]] to 0.
    obj.$ArrayLength = 0;
  } else {
    // 6. Else,
    // a. Perform ? AllocateTypedArrayBuffer(obj, length).
    AllocateTypedArrayBuffer(realm, obj, length);
  }

  // 7. Return obj.
  return obj;
}

// ECMA262 22.2.4.2.2
function AllocateTypedArrayBuffer(realm, O, length) {
  // Note that O is a new object, and we can thus write to internal slots
  (0, _invariant2.default)(realm.isNewObject(O));

  // 1. Assert: O is an Object that has a [[ViewedArrayBuffer]] internal slot.
  (0, _invariant2.default)(O instanceof _index.ObjectValue && "$ViewedArrayBuffer" in O, "O is an Object that has a [[ViewedArrayBuffer]] internal slot");

  // 2. Assert: O.[[ViewedArrayBuffer]] is undefined.
  (0, _invariant2.default)(O.$ViewedArrayBuffer === undefined, "O.[[ViewedArrayBuffer]] is undefined");

  // 3. Assert: length ≥ 0.
  (0, _invariant2.default)(length >= 0, "length ≥ 0");

  // 4. Let constructorName be the String value of O.[[TypedArrayName]].
  var constructorName = O.$TypedArrayName;
  (0, _invariant2.default)(constructorName);

  // 5. Let elementSize be the Element Size value in Table 50 for constructorName.
  var elementSize = ArrayElementSize[constructorName];

  // 6. Let byteLength be elementSize × length.
  var byteLength = elementSize * length;

  // 7. Let data be ? AllocateArrayBuffer(%ArrayBuffer%, byteLength).
  var data = (0, _arraybuffer.AllocateArrayBuffer)(realm, realm.intrinsics.ArrayBuffer, byteLength);

  // 8. Set O.[[ViewedArrayBuffer]] to data.
  O.$ViewedArrayBuffer = data;

  // 9. Set O.[[ByteLength]] to byteLength.
  O.$ByteLength = byteLength;

  // 10. Set O.[[ByteOffset]] to 0.
  O.$ByteOffset = 0;

  // 11. Set O.[[ArrayLength]] to length.
  O.$ArrayLength = length;

  // 12. Return O.
  return O;
}

// ECMA262 22.2.4.6
function TypedArrayCreate(realm, constructor, argumentList) {
  // 1. Let newTypedArray be ? Construct(constructor, argumentList).
  var newTypedArray = (0, _construct.Construct)(realm, constructor, argumentList);

  // 2. Perform ? ValidateTypedArray(newTypedArray).
  ValidateTypedArray(realm, newTypedArray);

  // 3. If argumentList is a List of a single Number, then
  if (argumentList.length === 1 && argumentList[0].mightBeNumber()) {
    if (argumentList[0].mightNotBeNumber()) {
      (0, _invariant2.default)(argumentList[0] instanceof _index.AbstractValue);
      _index.AbstractValue.reportIntrospectionError(argumentList[0]);
      throw new _errors.FatalError();
    }
    // a. If newTypedArray.[[ArrayLength]] < argumentList[0], throw a TypeError exception.
    (0, _invariant2.default)(typeof newTypedArray.$ArrayLength === "number");
    if (newTypedArray.$ArrayLength < argumentList[0].throwIfNotConcrete().value) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "newTypedArray.[[ArrayLength]] < argumentList[0]");
    }
  }

  // 4. Return newTypedArray.
  return newTypedArray;
}

// ECMA262 22.2.4.7
function TypedArraySpeciesCreate(realm, exemplar, argumentList) {
  // 1. Assert: exemplar is an Object that has a [[TypedArrayName]] internal slot.
  (0, _invariant2.default)(exemplar instanceof _index.ObjectValue && typeof exemplar.$TypedArrayName === "string");

  // 2. Let defaultConstructor be the intrinsic object listed in column one of Table 50 for exemplar.[[TypedArrayName]].
  (0, _invariant2.default)(typeof exemplar.$TypedArrayName === "string");
  var defaultConstructor = {
    Float32Array: realm.intrinsics.Float32Array,
    Float64Array: realm.intrinsics.Float64Array,
    Int8Array: realm.intrinsics.Int8Array,
    Int16Array: realm.intrinsics.Int16Array,
    Int32Array: realm.intrinsics.Int32Array,
    Uint8Array: realm.intrinsics.Uint8Array,
    Uint16Array: realm.intrinsics.Uint16Array,
    Uint32Array: realm.intrinsics.Uint32Array,
    Uint8ClampedArray: realm.intrinsics.Uint8ClampedArray
  }[exemplar.$TypedArrayName];

  // 3. Let constructor be ? SpeciesConstructor(exemplar, defaultConstructor).
  var constructor = (0, _construct.SpeciesConstructor)(realm, exemplar, defaultConstructor);

  // 4. Return ? TypedArrayCreate(constructor, argumentList).
  return TypedArrayCreate(realm, constructor, argumentList);
}
//# sourceMappingURL=typedarray.js.map