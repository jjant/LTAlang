{"version":3,"sources":["../../src/methods/function.js"],"names":["t","InternalCall","realm","F","thisArgument","argsList","tracerIndex","tracer","tracers","nextIndex","detourResult","detourCall","undefined","length","$FunctionKind","createErrorThrowCompletion","intrinsics","TypeError","callerContext","getRunningContext","calleeContext","result","t1","beforeCall","popContext","t2","afterCall","value","joinAndRemoveNestedReturnCompletions","$BoundCall","argumentsList","target","$BoundTargetFunction","boundThis","$BoundThis","boundArgs","$BoundArguments","args","concat","$BoundConstruct","newTarget","$Construct","InternalConstruct","kind","$ConstructorKind","envRec","constructorEnv","lexicalEnvironment","environmentRecord","mightBeObject","throwIfNotConcreteObject","mightBeUndefined","throwIfNotConcrete","envRecThisBinding","GetThisBinding","FunctionImplementation","ast_node","FindVarScopedDeclarationsFor","ast","level","statements","type","body","astIfStatement","consequent","alternate","astForStatement","init","astForInStatement","left","astForOfStatement","cases","switchCase","astTryStatement","block","finalizer","push","handler","decls","statement","func","env","code","$ECMAScriptCode","strict","$Strict","formals","$FormalParameters","parameterNames","Object","create","param","paramBindings","getBindingIdentifiers","name","hasDuplicates","identifiers","keys","simpleParameterList","hasParameterExpressions","ContainsExpression","varNames","node","varDeclarations","FindVarScopedDeclarations","lexicalNames","functionNames","functionsToInitialize","reverse","d","fn","BoundNames","indexOf","unshift","argumentsObjectNeeded","$ThisMode","paramName","alreadyDeclared","HasBinding","CreateMutableBinding","InitializeBinding","ao","CreateImmutableBinding","iteratorRecord","$Iterator","$Done","IteratorBindingInitialization","varEnv","varEnvRec","instantiatedVarNames","slice","n","NewDeclarativeEnvironment","variableEnvironment","initialValue","GetBindingValue","lexEnv","lexEnvRec","lexDeclarations","dn","f","fo","evaluate","SetMutableBinding","empty","prefix","getExtensible","description","$Description","emptyString","throwIfNotConcreteString","prefixVal","createFromBinaryOp","expressionLocation","DefinePropertyOrThrow","enumerable","writable","configurable","ParameterList","Body","Scope","isNewObject","len","FormalParameter","Strict","$Environment","uniqueTag","functionBodyUniqueTagSeed","$ScriptOrModule","GetActiveScriptOrModule","functionPrototype","Generator","FunctionAllocate","FunctionInitialize","thrower","ThrowTypeError","desc","get","set","functionKind","needsConstruct","$Call","$Prototype","setExtensible","$Realm","targetFunction","proto","$GetPrototypeOf","obj","x","evalRealm","strictCaller","direct","script","program","blockStatement","directives","strictEval","ctx","$GlobalEnv","suspend","evalCxt","isStrict","setFunction","setRealm","ScriptOrModule","pushContext","EvalDeclarationInstantiation","e","directive","EvaluateStatements","resume","c","savedCompletion","updatePossiblyNormalCompletionWithValue","getCapturedEffects","stopEffectCaptureAndUndoEffects","joined_effects","joinPossiblyNormalCompletionWithAbruptCompletion","applyEffects","jc","initialBlockValue","strictCode","blockEnv","blockValue","res","evaluateCompletionDeref","statementAsts","partiallyEvaluateCompletionDeref","nast","nio","ioAst","prototype","FunctionPrototype","allocKind","HasLexicalDeclaration","SyntaxError","thisLex","thisEnvRec","parent","declaredFunctionNames","fnDefinable","CanDeclareGlobalFunction","declaredVarNames","vn","vnDefinable","CanDeclareGlobalVar","s","CreateGlobalFunctionBinding","bindingExists","CreateGlobalVarBinding","homeObject","$HomeObject","prop","propKey","scope","closure","FunctionCreate","params","MakeMethod","$Key","$Closure"],"mappings":"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","file":"function.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport type { PropertyKeyValue, FunctionBodyAstNode } from \"../types.js\";\nimport type { Realm } from \"../realm.js\";\nimport type { ECMAScriptFunctionValue } from \"../values/index.js\";\nimport {\n  Completion,\n  ReturnCompletion,\n  AbruptCompletion,\n  JoinedAbruptCompletions,\n  NormalCompletion,\n} from \"../completions.js\";\nimport { ExecutionContext } from \"../realm.js\";\nimport { GlobalEnvironmentRecord, ObjectEnvironmentRecord } from \"../environment.js\";\nimport {\n  AbstractValue,\n  BoundFunctionValue,\n  ECMAScriptSourceFunctionValue,\n  EmptyValue,\n  FunctionValue,\n  NumberValue,\n  ObjectValue,\n  StringValue,\n  SymbolValue,\n  UndefinedValue,\n  Value,\n} from \"../values/index.js\";\nimport { OrdinaryCreateFromConstructor, CreateUnmappedArgumentsObject, CreateMappedArgumentsObject } from \"./create.js\";\nimport { OrdinaryCallEvaluateBody, OrdinaryCallBindThis, PrepareForOrdinaryCall, Call } from \"./call.js\";\nimport { SameValue } from \"../methods/abstract.js\";\nimport { Construct } from \"../methods/construct.js\";\nimport { UpdateEmpty } from \"../methods/index.js\";\nimport { CreateListIterator } from \"../methods/iterator.js\";\nimport { EvalPropertyName } from \"../evaluators/ObjectExpression.js\";\nimport { Environment, Join, Properties } from \"../singletons.js\";\nimport traverseFast from \"../utils/traverse-fast.js\";\nimport invariant from \"../invariant.js\";\nimport parse from \"../utils/parse.js\";\nimport IsStrict from \"../utils/strict.js\";\nimport * as t from \"babel-types\";\nimport type {\n  BabelNode,\n  BabelNodeLVal,\n  BabelNodeStatement,\n  BabelNodeBlockStatement,\n  BabelNodeProgram,\n  BabelNodeDoWhileStatement,\n  BabelNodeWhileStatement,\n  BabelNodeLabeledStatement,\n  BabelNodeWithStatement,\n  BabelNodeSwitchStatement,\n  BabelNodeIfStatement,\n  BabelNodeForStatement,\n  BabelNodeForInStatement,\n  BabelNodeForOfStatement,\n  BabelNodeTryStatement,\n  BabelNodeObjectMethod,\n  BabelNodeClassMethod,\n} from \"babel-types\";\n\nfunction InternalCall(\n  realm: Realm,\n  F: ECMAScriptFunctionValue,\n  thisArgument: Value,\n  argsList: Array<Value>,\n  tracerIndex: number\n): Value {\n  // 1. Assert: F is an ECMAScript function object.\n  invariant(F instanceof FunctionValue, \"expected function value\");\n\n  // Tracing: Give all registered tracers a chance to detour, wrapping around each other if needed.\n  while (tracerIndex < realm.tracers.length) {\n    let tracer = realm.tracers[tracerIndex];\n    let nextIndex = ++tracerIndex;\n    let detourResult = tracer.detourCall(F, thisArgument, argsList, undefined, () =>\n      InternalCall(realm, F, thisArgument, argsList, nextIndex)\n    );\n    if (detourResult instanceof Value) return detourResult;\n  }\n\n  // 2. If F's [[FunctionKind]] internal slot is \"classConstructor\", throw a TypeError exception.\n  if (F.$FunctionKind === \"classConstructor\")\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not callable\");\n\n  // 3. Let callerContext be the running execution context.\n  let callerContext = realm.getRunningContext();\n\n  // 4. Let calleeContext be PrepareForOrdinaryCall(F, undefined).\n  let calleeContext = PrepareForOrdinaryCall(realm, F, undefined);\n\n  let result;\n  try {\n    for (let t1 of realm.tracers) t1.beforeCall(F, thisArgument, argsList, undefined);\n\n    // 5. Assert: calleeContext is now the running execution context.\n    invariant(realm.getRunningContext() === calleeContext, \"calleeContext should be current execution context\");\n\n    // 6. Perform OrdinaryCallBindThis(F, calleeContext, thisArgument).\n    OrdinaryCallBindThis(realm, F, calleeContext, thisArgument);\n\n    // 7. Let result be OrdinaryCallEvaluateBody(F, argumentsList).\n    result = OrdinaryCallEvaluateBody(realm, F, argsList);\n  } finally {\n    // 8. Remove calleeContext from the execution context stack and restore callerContext as the running execution context.\n    realm.popContext(calleeContext);\n    invariant(realm.getRunningContext() === callerContext);\n\n    for (let t2 of realm.tracers) t2.afterCall(F, thisArgument, argsList, undefined, (result: any));\n  }\n\n  // 9. If result.[[Type]] is return, return NormalCompletion(result.[[Value]]).\n  if (result instanceof ReturnCompletion) {\n    return result.value;\n  }\n  if (result instanceof JoinedAbruptCompletions) {\n    result = Join.joinAndRemoveNestedReturnCompletions(realm, result);\n  }\n\n  // 10. ReturnIfAbrupt(result).  or if possibly abrupt\n  if (result instanceof Completion) {\n    throw result;\n  }\n\n  // 11. Return NormalCompletion(undefined).\n  return realm.intrinsics.undefined;\n}\n\n// ECMA262 9.4.1.1\nfunction $BoundCall(realm: Realm, F: BoundFunctionValue, thisArgument: Value, argumentsList: Array<Value>): Value {\n  // 1. Let target be the value of F's [[BoundTargetFunction]] internal slot.\n  let target = F.$BoundTargetFunction;\n\n  // 2. Let boundThis be the value of F's [[BoundThis]] internal slot.\n  let boundThis = F.$BoundThis;\n\n  // 3. Let boundArgs be the value of F's [[BoundArguments]] internal slot.\n  let boundArgs = F.$BoundArguments;\n\n  // 4. Let args be a new list containing the same values as the list boundArgs in the same order followed\n  //    by the same values as the list argumentsList in the same order.\n  let args = boundArgs.concat(argumentsList);\n\n  // 5. Return ? Call(target, boundThis, args).\n  return Call(realm, target, boundThis, args);\n}\n\n// ECMA262 9.4.1.2\nfunction $BoundConstruct(\n  realm: Realm,\n  F: BoundFunctionValue,\n  argumentsList: Array<Value>,\n  newTarget: ObjectValue\n): ObjectValue {\n  // 1. Let target be the value of F's [[BoundTargetFunction]] internal slot.\n  let target = F.$BoundTargetFunction;\n\n  // 2. Assert: target has a [[Construct]] internal method.\n  invariant(target.$Construct !== undefined, \"doesn't have a construct internal method\");\n\n  // 3. Let boundArgs be the value of F's [[BoundArguments]] internal slot.\n  let boundArgs = F.$BoundArguments;\n\n  // 4. Let args be a new list containing the same values as the list boundArgs in the same order followed\n  //    by the same values as the list argumentsList in the same order.\n  let args = boundArgs.concat(argumentsList);\n\n  // 5. If SameValue(F, newTarget) is true, let newTarget be target.\n  if (SameValue(realm, F, newTarget)) newTarget = target;\n\n  // 6. Return ? Construct(target, args, newTarget).\n  return Construct(realm, target, args, newTarget);\n}\n\nfunction InternalConstruct(\n  realm: Realm,\n  F: ECMAScriptFunctionValue,\n  argumentsList: Array<Value>,\n  newTarget: ObjectValue,\n  thisArgument: void | ObjectValue,\n  tracerIndex: number\n): ObjectValue {\n  // 1. Assert: F is an ECMAScript function object.\n  invariant(F instanceof FunctionValue, \"expected function\");\n\n  // 2. Assert: Type(newTarget) is Object.\n  invariant(newTarget instanceof ObjectValue, \"expected object\");\n\n  // 3. Let callerContext be the running execution context.\n  let callerContext = realm.getRunningContext();\n\n  // 4. Let kind be F's [[ConstructorKind]] internal slot.\n  let kind = F.$ConstructorKind;\n\n  // 5. If kind is \"base\", then\n  if (thisArgument === undefined && kind === \"base\") {\n    // a. Let thisArgument be ? OrdinaryCreateFromConstructor(newTarget, \"%ObjectPrototype%\").\n    thisArgument = OrdinaryCreateFromConstructor(realm, newTarget, \"ObjectPrototype\");\n  }\n\n  // Tracing: Give all registered tracers a chance to detour, wrapping around each other if needed.\n  while (tracerIndex < realm.tracers.length) {\n    let tracer = realm.tracers[tracerIndex];\n    let nextIndex = ++tracerIndex;\n    let detourResult = tracer.detourCall(F, thisArgument, argumentsList, newTarget, () =>\n      InternalConstruct(realm, F, argumentsList, newTarget, thisArgument, nextIndex)\n    );\n    if (detourResult instanceof ObjectValue) return detourResult;\n    invariant(detourResult === undefined);\n  }\n\n  // 6. Let calleeContext be PrepareForOrdinaryCall(F, newTarget).\n  let calleeContext = PrepareForOrdinaryCall(realm, F, newTarget);\n\n  // 7. Assert: calleeContext is now the running execution context.\n  invariant(realm.getRunningContext() === calleeContext, \"expected calleeContext to be running context\");\n\n  let result, envRec;\n  try {\n    for (let t1 of realm.tracers) t1.beforeCall(F, thisArgument, argumentsList, newTarget);\n\n    // 8. If kind is \"base\", perform OrdinaryCallBindThis(F, calleeContext, thisArgument).\n    if (kind === \"base\") {\n      invariant(thisArgument, \"this wasn't initialized for some reason\");\n      OrdinaryCallBindThis(realm, F, calleeContext, thisArgument);\n    }\n\n    // 9. Let constructorEnv be the LexicalEnvironment of calleeContext.\n    let constructorEnv = calleeContext.lexicalEnvironment;\n\n    // 10. Let envRec be constructorEnv's EnvironmentRecord.\n    envRec = constructorEnv.environmentRecord;\n\n    // 11. Let result be OrdinaryCallEvaluateBody(F, argumentsList).\n    result = OrdinaryCallEvaluateBody(realm, F, argumentsList);\n  } finally {\n    // 12. Remove calleeContext from the execution context stack and restore callerContext as the running execution context.\n    realm.popContext(calleeContext);\n    invariant(realm.getRunningContext() === callerContext);\n\n    for (let t2 of realm.tracers) t2.afterCall(F, thisArgument, argumentsList, newTarget, result);\n  }\n\n  // 13. If result.[[Type]] is return, then\n  if (result instanceof ReturnCompletion) {\n    // a. If Type(result.[[Value]]) is Object, return NormalCompletion(result.[[Value]]).\n    if (result.value.mightBeObject()) {\n      return result.value.throwIfNotConcreteObject();\n    }\n\n    // b. If kind is \"base\", return NormalCompletion(thisArgument).\n    if (kind === \"base\") {\n      invariant(thisArgument, \"this wasn't initialized for some reason\");\n      return thisArgument;\n    }\n\n    // c. If result.[[Value]] is not undefined, throw a TypeError exception.\n    if (!result.value.mightBeUndefined())\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"constructor must return Object\");\n    result.value.throwIfNotConcrete();\n  } else if (result instanceof AbruptCompletion) {\n    // 14. Else, ReturnIfAbrupt(result).\n    throw result;\n  }\n\n  // 15. Return ? envRec.GetThisBinding().\n  let envRecThisBinding = envRec.GetThisBinding();\n  invariant(envRecThisBinding instanceof ObjectValue);\n  return envRecThisBinding;\n}\n\nexport class FunctionImplementation {\n  FindVarScopedDeclarations(ast_node: BabelNode): Array<BabelNode> {\n    function FindVarScopedDeclarationsFor(ast: BabelNode, level: number) {\n      let statements = [];\n      switch (ast.type) {\n        case \"Program\":\n          statements = ((ast: any): BabelNodeProgram).body;\n          break;\n        case \"BlockStatement\":\n          statements = ((ast: any): BabelNodeBlockStatement).body;\n          break;\n        case \"DoWhileStatement\":\n          statements = [((ast: any): BabelNodeDoWhileStatement).body];\n          break;\n        case \"WhileStatement\":\n          statements = [((ast: any): BabelNodeWhileStatement).body];\n          break;\n        case \"IfStatement\":\n          let astIfStatement: BabelNodeIfStatement = (ast: any);\n          statements = [astIfStatement.consequent, astIfStatement.alternate];\n          break;\n        case \"ForStatement\":\n          let astForStatement: BabelNodeForStatement = (ast: any);\n          statements = [astForStatement.init, astForStatement.body];\n          break;\n        case \"ForInStatement\":\n          let astForInStatement: BabelNodeForInStatement = (ast: any);\n          statements = [astForInStatement.left, astForInStatement.body];\n          break;\n        case \"ForOfStatement\":\n          let astForOfStatement: BabelNodeForOfStatement = (ast: any);\n          statements = [astForOfStatement.left, astForOfStatement.body];\n          break;\n        case \"LabeledStatement\":\n          statements = [((ast: any): BabelNodeLabeledStatement).body];\n          break;\n        case \"WithStatement\":\n          statements = [((ast: any): BabelNodeWithStatement).body];\n          break;\n        case \"SwitchStatement\":\n          for (let switchCase of ((ast: any): BabelNodeSwitchStatement).cases) {\n            statements = statements.concat(switchCase.consequent);\n          }\n          break;\n        case \"TryStatement\":\n          let astTryStatement: BabelNodeTryStatement = (ast: any);\n          statements = [astTryStatement.block];\n          if (astTryStatement.finalizer) statements.push(astTryStatement.finalizer);\n          if (astTryStatement.handler) statements.push(astTryStatement.handler.body);\n          break;\n        case \"VariableDeclaration\":\n          return ast.kind === \"var\" ? [ast] : [];\n        case \"FunctionDeclaration\":\n          return level < 2 ? [ast] : [];\n        default:\n          return [];\n      }\n\n      let decls = [];\n      for (let statement of statements) {\n        if (statement) {\n          decls = decls.concat(FindVarScopedDeclarationsFor(statement, level + 1));\n        }\n      }\n\n      return decls;\n    }\n    return FindVarScopedDeclarationsFor(ast_node, 0);\n  }\n\n  // ECMA262 9.2.12\n  FunctionDeclarationInstantiation(\n    realm: Realm,\n    func: ECMAScriptSourceFunctionValue,\n    argumentsList: Array<Value>\n  ): EmptyValue {\n    // 1. Let calleeContext be the running execution context.\n    let calleeContext = realm.getRunningContext();\n\n    // 2. Let env be the LexicalEnvironment of calleeContext.\n    let env = calleeContext.lexicalEnvironment;\n\n    // 3. Let envRec be env's EnvironmentRecord.\n    let envRec = env.environmentRecord;\n\n    // 4. Let code be the value of the [[ECMAScriptCode]] internal slot of func.\n    let code = func.$ECMAScriptCode;\n    invariant(code !== undefined);\n\n    // 5. Let strict be the value of the [[Strict]] internal slot of func.\n    let strict = func.$Strict;\n\n    // 6. Let formals be the value of the [[FormalParameters]] internal slot of func.\n    let formals = func.$FormalParameters;\n    invariant(formals !== undefined);\n\n    // 7. Let parameterNames be the BoundNames of formals.\n    let parameterNames = Object.create(null);\n    for (let param of formals) {\n      let paramBindings = t.getBindingIdentifiers(param, true);\n\n      for (let name in paramBindings) {\n        parameterNames[name] = (parameterNames[name] || []).concat(paramBindings[name]);\n      }\n    }\n\n    // 8. If parameterNames has any duplicate entries, let hasDuplicates be true. Otherwise, let hasDuplicates be false.\n    let hasDuplicates = false;\n    for (let name in parameterNames) {\n      let identifiers = parameterNames[name];\n      if (identifiers.length > 1) hasDuplicates = true;\n    }\n    parameterNames = Object.keys(parameterNames);\n\n    // 9. Let simpleParameterList be IsSimpleParameterList of formals.\n    let simpleParameterList = true;\n    for (let param of formals) {\n      if (param.type !== \"Identifier\") {\n        simpleParameterList = false;\n        break;\n      }\n    }\n\n    // 10. Let hasParameterExpressions be ContainsExpression of formals.\n    let hasParameterExpressions = false;\n    invariant(formals !== undefined);\n    for (let param of formals) {\n      if (Environment.ContainsExpression(realm, param)) {\n        hasParameterExpressions = true;\n        break;\n      }\n    }\n\n    // 11. Let varNames be the VarDeclaredNames of code.\n    let varNames = [];\n    traverseFast(code, node => {\n      if (node.type === \"VariableDeclaration\" && node.kind === \"var\") {\n        varNames = varNames.concat(Object.keys(t.getBindingIdentifiers(node)));\n      }\n\n      if (node.type === \"FunctionExpression\" || node.type === \"FunctionDeclaration\") {\n        return true;\n      }\n\n      return false;\n    });\n\n    // 12. Let varDeclarations be the VarScopedDeclarations of code.\n    let varDeclarations = this.FindVarScopedDeclarations(code);\n\n    // 13. Let lexicalNames be the LexicallyDeclaredNames of code.\n    let lexicalNames = [];\n\n    // 14. Let functionNames be an empty List.\n    let functionNames = [];\n\n    // 15. Let functionsToInitialize be an empty List.\n    let functionsToInitialize = [];\n\n    // 16. For each d in varDeclarations, in reverse list order do\n    for (let d of varDeclarations.reverse()) {\n      // a. If d is neither a VariableDeclaration or a ForBinding, then\n      if (d.type !== \"VariableDeclaration\") {\n        // i. Assert: d is either a FunctionDeclaration or a GeneratorDeclaration.\n        invariant(d.type === \"FunctionDeclaration\" || d.type === \"GeneratorDeclaration\");\n        // ii. Let fn be the sole element of the BoundNames of d.\n        let fn = Environment.BoundNames(realm, d)[0];\n        // iii. If fn is not an element of functionNames, then\n        if (functionNames.indexOf(fn) < 0) {\n          // 1. Insert fn as the first element of functionNames.\n          functionNames.unshift(fn);\n          // 2. NOTE If there are multiple FunctionDeclarations or GeneratorDeclarations for the same name, the last declaration is used.\n          // 3. Insert d as the first element of functionsToInitialize.\n          functionsToInitialize.unshift(d);\n        }\n      }\n    }\n\n    // 17. Let argumentsObjectNeeded be true.\n    let argumentsObjectNeeded = true;\n\n    // 18. If the value of the [[realmMode]] internal slot of func is lexical, then\n    if (func.$ThisMode === \"lexical\") {\n      // a. NOTE Arrow functions never have an arguments objects.\n      // b. Let argumentsObjectNeeded be false.\n      argumentsObjectNeeded = false;\n    } else if (parameterNames.indexOf(\"arguments\") >= 0) {\n      // 19. Else if \"arguments\" is an element of parameterNames, then\n      // a. Let argumentsObjectNeeded be false.\n      argumentsObjectNeeded = false;\n    } else if (hasParameterExpressions === false) {\n      // 20. Else if hasParameterExpressions is false, then\n      // a. If \"arguments\" is an element of functionNames or if \"arguments\" is an element of lexicalNames, then\n      if (functionNames.indexOf(\"arguments\") >= 0 || lexicalNames.indexOf(\"arguments\") >= 0) {\n        // i. Let argumentsObjectNeeded be false.\n        argumentsObjectNeeded = true;\n      }\n    }\n\n    // 21. For each String paramName in parameterNames, do\n    for (let paramName of parameterNames) {\n      // a. Let alreadyDeclared be envRec.HasBinding(paramName).\n      let alreadyDeclared = envRec.HasBinding(paramName);\n\n      // b. NOTE Early errors ensure that duplicate parameter names can only occur in non-strict functions that do not have parameter default values or rest parameters.\n\n      // c. If alreadyDeclared is false, then\n      if (alreadyDeclared === false) {\n        // i. Perform ! envRec.CreateMutableBinding(paramName, false).\n        envRec.CreateMutableBinding(paramName, false);\n\n        // ii. If hasDuplicates is true, then\n        if (hasDuplicates === true) {\n          // 1. Perform ! envRec.InitializeBinding(paramName, undefined).\n          envRec.InitializeBinding(paramName, realm.intrinsics.undefined);\n        }\n      }\n    }\n\n    // 22. If argumentsObjectNeeded is true, then\n    if (argumentsObjectNeeded === true) {\n      let ao;\n\n      // a. If strict is true or if simpleParameterList is false, then\n      if (strict === true || simpleParameterList === false) {\n        // i. Let ao be CreateUnmappedArgumentsObject(argumentsList).\n        ao = CreateUnmappedArgumentsObject(realm, argumentsList);\n      } else {\n        // b. Else,\n        // i. NOTE mapped argument object is only provided for non-strict functions that don't have a rest parameter, any parameter default value initializers, or any destructured parameters.\n        // ii. Let ao be CreateMappedArgumentsObject(func, formals, argumentsList, envRec).\n        invariant(formals !== undefined);\n        ao = CreateMappedArgumentsObject(realm, func, formals, argumentsList, envRec);\n      }\n\n      // c. If strict is true, then\n      if (strict === true) {\n        // i. Perform ! envRec.CreateImmutableBinding(\"arguments\", false).\n        envRec.CreateImmutableBinding(\"arguments\", false);\n      } else {\n        // d. Else,\n        // i. Perform ! envRec.CreateMutableBinding(\"arguments\", false).\n        envRec.CreateMutableBinding(\"arguments\", false);\n      }\n\n      // e. Call envRec.InitializeBinding(\"arguments\", ao).\n      envRec.InitializeBinding(\"arguments\", ao);\n\n      // f. Append \"arguments\" to parameterNames.\n      parameterNames.push(\"arguments\");\n    }\n\n    // 23. Let iteratorRecord be Record {[[Iterator]]: CreateListIterator(argumentsList), [[Done]]: false}.\n    let iteratorRecord = {\n      $Iterator: CreateListIterator(realm, argumentsList),\n      $Done: false,\n    };\n\n    // 24. If hasDuplicates is true, then\n    if (hasDuplicates === true) {\n      // a. Perform ? IteratorBindingInitialization for formals with iteratorRecord and undefined as arguments.\n      invariant(formals !== undefined);\n      Environment.IteratorBindingInitialization(realm, formals, iteratorRecord, strict);\n    } else {\n      // 25. Else,\n      // a. Perform ? IteratorBindingInitialization for formals with iteratorRecord and env as arguments.\n      invariant(formals !== undefined);\n      Environment.IteratorBindingInitialization(realm, formals, iteratorRecord, strict, env);\n    }\n\n    // 26. If hasParameterExpressions is false, then\n    let varEnv, varEnvRec;\n    if (hasParameterExpressions === false) {\n      // a. NOTE Only a single lexical environment is needed for the parameters and top-level vars.\n      // b. Let instantiatedVarNames be a copy of the List parameterNames.\n      let instantiatedVarNames = parameterNames.slice();\n\n      // c. For each n in varNames, do\n      for (let n of varNames) {\n        // i. If n is not an element of instantiatedVarNames, then\n        if (instantiatedVarNames.indexOf(n) < 0) {\n          // 1. Append n to instantiatedVarNames.\n          instantiatedVarNames.push(n);\n\n          // 2. Perform ! envRec.CreateMutableBinding(n, false).\n          envRec.CreateMutableBinding(n, false);\n\n          // 3. Call envRec.InitializeBinding(n, undefined).\n          envRec.InitializeBinding(n, realm.intrinsics.undefined);\n        }\n      }\n\n      // e. Let varEnv be env.\n      varEnv = env;\n\n      // f. Let varEnvRec be envRec.\n      varEnvRec = envRec;\n    } else {\n      // 27. Else,\n      // a. NOTE A separate Environment Record is needed to ensure that closures created by expressions in the formal parameter list do not have visibility of declarations in the function body.\n\n      // b. Let varEnv be NewDeclarativeEnvironment(env).\n      varEnv = Environment.NewDeclarativeEnvironment(realm, env);\n\n      // c. Let varEnvRec be varEnv's EnvironmentRecord.\n      varEnvRec = varEnv.environmentRecord;\n\n      // d. Set the VariableEnvironment of calleeContext to varEnv.\n      calleeContext.variableEnvironment = varEnv;\n\n      // e. Let instantiatedVarNames be a new empty List.\n      let instantiatedVarNames = [];\n\n      // f. For each n in varNames, do\n      for (let n of varNames) {\n        // i. If n is not an element of instantiatedVarNames, then\n        if (instantiatedVarNames.indexOf(n) < 0) {\n          // 1. Append n to instantiatedVarNames.\n          instantiatedVarNames.push(n);\n\n          // 2. Perform ! varEnvRec.CreateMutableBinding(n, false).\n          varEnvRec.CreateMutableBinding(n, false);\n\n          // 3. If n is not an element of parameterNames or if n is an element of functionNames, let initialValue be undefined.\n          let initialValue;\n          if (parameterNames.indexOf(n) < 0 || functionNames.indexOf(n) < 0) {\n            initialValue = realm.intrinsics.undefined;\n          } else {\n            // 4. Else,\n            // a. Let initialValue be ! envRec.GetBindingValue(n, false).\n            initialValue = envRec.GetBindingValue(n, false);\n          }\n\n          // 5. Call varEnvRec.InitializeBinding(n, initialValue).\n          varEnvRec.InitializeBinding(n, initialValue);\n\n          // 6. NOTE vars whose names are the same as a formal parameter, initially have the same value as the corresponding initialized parameter.\n        }\n      }\n    }\n\n    // 28. NOTE: Annex B.3.3.1 adds additional steps at realm point.\n\n    let lexEnv;\n\n    // 29. If strict is false, then\n    if (strict === false) {\n      // a. Let lexEnv be NewDeclarativeEnvironment(varEnv).\n      lexEnv = Environment.NewDeclarativeEnvironment(realm, varEnv);\n\n      // b. NOTE: Non-strict functions use a separate lexical Environment Record for top-level lexical declarations so that a direct eval (see 12.3.4.1) can determine whether any var scoped declarations introduced by the eval code conflict with pre-existing top-level lexically scoped declarations. realm is not needed for strict functions because a strict direct eval always places all declarations into a new Environment Record.\n    } else {\n      // 30. Else, let lexEnv be varEnv.\n      lexEnv = varEnv;\n    }\n\n    // 31. Let lexEnvRec be lexEnv's EnvironmentRecord.\n    let lexEnvRec = lexEnv.environmentRecord;\n\n    // 32. Set the LexicalEnvironment of calleeContext to lexEnv.\n    calleeContext.lexicalEnvironment = lexEnv;\n\n    // 33. Let lexDeclarations be the LexicallyScopedDeclarations of code.\n    let lexDeclarations = [];\n\n    // 34. For each element d in lexDeclarations do\n    for (let d of lexDeclarations) {\n      // a. NOTE A lexically declared name cannot be the same as a function/generator declaration, formal parameter, or a var name. Lexically declared names are only instantiated here but not initialized.\n      // b. For each element dn of the BoundNames of d do\n      for (let dn of Environment.BoundNames(realm, d)) {\n        // i. If IsConstantDeclaration of d is true, then\n        if (d.kind === \"const\") {\n          // 1. Perform ! lexEnvRec.CreateImmutableBinding(dn, true).\n          lexEnvRec.CreateImmutableBinding(dn, true);\n        } else {\n          // ii. Else,\n          // 1. Perform ! lexEnvRec.CreateMutableBinding(dn, false).\n          lexEnvRec.CreateMutableBinding(dn, false);\n        }\n      }\n    }\n\n    // 35. For each parsed grammar phrase f in functionsToInitialize, do\n    for (let f of functionsToInitialize) {\n      // a. Let fn be the sole element of the BoundNames of f.\n      let fn = Environment.BoundNames(realm, f)[0];\n      // b. Let fo be the result of performing InstantiateFunctionObject for f with argument lexEnv.\n      let fo = lexEnv.evaluate(f, strict);\n      invariant(fo instanceof Value);\n      // c. Perform ! varEnvRec.SetMutableBinding(fn, fo, false).\n      varEnvRec.SetMutableBinding(fn, fo, false);\n    }\n\n    // 36. Return NormalCompletion(empty).\n    return realm.intrinsics.empty;\n  }\n\n  // ECMA262 9.2.11\n  SetFunctionName(realm: Realm, F: ObjectValue, name: PropertyKeyValue | AbstractValue, prefix?: string): boolean {\n    // 1. Assert: F is an extensible object that does not have a name own property.\n    invariant(F.getExtensible(), \"expected object to be extensible and not have a name property\");\n\n    // 2. Assert: Type(name) is either Symbol or String.\n    invariant(\n      typeof name === \"string\" ||\n        name instanceof StringValue ||\n        name instanceof SymbolValue ||\n        name instanceof AbstractValue,\n      \"expected name to be a string or symbol\"\n    );\n    if (typeof name === \"string\") name = new StringValue(realm, name);\n\n    // 3. Assert: If prefix was passed, then Type(prefix) is String.\n    invariant(prefix === undefined || typeof prefix === \"string\", \"expected prefix to be a string if passed\");\n\n    // 4. If Type(name) is Symbol, then\n    if (name instanceof SymbolValue) {\n      // a. Let description be name's [[Description]] value.\n      let description = name.$Description;\n\n      // b. If description is undefined, let name be the empty String.\n      if (description === undefined) {\n        name = realm.intrinsics.emptyString;\n      } else {\n        // c. Else, let name be the concatenation of \"[\", description, and \"]\".\n        invariant(description instanceof Value);\n        name = new StringValue(realm, `[${description.throwIfNotConcreteString().value}]`);\n      }\n    }\n\n    // 5. If prefix was passed, then\n    if (prefix) {\n      // a. Let name be the concatenation of prefix, code unit 0x0020 (SPACE), and name.\n      if (name instanceof AbstractValue) {\n        let prefixVal = new StringValue(realm, prefix + \" \");\n        name = AbstractValue.createFromBinaryOp(realm, \"+\", prefixVal, name, name.expressionLocation);\n      } else {\n        name = new StringValue(realm, `${prefix} ${name.value}`);\n      }\n    }\n\n    // 6. Return ! DefinePropertyOrThrow(F, \"name\", PropertyDescriptor{[[Value]]: name, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true}).\n    return Properties.DefinePropertyOrThrow(realm, F, \"name\", {\n      value: name,\n      enumerable: false,\n      writable: false,\n      configurable: true,\n    });\n  }\n\n  // ECMA262 9.2.3\n  FunctionInitialize(\n    realm: Realm,\n    F: ECMAScriptSourceFunctionValue,\n    kind: \"normal\" | \"method\" | \"arrow\",\n    ParameterList: Array<BabelNodeLVal>,\n    Body: BabelNodeBlockStatement,\n    Scope: LexicalEnvironment\n  ): ECMAScriptSourceFunctionValue {\n    // Note that F is a new object, and we can thus write to internal slots\n    invariant(realm.isNewObject(F));\n\n    // 1. Assert: F is an extensible object that does not have a length own property.\n    invariant(F.getExtensible(), \"expected to be extensible and no length property\");\n\n    // 2. Let len be the ExpectedArgumentCount of ParameterList.\n    let len = 0;\n    for (let FormalParameter of ParameterList) {\n      if (FormalParameter.type === \"AssignmentPattern\") {\n        break;\n      }\n      len += 1;\n    }\n\n    // 3. Perform ! DefinePropertyOrThrow(F, \"length\", PropertyDescriptor{[[Value]]: len, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true}).\n    Properties.DefinePropertyOrThrow(realm, F, \"length\", {\n      value: new NumberValue(realm, len),\n      writable: false,\n      enumerable: false,\n      configurable: true,\n    });\n\n    // 4. Let Strict be the value of the [[Strict]] internal slot of F.\n    let Strict = F.$Strict;\n    if (!Strict) {\n      Properties.DefinePropertyOrThrow(realm, F, \"caller\", {\n        value: new UndefinedValue(realm),\n        writable: true,\n        enumerable: false,\n        configurable: true,\n      });\n    }\n\n    // 5. Set the [[Environment]] internal slot of F to the value of Scope.\n    F.$Environment = Scope;\n\n    // 6. Set the [[FormalParameters]] internal slot of F to ParameterList.\n    F.$FormalParameters = ParameterList;\n\n    // 7. Set the [[ECMAScriptCode]] internal slot of F to Body.\n    ((Body: any): FunctionBodyAstNode).uniqueTag = realm.functionBodyUniqueTagSeed++;\n    F.$ECMAScriptCode = Body;\n\n    // 8. Set the [[ScriptOrModule]] internal slot of F to GetActiveScriptOrModule().\n    F.$ScriptOrModule = Environment.GetActiveScriptOrModule(realm);\n\n    // 9. If kind is Arrow, set the [[realmMode]] internal slot of F to lexical.\n    if (kind === \"arrow\") {\n      F.$ThisMode = \"lexical\";\n    } else if (Strict === true) {\n      // 10. Else if Strict is true, set the [[realmMode]] internal slot of F to strict.\n      F.$ThisMode = \"strict\";\n    } else {\n      // 11. Else set the [[realmMode]] internal slot of F to global.\n      F.$ThisMode = \"global\";\n    }\n\n    // Return F.\n    return F;\n  }\n\n  // ECMA262 9.2.6\n  GeneratorFunctionCreate(\n    realm: Realm,\n    kind: \"normal\" | \"method\",\n    ParameterList: Array<BabelNodeLVal>,\n    Body: BabelNodeBlockStatement,\n    Scope: LexicalEnvironment,\n    Strict: boolean\n  ): ECMAScriptSourceFunctionValue {\n    // 1. Let functionPrototype be the intrinsic object %Generator%.\n    let functionPrototype = realm.intrinsics.Generator;\n\n    // 2. Let F be FunctionAllocate(functionPrototype, Strict, \"generator\").\n    let F = this.FunctionAllocate(realm, functionPrototype, Strict, \"generator\");\n\n    // 3. Return FunctionInitialize(F, kind, ParameterList, Body, Scope).\n    return this.FunctionInitialize(realm, F, kind, ParameterList, Body, Scope);\n  }\n\n  // ECMA262 9.2.7\n  AddRestrictedFunctionProperties(F: FunctionValue, realm: Realm): boolean {\n    // 1. Assert: realm.[[Intrinsics]].[[%ThrowTypeError%]] exists and has been initialized.\n    // 2. Let thrower be realm.[[Intrinsics]].[[%ThrowTypeError%]].\n    let thrower = realm.intrinsics.ThrowTypeError;\n    invariant(thrower);\n\n    let desc = {\n      get: thrower,\n      set: thrower,\n      enumerable: false,\n      configurable: true,\n    };\n    // 3. Perform ! DefinePropertyOrThrow(F, \"caller\", PropertyDescriptor {[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: true}).\n    Properties.DefinePropertyOrThrow(realm, F, \"caller\", desc);\n    // 4. Return ! DefinePropertyOrThrow(F, \"arguments\", PropertyDescriptor {[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: true}).\n    return Properties.DefinePropertyOrThrow(realm, F, \"arguments\", desc);\n  }\n\n  // ECMA262 9.2.1\n  $Call(realm: Realm, F: ECMAScriptFunctionValue, thisArgument: Value, argsList: Array<Value>): Value {\n    return InternalCall(realm, F, thisArgument, argsList, 0);\n  }\n\n  // ECMA262 9.2.2\n  $Construct(\n    realm: Realm,\n    F: ECMAScriptFunctionValue,\n    argumentsList: Array<Value>,\n    newTarget: ObjectValue\n  ): ObjectValue {\n    return InternalConstruct(realm, F, argumentsList, newTarget, undefined, 0);\n  }\n\n  // ECMA262 9.2.3\n  FunctionAllocate(\n    realm: Realm,\n    functionPrototype: ObjectValue,\n    strict: boolean,\n    functionKind: \"normal\" | \"non-constructor\" | \"generator\"\n  ): ECMAScriptSourceFunctionValue {\n    // 1. Assert: Type(functionPrototype) is Object.\n    invariant(functionPrototype instanceof ObjectValue, \"expected functionPrototype to be an object\");\n\n    // 2. Assert: functionKind is either \"normal\", \"non-constructor\" or \"generator\".\n    invariant(\n      functionKind === \"normal\" || functionKind === \"non-constructor\" || functionKind === \"generator\",\n      \"invalid functionKind\"\n    );\n\n    // 3. If functionKind is \"normal\", let needsConstruct be true.\n    let needsConstruct;\n    if (functionKind === \"normal\") {\n      needsConstruct = true;\n    } else {\n      // 4. Else, let needsConstruct be false.\n      needsConstruct = false;\n    }\n\n    // 5. If functionKind is \"non-constructor\", let functionKind be \"normal\".\n    if (functionKind === \"non-constructor\") {\n      functionKind = \"normal\";\n    }\n\n    // 6. Let F be a newly created ECMAScript function object with the internal slots listed in Table 27. All of those internal slots are initialized to undefined.\n    let F = new ECMAScriptSourceFunctionValue(realm);\n\n    // 7. Set F's essential internal methods to the default ordinary object definitions specified in 9.1.\n\n    // 8. Set F's [[Call]] internal method to the definition specified in 9.2.1.\n    F.$Call = (thisArgument, argsList) => {\n      return this.$Call(realm, F, thisArgument, argsList);\n    };\n\n    // 9. If needsConstruct is true, then\n    if (needsConstruct === true) {\n      // a. Set F's [[Construct]] internal method to the definition specified in 9.2.2.\n      F.$Construct = (argumentsList, newTarget) => {\n        return this.$Construct(realm, F, argumentsList, newTarget);\n      };\n\n      // b. Set the [[ConstructorKind]] internal slot of F to \"base\".\n      F.$ConstructorKind = \"base\";\n    }\n\n    // 10. Set the [[Strict]] internal slot of F to strict.\n    F.$Strict = strict;\n\n    // 11. Set the [[FunctionKind]] internal slot of F to functionKind.\n    F.$FunctionKind = functionKind;\n\n    // 12. Set the [[Prototype]] internal slot of F to functionPrototype.\n    F.$Prototype = functionPrototype;\n\n    // 13. Set the [[Extensible]] internal slot of F to true.\n    F.setExtensible(true);\n\n    // 14. Set the [[Realm]] internal slot of F to the current Realm Record.\n    F.$Realm = realm;\n\n    // 15. Return F.\n    return F;\n  }\n\n  // ECMA262 9.4.1.3\n  BoundFunctionCreate(\n    realm: Realm,\n    targetFunction: ObjectValue,\n    boundThis: Value,\n    boundArgs: Array<Value>\n  ): ObjectValue {\n    // 1. Assert: Type(targetFunction) is Object.\n    invariant(targetFunction instanceof ObjectValue, \"expected an object\");\n\n    // 2. Let proto be ? targetFunction.[[GetPrototypeOf]]().\n    let proto = targetFunction.$GetPrototypeOf();\n\n    // 3. Let obj be a newly created object.\n    let obj = new BoundFunctionValue(realm);\n\n    // 4. Set obj's essential internal methods to the default ordinary object definitions specified in 9.1.\n\n    // 5. Set the [[Call]] internal method of obj as described in 9.4.1.1.\n    obj.$Call = (thisArgument, argsList) => {\n      return $BoundCall(realm, obj, thisArgument, argsList);\n    };\n\n    // 6. If targetFunction has a [[Construct]] internal method, then\n    if (targetFunction.$Construct) {\n      // a. Set the [[Construct]] internal method of obj as described in 9.4.1.2.\n      obj.$Construct = (thisArgument, argsList) => {\n        return $BoundConstruct(realm, obj, thisArgument, argsList);\n      };\n    }\n\n    // 7. Set the [[Prototype]] internal slot of obj to proto.\n    obj.$Prototype = proto;\n\n    // 8. Set the [[Extensible]] internal slot of obj to true.\n    obj.setExtensible(true);\n\n    // 9. Set the [[BoundTargetFunction]] internal slot of obj to targetFunction.\n    obj.$BoundTargetFunction = targetFunction;\n\n    // 10. Set the [[BoundThis]] internal slot of obj to the value of boundThis.\n    obj.$BoundThis = boundThis;\n\n    // 11. Set the [[BoundArguments]] internal slot of obj to boundArgs.\n    obj.$BoundArguments = boundArgs;\n\n    // 12. Return obj.\n    return obj;\n  }\n\n  // ECMA262 18.2.1.1\n  PerformEval(realm: Realm, x: Value, evalRealm: Realm, strictCaller: boolean, direct: boolean): Value {\n    // 1. Assert: If direct is false, then strictCaller is also false.\n    if (direct === false) invariant(strictCaller === false, \"strictCaller is only allowed on direct eval\");\n\n    // 2. If Type(x) is not String, return x.\n    if (!(x instanceof StringValue)) return x;\n\n    // 3. Let script be the ECMAScript code that is the result of parsing x, interpreted as UTF-16 encoded Unicode text\n    //    as described in 6.1.4, for the goal symbol Script. If the parse fails, throw a SyntaxError exception. If any\n    //    early errors are detected, throw a SyntaxError or a ReferenceError exception, depending on the type of the\n    //    error (but see also clause 16). Parsing and early error detection may be interweaved in an implementation\n    //    dependent manner.\n    let ast = parse(realm, x.value, \"eval\", \"script\");\n    let script = ast.program;\n\n    // 4. If script Contains ScriptBody is false, return undefined.\n    if (!script.body) return realm.intrinsics.undefined;\n\n    // 5. Let body be the ScriptBody of script.\n    let body = t.blockStatement(script.body, script.directives);\n\n    // 6. If strictCaller is true, let strictEval be true.\n    let strictEval;\n    if (strictCaller) {\n      strictEval = true;\n    } else {\n      // 7. Else, let strictEval be IsStrict of script.\n      strictEval = IsStrict(script);\n    }\n\n    // 8. Let ctx be the running execution context. If direct is true, ctx will be the execution context that\n    //    performed the direct eval. If direct is false, ctx will be the execution context for the invocation of\n    //    the eval function.\n    let ctx = realm.getRunningContext();\n\n    // 9. If direct is true, then\n    let lexEnv, varEnv;\n    if (direct) {\n      // a. Let lexEnv be NewDeclarativeEnvironment(ctx's LexicalEnvironment).\n      lexEnv = Environment.NewDeclarativeEnvironment(realm, ctx.lexicalEnvironment);\n\n      // b. Let varEnv be ctx's VariableEnvironment.\n      varEnv = ctx.variableEnvironment;\n    } else {\n      // 10. Else,\n      // a. Let lexEnv be NewDeclarativeEnvironment(evalRealm.[[GlobalEnv]]).\n      lexEnv = Environment.NewDeclarativeEnvironment(realm, evalRealm.$GlobalEnv);\n\n      // b. Let varEnv be evalRealm.[[GlobalEnv]].\n      varEnv = evalRealm.$GlobalEnv;\n    }\n\n    // 11. If strictEval is true, let varEnv be lexEnv.\n    if (strictEval) varEnv = lexEnv;\n\n    // 12. If ctx is not already suspended, suspend ctx.\n    ctx.suspend();\n\n    // 13. Let evalCxt be a new ECMAScript code execution context.\n    let evalCxt = new ExecutionContext();\n    evalCxt.isStrict = strictEval;\n\n    // 14. Set the evalCxt's Function to null.\n    evalCxt.setFunction(null);\n\n    // 15. Set the evalCxt's Realm to evalRealm.\n    evalCxt.setRealm(evalRealm);\n\n    // 16. Set the evalCxt's ScriptOrModule to ctx's ScriptOrModule.\n    evalCxt.ScriptOrModule = ctx.ScriptOrModule;\n\n    // 17. Set the evalCxt's VariableEnvironment to varEnv.\n    evalCxt.variableEnvironment = varEnv;\n\n    // 18. Set the evalCxt's LexicalEnvironment to lexEnv.\n    evalCxt.lexicalEnvironment = lexEnv;\n\n    // 19. Push evalCxt on to the execution context stack; evalCxt is now the running execution context.\n    realm.pushContext(evalCxt);\n\n    let result;\n    try {\n      // 20. Let result be EvalDeclarationInstantiation(body, varEnv, lexEnv, strictEval).\n      invariant(varEnv);\n      try {\n        result = this.EvalDeclarationInstantiation(realm, body, varEnv, lexEnv, strictEval);\n      } catch (e) {\n        if (e instanceof AbruptCompletion) {\n          result = e;\n        } else {\n          throw e;\n        }\n      }\n      invariant(result instanceof Value || result instanceof AbruptCompletion);\n\n      // 21. If result.[[Type]] is normal, then\n      if (result instanceof Value) {\n        // Evaluate expressions that passed for directives.\n        if (script.directives) {\n          for (let directive of script.directives) {\n            result = new StringValue(realm, directive.value.value);\n          }\n        }\n\n        // a. Let result be the result of evaluating body.\n        result = this.EvaluateStatements(script.body, result, strictEval, lexEnv, realm);\n      }\n\n      // 22. If result.[[Type]] is normal and result.[[Value]] is empty, then\n      if (result instanceof EmptyValue) {\n        // a. Let result be NormalCompletion(undefined).\n        result = realm.intrinsics.undefined;\n      }\n    } finally {\n      // 23. Suspend evalCxt and remove it from the execution context stack.\n      evalCxt.suspend();\n      realm.popContext(evalCxt);\n    }\n\n    // 24. Resume the context that is now on the top of the execution context stack as the running execution context.\n    invariant(realm.getRunningContext() === ctx);\n    ctx.resume();\n\n    // 25. Return Completion(result).\n    if (result instanceof Value) {\n      return result;\n    } else {\n      invariant(result instanceof AbruptCompletion);\n      throw result;\n    }\n  }\n\n  // If c is an abrupt completion and realm.savedCompletion is defined, the result is an instance of\n  // JoinedAbruptCompletions and the effects that have been captured since the PossiblyNormalCompletion instance\n  // in realm.savedCompletion has been created, becomes the effects of the branch that terminates in c.\n  // If c is a normal completion, the result is realm.savedCompletion, with its value updated to c.\n  // If c is undefined, the result is just realm.savedCompletion.\n  // Call this only when a join point has been reached.\n  incorporateSavedCompletion(realm: Realm, c: void | AbruptCompletion | Value): void | Completion | Value {\n    let savedCompletion = realm.savedCompletion;\n    if (savedCompletion !== undefined) {\n      realm.savedCompletion = undefined;\n      if (c === undefined) return savedCompletion;\n      if (c instanceof Value) {\n        Join.updatePossiblyNormalCompletionWithValue(realm, savedCompletion, c);\n        return savedCompletion;\n      } else {\n        let e = realm.getCapturedEffects(savedCompletion);\n        invariant(e !== undefined);\n        realm.stopEffectCaptureAndUndoEffects(savedCompletion);\n        let joined_effects = Join.joinPossiblyNormalCompletionWithAbruptCompletion(realm, savedCompletion, c, e);\n        realm.applyEffects(joined_effects);\n        let jc = joined_effects[0];\n        invariant(jc instanceof AbruptCompletion);\n        return jc;\n      }\n    }\n    return c;\n  }\n\n  EvaluateStatements(\n    body: Array<BabelNodeStatement>,\n    initialBlockValue: void | Value,\n    strictCode: boolean,\n    blockEnv: LexicalEnvironment,\n    realm: Realm\n  ): Value {\n    let blockValue = initialBlockValue;\n    for (let node of body) {\n      if (node.type !== \"FunctionDeclaration\") {\n        let res = blockEnv.evaluateCompletionDeref(node, strictCode);\n        if (!(res instanceof EmptyValue)) {\n          if (res instanceof AbruptCompletion) throw UpdateEmpty(realm, res, blockValue || realm.intrinsics.empty);\n          invariant(res instanceof Value);\n          blockValue = res;\n        }\n      }\n    }\n\n    // 7. Return blockValue.\n    return blockValue || realm.intrinsics.empty;\n  }\n\n  PartiallyEvaluateStatements(\n    body: Array<BabelNodeStatement>,\n    blockValue: void | NormalCompletion | Value,\n    strictCode: boolean,\n    blockEnv: LexicalEnvironment,\n    realm: Realm\n  ): [Completion | Value, Array<BabelNodeStatement>] {\n    let statementAsts = [];\n    for (let node of body) {\n      if (node.type !== \"FunctionDeclaration\") {\n        let [res, nast, nio] = blockEnv.partiallyEvaluateCompletionDeref(node, strictCode);\n        for (let ioAst of nio) statementAsts.push(ioAst);\n        statementAsts.push((nast: any));\n        if (!(res instanceof EmptyValue)) {\n          if (blockValue === undefined || blockValue instanceof Value) {\n            if (res instanceof AbruptCompletion)\n              return [UpdateEmpty(realm, res, blockValue || realm.intrinsics.empty), statementAsts];\n            invariant(res instanceof NormalCompletion || res instanceof Value);\n            blockValue = res;\n          }\n        }\n      }\n    }\n\n    // 7. Return blockValue.\n    return [blockValue || realm.intrinsics.empty, statementAsts];\n  }\n\n  // ECMA262 9.2.5\n  FunctionCreate(\n    realm: Realm,\n    kind: \"normal\" | \"arrow\" | \"method\",\n    ParameterList: Array<BabelNodeLVal>,\n    Body: BabelNodeBlockStatement,\n    Scope: LexicalEnvironment,\n    Strict: boolean,\n    prototype?: ObjectValue\n  ): ECMAScriptSourceFunctionValue {\n    // 1. If the prototype argument was not passed, then\n    if (!prototype) {\n      // a. Let prototype be the intrinsic object %FunctionPrototype%.\n      prototype = realm.intrinsics.FunctionPrototype;\n    }\n\n    // 2. If kind is not Normal, let allocKind be \"non-constructor\".\n    let allocKind;\n    if (kind !== \"normal\") {\n      allocKind = \"non-constructor\";\n    } else {\n      // 3. Else, let allocKind be \"normal\".\n      allocKind = \"normal\";\n    }\n\n    // 4. Let F be FunctionAllocate(prototype, Strict, allocKind).\n    let F = this.FunctionAllocate(realm, prototype, Strict, allocKind);\n\n    // ECMAScript 2016, section 17:\n    //   \"Every other data property described in clauses 18 through 26 and in Annex B.2 has the attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true } unless otherwise specified.\"\n    // Because we call `AddRestrictedFunctionProperties` on `FunctionPrototype`, accessing property \"arguments\" will raise a `TypeError` by default.\n    // However, in non-strict mode this behavior is not desired, so we will add them as own properties of each `FunctionValue`, in accordance with ECMA 17.\n    // Note: \"arguments\" ***MUST NOT*** be set if the function is in strict mode or is an arrow, method, constructor, or generator function.\n    //   See 16.2 \"Forbidden Extensions\"\n    if (!Strict && kind === \"normal\") {\n      Properties.DefinePropertyOrThrow(realm, F, \"arguments\", {\n        value: realm.intrinsics.undefined,\n        enumerable: false,\n        writable: true,\n        configurable: true,\n      });\n    }\n\n    // 5. Return FunctionInitialize(F, kind, ParameterList, Body, Scope).\n    return this.FunctionInitialize(realm, F, kind, ParameterList, Body, Scope);\n  }\n\n  // ECMA262 18.2.1.2\n  EvalDeclarationInstantiation(\n    realm: Realm,\n    body: BabelNodeBlockStatement,\n    varEnv: LexicalEnvironment,\n    lexEnv: LexicalEnvironment,\n    strict: boolean\n  ): Value {\n    // 1. Let varNames be the VarDeclaredNames of body.\n    let varNames = [];\n    traverseFast(body, node => {\n      if (node.type === \"VariableDeclaration\" && node.kind === \"var\") {\n        varNames = varNames.concat(Object.keys(t.getBindingIdentifiers(node)));\n      }\n\n      if (node.type === \"FunctionExpression\" || node.type === \"FunctionDeclaration\") {\n        return true;\n      }\n\n      return false;\n    });\n\n    // 2. Let varDeclarations be the VarScopedDeclarations of body.\n    let varDeclarations = this.FindVarScopedDeclarations(body);\n\n    // 3. Let lexEnvRec be lexEnv's EnvironmentRecord.\n    let lexEnvRec = lexEnv.environmentRecord;\n\n    // 4. Let varEnvRec be varEnv's EnvironmentRecord.\n    let varEnvRec = varEnv.environmentRecord;\n\n    // 5. If strict is false, then\n    if (!strict) {\n      // a. If varEnvRec is a global Environment Record, then\n      if (varEnvRec instanceof GlobalEnvironmentRecord) {\n        // i. For each name in varNames, do\n        for (let name of varNames) {\n          // 1. If varEnvRec.HasLexicalDeclaration(name) is true, throw a SyntaxError exception.\n          if (varEnvRec.HasLexicalDeclaration(name)) {\n            throw realm.createErrorThrowCompletion(\n              realm.intrinsics.SyntaxError,\n              new StringValue(realm, name + \" global object is restricted\")\n            );\n          }\n          // 2. NOTE: eval will not create a global var declaration that would be shadowed by a global lexical declaration.\n        }\n      }\n      // b. Let thisLex be lexEnv.\n      let thisLex = lexEnv;\n      // c. Assert: The following loop will terminate.\n      // d. Repeat while thisLex is not the same as varEnv,\n      while (thisLex !== varEnv) {\n        // i. Let thisEnvRec be thisLex's EnvironmentRecord.\n        let thisEnvRec = thisLex.environmentRecord;\n        // ii. If thisEnvRec is not an object Environment Record, then\n        if (!(thisEnvRec instanceof ObjectEnvironmentRecord)) {\n          // 1. NOTE: The environment of with statements cannot contain any lexical declaration so it doesn't need to be checked for var/let hoisting conflicts.\n          // 2. For each name in varNames, do\n          for (let name of varNames) {\n            // a. If thisEnvRec.HasBinding(name) is true, then\n            if (thisEnvRec.HasBinding(name)) {\n              // i. Throw a SyntaxError exception.\n              throw realm.createErrorThrowCompletion(\n                realm.intrinsics.SyntaxError,\n                name + \" global object is restricted\"\n              );\n              // ii. NOTE: Annex B.3.5 defines alternate semantics for the above step.\n            }\n            // b. NOTE: A direct eval will not hoist var declaration over a like-named lexical declaration.\n          }\n        }\n        // iii. Let thisLex be thisLex's outer environment reference.\n        thisLex = thisLex.parent;\n        invariant(thisLex !== null);\n      }\n    }\n\n    // 6. Let functionsToInitialize be a new empty List.\n    let functionsToInitialize = [];\n\n    // 7. Let declaredFunctionNames be a new empty List.\n    let declaredFunctionNames = [];\n\n    // 8. For each d in varDeclarations, in reverse list order do\n    for (let d of varDeclarations.reverse()) {\n      // a. If d is neither a VariableDeclaration or a ForBinding, then\n      if (d.type !== \"VariableDeclaration\") {\n        // i. Assert: d is either a FunctionDeclaration or a GeneratorDeclaration.\n        invariant(d.type === \"FunctionDeclaration\" || d.type === \"GeneratorDeclaration\");\n        // ii. NOTE If there are multiple FunctionDeclarations for the same name, the last declaration is used.\n        // iii. Let fn be the sole element of the BoundNames of d.\n        let fn = Environment.BoundNames(realm, d)[0];\n        // iv. If fn is not an element of declaredFunctionNames, then\n        if (declaredFunctionNames.indexOf(fn) < 0) {\n          // 1. If varEnvRec is a global Environment Record, then\n          if (varEnvRec instanceof GlobalEnvironmentRecord) {\n            // a. Let fnDefinable be ? varEnvRec.CanDeclareGlobalFunction(fn).\n            let fnDefinable = varEnvRec.CanDeclareGlobalFunction(fn);\n            // b. If fnDefinable is false, throw a TypeError exception.\n            if (!fnDefinable) {\n              throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, fn + \" is not definable\");\n            }\n          }\n          // 2. Append fn to declaredFunctionNames.\n          declaredFunctionNames.push(fn);\n          // 3. Insert d as the first element of functionsToInitialize.\n          functionsToInitialize.unshift(d);\n        }\n      }\n    }\n\n    // 9. NOTE: Annex B.3.3.3 adds additional steps at this point.\n\n    // 10. Let declaredVarNames be a new empty List.\n    let declaredVarNames = [];\n\n    // 11. For each d in varDeclarations, do\n    for (let d of varDeclarations) {\n      // a. If d is a VariableDeclaration or a ForBinding, then\n      if (d.type === \"VariableDeclaration\") {\n        // i. For each String vn in the BoundNames of d, do\n        for (let vn of Environment.BoundNames(realm, d)) {\n          // 1. If vn is not an element of declaredFunctionNames, then\n          if (declaredFunctionNames.indexOf(vn) < 0) {\n            // a. If varEnvRec is a global Environment Record, then\n            if (varEnvRec instanceof GlobalEnvironmentRecord) {\n              // i. Let vnDefinable be ? varEnvRec.CanDeclareGlobalVar(vn).\n              let vnDefinable = varEnvRec.CanDeclareGlobalVar(vn);\n              // ii. If vnDefinable is false, throw a TypeError exception.\n              if (!vnDefinable) {\n                throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, vn + \" is not definable\");\n              }\n            }\n            // b. If vn is not an element of declaredVarNames, then\n            if (declaredVarNames.indexOf(vn) < 0) {\n              // i. Append vn to declaredVarNames.\n              declaredVarNames.push(vn);\n            }\n          }\n        }\n      }\n    }\n\n    // 12. NOTE: No abnormal terminations occur after this algorithm step unless varEnvRec is a global Environment Record and the global object is a Proxy exotic object.\n\n    // 13. Let lexDeclarations be the LexicallyScopedDeclarations of body.\n    let lexDeclarations = [];\n    for (let s of body.body) {\n      if (s.type === \"VariableDeclaration\" && s.kind !== \"var\") {\n        lexDeclarations.push(s);\n      }\n    }\n\n    // 14. For each element d in lexDeclarations do\n    for (let d of lexDeclarations) {\n      // a. NOTE Lexically declared names are only instantiated here but not initialized.\n      // b. For each element dn of the BoundNames of d do\n      for (let dn of Environment.BoundNames(realm, d)) {\n        // c. If IsConstantDeclaration of d is true, then\n        if (d.kind === \"const\") {\n          // i. Perform ? lexEnvRec.CreateImmutableBinding(dn, true).\n          lexEnvRec.CreateImmutableBinding(dn, true);\n        } else {\n          // d. Else,\n          // i. Perform ? lexEnvRec.CreateMutableBinding(dn, false).\n          lexEnvRec.CreateMutableBinding(dn, false);\n        }\n      }\n    }\n\n    // 15. For each production f in functionsToInitialize, do\n    for (let f of functionsToInitialize) {\n      // a. Let fn be the sole element of the BoundNames of f.\n      let fn = Environment.BoundNames(realm, f)[0];\n      // b. Let fo be the result of performing InstantiateFunctionObject for f with argument lexEnv.\n      let fo = lexEnv.evaluate(f, strict);\n      invariant(fo instanceof Value);\n      // c. If varEnvRec is a global Environment Record, then\n      if (varEnvRec instanceof GlobalEnvironmentRecord) {\n        // i. Perform ? varEnvRec.CreateGlobalFunctionBinding(fn, fo, true).\n        varEnvRec.CreateGlobalFunctionBinding(fn, fo, true);\n      } else {\n        // d. Else,\n        // i. Let bindingExists be varEnvRec.HasBinding(fn).\n        let bindingExists = varEnvRec.HasBinding(fn);\n        // ii. If bindingExists is false, then\n        if (!bindingExists) {\n          // 1. Let status be ! varEnvRec.CreateMutableBinding(fn, true).\n          varEnvRec.CreateMutableBinding(fn, true);\n          // 2. Assert: status is not an abrupt completion because of validation preceding step 12.\n          // 3. Perform ! varEnvRec.InitializeBinding(fn, fo).\n          varEnvRec.InitializeBinding(fn, fo);\n        } else {\n          // iii. Else,\n          // 1. Perform ! varEnvRec.SetMutableBinding(fn, fo, false).\n          varEnvRec.SetMutableBinding(fn, fo, false);\n        }\n      }\n    }\n\n    // 16. For each String vn in declaredVarNames, in list order do\n    for (let vn of declaredVarNames) {\n      // a. If varEnvRec is a global Environment Record, then\n      if (varEnvRec instanceof GlobalEnvironmentRecord) {\n        // i. Perform ? varEnvRec.CreateGlobalVarBinding(vn, true).\n        varEnvRec.CreateGlobalVarBinding(vn, true);\n      } else {\n        // b. Else,\n        // i. Let bindingExists be varEnvRec.HasBinding(vn).\n        let bindingExists = varEnvRec.HasBinding(vn);\n        // ii. If bindingExists is false, then\n        if (!bindingExists) {\n          // 1. Let status be ! varEnvRec.CreateMutableBinding(vn, true).\n          varEnvRec.CreateMutableBinding(vn, true);\n          // 2. Assert: status is not an abrupt completion because of validation preceding step 12.\n          // 3. Perform ! varEnvRec.InitializeBinding(vn, undefined).\n          varEnvRec.InitializeBinding(vn, realm.intrinsics.undefined);\n        }\n      }\n    }\n\n    // 17. Return NormalCompletion(empty).\n    return realm.intrinsics.empty;\n  }\n\n  // ECMA 9.2.10\n  MakeMethod(realm: Realm, F: ECMAScriptSourceFunctionValue, homeObject: ObjectValue): Value {\n    // Note that F is a new object, and we can thus write to internal slots\n    invariant(realm.isNewObject(F));\n\n    // 1. Assert: F is an ECMAScript function object.\n    invariant(F instanceof ECMAScriptSourceFunctionValue, \"F is an ECMAScript function object.\");\n\n    // 2. Assert: Type(homeObject) is Object.\n    invariant(homeObject instanceof ObjectValue, \"Type(homeObject) is Object.\");\n\n    // 3. Set the [[HomeObject]] internal slot of F to homeObject.\n    F.$HomeObject = homeObject;\n\n    // 4. Return NormalCompletion(undefined).\n    return realm.intrinsics.undefined;\n  }\n\n  // ECMA 14.3.8\n  DefineMethod(\n    realm: Realm,\n    prop: BabelNodeObjectMethod | BabelNodeClassMethod,\n    obj: ObjectValue,\n    env: LexicalEnvironment,\n    strictCode: boolean,\n    functionPrototype?: ObjectValue\n  ): { $Key: PropertyKeyValue, $Closure: ECMAScriptSourceFunctionValue } {\n    // 1. Let propKey be the result of evaluating PropertyName.\n    let propKey = EvalPropertyName(prop, env, realm, strictCode);\n\n    // 2. ReturnIfAbrupt(propKey).\n\n    // 3. If the function code for this MethodDefinition is strict mode code, let strict be true. Otherwise let strict be false.\n    let strict = strictCode || IsStrict(prop.body);\n\n    // 4. Let scope be the running execution context's LexicalEnvironment.\n    let scope = env;\n\n    // 5. If functionPrototype was passed as a parameter, let kind be Normal; otherwise let kind be Method.\n    let kind;\n    if (functionPrototype) {\n      // let kind be Normal;\n      kind = \"normal\";\n    } else {\n      // otherwise let kind be Method.\n      kind = \"method\";\n    }\n\n    // 6. Let closure be FunctionCreate(kind, StrictFormalParameters, FunctionBody, scope, strict). If functionPrototype was passed as a parameter, then pass its value as the prototype optional argument of FunctionCreate.\n    let closure = this.FunctionCreate(realm, kind, prop.params, prop.body, scope, strict, functionPrototype);\n\n    // 7. Perform MakeMethod(closure, object).\n    this.MakeMethod(realm, closure, obj);\n\n    // 8. Return the Record{[[Key]]: propKey, [[Closure]]: closure}.\n    return { $Key: propKey, $Closure: closure };\n  }\n}\n"]}